{
  "name": "Scenario Generator V1 - Building Workflow",
  "nodes": [
    {
      "parameters": {
        "path": "scenario-generator-v1/implementation",
        "responseMode": "lastNode",
        "options": {}
      },
      "id": "implementation-webhook",
      "name": "Implementation Trigger",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 1,
      "position": [200, 300],
      "webhookId": "implementation-webhook"
    },

    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// Initialize implementation phase\nconst scenarioData = JSON.parse($input.item.json.scenarioData);\n\n// Validate scenario data\nif (!scenarioData.scenarioId) {\n  throw new Error('Missing scenarioId in implementation data');\n}\n\nif (!scenarioData.finalPlan) {\n  throw new Error('Missing final plan for implementation');\n}\n\nconst implementationState = {\n  ...scenarioData,\n  implementationPhase: 'building',\n  currentIteration: 1,\n  maxIterations: scenarioData.implementationIterations || 2,\n  implementations: [],\n  issues: [],\n  startTime: Date.now(),\n  planData: scenarioData.finalPlan\n};\n\nconsole.log(`Starting implementation for scenario ${scenarioData.scenarioId}`);\nconsole.log(`Implementation iterations configured: ${implementationState.maxIterations}`);\n\nreturn implementationState;"
      },
      "id": "initialize-implementation",
      "name": "Initialize Implementation",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [400, 300]
    },

    {
      "parameters": {
        "operation": "executeQuery",
        "query": "UPDATE scenarios SET status = 'implementing', current_phase = 'implementation', progress_percent = 40, plan_completed_at = NOW() WHERE scenario_id = $1",
        "additionalFields": {
          "mode": "independently",
          "valuesUi": {
            "values": [
              {
                "column": "$1",
                "value": "={{ $json.scenarioId }}"
              }
            ]
          }
        }
      },
      "id": "update-implementation-status",
      "name": "Update Implementation Status",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2,
      "position": [600, 300],
      "credentials": {
        "postgres": {
          "id": "postgres-scenario-generator",
          "name": "PostgreSQL - Scenario Generator"
        }
      }
    },

    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// Prepare Claude prompt for implementation\nconst state = $input.item.json;\n\n// Create implementation prompt with plan data\nconst implementationPrompt = `# Vrooli Scenario Implementation Prompt\n\n## System Context  \nYou are Claude Code, an expert Vrooli scenario developer in the IMPLEMENTATION phase. Your task is to transform a refined implementation plan into complete, production-ready scenario files that can be immediately deployed using scenario-to-app.sh.\n\n## Implementation Plan\n${JSON.stringify(state.planData, null, 2)}\n\n## Scenario Configuration\n- **Scenario ID**: ${state.scenarioId}\n- **Implementation Iteration**: ${state.currentIteration} of ${state.maxIterations}\n- **Previous Issues**: ${state.issues.map(i => i.description).join(', ') || 'None'}\n\n## Your Mission\nCreate all the files, configurations, and code necessary to implement the planned scenario. Every file must be complete, functional, and ready for deployment without further modification.\n\n## Required Scenario Files\nYou must implement ALL of these files completely:\n\n### 1. Core Scenario Structure\n- \\`scenario-test.yaml\\` - Testing configuration and resource requirements\n- \\`README.md\\` - Complete user documentation\n- \\`IMPLEMENTATION_PLAN.md\\` - Copy of the plan used for this implementation\n\n### 2. Database Layer  \n- \\`initialization/storage/schema.sql\\` - Complete PostgreSQL schema\n- \\`initialization/storage/seed.sql\\` - Sample data for testing\n\n### 3. Automation Workflows\nBased on plan requirements, implement ONE primary workflow:\n- \\`initialization/automation/n8n/main-workflow.json\\` - For n8n-based scenarios\n- \\`initialization/automation/windmill/main-app.json\\` - For windmill-based scenarios  \n- \\`initialization/automation/node-red/main-flow.json\\` - For node-red-based scenarios\n\n### 4. Configuration Files\n- \\`initialization/configuration/app-config.json\\` - Application settings\n- \\`initialization/configuration/resource-urls.json\\` - Resource endpoint configuration  \n- \\`initialization/configuration/feature-flags.json\\` - Feature toggles\n\n### 5. Deployment & Operations\n- \\`deployment/startup.sh\\` - Complete deployment script\n- \\`custom-tests.sh\\` - Scenario-specific validation tests\n- \\`test.sh\\` - Integration test runner\n\n## Output Format\nReturn all scenario files in JSON format with \\\"implementationSummary\\\" and \\\"scenarioFiles\\\" objects. Each file must be complete and functional.\n\nFocus on creating a complete, working scenario that can be deployed immediately and provides real value to users.`;\n\nconst claudeRequest = {\n  scenarioId: state.scenarioId,\n  iteration: state.currentIteration,\n  phase: 'implementation',\n  prompt: implementationPrompt,\n  maxTokens: 12000,\n  temperature: 0.3\n};\n\nconsole.log(`Prepared Claude implementation request for scenario ${state.scenarioId}, iteration ${state.currentIteration}`);\nreturn { ...state, claudeRequest };"
      },
      "id": "prepare-implementation-prompt",
      "name": "Prepare Implementation Prompt",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [800, 300]
    },

    {
      "parameters": {
        "command": "/bin/bash",
        "parameters": "-c \"cd ${VROOLI_ROOT:-/home/matthalloran8/Vrooli} && echo '{{ $json.claudeRequest.prompt }}' | claude --model claude-3-sonnet-20241022 --max-tokens {{ $json.claudeRequest.maxTokens }} --temperature {{ $json.claudeRequest.temperature }}\"",
        "options": {
          "timeout": 600000
        }
      },
      "id": "call-claude-implementation",
      "name": "Call Claude for Implementation",
      "type": "n8n-nodes-base.executeCommand",
      "typeVersion": 1,
      "position": [1000, 300]
    },

    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// Process Claude implementation response\nconst state = $('prepare-implementation-prompt').item.json;\nconst claudeOutput = $input.item.json;\n\nif (claudeOutput.exitCode !== 0) {\n  console.error('Claude implementation failed:', claudeOutput.stderr);\n  throw new Error(`Claude implementation failed: ${claudeOutput.stderr}`);\n}\n\nlet implementationData;\ntry {\n  const responseText = claudeOutput.stdout.trim();\n  // Look for JSON block in response\n  const jsonMatch = responseText.match(/```json\\s*([\\s\\S]*?)\\s*```/) || [null, responseText];\n  implementationData = JSON.parse(jsonMatch[1]);\n} catch (error) {\n  console.error('Failed to parse Claude implementation response:', error);\n  throw new Error(`Invalid JSON response from Claude implementation: ${error.message}`);\n}\n\n// Validate required fields in implementation\nif (!implementationData.scenarioFiles) {\n  throw new Error('Missing scenarioFiles in implementation response');\n}\n\nif (!implementationData.implementationSummary) {\n  throw new Error('Missing implementationSummary in implementation response');\n}\n\n// Create implementation record\nconst implementation = {\n  iteration: state.currentIteration,\n  phase: state.implementationPhase,\n  summary: implementationData.implementationSummary,\n  files: implementationData.scenarioFiles,\n  notes: implementationData.implementationNotes || {},\n  generatedAt: new Date().toISOString(),\n  tokens: responseText.length,\n  quality: 'pending'\n};\n\n// Update state\nconst updatedState = {\n  ...state,\n  implementations: [...state.implementations, implementation],\n  currentImplementation: implementation,\n  lastImplementationData: implementationData\n};\n\nconsole.log(`Implementation generated for ${state.scenarioId}, iteration ${state.currentIteration}`);\nconsole.log(`Files generated: ${Object.keys(implementationData.scenarioFiles).length}`);\nreturn updatedState;"
      },
      "id": "process-implementation-response",
      "name": "Process Implementation Response",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1200, 300]
    },

    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// Store implementation files in MinIO\nconst state = $input.item.json;\nconst files = state.lastImplementationData.scenarioFiles;\n\n// Create file storage tasks\nconst storageBasePath = `scenarios/${state.scenarioId}/implementations/iteration-${state.currentIteration}`;\nconst filesToStore = [];\n\n// Process each file for storage\nfor (const [filePath, content] of Object.entries(files)) {\n  const minioPath = `${storageBasePath}/${filePath}`;\n  filesToStore.push({\n    path: minioPath,\n    content: content,\n    originalPath: filePath\n  });\n}\n\nconst storageState = {\n  ...state,\n  filesToStore: filesToStore,\n  storagePath: storageBasePath,\n  totalFiles: filesToStore.length\n};\n\nconsole.log(`Prepared ${filesToStore.length} files for storage in ${storageBasePath}`);\nreturn storageState;"
      },
      "id": "prepare-file-storage",
      "name": "Prepare File Storage",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1400, 300]
    },

    {
      "parameters": {
        "bucket": {
          "__rl": true,
          "value": "scenario-artifacts",
          "mode": "name"
        },
        "fileName": "={{ $json.storagePath }}/implementation-manifest.json",
        "binaryData": false,
        "fileContent": "={{ JSON.stringify({ scenarioId: $json.scenarioId, iteration: $json.currentIteration, files: $json.filesToStore.map(f => ({ path: f.originalPath, minioPath: f.path })), generatedAt: new Date().toISOString(), summary: $json.lastImplementationData.implementationSummary }, null, 2) }}"
      },
      "id": "store-implementation-manifest",
      "name": "Store Implementation Manifest",
      "type": "n8n-nodes-base.s3",
      "typeVersion": 1,
      "position": [1600, 300],
      "credentials": {
        "s3": {
          "id": "minio-scenario-generator",
          "name": "MinIO - Scenario Generator"
        }
      }
    },

    {
      "parameters": {
        "operation": "executeQuery",
        "query": "INSERT INTO claude_interactions (scenario_id, phase, iteration_number, interaction_type, prompt_template, prompt_content, response_content, started_at, completed_at, duration_ms, success, input_tokens, output_tokens, estimated_cost_usd, claude_model, temperature) VALUES ((SELECT id FROM scenarios WHERE scenario_id = $1), $2, $3, $4, $5, $6, $7, $8, NOW(), $9, $10, $11, $12, $13, $14, $15)",
        "additionalFields": {
          "mode": "independently",
          "valuesUi": {
            "values": [
              {
                "column": "$1",
                "value": "={{ $json.scenarioId }}"
              },
              {
                "column": "$2",
                "value": "implementation"
              },
              {
                "column": "$3",
                "value": "={{ $json.currentIteration }}"
              },
              {
                "column": "$4",
                "value": "response"
              },
              {
                "column": "$5",
                "value": "implementation-prompt"
              },
              {
                "column": "$6",
                "value": "={{ $json.claudeRequest.prompt.substring(0, 1000) }}"
              },
              {
                "column": "$7",
                "value": "={{ JSON.stringify($json.lastImplementationData.implementationSummary).substring(0, 2000) }}"
              },
              {
                "column": "$8",
                "value": "={{ $json.startTime }}"
              },
              {
                "column": "$9",
                "value": "={{ Date.now() - $json.startTime }}"
              },
              {
                "column": "$10",
                "value": "true"
              },
              {
                "column": "$11",
                "value": "={{ Math.floor($json.claudeRequest.prompt.length / 4) }}"
              },
              {
                "column": "$12",
                "value": "={{ Math.floor(JSON.stringify($json.lastImplementationData).length / 4) }}"
              },
              {
                "column": "$13",
                "value": "0.08"
              },
              {
                "column": "$14",
                "value": "claude-3-sonnet"
              },
              {
                "column": "$15",
                "value": "={{ $json.claudeRequest.temperature }}"
              }
            ]
          }
        }
      },
      "id": "log-implementation-interaction",
      "name": "Log Implementation Interaction",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2,
      "position": [1800, 300],
      "credentials": {
        "postgres": {
          "id": "postgres-scenario-generator",
          "name": "PostgreSQL - Scenario Generator"
        }
      }
    },

    {
      "parameters": {
        "conditions": {
          "number": [
            {
              "value1": "={{ $json.currentIteration }}",
              "value2": "={{ $json.maxIterations }}",
              "operation": "smaller"
            }
          ]
        }
      },
      "id": "check-more-implementation-iterations",
      "name": "More Implementation Iterations?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 1,
      "position": [2000, 300]
    },

    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// Prepare bug fixing iteration\nconst state = $input.item.json;\n\n// Create bug fixing prompt\nconst previousImplementation = JSON.stringify(state.lastImplementationData.scenarioFiles, null, 2);\nconst previousIssues = state.issues.map(issue => issue.description).join('\\n- ');\n\nconst bugFixingPrompt = `# Vrooli Scenario Bug Fixing & Enhancement Prompt\n\n## System Context\nYou are Claude Code in the IMPLEMENTATION REFINEMENT phase. Analyze and improve the existing scenario implementation, fixing any issues and enhancing quality.\n\n## Previous Implementation\n${previousImplementation.substring(0, 8000)}\n\n## Iteration Context\nThis is implementation iteration #${state.currentIteration + 1} of ${state.maxIterations}\n\n## Previous Issues\n${previousIssues || 'None identified yet'}\n\n## Your Task\nCritically analyze the implementation and produce an improved version that addresses:\n- Code quality and best practices\n- Error handling and edge cases\n- Resource integration completeness\n- Configuration and deployment issues\n- Performance and security concerns\n\n## Required Output Format\nReturn JSON with:\n- implementationSummary: Changes made and improvements\n- scenarioFiles: Complete enhanced implementation files\n- implementationNotes: Specific modifications and reasoning\n- qualityAssessment: Remaining issues and recommendations\n\nFocus on meaningful improvements that increase deployment success probability.`;\n\nconst refinedState = {\n  ...state,\n  currentIteration: state.currentIteration + 1,\n  implementationPhase: 'bug-fixing',\n  claudeRequest: {\n    scenarioId: state.scenarioId,\n    iteration: state.currentIteration + 1,\n    phase: 'bug-fixing',\n    prompt: bugFixingPrompt,\n    maxTokens: 12000,\n    temperature: 0.3\n  }\n};\n\nconsole.log(`Prepared bug fixing iteration ${refinedState.currentIteration} for ${state.scenarioId}`);\nreturn refinedState;"
      },
      "id": "prepare-bug-fixing",
      "name": "Prepare Bug Fixing",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1800, 180]
    },

    {
      "parameters": {
        "command": "/bin/bash",
        "parameters": "-c \"cd ${VROOLI_ROOT:-/home/matthalloran8/Vrooli} && echo '{{ $json.claudeRequest.prompt }}' | claude --model claude-3-sonnet-20241022 --max-tokens {{ $json.claudeRequest.maxTokens }} --temperature {{ $json.claudeRequest.temperature }}\"",
        "options": {
          "timeout": 600000
        }
      },
      "id": "call-claude-bug-fixing",
      "name": "Call Claude for Bug Fixing",
      "type": "n8n-nodes-base.executeCommand",
      "typeVersion": 1,
      "position": [1600, 180]
    },

    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// Process bug fixing response\nconst state = $('prepare-bug-fixing').item.json;\nconst claudeOutput = $input.item.json;\n\nif (claudeOutput.exitCode !== 0) {\n  console.error('Claude bug fixing failed:', claudeOutput.stderr);\n  throw new Error(`Claude bug fixing failed: ${claudeOutput.stderr}`);\n}\n\nlet bugFixingData;\ntry {\n  const responseText = claudeOutput.stdout.trim();\n  const jsonMatch = responseText.match(/```json\\s*([\\s\\S]*?)\\s*```/) || [null, responseText];\n  bugFixingData = JSON.parse(jsonMatch[1]);\n} catch (error) {\n  console.error('Failed to parse bug fixing response:', error);\n  throw new Error(`Invalid JSON response from Claude bug fixing: ${error.message}`);\n}\n\n// Extract improved implementation from bug fixing\nconst improvedFiles = bugFixingData.scenarioFiles || bugFixingData;\n\n// Create bug fixing record\nconst implementation = {\n  iteration: state.currentIteration,\n  phase: 'bug-fixing',\n  summary: bugFixingData.implementationSummary,\n  files: improvedFiles,\n  bugFixingSummary: bugFixingData.bugFixingSummary,\n  improvements: bugFixingData.implementationNotes,\n  generatedAt: new Date().toISOString(),\n  tokens: responseText.length\n};\n\n// Update state with improved implementation\nconst updatedState = {\n  ...state,\n  implementations: [...state.implementations, implementation],\n  currentImplementation: implementation,\n  lastImplementationData: { ...bugFixingData, scenarioFiles: improvedFiles }\n};\n\nconsole.log(`Bug fixing completed for ${state.scenarioId}, iteration ${state.currentIteration}`);\nreturn updatedState;"
      },
      "id": "process-bug-fixing-response",
      "name": "Process Bug Fixing",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1400, 180]
    },

    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// Finalize implementation phase\nconst state = $input.item.json;\n\n// Store final implementation in MinIO\nconst finalImplementation = {\n  scenarioId: state.scenarioId,\n  implementationCompleted: new Date().toISOString(),\n  totalIterations: state.implementations.length,\n  finalFiles: state.lastImplementationData.scenarioFiles,\n  allIterations: state.implementations,\n  implementationDuration: Date.now() - state.startTime,\n  summary: state.lastImplementationData.implementationSummary,\n  notes: state.lastImplementationData.implementationNotes || {}\n};\n\nconst minioPath = `scenarios/${state.scenarioId}/implementations/final-implementation.json`;\n\nconst completedState = {\n  ...state,\n  status: 'implementation_completed',\n  finalImplementation: finalImplementation,\n  implementationPath: minioPath,\n  nextPhase: 'validation'\n};\n\nconsole.log(`Implementation completed for ${state.scenarioId}`);\nconsole.log(`Total implementation iterations: ${state.implementations.length}`);\nconsole.log(`Implementation duration: ${(Date.now() - state.startTime) / 1000} seconds`);\nconsole.log(`Final files count: ${Object.keys(state.lastImplementationData.scenarioFiles).length}`);\n\nreturn completedState;"
      },
      "id": "finalize-implementation",
      "name": "Finalize Implementation",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [2200, 300]
    },

    {
      "parameters": {
        "bucket": {
          "__rl": true,
          "value": "scenario-artifacts",
          "mode": "name"
        },
        "fileName": "={{ $json.implementationPath }}",
        "binaryData": false,
        "fileContent": "={{ JSON.stringify($json.finalImplementation, null, 2) }}"
      },
      "id": "store-final-implementation",
      "name": "Store Final Implementation",
      "type": "n8n-nodes-base.s3",
      "typeVersion": 1,
      "position": [2400, 300],
      "credentials": {
        "s3": {
          "id": "minio-scenario-generator",
          "name": "MinIO - Scenario Generator"
        }
      }
    },

    {
      "parameters": {
        "operation": "executeQuery",
        "query": "UPDATE scenarios SET status = 'validating', current_phase = 'validation', progress_percent = 70, implementation_path = $2, implementation_completed_at = NOW() WHERE scenario_id = $1",
        "additionalFields": {
          "mode": "independently",
          "valuesUi": {
            "values": [
              {
                "column": "$1",
                "value": "={{ $json.scenarioId }}"
              },
              {
                "column": "$2",
                "value": "={{ $json.implementationPath }}"
              }
            ]
          }
        }
      },
      "id": "update-validation-status",
      "name": "Update to Validation",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2,
      "position": [2600, 300],
      "credentials": {
        "postgres": {
          "id": "postgres-scenario-generator",
          "name": "PostgreSQL - Scenario Generator"
        }
      }
    },

    {
      "parameters": {
        "url": "http://localhost:5678/webhook/scenario-generator-v1/validation",
        "sendBody": true,
        "bodyParameters": {
          "parameters": [
            {
              "name": "scenarioData",
              "value": "={{ JSON.stringify($json) }}"
            }
          ]
        },
        "options": {
          "timeout": 5000
        }
      },
      "id": "trigger-validation",
      "name": "Trigger Validation",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4,
      "position": [2800, 300]
    }
  ],

  "connections": {
    "Implementation Trigger": {
      "main": [
        [
          {
            "node": "Initialize Implementation",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Initialize Implementation": {
      "main": [
        [
          {
            "node": "Update Implementation Status",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Update Implementation Status": {
      "main": [
        [
          {
            "node": "Prepare Implementation Prompt",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Implementation Prompt": {
      "main": [
        [
          {
            "node": "Call Claude for Implementation",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Call Claude for Implementation": {
      "main": [
        [
          {
            "node": "Process Implementation Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Process Implementation Response": {
      "main": [
        [
          {
            "node": "Prepare File Storage",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare File Storage": {
      "main": [
        [
          {
            "node": "Store Implementation Manifest",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Store Implementation Manifest": {
      "main": [
        [
          {
            "node": "Log Implementation Interaction",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Log Implementation Interaction": {
      "main": [
        [
          {
            "node": "More Implementation Iterations?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "More Implementation Iterations?": {
      "main": [
        [
          {
            "node": "Prepare Bug Fixing",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Finalize Implementation",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Bug Fixing": {
      "main": [
        [
          {
            "node": "Call Claude for Bug Fixing",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Call Claude for Bug Fixing": {
      "main": [
        [
          {
            "node": "Process Bug Fixing",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Process Bug Fixing": {
      "main": [
        [
          {
            "node": "More Implementation Iterations?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Finalize Implementation": {
      "main": [
        [
          {
            "node": "Store Final Implementation",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Store Final Implementation": {
      "main": [
        [
          {
            "node": "Update to Validation",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Update to Validation": {
      "main": [
        [
          {
            "node": "Trigger Validation",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },

  "active": true,
  "settings": {
    "executionOrder": "v1",
    "saveManualExecutions": true,
    "callerPolicy": "workflowsFromSameOwner"
  },

  "versionId": "scenario-generator-v1-building",
  "id": "scenario-generator-v1-building",

  "meta": {
    "templateCreatedBy": "vrooli-scenario-generator-v1",
    "instanceId": "scenario-generator-v1-building"
  },

  "tags": [
    {
      "id": "scenario-generator-v1",
      "name": "Scenario Generator V1"
    },
    {
      "id": "building-workflow",
      "name": "Building Workflow"
    }
  ]
}