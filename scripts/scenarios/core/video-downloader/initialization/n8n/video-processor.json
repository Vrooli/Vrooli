{
  "name": "Video Processor",
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "process-video",
        "responseMode": "responseNode",
        "options": {}
      },
      "id": "webhook_trigger",
      "name": "Webhook",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 1.1,
      "position": [200, 300]
    },
    {
      "parameters": {},
      "id": "manual_trigger",
      "name": "Manual Trigger",
      "type": "n8n-nodes-base.manualTrigger",
      "typeVersion": 1,
      "position": [200, 500]
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "return {\n  url: 'https://www.youtube.com/watch?v=dQw4w9WgXcQ',\n  quality: '720p',\n  format: 'mp4',\n  audio_only: false,\n  download_id: 1\n};"
      },
      "id": "test_defaults",
      "name": "Test Defaults",
      "type": "n8n-nodes-base.code",
      "typeVersion": 1,
      "position": [400, 500]
    },
    {
      "parameters": {},
      "id": "merge",
      "name": "Merge",
      "type": "n8n-nodes-base.merge",
      "typeVersion": 2.1,
      "position": [600, 400]
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "const input = $input.item.json;\n\n// Validate required fields\nif (!input.url) {\n  throw new Error('URL is required');\n}\n\nif (!input.download_id) {\n  throw new Error('Download ID is required');\n}\n\n// Set defaults\nconst quality = input.quality || 'best';\nconst format = input.format || 'mp4';\nconst audioOnly = input.audio_only === true;\n\n// Create download directory path\nconst timestamp = new Date().toISOString().split('T')[0];\nconst downloadDir = `/tmp/video-downloads/${timestamp}`;\n\nreturn {\n  url: input.url,\n  download_id: input.download_id,\n  quality: quality,\n  format: format,\n  audio_only: audioOnly,\n  download_dir: downloadDir,\n  user_id: input.user_id || 'anonymous'\n};"
      },
      "id": "prepare_download",
      "name": "Prepare Download",
      "type": "n8n-nodes-base.code",
      "typeVersion": 1,
      "position": [800, 400]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "UPDATE downloads SET status = 'downloading', started_at = NOW() WHERE id = {{ $json.download_id }}",
        "options": {}
      },
      "id": "update_status_downloading",
      "name": "Update Status - Downloading",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.4,
      "position": [1000, 300],
      "credentials": {
        "postgres": {
          "id": "${service.postgres.credentialId}",
          "name": "Postgres"
        }
      }
    },
    {
      "parameters": {
        "command": "#!/bin/bash\n\nurl=\"{{ $json.url }}\"\nquality=\"{{ $json.quality }}\"\nformat=\"{{ $json.format }}\"\naudio_only=\"{{ $json.audio_only }}\"\ndownload_dir=\"{{ $json.download_dir }}\"\ndownload_id=\"{{ $json.download_id }}\"\n\n# Create download directory\nmkdir -p \"$download_dir\"\n\n# Build yt-dlp command\nif [ \"$audio_only\" = \"true\" ]; then\n  # Audio only download\n  yt_command=\"yt-dlp -x --audio-format mp3 --audio-quality 0\"\nelse\n  # Video download with quality selection\n  if [ \"$quality\" = \"best\" ]; then\n    yt_command=\"yt-dlp -f 'bestvideo[ext=mp4]+bestaudio[ext=m4a]/best[ext=mp4]/best'\"\n  else\n    # Try to get specific quality, fallback to best if not available\n    height=\"${quality%p}\"\n    yt_command=\"yt-dlp -f 'bestvideo[height<=${height}][ext=mp4]+bestaudio[ext=m4a]/best[height<=${height}][ext=mp4]/best[ext=mp4]/best'\"\n  fi\n  \n  # Add format conversion if needed\n  if [ \"$format\" != \"mp4\" ]; then\n    yt_command=\"$yt_command --recode-video $format\"\n  fi\nfi\n\n# Add output template and other options\nyt_command=\"$yt_command -o '$download_dir/%(title)s.%(ext)s' --restrict-filenames --no-playlist\"\n\n# Execute download\noutput=$(eval \"$yt_command '$url'\" 2>&1)\nstatus=$?\n\nif [ $status -eq 0 ]; then\n  # Get the downloaded file path\n  file_path=$(find \"$download_dir\" -type f -name \"*.*\" | head -1)\n  \n  if [ -n \"$file_path\" ]; then\n    file_size=$(stat -c%s \"$file_path\" 2>/dev/null || stat -f%z \"$file_path\" 2>/dev/null || echo 0)\n    echo \"{\\\"success\\\": true, \\\"file_path\\\": \\\"$file_path\\\", \\\"file_size\\\": $file_size, \\\"download_id\\\": $download_id}\"\n  else\n    echo \"{\\\"success\\\": false, \\\"error\\\": \\\"File not found after download\\\", \\\"download_id\\\": $download_id}\"\n  fi\nelse\n  echo \"{\\\"success\\\": false, \\\"error\\\": \\\"Download failed: $output\\\", \\\"download_id\\\": $download_id}\"\nfi"
      },
      "id": "download_video",
      "name": "Download Video",
      "type": "n8n-nodes-base.executeCommand",
      "typeVersion": 1,
      "position": [1200, 400]
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "const result = JSON.parse($input.item.json.stdout || '{}');\nconst downloadData = $node[\"prepare_download\"].json;\n\nif (result.success) {\n  return {\n    success: true,\n    download_id: result.download_id,\n    file_path: result.file_path,\n    file_size: result.file_size,\n    status: 'completed'\n  };\n} else {\n  return {\n    success: false,\n    download_id: result.download_id,\n    error: result.error || 'Unknown error',\n    status: 'failed'\n  };\n}"
      },
      "id": "process_result",
      "name": "Process Result",
      "type": "n8n-nodes-base.code",
      "typeVersion": 1,
      "position": [1400, 400]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "UPDATE downloads \nSET \n  status = '{{ $json.status }}',\n  file_path = {{ $json.file_path ? \"'\" + $json.file_path + \"'\" : 'NULL' }},\n  file_size = {{ $json.file_size || 'NULL' }},\n  error_message = {{ $json.error ? \"'\" + $json.error + \"'\" : 'NULL' }},\n  completed_at = {{ $json.success ? 'NOW()' : 'NULL' }},\n  progress = {{ $json.success ? '100' : '0' }}\nWHERE id = {{ $json.download_id }}",
        "options": {}
      },
      "id": "update_final_status",
      "name": "Update Final Status",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.4,
      "position": [1600, 400],
      "credentials": {
        "postgres": {
          "id": "${service.postgres.credentialId}",
          "name": "Postgres"
        }
      }
    },
    {
      "parameters": {
        "respondWith": "allIncomingItems",
        "options": {}
      },
      "id": "respond",
      "name": "Respond to Webhook",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1,
      "position": [1800, 400]
    }
  ],
  "connections": {
    "webhook_trigger": {
      "main": [[{ "node": "merge", "type": "main", "index": 0 }]]
    },
    "manual_trigger": {
      "main": [[{ "node": "test_defaults", "type": "main", "index": 0 }]]
    },
    "test_defaults": {
      "main": [[{ "node": "merge", "type": "main", "index": 1 }]]
    },
    "merge": {
      "main": [[{ "node": "prepare_download", "type": "main", "index": 0 }]]
    },
    "prepare_download": {
      "main": [[{ "node": "update_status_downloading", "type": "main", "index": 0 }]]
    },
    "update_status_downloading": {
      "main": [[{ "node": "download_video", "type": "main", "index": 0 }]]
    },
    "download_video": {
      "main": [[{ "node": "process_result", "type": "main", "index": 0 }]]
    },
    "process_result": {
      "main": [[{ "node": "update_final_status", "type": "main", "index": 0 }]]
    },
    "update_final_status": {
      "main": [[{ "node": "respond", "type": "main", "index": 0 }]]
    }
  },
  "active": true,
  "settings": {
    "executionOrder": "v1"
  },
  "versionId": "01234567-89ab-cdef-0123-456789abcdef",
  "id": "video-downloader-processor",
  "meta": {
    "instanceId": "${service.n8n.instanceId}"
  },
  "tags": []
}