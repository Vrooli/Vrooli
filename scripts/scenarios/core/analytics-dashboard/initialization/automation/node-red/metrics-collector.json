[
  {
    "id": "flow-metrics-collector",
    "type": "tab",
    "label": "Resource Metrics Collector",
    "disabled": false,
    "info": "Real-time metrics collection flow for resource monitoring"
  },
  {
    "id": "inject-30sec",
    "type": "inject",
    "z": "flow-metrics-collector",
    "name": "Every 30 seconds",
    "props": [
      {
        "p": "payload"
      },
      {
        "p": "topic",
        "vt": "str"
      }
    ],
    "repeat": "30",
    "crontab": "",
    "once": true,
    "onceDelay": "5",
    "topic": "metrics-collection",
    "payload": "{}",
    "payloadType": "json",
    "x": 150,
    "y": 100,
    "wires": [["get-resources"]]
  },
  {
    "id": "get-resources",
    "type": "function",
    "z": "flow-metrics-collector",
    "name": "Get Resource List",
    "func": "// Get list of resources from Redis cache or default list\nconst resources = [\n    { name: 'postgres', port: 5433, type: 'storage', endpoint: null },\n    { name: 'redis', port: 6380, type: 'storage', endpoint: '/ping' },\n    { name: 'questdb', port: 9009, type: 'storage', endpoint: '/status' },\n    { name: 'n8n', port: 5678, type: 'automation', endpoint: '/healthz' },\n    { name: 'node-red', port: 1880, type: 'automation', endpoint: '/settings' },\n    { name: 'windmill', port: 5681, type: 'automation', endpoint: '/api/version' },\n    { name: 'vault', port: 8200, type: 'storage', endpoint: '/v1/sys/health' },\n    { name: 'ollama', port: 11434, type: 'ai', endpoint: '/api/tags' },\n    { name: 'minio', port: 9000, type: 'storage', endpoint: '/minio/health/live' }\n];\n\n// Send each resource as a separate message\nconst messages = resources.map(resource => ({\n    payload: resource,\n    topic: 'check-health'\n}));\n\nreturn [messages];",
    "outputs": 1,
    "noerr": 0,
    "initialize": "",
    "finalize": "",
    "libs": [],
    "x": 350,
    "y": 100,
    "wires": [["health-check"]]
  },
  {
    "id": "health-check",
    "type": "http request",
    "z": "flow-metrics-collector",
    "name": "Health Check",
    "method": "GET",
    "ret": "obj",
    "paytoqs": "ignore",
    "url": "{{{payload.endpoint ? 'http://localhost:' + payload.port + payload.endpoint : ''}}}",
    "tls": "",
    "persist": false,
    "proxy": "",
    "authType": "",
    "senderr": false,
    "headers": [],
    "timeout": "3",
    "x": 550,
    "y": 100,
    "wires": [["process-response"], ["handle-error"]]
  },
  {
    "id": "process-response",
    "type": "function",
    "z": "flow-metrics-collector",
    "name": "Process Health Response",
    "func": "// Process successful health check response\nconst resource = msg.payload;\nconst timestamp = new Date().toISOString();\nconst responseTime = msg.responseTime || 0;\n\nconst metric = {\n    timestamp: timestamp,\n    resource_name: resource.name,\n    resource_type: resource.type,\n    metric_type: 'availability',\n    value: 1.0,\n    status: 'healthy',\n    response_time_ms: Math.round(responseTime),\n    error_count: 0,\n    tags: 'source=node-red'\n};\n\nmsg.payload = metric;\nmsg.topic = 'metric-ready';\nreturn msg;",
    "outputs": 1,
    "noerr": 0,
    "initialize": "",
    "finalize": "",
    "libs": [],
    "x": 780,
    "y": 80,
    "wires": [["write-questdb", "publish-redis"]]
  },
  {
    "id": "handle-error",
    "type": "function",
    "z": "flow-metrics-collector",
    "name": "Handle Error",
    "func": "// Process failed health check\nconst resource = msg.payload;\nconst timestamp = new Date().toISOString();\n\nconst metric = {\n    timestamp: timestamp,\n    resource_name: resource.name,\n    resource_type: resource.type,\n    metric_type: 'availability',\n    value: 0.0,\n    status: 'down',\n    response_time_ms: 0,\n    error_count: 1,\n    tags: 'source=node-red,error=true'\n};\n\n// Check if critical resource\nconst criticalResources = ['postgres', 'redis', 'vault', 'n8n', 'questdb'];\nif (criticalResources.includes(resource.name)) {\n    metric.alert_required = true;\n    metric.severity = 'critical';\n}\n\nmsg.payload = metric;\nmsg.topic = 'metric-error';\nreturn msg;",
    "outputs": 1,
    "noerr": 0,
    "initialize": "",
    "finalize": "",
    "libs": [],
    "x": 770,
    "y": 120,
    "wires": [["write-questdb", "publish-redis", "check-alert"]]
  },
  {
    "id": "write-questdb",
    "type": "http request",
    "z": "flow-metrics-collector",
    "name": "Write to QuestDB",
    "method": "GET",
    "ret": "txt",
    "paytoqs": "query",
    "url": "http://localhost:9009/exec",
    "tls": "",
    "persist": false,
    "proxy": "",
    "authType": "",
    "senderr": false,
    "headers": [],
    "x": 1010,
    "y": 100,
    "wires": [["questdb-success"]]
  },
  {
    "id": "publish-redis",
    "type": "function",
    "z": "flow-metrics-collector",
    "name": "Publish to Redis",
    "func": "// Prepare message for Redis pub/sub\nconst channel = `monitoring:metrics:${msg.payload.resource_name}`;\nconst data = JSON.stringify(msg.payload);\n\nmsg.topic = channel;\nmsg.payload = data;\nreturn msg;",
    "outputs": 1,
    "noerr": 0,
    "initialize": "",
    "finalize": "",
    "libs": [],
    "x": 1010,
    "y": 160,
    "wires": [["redis-publish"]]
  },
  {
    "id": "check-alert",
    "type": "switch",
    "z": "flow-metrics-collector",
    "name": "Alert Required?",
    "property": "payload.alert_required",
    "propertyType": "msg",
    "rules": [
      {
        "t": "true"
      }
    ],
    "checkall": "true",
    "repair": false,
    "outputs": 1,
    "x": 1010,
    "y": 220,
    "wires": [["trigger-alert"]]
  },
  {
    "id": "trigger-alert",
    "type": "http request",
    "z": "flow-metrics-collector",
    "name": "Trigger n8n Alert",
    "method": "POST",
    "ret": "obj",
    "paytoqs": "ignore",
    "url": "http://localhost:5678/webhook/alert-handler",
    "tls": "",
    "persist": false,
    "proxy": "",
    "authType": "",
    "senderr": false,
    "headers": [
      {
        "keyType": "Content-Type",
        "keyValue": "",
        "valueType": "other",
        "valueValue": "application/json"
      }
    ],
    "x": 1210,
    "y": 220,
    "wires": [[]]
  },
  {
    "id": "redis-publish",
    "type": "function",
    "z": "flow-metrics-collector",
    "name": "Redis Pub/Sub",
    "func": "// This would normally use a Redis node\n// Simulating Redis publish for real-time updates\nnode.status({fill:\"green\",shape:\"dot\",text:\"published\"});\nreturn msg;",
    "outputs": 1,
    "noerr": 0,
    "initialize": "",
    "finalize": "",
    "libs": [],
    "x": 1210,
    "y": 160,
    "wires": [[]]
  },
  {
    "id": "questdb-success",
    "type": "function",
    "z": "flow-metrics-collector",
    "name": "Log Success",
    "func": "// Log successful metric write\nnode.status({fill:\"green\",shape:\"dot\",text:\"metric stored\"});\nreturn msg;",
    "outputs": 1,
    "noerr": 0,
    "initialize": "",
    "finalize": "",
    "libs": [],
    "x": 1210,
    "y": 100,
    "wires": [[]]
  },
  {
    "id": "ws-realtime",
    "type": "websocket out",
    "z": "flow-metrics-collector",
    "name": "WebSocket Broadcast",
    "server": "",
    "client": "ws-server",
    "x": 1240,
    "y": 300,
    "wires": []
  },
  {
    "id": "ws-server",
    "type": "websocket-listener",
    "path": "/ws/metrics",
    "wholemsg": "false"
  },
  {
    "id": "aggregate-metrics",
    "type": "inject",
    "z": "flow-metrics-collector",
    "name": "Every 5 minutes",
    "props": [
      {
        "p": "payload"
      },
      {
        "p": "topic",
        "vt": "str"
      }
    ],
    "repeat": "300",
    "crontab": "",
    "once": false,
    "onceDelay": "60",
    "topic": "aggregate",
    "payload": "{}",
    "payloadType": "json",
    "x": 150,
    "y": 400,
    "wires": [["calculate-aggregates"]]
  },
  {
    "id": "calculate-aggregates",
    "type": "function",
    "z": "flow-metrics-collector",
    "name": "Calculate 5min Aggregates",
    "func": "// Query QuestDB for recent metrics and calculate aggregates\nconst query = `\n    SELECT \n        resource_name,\n        resource_type,\n        avg(value) as availability_percent,\n        avg(response_time_ms) as avg_response_time_ms,\n        max(response_time_ms) as max_response_time_ms,\n        min(response_time_ms) as min_response_time_ms,\n        sum(error_count) as error_count,\n        count(*) as request_count\n    FROM resource_metrics\n    WHERE timestamp > dateadd('m', -5, now())\n    GROUP BY resource_name, resource_type\n`;\n\nmsg.payload = { query: query };\nmsg.topic = 'aggregate-query';\nreturn msg;",
    "outputs": 1,
    "noerr": 0,
    "initialize": "",
    "finalize": "",
    "libs": [],
    "x": 380,
    "y": 400,
    "wires": [["query-questdb"]]
  },
  {
    "id": "query-questdb",
    "type": "http request",
    "z": "flow-metrics-collector",
    "name": "Query QuestDB",
    "method": "GET",
    "ret": "obj",
    "paytoqs": "query",
    "url": "http://localhost:9009/exec",
    "tls": "",
    "persist": false,
    "proxy": "",
    "authType": "",
    "senderr": false,
    "headers": [],
    "x": 600,
    "y": 400,
    "wires": [["store-aggregates"]]
  },
  {
    "id": "store-aggregates",
    "type": "function",
    "z": "flow-metrics-collector",
    "name": "Store Aggregates",
    "func": "// Store aggregated metrics back to QuestDB\nconst timestamp = new Date().toISOString();\nconst aggregates = msg.payload.dataset || [];\n\nconst queries = aggregates.map(agg => {\n    return `INSERT INTO metrics_5min VALUES('${timestamp}', '${agg.resource_name}', '${agg.resource_type}', ${agg.availability_percent}, ${agg.avg_response_time_ms}, ${agg.max_response_time_ms}, ${agg.min_response_time_ms}, ${agg.error_count}, ${agg.request_count}, null, null, null)`;\n});\n\nmsg.payload = { queries: queries };\nmsg.topic = 'store-aggregates';\nreturn msg;",
    "outputs": 1,
    "noerr": 0,
    "initialize": "",
    "finalize": "",
    "libs": [],
    "x": 810,
    "y": 400,
    "wires": [["write-aggregates"]]
  },
  {
    "id": "write-aggregates",
    "type": "http request",
    "z": "flow-metrics-collector",
    "name": "Write Aggregates",
    "method": "GET",
    "ret": "txt",
    "paytoqs": "query",
    "url": "http://localhost:9009/exec",
    "tls": "",
    "persist": false,
    "proxy": "",
    "authType": "",
    "senderr": false,
    "headers": [],
    "x": 1010,
    "y": 400,
    "wires": [[]]
  },
  {
    "id": "http-api",
    "type": "http in",
    "z": "flow-metrics-collector",
    "name": "Metrics API",
    "url": "/api/metrics/current",
    "method": "get",
    "upload": false,
    "swaggerDoc": "",
    "x": 130,
    "y": 500,
    "wires": [["get-current-metrics"]]
  },
  {
    "id": "get-current-metrics",
    "type": "function",
    "z": "flow-metrics-collector",
    "name": "Get Current Metrics",
    "func": "// Return current metrics from cache\nmsg.payload = {\n    timestamp: new Date().toISOString(),\n    metrics: global.get('current_metrics') || {},\n    summary: global.get('health_summary') || {}\n};\nreturn msg;",
    "outputs": 1,
    "noerr": 0,
    "initialize": "",
    "finalize": "",
    "libs": [],
    "x": 340,
    "y": 500,
    "wires": [["http-response"]]
  },
  {
    "id": "http-response",
    "type": "http response",
    "z": "flow-metrics-collector",
    "name": "API Response",
    "statusCode": "200",
    "headers": {
      "Content-Type": "application/json"
    },
    "x": 540,
    "y": 500,
    "wires": []
  }
]