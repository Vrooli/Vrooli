[
  {
    "id": "flow-metrics-collector",
    "type": "tab",
    "label": "Resource Metrics Collector",
    "disabled": false,
    "info": "Real-time metrics collection flow for resource monitoring"
  },
  {
    "id": "init-flow",
    "type": "inject",
    "z": "flow-metrics-collector",
    "name": "Initialize Flow",
    "props": [
      {
        "p": "payload"
      }
    ],
    "repeat": "",
    "crontab": "",
    "once": true,
    "onceDelay": "2",
    "topic": "",
    "payload": "{}",
    "payloadType": "json",
    "x": 130,
    "y": 40,
    "wires": [["setup-flow-context"]]
  },
  {
    "id": "setup-flow-context",
    "type": "function",
    "z": "flow-metrics-collector",
    "name": "Setup Flow Context",
    "func": "// Initialize flow context with port configurations\nflow.set('questdb_port', parseInt(env.get('QUESTDB_PORT') || '9009'));\nflow.set('n8n_port', parseInt(env.get('N8N_PORT') || '5678'));\nflow.set('redis_port', parseInt(env.get('REDIS_PORT') || '6380'));\n\n// Set monitoring configuration\nflow.set('monitoring_interval', 30); // seconds\nflow.set('aggregation_interval', 300); // 5 minutes\nflow.set('retention_days', 30);\n\nnode.log('Flow context initialized with port configurations');\nnode.status({fill:\"green\",shape:\"dot\",text:\"initialized\"});\n\nreturn null;",
    "outputs": 0,
    "noerr": 0,
    "initialize": "",
    "finalize": "",
    "libs": [],
    "x": 350,
    "y": 40,
    "wires": []
  },
  {
    "id": "inject-30sec",
    "type": "inject",
    "z": "flow-metrics-collector",
    "name": "Every 30 seconds",
    "props": [
      {
        "p": "payload"
      },
      {
        "p": "topic",
        "vt": "str"
      }
    ],
    "repeat": "30",
    "crontab": "",
    "once": true,
    "onceDelay": "5",
    "topic": "metrics-collection",
    "payload": "{}",
    "payloadType": "json",
    "x": 150,
    "y": 100,
    "wires": [["get-resources"]]
  },
  {
    "id": "get-resources",
    "type": "function",
    "z": "flow-metrics-collector",
    "name": "Get Resource List",
    "func": "// Get list of resources from environment or default configuration\n// This would ideally fetch from PostgreSQL resources table, but fallback to defaults\nconst defaultResources = [\n    { name: 'postgres', port: parseInt(env.get('POSTGRES_PORT') || '5433'), type: 'storage', endpoint: null, critical: true },\n    { name: 'redis', port: parseInt(env.get('REDIS_PORT') || '6380'), type: 'storage', endpoint: null, critical: true },\n    { name: 'questdb', port: parseInt(env.get('QUESTDB_PORT') || '9009'), type: 'storage', endpoint: '/status', critical: true },\n    { name: 'n8n', port: parseInt(env.get('N8N_PORT') || '5678'), type: 'automation', endpoint: '/healthz', critical: true },\n    { name: 'node-red', port: parseInt(env.get('NODE_RED_PORT') || '1880'), type: 'automation', endpoint: '/settings', critical: false },\n    { name: 'windmill', port: parseInt(env.get('WINDMILL_PORT') || '5681'), type: 'automation', endpoint: '/api/version', critical: false },\n    { name: 'vault', port: parseInt(env.get('VAULT_PORT') || '8200'), type: 'storage', endpoint: '/v1/sys/health', critical: true },\n    { name: 'ollama', port: parseInt(env.get('OLLAMA_PORT') || '11434'), type: 'ai', endpoint: '/api/tags', critical: false },\n    { name: 'minio', port: parseInt(env.get('MINIO_PORT') || '9000'), type: 'storage', endpoint: '/minio/health/live', critical: false },\n    { name: 'browserless', port: parseInt(env.get('BROWSERLESS_PORT') || '4110'), type: 'agent', endpoint: '/metrics', critical: false },\n    { name: 'qdrant', port: parseInt(env.get('QDRANT_PORT') || '6333'), type: 'storage', endpoint: '/health', critical: false },\n    { name: 'whisper', port: parseInt(env.get('WHISPER_PORT') || '8090'), type: 'ai', endpoint: '/health', critical: false },\n    { name: 'unstructured-io', port: parseInt(env.get('UNSTRUCTURED_IO_PORT') || '11450'), type: 'ai', endpoint: '/general/v0/general', critical: false },\n    { name: 'judge0', port: parseInt(env.get('JUDGE0_PORT') || '2358'), type: 'execution', endpoint: '/config', critical: false }\n];\n\n// Get cached resources from global context or use defaults\nconst cachedResources = global.get('monitored_resources') || defaultResources;\n\n// Filter only enabled resources\nconst enabledResources = cachedResources.filter(r => r.enabled !== false);\n\n// Send each resource as a separate message\nconst messages = enabledResources.map(resource => ({\n    payload: resource,\n    topic: 'check-health'\n}));\n\nnode.log(`Monitoring ${messages.length} resources`);\nreturn [messages];",
    "outputs": 1,
    "noerr": 0,
    "initialize": "",
    "finalize": "",
    "libs": [],
    "x": 350,
    "y": 100,
    "wires": [["route-health-check"]]
  },
  {
    "id": "route-health-check",
    "type": "switch",
    "z": "flow-metrics-collector",
    "name": "Route Health Check",
    "property": "payload.endpoint",
    "propertyType": "msg",
    "rules": [
      {
        "t": "nnull"
      },
      {
        "t": "null"
      }
    ],
    "checkall": "true",
    "repair": false,
    "outputs": 2,
    "x": 550,
    "y": 100,
    "wires": [["http-health-check"], ["tcp-health-check"]]
  },
  {
    "id": "http-health-check",
    "type": "http request",
    "z": "flow-metrics-collector",
    "name": "HTTP Health Check",
    "method": "GET",
    "ret": "obj",
    "paytoqs": "ignore",
    "url": "http://localhost:{{payload.port}}{{payload.endpoint}}",
    "tls": "",
    "persist": false,
    "proxy": "",
    "authType": "",
    "senderr": false,
    "headers": [],
    "timeout": "3",
    "x": 750,
    "y": 80,
    "wires": [["process-response"], ["handle-error"]]
  },
  {
    "id": "tcp-health-check",
    "type": "function",
    "z": "flow-metrics-collector",
    "name": "TCP Health Check",
    "func": "// Simulate TCP health check for services without HTTP endpoints\nconst resource = msg.payload;\nconst startTime = Date.now();\n\n// Simulate TCP connection check with timeout\nsetTimeout(() => {\n    const responseTime = Date.now() - startTime;\n    \n    // For TCP services, we assume they're healthy if port is reachable\n    // In a real implementation, this would use a TCP socket connection\n    msg.payload = resource;\n    msg.responseTime = responseTime;\n    msg.statusCode = 200; // Simulate successful TCP connection\n    \n    node.send([msg, null]); // Send to first output (success)\n}, Math.random() * 100 + 50); // Simulate network latency\n\nreturn null; // Don't return immediately",
    "outputs": 2,
    "noerr": 0,
    "initialize": "",
    "finalize": "",
    "libs": [],
    "x": 750,
    "y": 120,
    "wires": [["process-response"], ["handle-error"]]
  },
  {
    "id": "process-response",
    "type": "function",
    "z": "flow-metrics-collector",
    "name": "Process Health Response",
    "func": "// Process successful health check response\nconst resource = msg.payload;\nconst timestamp = new Date().toISOString();\nconst responseTime = msg.responseTime || Math.random() * 50 + 10; // Fallback for TCP checks\n\n// Determine status based on response time and resource type\nlet status = 'healthy';\nif (responseTime > 5000) {\n    status = 'degraded';\n} else if (responseTime > 1000 && resource.critical) {\n    status = 'degraded';\n}\n\nconst metric = {\n    timestamp: timestamp,\n    resource_name: resource.name,\n    resource_type: resource.type,\n    metric_type: 'availability',\n    value: 1.0,\n    status: status,\n    response_time_ms: Math.round(responseTime),\n    error_count: 0,\n    tags: `source=node-red,critical=${resource.critical || false}`\n};\n\n// Store original resource info for downstream processing\nmsg.resource = resource;\nmsg.payload = metric;\nmsg.topic = 'metric-ready';\nreturn msg;",
    "outputs": 1,
    "noerr": 0,
    "initialize": "",
    "finalize": "",
    "libs": [],
    "x": 780,
    "y": 80,
    "wires": [["prepare-questdb-query", "publish-redis"]]
  },
  {
    "id": "handle-error",
    "type": "function",
    "z": "flow-metrics-collector",
    "name": "Handle Error",
    "func": "// Process failed health check\nconst resource = msg.payload;\nconst timestamp = new Date().toISOString();\nconst errorInfo = msg.error || {};\n\n// Determine severity based on resource criticality\nconst severity = resource.critical ? 'critical' : 'warning';\n\nconst metric = {\n    timestamp: timestamp,\n    resource_name: resource.name,\n    resource_type: resource.type,\n    metric_type: 'availability',\n    value: 0.0,\n    status: 'down',\n    response_time_ms: 0,\n    error_count: 1,\n    tags: `source=node-red,error=true,critical=${resource.critical}`\n};\n\n// Add alert information for critical resources or repeated failures\nif (resource.critical || severity === 'critical') {\n    metric.alert_required = true;\n    metric.severity = severity;\n    metric.alert_message = `${resource.name} (${resource.type}) is unreachable - ${errorInfo.message || 'Connection failed'}`;\n}\n\n// Store original resource info and error details\nmsg.resource = resource;\nmsg.error_info = errorInfo;\nmsg.payload = metric;\nmsg.topic = 'metric-error';\n\nnode.warn(`Health check failed for ${resource.name}: ${errorInfo.message || 'Unknown error'}`);\nreturn msg;",
    "outputs": 1,
    "noerr": 0,
    "initialize": "",
    "finalize": "",
    "libs": [],
    "x": 770,
    "y": 120,
    "wires": [["prepare-questdb-query", "publish-redis", "check-alert"]]
  },
  {
    "id": "prepare-questdb-query",
    "type": "function",
    "z": "flow-metrics-collector",
    "name": "Prepare QuestDB Query",
    "func": "// Build QuestDB INSERT query for resource_metrics table\nconst metric = msg.payload;\n\nconst query = `INSERT INTO resource_metrics VALUES(\n    '${metric.timestamp}',\n    '${metric.resource_name}',\n    '${metric.resource_type}',\n    '${metric.metric_type}',\n    ${metric.value},\n    '${metric.status}',\n    ${metric.response_time_ms},\n    ${metric.error_count},\n    '${metric.tags}'\n)`;\n\nmsg.payload = { query: query };\nreturn msg;",
    "outputs": 1,
    "noerr": 0,
    "initialize": "",
    "finalize": "",
    "libs": [],
    "x": 990,
    "y": 80,
    "wires": [["write-questdb"]]
  },
  {
    "id": "write-questdb",
    "type": "http request",
    "z": "flow-metrics-collector",
    "name": "Write to QuestDB",
    "method": "GET",
    "ret": "txt",
    "paytoqs": "query",
    "url": "http://localhost:{{flow.get('questdb_port') || 9009}}/exec",
    "tls": "",
    "persist": false,
    "proxy": "",
    "authType": "",
    "senderr": false,
    "headers": [],
    "x": 1210,
    "y": 80,
    "wires": [["questdb-success"], ["questdb-error"]]
  },
  {
    "id": "publish-redis",
    "type": "function",
    "z": "flow-metrics-collector",
    "name": "Publish to Redis",
    "func": "// Prepare message for Redis pub/sub and cache\nconst metric = msg.payload;\nconst channel = `monitoring:metrics:${metric.resource_name}`;\nconst cacheKey = `monitoring:current:${metric.resource_name}`;\n\n// Prepare Redis operations\nconst operations = [\n    // Publish real-time update\n    {\n        command: 'PUBLISH',\n        args: [channel, JSON.stringify(metric)]\n    },\n    // Update current status cache (expires in 5 minutes)\n    {\n        command: 'SETEX',\n        args: [cacheKey, 300, JSON.stringify({\n            status: metric.status,\n            timestamp: metric.timestamp,\n            response_time_ms: metric.response_time_ms,\n            resource_type: metric.resource_type\n        })]\n    },\n    // Update global status summary\n    {\n        command: 'HSET',\n        args: [`monitoring:summary`, metric.resource_name, metric.status]\n    }\n];\n\nmsg.payload = operations;\nmsg.topic = 'redis-operations';\nreturn msg;",
    "outputs": 1,
    "noerr": 0,
    "initialize": "",
    "finalize": "",
    "libs": [],
    "x": 1010,
    "y": 160,
    "wires": [["redis-batch"]]
  },
  {
    "id": "check-alert",
    "type": "switch",
    "z": "flow-metrics-collector",
    "name": "Alert Required?",
    "property": "payload.alert_required",
    "propertyType": "msg",
    "rules": [
      {
        "t": "true"
      }
    ],
    "checkall": "true",
    "repair": false,
    "outputs": 1,
    "x": 1010,
    "y": 220,
    "wires": [["trigger-alert"]]
  },
  {
    "id": "trigger-alert",
    "type": "http request",
    "z": "flow-metrics-collector",
    "name": "Trigger n8n Alert",
    "method": "POST",
    "ret": "obj",
    "paytoqs": "ignore",
    "url": "http://localhost:{{flow.get('n8n_port') || 5678}}/webhook/alert-handler",
    "tls": "",
    "persist": false,
    "proxy": "",
    "authType": "",
    "senderr": false,
    "headers": [
      {
        "keyType": "Content-Type",
        "keyValue": "",
        "valueType": "other",
        "valueValue": "application/json"
      }
    ],
    "x": 1210,
    "y": 220,
    "wires": [[]]
  },
  {
    "id": "redis-batch",
    "type": "function",
    "z": "flow-metrics-collector",
    "name": "Execute Redis Batch",
    "func": "// Execute Redis operations via HTTP API (redis-cli over HTTP)\n// This simulates Redis operations for environments without Redis node\nconst operations = msg.payload;\nlet completedOps = 0;\nconst totalOps = operations.length;\n\n// Simulate Redis operations\noperations.forEach(op => {\n    // In a real implementation, this would make HTTP calls to Redis\n    // For now, we'll simulate successful operations\n    node.log(`Redis ${op.command}: ${op.args.join(' ')}`);\n    completedOps++;\n});\n\n// Update node status\nif (completedOps === totalOps) {\n    node.status({fill:\"green\",shape:\"dot\",text:`${completedOps} ops complete`});\n} else {\n    node.status({fill:\"yellow\",shape:\"dot\",text:`${completedOps}/${totalOps} ops`});\n}\n\n// Pass message through for further processing if needed\nreturn msg;",
    "outputs": 1,
    "noerr": 0,
    "initialize": "",
    "finalize": "",
    "libs": [],
    "x": 1210,
    "y": 160,
    "wires": [["ws-realtime"]]
  },
  {
    "id": "questdb-success",
    "type": "function",
    "z": "flow-metrics-collector",
    "name": "Log Success",
    "func": "// Log successful metric write\nnode.status({fill:\"green\",shape:\"dot\",text:\"metric stored\"});\n// Store current metric in global context for API access\nconst current_metrics = global.get('current_metrics') || {};\ncurrent_metrics[msg.payload.resource_name] = {\n    status: msg.payload.status,\n    timestamp: msg.payload.timestamp,\n    response_time: msg.payload.response_time_ms\n};\nglobal.set('current_metrics', current_metrics);\nreturn msg;",
    "outputs": 1,
    "noerr": 0,
    "initialize": "",
    "finalize": "",
    "libs": [],
    "x": 1400,
    "y": 60,
    "wires": [[]]
  },
  {
    "id": "questdb-error",
    "type": "function",
    "z": "flow-metrics-collector",
    "name": "Log QuestDB Error",
    "func": "// Log QuestDB write errors\nnode.warn(`Failed to write metric to QuestDB: ${msg.error}`);\nnode.status({fill:\"red\",shape:\"dot\",text:\"write failed\"});\nreturn null;",
    "outputs": 0,
    "noerr": 0,
    "initialize": "",
    "finalize": "",
    "libs": [],
    "x": 1410,
    "y": 100,
    "wires": []
  },
  {
    "id": "ws-realtime",
    "type": "websocket out",
    "z": "flow-metrics-collector",
    "name": "WebSocket Broadcast",
    "server": "",
    "client": "ws-server",
    "x": 1240,
    "y": 300,
    "wires": []
  },
  {
    "id": "ws-server",
    "type": "websocket-listener",
    "path": "/ws/metrics",
    "wholemsg": "false"
  },
  {
    "id": "aggregate-metrics",
    "type": "inject",
    "z": "flow-metrics-collector",
    "name": "Every 5 minutes",
    "props": [
      {
        "p": "payload"
      },
      {
        "p": "topic",
        "vt": "str"
      }
    ],
    "repeat": "300",
    "crontab": "",
    "once": false,
    "onceDelay": "60",
    "topic": "aggregate",
    "payload": "{}",
    "payloadType": "json",
    "x": 150,
    "y": 400,
    "wires": [["calculate-aggregates"]]
  },
  {
    "id": "calculate-aggregates",
    "type": "function",
    "z": "flow-metrics-collector",
    "name": "Calculate 5min Aggregates",
    "func": "// Query QuestDB for recent metrics and calculate aggregates\nconst query = `\n    SELECT \n        resource_name,\n        resource_type,\n        avg(value) as availability_percent,\n        avg(response_time_ms) as avg_response_time_ms,\n        max(response_time_ms) as max_response_time_ms,\n        min(response_time_ms) as min_response_time_ms,\n        sum(error_count) as error_count,\n        count(*) as request_count\n    FROM resource_metrics\n    WHERE timestamp > dateadd('m', -5, now())\n    GROUP BY resource_name, resource_type\n`;\n\nmsg.payload = { query: query };\nmsg.topic = 'aggregate-query';\nreturn msg;",
    "outputs": 1,
    "noerr": 0,
    "initialize": "",
    "finalize": "",
    "libs": [],
    "x": 380,
    "y": 400,
    "wires": [["query-questdb"]]
  },
  {
    "id": "query-questdb",
    "type": "http request",
    "z": "flow-metrics-collector",
    "name": "Query QuestDB",
    "method": "GET",
    "ret": "obj",
    "paytoqs": "query",
    "url": "http://localhost:{{flow.get('questdb_port') || 9009}}/exec",
    "tls": "",
    "persist": false,
    "proxy": "",
    "authType": "",
    "senderr": false,
    "headers": [],
    "x": 600,
    "y": 400,
    "wires": [["store-aggregates"]]
  },
  {
    "id": "store-aggregates",
    "type": "function",
    "z": "flow-metrics-collector",
    "name": "Store Aggregates",
    "func": "// Store aggregated metrics back to QuestDB\nconst timestamp = new Date().toISOString();\nconst aggregates = msg.payload.dataset || [];\n\nconst queries = aggregates.map(agg => {\n    return `INSERT INTO metrics_5min VALUES('${timestamp}', '${agg.resource_name}', '${agg.resource_type}', ${agg.availability_percent}, ${agg.avg_response_time_ms}, ${agg.max_response_time_ms}, ${agg.min_response_time_ms}, ${agg.error_count}, ${agg.request_count}, null, null, null)`;\n});\n\nmsg.payload = { queries: queries };\nmsg.topic = 'store-aggregates';\nreturn msg;",
    "outputs": 1,
    "noerr": 0,
    "initialize": "",
    "finalize": "",
    "libs": [],
    "x": 810,
    "y": 400,
    "wires": [["write-aggregates"]]
  },
  {
    "id": "write-aggregates",
    "type": "http request",
    "z": "flow-metrics-collector",
    "name": "Write Aggregates",
    "method": "GET",
    "ret": "txt",
    "paytoqs": "query",
    "url": "http://localhost:{{flow.get('questdb_port') || 9009}}/exec",
    "tls": "",
    "persist": false,
    "proxy": "",
    "authType": "",
    "senderr": false,
    "headers": [],
    "x": 1010,
    "y": 400,
    "wires": [[]]
  },
  {
    "id": "http-api",
    "type": "http in",
    "z": "flow-metrics-collector",
    "name": "Metrics API",
    "url": "/api/metrics/current",
    "method": "get",
    "upload": false,
    "swaggerDoc": "",
    "x": 130,
    "y": 500,
    "wires": [["get-current-metrics"]]
  },
  {
    "id": "get-current-metrics",
    "type": "function",
    "z": "flow-metrics-collector",
    "name": "Get Current Metrics",
    "func": "// Return current metrics from cache\nmsg.payload = {\n    timestamp: new Date().toISOString(),\n    metrics: global.get('current_metrics') || {},\n    summary: global.get('health_summary') || {}\n};\nreturn msg;",
    "outputs": 1,
    "noerr": 0,
    "initialize": "",
    "finalize": "",
    "libs": [],
    "x": 340,
    "y": 500,
    "wires": [["http-response"]]
  },
  {
    "id": "http-response",
    "type": "http response",
    "z": "flow-metrics-collector",
    "name": "API Response",
    "statusCode": "200",
    "headers": {
      "Content-Type": "application/json"
    },
    "x": 540,
    "y": 500,
    "wires": []
  }
]