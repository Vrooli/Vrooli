{
  "name": "Research Orchestrator - Main Pipeline",
  "nodes": [
    {
      "parameters": {
        "path": "research-request",
        "httpMethod": "POST",
        "responseMode": "onReceived",
        "options": {}
      },
      "id": "webhook-trigger",
      "name": "Research Request Webhook",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2,
      "position": [240, 300],
      "webhookId": "research-request"
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// Validate and process research request\nconst body = $input.item.json.body;\n\n// Validate required fields\nif (!body.topic) {\n  throw new Error('Topic is required');\n}\n\n// Set defaults and validate parameters\nconst request = {\n  id: body.id || $('Webhook').item.json.headers['x-request-id'] || crypto.randomUUID(),\n  topic: body.topic.trim(),\n  depth: body.depth || 'standard', // quick, standard, deep\n  target_length: Math.max(1, Math.min(10, body.target_length || 5)),\n  language: body.language || 'en',\n  requested_by: body.requested_by || 'system',\n  organization: body.organization || 'default',\n  schedule_id: body.schedule_id || null,\n  custom_prompts: body.custom_prompts || {},\n  search_filters: body.search_filters || {},\n  timestamp: new Date().toISOString(),\n  processing_start: Date.now()\n};\n\n// Calculate search parameters based on depth\nconst depthConfig = {\n  quick: { max_sources: 10, search_rounds: 2, min_credible_sources: 5 },\n  standard: { max_sources: 20, search_rounds: 3, min_credible_sources: 10 },\n  deep: { max_sources: 40, search_rounds: 4, min_credible_sources: 15 }\n};\n\nconst config = depthConfig[request.depth];\nrequest.search_config = config;\n\n// Generate initial search queries\nconst queries = [\n  request.topic,\n  `${request.topic} latest research`,\n  `${request.topic} analysis trends`,\n  `${request.topic} expert opinion`\n];\n\nif (request.depth === 'deep') {\n  queries.push(\n    `${request.topic} academic papers`,\n    `${request.topic} industry report`,\n    `${request.topic} market analysis`\n  );\n}\n\nrequest.search_queries = queries;\n\nreturn request;"
      },
      "id": "process-request",
      "name": "Process Research Request",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [460, 300]
    },
    {
      "parameters": {
        "operation": "insert",
        "schema": "research_assistant",
        "table": "reports",
        "columns": "id, title, topic, depth, target_length, status, requested_at, requested_by, organization, schedule_id",
        "additionalFields": {
          "mode": "independently"
        }
      },
      "id": "create-report-record",
      "name": "Create Report Record",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2,
      "position": [680, 300],
      "credentials": {
        "postgres": {
          "id": "postgres-research",
          "name": "Research Assistant DB"
        }
      }
    },
    {
      "parameters": {
        "batchSize": 1,
        "options": {}
      },
      "id": "split-search-queries",
      "name": "Split Search Queries",
      "type": "n8n-nodes-base.splitInBatches",
      "typeVersion": 3,
      "position": [900, 300]
    },
    {
      "parameters": {
        "url": "http://localhost:9200/search",
        "sendQuery": true,
        "queryParameters": {
          "parameters": [
            {
              "name": "q",
              "value": "={{ $json.search_queries[$json.search_round || 0] }}"
            },
            {
              "name": "format",
              "value": "json"
            },
            {
              "name": "engines",
              "value": "google,bing,duckduckgo,startpage"
            },
            {
              "name": "safesearch",
              "value": "1"
            },
            {
              "name": "time_range",
              "value": "month"
            }
          ]
        },
        "options": {
          "timeout": 15000,
          "retry": {
            "enabled": true,
            "maxRetries": 2
          }
        }
      },
      "id": "searxng-search",
      "name": "SearXNG Web Search",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4,
      "position": [1120, 300]
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// Process and filter search results\nconst results = $input.item.json.results || [];\nconst query = $input.item.json.query || '';\nconst searchConfig = $('Process Research Request').item.json.search_config;\n\n// Filter and score results\nconst processedResults = results\n  .filter(result => {\n    // Basic filtering\n    if (!result.url || !result.title) return false;\n    if (result.url.includes('facebook.com') || result.url.includes('twitter.com')) return false;\n    if (result.content && result.content.length < 50) return false;\n    return true;\n  })\n  .map(result => {\n    // Calculate relevance score\n    let relevanceScore = 0;\n    const title = (result.title || '').toLowerCase();\n    const content = (result.content || '').toLowerCase();\n    const queryTerms = query.toLowerCase().split(' ');\n    \n    queryTerms.forEach(term => {\n      if (title.includes(term)) relevanceScore += 3;\n      if (content.includes(term)) relevanceScore += 1;\n    });\n    \n    // Domain credibility scoring\n    let credibilityScore = 0.5; // Default\n    const domain = new URL(result.url).hostname;\n    \n    const highCredibilityDomains = ['arxiv.org', 'nature.com', 'science.org', 'ieee.org', 'acm.org', 'pubmed.ncbi.nlm.nih.gov'];\n    const mediumCredibilityDomains = ['edu', 'gov', 'org'];\n    \n    if (highCredibilityDomains.some(d => domain.includes(d))) {\n      credibilityScore = 0.95;\n    } else if (mediumCredibilityDomains.some(d => domain.includes(d))) {\n      credibilityScore = 0.8;\n    } else if (domain.includes('wikipedia.org')) {\n      credibilityScore = 0.7;\n    }\n    \n    return {\n      ...result,\n      relevance_score: relevanceScore,\n      credibility_score: credibilityScore,\n      domain: domain,\n      query_used: query\n    };\n  })\n  .sort((a, b) => (b.relevance_score * b.credibility_score) - (a.relevance_score * a.credibility_score))\n  .slice(0, Math.ceil(searchConfig.max_sources / 3)); // Take top results per search\n\nreturn {\n  search_results: processedResults,\n  search_query: query,\n  results_count: processedResults.length,\n  processing_timestamp: new Date().toISOString()\n};"
      },
      "id": "process-search-results",
      "name": "Process Search Results",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1340, 300]
    },
    {
      "parameters": {
        "batchSize": 1,
        "options": {}
      },
      "id": "split-top-sources",
      "name": "Split Top Sources",
      "type": "n8n-nodes-base.splitInBatches",
      "typeVersion": 3,
      "position": [1560, 300]
    },
    {
      "parameters": {
        "url": "http://localhost:4110/content",
        "sendBody": true,
        "bodyParameters": {
          "parameters": [
            {
              "name": "url",
              "value": "={{ $json.search_results[0].url }}"
            },
            {
              "name": "waitFor",
              "value": "networkidle2"
            },
            {
              "name": "timeout",
              "value": "30000"
            }
          ]
        },
        "options": {
          "timeout": 45000,
          "retry": {
            "enabled": true,
            "maxRetries": 1
          }
        }
      },
      "id": "browserless-extract",
      "name": "Extract Content (Browserless)",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4,
      "position": [1780, 300]
    },
    {
      "parameters": {
        "url": "http://localhost:11450/general/v0/general",
        "sendBody": true,
        "bodyParameters": {
          "parameters": [
            {
              "name": "text",
              "value": "={{ $json.content }}"
            },
            {
              "name": "strategy",
              "value": "fast"
            },
            {
              "name": "chunking_strategy",
              "value": "by_title"
            }
          ]
        },
        "options": {
          "timeout": 30000
        }
      },
      "id": "unstructured-process",
      "name": "Process with Unstructured-IO",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4,
      "position": [2000, 300]
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// Combine extracted content with source metadata\nconst sourceResult = $('Split Top Sources').item.json.search_results[0];\nconst extractedContent = $input.item.json.elements || [];\n\n// Clean and structure the extracted text\nconst cleanText = extractedContent\n  .map(el => el.text || '')\n  .join(' ')\n  .replace(/\\s+/g, ' ')\n  .trim();\n\nif (!cleanText || cleanText.length < 100) {\n  // If extraction failed, use original search result content\n  return {\n    url: sourceResult.url,\n    title: sourceResult.title,\n    extracted_text: sourceResult.content || '',\n    extraction_method: 'searxng_fallback',\n    credibility_score: sourceResult.credibility_score,\n    relevance_score: sourceResult.relevance_score,\n    domain: sourceResult.domain,\n    word_count: (sourceResult.content || '').split(' ').length,\n    extraction_success: false\n  };\n}\n\nreturn {\n  url: sourceResult.url,\n  title: sourceResult.title,\n  extracted_text: cleanText,\n  extraction_method: 'browserless_unstructured',\n  credibility_score: sourceResult.credibility_score,\n  relevance_score: sourceResult.relevance_score,\n  domain: sourceResult.domain,\n  word_count: cleanText.split(' ').length,\n  extraction_success: true,\n  processing_timestamp: new Date().toISOString()\n};"
      },
      "id": "combine-source-data",
      "name": "Combine Source Data",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [2220, 300]
    },
    {
      "parameters": {
        "operation": "insert",
        "schema": "research_assistant",
        "table": "report_sources",
        "columns": "report_id, url, title, extracted_text, credibility_score, relevance_score, extraction_method, domain",
        "additionalFields": {
          "mode": "independently"
        }
      },
      "id": "save-source",
      "name": "Save Source to DB",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2,
      "position": [2440, 300],
      "credentials": {
        "postgres": {
          "id": "postgres-research",
          "name": "Research Assistant DB"
        }
      }
    },
    {
      "parameters": {
        "mode": "runOnceForAllItems",
        "jsCode": "// Aggregate all sources for analysis\nconst reportId = $('Process Research Request').item.json.id;\nconst topic = $('Process Research Request').item.json.topic;\nconst depth = $('Process Research Request').item.json.depth;\nconst targetLength = $('Process Research Request').item.json.target_length;\nconst customPrompts = $('Process Research Request').item.json.custom_prompts;\n\n// Collect all processed sources\nconst sources = $input.all().map(item => ({\n  url: item.json.url,\n  title: item.json.title,\n  text: item.json.extracted_text,\n  credibility: item.json.credibility_score,\n  relevance: item.json.relevance_score,\n  domain: item.json.domain,\n  word_count: item.json.word_count\n}));\n\n// Filter high-quality sources\nconst qualitySources = sources\n  .filter(s => s.credibility >= 0.6 && s.word_count >= 100)\n  .sort((a, b) => (b.credibility * b.relevance) - (a.credibility * a.relevance));\n\nif (qualitySources.length < 3) {\n  throw new Error(`Insufficient quality sources found. Got ${qualitySources.length}, need at least 3.`);\n}\n\n// Prepare analysis prompt based on depth and custom prompts\nlet analysisPrompt = `You are a professional research analyst. Create a comprehensive research report on \"${topic}\".\n\n**Requirements:**\n- Target length: ${targetLength} pages (approximately ${targetLength * 500} words)\n- Research depth: ${depth}\n- Use only the provided sources\n- Include proper citations\n- Maintain objectivity and cite conflicting viewpoints\n- Provide executive summary and key findings\n\n**Sources to analyze:**\n`;\n\nqualitySources.slice(0, depth === 'deep' ? 25 : depth === 'standard' ? 15 : 10).forEach((source, idx) => {\n  analysisPrompt += `\\n[${idx + 1}] ${source.title} (${source.domain})\\n${source.text.substring(0, 1000)}...\\n`;\n});\n\nanalysisPrompt += `\\n\\n**Structure your report with:**\n1. Executive Summary (2-3 paragraphs)\n2. Key Findings (with confidence levels)\n3. Detailed Analysis (main body)\n4. Contradictions or Limitations (if any)\n5. Conclusions and Implications\n6. Sources (numbered list)\n\n**Important:** Base all claims on the provided sources and cite them using [1], [2], etc.`;\n\n// Add custom prompt modifications\nif (customPrompts.focus_areas) {\n  analysisPrompt += `\\n\\n**Special Focus Areas:** ${customPrompts.focus_areas.join(', ')}`;\n}\nif (customPrompts.tone) {\n  analysisPrompt += `\\n\\n**Tone:** ${customPrompts.tone}`;\n}\n\nreturn {\n  report_id: reportId,\n  topic: topic,\n  analysis_prompt: analysisPrompt,\n  sources_count: qualitySources.length,\n  high_credibility_sources: qualitySources.filter(s => s.credibility >= 0.8).length,\n  total_word_count: qualitySources.reduce((sum, s) => sum + s.word_count, 0),\n  sources: qualitySources\n};"
      },
      "id": "aggregate-sources",
      "name": "Aggregate Sources for Analysis",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [2660, 300]
    },
    {
      "parameters": {
        "url": "http://localhost:11434/api/generate",
        "sendBody": true,
        "bodyParameters": {
          "parameters": [
            {
              "name": "model",
              "value": "qwen2.5:32b"
            },
            {
              "name": "prompt",
              "value": "={{ $json.analysis_prompt }}"
            },
            {
              "name": "stream",
              "value": "false"
            },
            {
              "name": "options",
              "value": "{\n  \"temperature\": 0.7,\n  \"top_p\": 0.9,\n  \"max_tokens\": 4000\n}"
            }
          ]
        },
        "options": {
          "timeout": 300000
        }
      },
      "id": "ollama-analysis",
      "name": "Generate Report (Ollama)",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4,
      "position": [2880, 300]
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// Process the generated report\nconst reportData = $('Aggregate Sources for Analysis').item.json;\nconst aiResponse = $input.item.json.response;\n\nif (!aiResponse || aiResponse.trim().length < 500) {\n  throw new Error('Generated report is too short or empty');\n}\n\n// Extract key findings (simple pattern matching)\nconst keyFindingsRegex = /(?:key findings?|main findings?|findings):\\s*([\\s\\S]*?)(?:\\n\\n|(?=\\d+\\.|conclusion|sources?))/i;\nconst keyFindingsMatch = aiResponse.match(keyFindingsRegex);\nconst keyFindingsText = keyFindingsMatch ? keyFindingsMatch[1].trim() : '';\n\n// Extract summary\nconst summaryRegex = /(?:executive summary|summary):\\s*([\\s\\S]*?)(?:\\n\\n|(?=\\d+\\.|key findings?))/i;\nconst summaryMatch = aiResponse.match(summaryRegex);\nconst summary = summaryMatch ? summaryMatch[1].trim() : aiResponse.substring(0, 300) + '...';\n\n// Calculate confidence score based on source quality\nconst avgCredibility = reportData.sources.reduce((sum, s) => sum + s.credibility, 0) / reportData.sources.length;\nconst confidenceScore = Math.min(0.95, avgCredibility * 0.8 + (reportData.high_credibility_sources / reportData.sources_count) * 0.2);\n\n// Count words\nconst wordCount = aiResponse.split(/\\s+/).length;\n\n// Prepare key findings as JSONB\nconst keyFindings = keyFindingsText.split('\\n')\n  .filter(line => line.trim().length > 10)\n  .slice(0, 10) // Max 10 key findings\n  .map(finding => ({\n    finding: finding.replace(/^[\\d\\-\\*\\â€¢]\\s*/, '').trim(),\n    confidence: confidenceScore,\n    sources: Math.min(reportData.sources_count, 5)\n  }));\n\nreturn {\n  report_id: reportData.report_id,\n  markdown_content: aiResponse,\n  summary: summary,\n  key_findings: keyFindings,\n  sources_count: reportData.sources_count,\n  word_count: wordCount,\n  confidence_score: parseFloat(confidenceScore.toFixed(2)),\n  processing_time_seconds: Math.floor((Date.now() - $('Process Research Request').item.json.processing_start) / 1000),\n  completed_at: new Date().toISOString()\n};"
      },
      "id": "process-report",
      "name": "Process Generated Report",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [3100, 300]
    },
    {
      "parameters": {
        "operation": "update",
        "schema": "research_assistant", 
        "table": "reports",
        "updateKey": "id",
        "columns": "markdown_content, summary, key_findings, sources_count, word_count, confidence_score, status, completed_at, processing_time_seconds",
        "additionalFields": {
          "mode": "independently"
        }
      },
      "id": "update-report",
      "name": "Update Report Record",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2,
      "position": [3320, 300],
      "credentials": {
        "postgres": {
          "id": "postgres-research",
          "name": "Research Assistant DB"
        }
      }
    },
    {
      "parameters": {
        "url": "http://localhost:11434/api/embeddings",
        "sendBody": true,
        "bodyParameters": {
          "parameters": [
            {
              "name": "model",
              "value": "nomic-embed-text"
            },
            {
              "name": "prompt",
              "value": "={{ $json.summary + ' ' + $json.markdown_content.substring(0, 2000) }}"
            }
          ]
        },
        "options": {
          "timeout": 60000
        }
      },
      "id": "generate-embeddings",
      "name": "Generate Report Embeddings",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4,
      "position": [3540, 300]
    },
    {
      "parameters": {
        "url": "http://localhost:6333/collections/research-documents/points",
        "sendBody": true,
        "bodyParameters": {
          "parameters": [
            {
              "name": "points",
              "value": "[{\n  \"id\": \"{{ $('Process Generated Report').item.json.report_id }}\",\n  \"vector\": {{ $json.embedding }},\n  \"payload\": {\n    \"report_id\": \"{{ $('Process Generated Report').item.json.report_id }}\",\n    \"title\": \"{{ $('Process Research Request').item.json.topic }}\",\n    \"summary\": \"{{ $('Process Generated Report').item.json.summary }}\",\n    \"category\": \"research-report\",\n    \"created_at\": \"{{ $('Process Generated Report').item.json.completed_at }}\",\n    \"word_count\": {{ $('Process Generated Report').item.json.word_count }},\n    \"confidence_score\": {{ $('Process Generated Report').item.json.confidence_score }}\n  }\n}]"
            }
          ]
        },
        "options": {
          "timeout": 30000
        }
      },
      "id": "store-embeddings",
      "name": "Store in Qdrant",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4,
      "position": [3760, 300]
    },
    {
      "parameters": {
        "url": "http://localhost:11450/general/v0/pdf",
        "sendBody": true,
        "bodyParameters": {
          "parameters": [
            {
              "name": "text",
              "value": "={{ $('Process Generated Report').item.json.markdown_content }}"
            },
            {
              "name": "filename",
              "value": "research-report-{{ $('Process Generated Report').item.json.report_id }}.pdf"
            }
          ]
        },
        "options": {
          "timeout": 60000
        }
      },
      "id": "generate-pdf",
      "name": "Generate PDF Report",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4,
      "position": [3980, 300]
    },
    {
      "parameters": {
        "url": "http://localhost:9000/research-pdfs/{{ $('Process Generated Report').item.json.report_id }}.pdf",
        "sendBody": true,
        "bodyContentType": "raw",
        "body": "={{ $json.pdf_data }}",
        "options": {
          "timeout": 30000
        }
      },
      "id": "store-pdf",
      "name": "Store PDF in MinIO",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4,
      "position": [4200, 300]
    },
    {
      "parameters": {
        "operation": "update",
        "schema": "research_assistant",
        "table": "reports", 
        "updateKey": "id",
        "columns": "pdf_url, embedding_id",
        "additionalFields": {
          "mode": "independently"
        }
      },
      "id": "finalize-report",
      "name": "Finalize Report Record",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2,
      "position": [4420, 300],
      "credentials": {
        "postgres": {
          "id": "postgres-research",
          "name": "Research Assistant DB"
        }
      }
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "{\n  \"success\": true,\n  \"report_id\": \"{{ $('Process Generated Report').item.json.report_id }}\",\n  \"title\": \"{{ $('Process Research Request').item.json.topic }}\",\n  \"status\": \"completed\",\n  \"word_count\": {{ $('Process Generated Report').item.json.word_count }},\n  \"sources_count\": {{ $('Process Generated Report').item.json.sources_count }},\n  \"confidence_score\": {{ $('Process Generated Report').item.json.confidence_score }},\n  \"processing_time_seconds\": {{ $('Process Generated Report').item.json.processing_time_seconds }},\n  \"pdf_url\": \"http://localhost:9000/research-pdfs/{{ $('Process Generated Report').item.json.report_id }}.pdf\",\n  \"completed_at\": \"{{ $('Process Generated Report').item.json.completed_at }}\"\n}"
      },
      "id": "success-response",
      "name": "Success Response",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1,
      "position": [4640, 300]
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "id": "error_condition",
              "leftValue": "={{ $json.error }}",
              "rightValue": "",
              "operator": {
                "type": "string",
                "operation": "notExists"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "error-check",
      "name": "Check for Errors",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [680, 500]
    },
    {
      "parameters": {
        "operation": "update",
        "schema": "research_assistant",
        "table": "reports",
        "updateKey": "id", 
        "columns": "status, error_message",
        "additionalFields": {
          "mode": "independently"
        }
      },
      "id": "mark-failed",
      "name": "Mark Report as Failed",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2,
      "position": [900, 600],
      "credentials": {
        "postgres": {
          "id": "postgres-research",
          "name": "Research Assistant DB"
        }
      }
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "{\n  \"success\": false,\n  \"error\": \"{{ $json.error_message || 'Research pipeline failed' }}\",\n  \"report_id\": \"{{ $('Process Research Request').item.json.id }}\",\n  \"timestamp\": \"{{ new Date().toISOString() }}\"\n}",
        "responseCode": 500
      },
      "id": "error-response",
      "name": "Error Response", 
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1,
      "position": [1120, 600]
    }
  ],
  "pinData": {},
  "connections": {
    "Research Request Webhook": {
      "main": [
        [
          {
            "node": "Process Research Request",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Process Research Request": {
      "main": [
        [
          {
            "node": "Create Report Record",
            "type": "main",
            "index": 0
          },
          {
            "node": "Check for Errors",
            "type": "main", 
            "index": 0
          }
        ]
      ]
    },
    "Create Report Record": {
      "main": [
        [
          {
            "node": "Split Search Queries",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Split Search Queries": {
      "main": [
        [
          {
            "node": "SearXNG Web Search",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "SearXNG Web Search": {
      "main": [
        [
          {
            "node": "Process Search Results",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Process Search Results": {
      "main": [
        [
          {
            "node": "Split Top Sources",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Split Top Sources": {
      "main": [
        [
          {
            "node": "Extract Content (Browserless)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extract Content (Browserless)": {
      "main": [
        [
          {
            "node": "Process with Unstructured-IO",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Process with Unstructured-IO": {
      "main": [
        [
          {
            "node": "Combine Source Data",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Combine Source Data": {
      "main": [
        [
          {
            "node": "Save Source to DB",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Save Source to DB": {
      "main": [
        [
          {
            "node": "Aggregate Sources for Analysis",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Aggregate Sources for Analysis": {
      "main": [
        [
          {
            "node": "Generate Report (Ollama)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Generate Report (Ollama)": {
      "main": [
        [
          {
            "node": "Process Generated Report",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Process Generated Report": {
      "main": [
        [
          {
            "node": "Update Report Record",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Update Report Record": {
      "main": [
        [
          {
            "node": "Generate Report Embeddings",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Generate Report Embeddings": {
      "main": [
        [
          {
            "node": "Store in Qdrant",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Store in Qdrant": {
      "main": [
        [
          {
            "node": "Generate PDF Report",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Generate PDF Report": {
      "main": [
        [
          {
            "node": "Store PDF in MinIO",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Store PDF in MinIO": {
      "main": [
        [
          {
            "node": "Finalize Report Record",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Finalize Report Record": {
      "main": [
        [
          {
            "node": "Success Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Check for Errors": {
      "main": [
        [
          {
            "node": "Mark Report as Failed",
            "type": "main", 
            "index": 0
          }
        ]
      ]
    },
    "Mark Report as Failed": {
      "main": [
        [
          {
            "node": "Error Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": true,
  "settings": {
    "executionOrder": "v1"
  },
  "versionId": "1",
  "meta": {
    "templateCredsSetupCompleted": true
  },
  "id": "research-orchestrator",
  "tags": []
}