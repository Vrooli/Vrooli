{
  "name": "Task Planner - Text Parser",
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "parse-text",
        "responseMode": "responseNode",
        "options": {}
      },
      "id": "webhook_trigger",
      "name": "Webhook - Parse Text",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 1,
      "position": [200, 300]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "SELECT id, name, display_name, api_token FROM apps WHERE id = '{{ $json.app_id }}' AND api_token = '{{ $json.api_token }}'",
        "additionalFields": {}
      },
      "id": "validate_app",
      "name": "Validate App & Token",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 1,
      "position": [400, 300]
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "leftValue": "={{ $json.length }}",
              "rightValue": 0,
              "operator": {
                "type": "number",
                "operation": "gt"
              }
            }
          ],
          "combinator": "and"
        }
      },
      "id": "check_app_exists",
      "name": "Check App Exists",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [600, 300]
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// Extract and validate input\nconst rawText = $('webhook_trigger').item.json.raw_text;\nif (!rawText || typeof rawText !== 'string' || rawText.trim().length === 0) {\n  throw new Error('Missing or empty raw_text');\n}\n\n// Build the prompt for task extraction\nconst prompt = `You are a task extraction AI. Parse the following unstructured text into individual, actionable tasks.\n\nText to parse:\n${rawText}\n\nExtract tasks and return ONLY a JSON array with this format:\n[\n  {\n    \"title\": \"Task title (max 100 chars)\",\n    \"description\": \"Detailed description\",\n    \"priority\": \"high|medium|low\",\n    \"tags\": [\"tag1\", \"tag2\"],\n    \"estimated_hours\": 2.5\n  }\n]\n\nRules:\n- Extract all actionable items, TODOs, ideas that could become tasks\n- Keep titles concise but descriptive\n- Assign reasonable priorities based on context\n- Add relevant tags for categorization\n- Estimate completion time in hours\n- Return ONLY the JSON array, no other text`;\n\n// Escape single quotes in prompt for shell\nconst escapedPrompt = prompt.replace(/'/g, \"'\\\"'\\\"'\");\n\n// Build temp file for prompt\nconst timestamp = Date.now();\nconst randomId = Math.random().toString(36).substring(2, 8);\nconst tempFile = '/tmp/task_parser_prompt_' + timestamp + '_' + randomId + '.txt';\n\n// Build ollama command using the CLI\nconst command = `prompt_file=\"${tempFile}\"; ` +\n  `echo '${escapedPrompt}' > \"$prompt_file\"; ` +\n  `bash /vrooli/cli/vrooli resource ollama generate \"$(cat \"$prompt_file\")\" --model 'llama3.2:3b' --type 'reasoning' --quiet; ` +\n  `rm -f \"$prompt_file\"`;\n\nreturn {\n  command: command,\n  execution_meta: {\n    prompt_length: prompt.length,\n    model: 'llama3.2:3b',\n    type: 'reasoning',\n    temp_file: tempFile,\n    execution_id: 'task_parser_' + timestamp + '_' + randomId,\n    timestamp: new Date().toISOString()\n  }\n};"
      },
      "id": "prepare_ollama_command",
      "name": "Prepare Ollama Command",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [800, 200]
    },
    {
      "parameters": {
        "command": "={{ $json.command }}",
        "options": {
          "timeout": 60000
        }
      },
      "id": "parse_with_ollama",
      "name": "Parse Tasks with Ollama CLI",
      "type": "n8n-nodes-base.executeCommand",
      "typeVersion": 1,
      "position": [1000, 200]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "INSERT INTO unstructured_sessions (app_id, raw_text, input_type, submitted_by, processed) VALUES ('{{ $('validate_app').item.json.id }}', '{{ $('webhook_trigger').item.json.raw_text }}', '{{ $('webhook_trigger').item.json.input_type || \"markdown\" }}', '{{ $('webhook_trigger').item.json.submitted_by || \"api\" }}', false) RETURNING id",
        "additionalFields": {}
      },
      "id": "create_session",
      "name": "Create Processing Session",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 1,
      "position": [800, 300]
    },
    {
      "parameters": {
        "jsCode": "// Parse the Ollama CLI response and prepare task data\ntry {\n  const commandResult = $('parse_with_ollama').item.json;\n  const executionMeta = $('prepare_ollama_command').item.json.execution_meta;\n  const appId = $('validate_app').item.json.id;\n  const sessionId = $('create_session').item.json.id;\n  \n  // Check if the command was successful\n  if (commandResult.exitCode !== 0) {\n    throw new Error('Ollama command failed: ' + (commandResult.stderr || 'Unknown error'));\n  }\n  \n  const ollamaResponse = commandResult.stdout;\n  \n  // Clean and parse the JSON response\n  let tasksData;\n  try {\n    // Remove any markdown formatting or extra text\n    const cleanResponse = ollamaResponse.replace(/```json\\n?|```\\n?/g, '').trim();\n    tasksData = JSON.parse(cleanResponse);\n  } catch (parseError) {\n    // Fallback parsing for malformed responses\n    const jsonMatch = ollamaResponse.match(/\\[.*\\]/s);\n    if (jsonMatch) {\n      tasksData = JSON.parse(jsonMatch[0]);\n    } else {\n      throw new Error('Could not extract valid JSON from Ollama response');\n    }\n  }\n  \n  // Validate and prepare tasks for database insertion\n  const preparedTasks = tasksData.map((task, index) => ({\n    app_id: appId,\n    session_id: sessionId,\n    title: task.title.substring(0, 500), // Ensure max length\n    description: task.description || '',\n    priority: ['critical', 'high', 'medium', 'low'].includes(task.priority) ? task.priority : 'medium',\n    estimated_hours: parseFloat(task.estimated_hours) || null,\n    tags: JSON.stringify(task.tags || []),\n    status: 'backlog',\n    confidence_score: 0.85, // High confidence for AI-parsed tasks\n    metadata: JSON.stringify({\n      source: 'text_parser',\n      parsing_index: index,\n      original_text_snippet: task.title,\n      ollama_execution_id: executionMeta.execution_id\n    })\n  }));\n  \n  return [{ tasks: preparedTasks, task_count: preparedTasks.length }];\n  \n} catch (error) {\n  // Return error info for debugging\n  return [{ \n    error: error.message, \n    raw_response: $('parse_with_ollama').item.json,\n    tasks: [],\n    task_count: 0\n  }];\n}"
      },
      "id": "process_parsed_tasks",
      "name": "Process Parsed Tasks",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1200, 200]
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "leftValue": "={{ $json.task_count }}",
              "rightValue": 0,
              "operator": {
                "type": "number",
                "operation": "gt"
              }
            }
          ],
          "combinator": "and"
        }
      },
      "id": "check_tasks_found",
      "name": "Check Tasks Found",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [1200, 200]
    },
    {
      "parameters": {
        "mode": "chooseBranch",
        "output": "input",
        "rules": {
          "rules": [
            {
              "operation": "containsAny",
              "value": "={{ $json.tasks }}",
              "output": "split"
            }
          ]
        }
      },
      "id": "split_tasks",
      "name": "Split Tasks",
      "type": "n8n-nodes-base.splitInBatches",
      "typeVersion": 3,
      "position": [1400, 100]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "INSERT INTO tasks (app_id, session_id, title, description, status, priority, estimated_hours, tags, confidence_score, metadata) VALUES ('{{ $json.app_id }}', '{{ $json.session_id }}', '{{ $json.title }}', '{{ $json.description }}', '{{ $json.status }}', '{{ $json.priority }}', {{ $json.estimated_hours || 'NULL' }}, '{{ $json.tags }}', {{ $json.confidence_score }}, '{{ $json.metadata }}') RETURNING id, title, status, created_at",
        "additionalFields": {}
      },
      "id": "insert_task",
      "name": "Insert Task",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 1,
      "position": [1600, 100]
    },
    {
      "parameters": {
        "command": "=bash /vrooli/cli/vrooli resource ollama embed '{{ $json.title }} - {{ $json.description }}' --model 'nomic-embed-text' --quiet",
        "options": {
          "timeout": 30000
        }
      },
      "id": "generate_embedding",
      "name": "Generate Task Embedding",
      "type": "n8n-nodes-base.executeCommand",
      "typeVersion": 1,
      "position": [1800, 100]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "UPDATE tasks SET title_embedding = '{{ $json.stdout }}' WHERE id = '{{ $('insert_task').item.json.id }}'",
        "additionalFields": {}
      },
      "id": "update_embedding",
      "name": "Update Task Embedding",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 1,
      "position": [2000, 100]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "UPDATE unstructured_sessions SET processed = true, tasks_extracted = {{ $('process_parsed_tasks').item.json.task_count }}, processed_at = CURRENT_TIMESTAMP WHERE id = '{{ $('create_session').item.json.id }}'",
        "additionalFields": {}
      },
      "id": "update_session_status",
      "name": "Mark Session Complete",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 1,
      "position": [1400, 300]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "SELECT t.id, t.title, t.description, t.status, t.priority, t.tags, t.estimated_hours, t.created_at FROM tasks t WHERE t.session_id = '{{ $('create_session').item.json.id }}' ORDER BY t.created_at",
        "additionalFields": {}
      },
      "id": "get_created_tasks",
      "name": "Get Created Tasks",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 1,
      "position": [1600, 300]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "{\n  \"success\": true,\n  \"session_id\": \"{{ $('create_session').item.json.id }}\",\n  \"tasks_created\": {{ $('process_parsed_tasks').item.json.task_count }},\n  \"tasks\": {{ $json }}\n}"
      },
      "id": "success_response",
      "name": "Success Response",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1,
      "position": [1800, 300]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "{\n  \"success\": false,\n  \"error\": \"Invalid app_id or api_token\",\n  \"message\": \"Authentication failed\"\n}",
        "options": {
          "responseCode": 401
        }
      },
      "id": "auth_error_response",
      "name": "Auth Error Response",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1,
      "position": [600, 450]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "{\n  \"success\": false,\n  \"error\": \"No tasks found\",\n  \"message\": \"Could not extract any actionable tasks from the provided text\",\n  \"debug\": {{ JSON.stringify($('process_parsed_tasks').item.json) }}\n}",
        "options": {
          "responseCode": 422
        }
      },
      "id": "no_tasks_response",
      "name": "No Tasks Response",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1,
      "position": [1200, 350]
    }
  ],
  "pinData": {},
  "connections": {
    "webhook_trigger": {
      "main": [
        [
          {
            "node": "validate_app",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "validate_app": {
      "main": [
        [
          {
            "node": "check_app_exists",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "check_app_exists": {
      "main": [
        [
          {
            "node": "prepare_ollama_command",
            "type": "main",
            "index": 0
          },
          {
            "node": "create_session",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "auth_error_response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "prepare_ollama_command": {
      "main": [
        [
          {
            "node": "parse_with_ollama",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "parse_with_ollama": {
      "main": [
        [
          {
            "node": "process_parsed_tasks",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "process_parsed_tasks": {
      "main": [
        [
          {
            "node": "check_tasks_found",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "check_tasks_found": {
      "main": [
        [
          {
            "node": "split_tasks",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "no_tasks_response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "split_tasks": {
      "main": [
        [
          {
            "node": "insert_task",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "insert_task": {
      "main": [
        [
          {
            "node": "generate_embedding",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "generate_embedding": {
      "main": [
        [
          {
            "node": "update_embedding",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "update_embedding": {
      "main": [
        [
          {
            "node": "update_session_status",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "create_session": {
      "main": [
        [
          {
            "node": "update_session_status",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "update_session_status": {
      "main": [
        [
          {
            "node": "get_created_tasks",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "get_created_tasks": {
      "main": [
        [
          {
            "node": "success_response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "settings": {
    "executionOrder": "v1"
  },
  "staticData": null,
  "tags": [
    {
      "createdAt": "2024-01-01T00:00:00.000Z",
      "updatedAt": "2024-01-01T00:00:00.000Z",
      "id": "task-planner",
      "name": "task-planner"
    }
  ],
  "triggerCount": 1,
  "updatedAt": "2024-01-01T00:00:00.000Z",
  "versionId": "1"
}