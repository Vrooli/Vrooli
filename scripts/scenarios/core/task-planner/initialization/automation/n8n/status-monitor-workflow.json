{
  "name": "Task Planner - Status Monitor",
  "nodes": [
    {
      "parameters": {
        "rule": {
          "interval": [
            {
              "field": "minutes",
              "minutesInterval": 15
            }
          ]
        }
      },
      "id": "scheduler_trigger",
      "name": "Status Check Scheduler",
      "type": "n8n-nodes-base.cron",
      "typeVersion": 1,
      "position": [200, 300]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "SELECT COUNT(*) as stuck_tasks FROM tasks WHERE status = 'in_progress' AND (EXTRACT(EPOCH FROM (CURRENT_TIMESTAMP - started_at)) / 3600) > 24",
        "additionalFields": {}
      },
      "id": "check_stuck_tasks",
      "name": "Check for Stuck Tasks",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 1,
      "position": [400, 200]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "SELECT COUNT(*) as failed_runs FROM agent_runs WHERE created_at > CURRENT_TIMESTAMP - INTERVAL '1 hour' AND successful = false",
        "additionalFields": {}
      },
      "id": "check_failed_runs",
      "name": "Check Recent Failed Runs",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 1,
      "position": [400, 300]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "SELECT a.name, a.display_name, COUNT(t.id) as pending_tasks FROM apps a LEFT JOIN tasks t ON a.id = t.app_id AND t.status IN ('backlog', 'staged') GROUP BY a.id, a.name, a.display_name HAVING COUNT(t.id) > 0 ORDER BY COUNT(t.id) DESC",
        "additionalFields": {}
      },
      "id": "get_app_summaries",
      "name": "Get App Task Summaries",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 1,
      "position": [400, 400]
    },
    {
      "parameters": {
        "jsCode": "// Compile system status report\nconst stuckTasks = $('check_stuck_tasks').item.json.stuck_tasks || 0;\nconst recentFailures = $('check_failed_runs').item.json.failed_runs || 0;\nconst appSummaries = $input.all().map(item => item.json);\n\nconst systemStatus = {\n  timestamp: new Date().toISOString(),\n  health: {\n    stuck_tasks: parseInt(stuckTasks),\n    recent_failures: parseInt(recentFailures),\n    active_apps: appSummaries.length,\n    total_pending_tasks: appSummaries.reduce((sum, app) => sum + parseInt(app.pending_tasks), 0)\n  },\n  alerts: [],\n  app_summaries: appSummaries\n};\n\n// Generate alerts based on thresholds\nif (stuckTasks > 0) {\n  systemStatus.alerts.push({\n    level: 'warning',\n    type: 'stuck_tasks',\n    message: `${stuckTasks} tasks have been in progress for over 24 hours`,\n    action_required: 'Review and potentially restart or cancel stuck tasks'\n  });\n}\n\nif (recentFailures > 5) {\n  systemStatus.alerts.push({\n    level: 'error',\n    type: 'high_failure_rate',\n    message: `${recentFailures} agent runs failed in the last hour`,\n    action_required: 'Investigate system issues or resource availability'\n  });\n} else if (recentFailures > 2) {\n  systemStatus.alerts.push({\n    level: 'warning',\n    type: 'moderate_failures',\n    message: `${recentFailures} agent runs failed in the last hour`,\n    action_required: 'Monitor for recurring issues'\n  });\n}\n\n// Check for apps with high task volumes\nappSummaries.forEach(app => {\n  if (parseInt(app.pending_tasks) > 50) {\n    systemStatus.alerts.push({\n      level: 'info',\n      type: 'high_volume_app',\n      message: `App '${app.display_name}' has ${app.pending_tasks} pending tasks`,\n      action_required: 'Consider prioritizing or bulk processing'\n    });\n  }\n});\n\nreturn [{ status_report: systemStatus, has_alerts: systemStatus.alerts.length > 0 }];"
      },
      "id": "compile_status_report",
      "name": "Compile Status Report",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [600, 300]
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "leftValue": "={{ $json.has_alerts }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "equal"
              }
            }
          ],
          "combinator": "and"
        }
      },
      "id": "check_alerts_exist",
      "name": "Check If Alerts Exist",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [800, 300]
    },
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "status-update",
        "responseMode": "responseNode",
        "options": {}
      },
      "id": "webhook_status_update",
      "name": "Webhook - Status Update",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 1,
      "position": [200, 500]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "INSERT INTO task_transitions (task_id, from_status, to_status, triggered_by, trigger_type, reason, notes) VALUES ('{{ $json.task_id }}', '{{ $json.from_status }}', '{{ $json.to_status }}', '{{ $json.triggered_by || \"external\" }}', 'manual', '{{ $json.reason || \"Status updated via webhook\" }}', '{{ $json.notes || \"\" }}')",
        "additionalFields": {}
      },
      "id": "record_manual_transition",
      "name": "Record Manual Status Change",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 1,
      "position": [400, 500]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "UPDATE tasks SET status = '{{ $json.to_status }}', updated_at = CURRENT_TIMESTAMP WHERE id = '{{ $json.task_id }}'",
        "additionalFields": {}
      },
      "id": "update_task_status",
      "name": "Update Task Status",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 1,
      "position": [600, 500]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "SELECT t.*, a.name as app_name FROM tasks t JOIN apps a ON t.app_id = a.id WHERE t.id = '{{ $('webhook_status_update').item.json.task_id }}'",
        "additionalFields": {}
      },
      "id": "get_updated_task",
      "name": "Get Updated Task Details",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 1,
      "position": [800, 500]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "{\n  \"success\": true,\n  \"task_id\": \"{{ $json.id }}\",\n  \"title\": \"{{ $json.title }}\",\n  \"status\": \"{{ $json.status }}\",\n  \"app_name\": \"{{ $json.app_name }}\",\n  \"updated_at\": \"{{ $json.updated_at }}\"\n}"
      },
      "id": "status_update_response",
      "name": "Status Update Response",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1,
      "position": [1000, 500]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "SELECT t.id, t.title, t.status, t.priority, t.started_at, EXTRACT(EPOCH FROM (CURRENT_TIMESTAMP - t.started_at)) / 3600 as hours_in_progress, a.name as app_name FROM tasks t JOIN apps a ON t.app_id = a.id WHERE t.status = 'in_progress' AND (EXTRACT(EPOCH FROM (CURRENT_TIMESTAMP - t.started_at)) / 3600) > 24 ORDER BY t.started_at",
        "additionalFields": {}
      },
      "id": "get_stuck_task_details",
      "name": "Get Stuck Task Details",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 1,
      "position": [1000, 200]
    },
    {
      "parameters": {
        "mode": "chooseBranch",
        "output": "input",
        "rules": {
          "rules": [
            {
              "operation": "containsAny",
              "value": "={{ $input.all() }}",
              "output": "split"
            }
          ]
        }
      },
      "id": "split_stuck_tasks",
      "name": "Process Each Stuck Task",
      "type": "n8n-nodes-base.splitInBatches",
      "typeVersion": 3,
      "position": [1200, 200]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "UPDATE tasks SET status = 'failed', implementation_result = 'Task automatically failed due to timeout (>24 hours in progress)', completed_at = CURRENT_TIMESTAMP WHERE id = '{{ $json.id }}'",
        "additionalFields": {}
      },
      "id": "timeout_stuck_task",
      "name": "Timeout Stuck Task",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 1,
      "position": [1400, 200]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "INSERT INTO task_transitions (task_id, from_status, to_status, triggered_by, trigger_type, reason) VALUES ('{{ $('split_stuck_tasks').item.json.id }}', 'in_progress', 'failed', 'status-monitor', 'automated', 'Task timed out after 24 hours in progress')",
        "additionalFields": {}
      },
      "id": "record_timeout_transition",
      "name": "Record Timeout Transition",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 1,
      "position": [1600, 200]
    },
    {
      "parameters": {
        "jsCode": "// Log alert notification (could be extended to send emails, slack messages, etc.)\nconst statusReport = $('compile_status_report').item.json.status_report;\nconst alerts = statusReport.alerts;\n\n// For now, just log the alerts. In production, this could:\n// - Send email notifications\n// - Post to Slack/Discord\n// - Create dashboard notifications\n// - Trigger paging systems for critical alerts\n\nconst notificationSummary = {\n  timestamp: new Date().toISOString(),\n  alert_count: alerts.length,\n  error_alerts: alerts.filter(a => a.level === 'error').length,\n  warning_alerts: alerts.filter(a => a.level === 'warning').length,\n  info_alerts: alerts.filter(a => a.level === 'info').length,\n  system_health: {\n    stuck_tasks: statusReport.health.stuck_tasks,\n    recent_failures: statusReport.health.recent_failures,\n    active_apps: statusReport.health.active_apps,\n    total_pending_tasks: statusReport.health.total_pending_tasks\n  },\n  alerts_summary: alerts.map(alert => ({\n    level: alert.level,\n    type: alert.type,\n    message: alert.message\n  }))\n};\n\nconsole.log('Task Planner System Status Alert:', JSON.stringify(notificationSummary, null, 2));\n\nreturn [{ notification_sent: true, summary: notificationSummary }];"
      },
      "id": "send_alert_notifications",
      "name": "Send Alert Notifications",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1000, 250]
    },
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "bulk-status-update",
        "responseMode": "responseNode",
        "options": {}
      },
      "id": "webhook_bulk_update",
      "name": "Webhook - Bulk Status Update",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 1,
      "position": [200, 650]
    },
    {
      "parameters": {
        "jsCode": "// Process bulk status updates\nconst updates = $json.updates || [];\n\nif (!Array.isArray(updates) || updates.length === 0) {\n  return [{ error: 'No valid updates provided', processed: 0 }];\n}\n\n// Validate each update\nconst validUpdates = updates.filter(update => \n  update.task_id && \n  update.to_status && \n  ['backlog', 'staged', 'in_progress', 'completed', 'cancelled', 'failed'].includes(update.to_status)\n);\n\nreturn validUpdates.map(update => ({\n  task_id: update.task_id,\n  to_status: update.to_status,\n  from_status: update.from_status || null,\n  reason: update.reason || 'Bulk status update',\n  triggered_by: update.triggered_by || 'bulk-update',\n  notes: update.notes || ''\n}));"
      },
      "id": "process_bulk_updates",
      "name": "Process Bulk Updates",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [400, 650]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "UPDATE tasks SET status = '{{ $json.to_status }}', updated_at = CURRENT_TIMESTAMP WHERE id = '{{ $json.task_id }}'",
        "additionalFields": {}
      },
      "id": "bulk_update_task",
      "name": "Bulk Update Task",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 1,
      "position": [600, 650]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "INSERT INTO task_transitions (task_id, from_status, to_status, triggered_by, trigger_type, reason, notes) VALUES ('{{ $json.task_id }}', '{{ $json.from_status }}', '{{ $json.to_status }}', '{{ $json.triggered_by }}', 'bulk_update', '{{ $json.reason }}', '{{ $json.notes }}')",
        "additionalFields": {}
      },
      "id": "record_bulk_transition",
      "name": "Record Bulk Transition",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 1,
      "position": [800, 650]
    },
    {
      "parameters": {
        "jsCode": "// Summarize bulk update results\nconst allUpdates = $input.all();\nconst successfulUpdates = allUpdates.filter(item => !item.json.error);\n\nconst summary = {\n  total_requested: $('webhook_bulk_update').item.json.updates?.length || 0,\n  successfully_processed: successfulUpdates.length,\n  failed: allUpdates.length - successfulUpdates.length,\n  updated_tasks: successfulUpdates.map(item => ({\n    task_id: item.json.task_id,\n    new_status: item.json.to_status\n  }))\n};\n\nreturn [summary];"
      },
      "id": "summarize_bulk_results",
      "name": "Summarize Bulk Results",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1000, 650]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "{\n  \"success\": true,\n  \"total_requested\": {{ $json.total_requested }},\n  \"successfully_processed\": {{ $json.successfully_processed }},\n  \"failed\": {{ $json.failed }},\n  \"updated_tasks\": {{ JSON.stringify($json.updated_tasks) }}\n}"
      },
      "id": "bulk_update_response",
      "name": "Bulk Update Response", 
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1,
      "position": [1200, 650]
    }
  ],
  "pinData": {},
  "connections": {
    "scheduler_trigger": {
      "main": [
        [
          {
            "node": "check_stuck_tasks",
            "type": "main",
            "index": 0
          },
          {
            "node": "check_failed_runs",
            "type": "main",
            "index": 0
          },
          {
            "node": "get_app_summaries",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "check_stuck_tasks": {
      "main": [
        [
          {
            "node": "compile_status_report",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "check_failed_runs": {
      "main": [
        [
          {
            "node": "compile_status_report",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "get_app_summaries": {
      "main": [
        [
          {
            "node": "compile_status_report",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "compile_status_report": {
      "main": [
        [
          {
            "node": "check_alerts_exist",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "check_alerts_exist": {
      "main": [
        [
          {
            "node": "get_stuck_task_details",
            "type": "main",
            "index": 0
          },
          {
            "node": "send_alert_notifications",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "webhook_status_update": {
      "main": [
        [
          {
            "node": "record_manual_transition",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "record_manual_transition": {
      "main": [
        [
          {
            "node": "update_task_status",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "update_task_status": {
      "main": [
        [
          {
            "node": "get_updated_task",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "get_updated_task": {
      "main": [
        [
          {
            "node": "status_update_response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "get_stuck_task_details": {
      "main": [
        [
          {
            "node": "split_stuck_tasks",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "split_stuck_tasks": {
      "main": [
        [
          {
            "node": "timeout_stuck_task",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "timeout_stuck_task": {
      "main": [
        [
          {
            "node": "record_timeout_transition",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "webhook_bulk_update": {
      "main": [
        [
          {
            "node": "process_bulk_updates",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "process_bulk_updates": {
      "main": [
        [
          {
            "node": "bulk_update_task",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "bulk_update_task": {
      "main": [
        [
          {
            "node": "record_bulk_transition",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "record_bulk_transition": {
      "main": [
        [
          {
            "node": "summarize_bulk_results",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "summarize_bulk_results": {
      "main": [
        [
          {
            "node": "bulk_update_response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "settings": {
    "executionOrder": "v1"
  },
  "staticData": null,
  "tags": [
    {
      "createdAt": "2024-01-01T00:00:00.000Z",
      "updatedAt": "2024-01-01T00:00:00.000Z",
      "id": "task-planner",
      "name": "task-planner"
    }
  ],
  "triggerCount": 3,
  "updatedAt": "2024-01-01T00:00:00.000Z",
  "versionId": "1"
}