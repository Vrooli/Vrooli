#!/usr/bin/env bash
# {{RESOURCE_NAME}} Status Operations
# Auto-generated by Resource Experimenter

# Show service status
{{resource_name}}::show_status() {
    local container_name="${{{RESOURCE_NAME}}_CONTAINER_NAME}"
    local status
    
    status=$({{resource_name}}::docker_status)
    
    echo "=== {{DISPLAY_NAME}} Status ==="
    echo ""
    
    case "${status}" in
        "running")
            echo "Status: ${MSG_{{RESOURCE_NAME}}_RUNNING}"
            echo "Health: $({{resource_name}}::get_health_status)"
            echo "Uptime: $({{resource_name}}::get_uptime)"
            echo "URL: ${{{RESOURCE_NAME}}_PROTOCOL}://${{{RESOURCE_NAME}}_HOST}:${{{RESOURCE_NAME}}_PORT}"
            ;;
        "stopped")
            echo "Status: ${MSG_{{RESOURCE_NAME}}_STOPPED_STATUS}"
            ;;
        "not_found")
            echo "Status: ${MSG_{{RESOURCE_NAME}}_NOT_INSTALLED}"
            ;;
        *)
            echo "Status: ${MSG_{{RESOURCE_NAME}}_STATUS_UNKNOWN}"
            ;;
    esac
    
    echo ""
    
    # Show resource usage if running
    if [[ "${status}" == "running" ]]; then
        {{resource_name}}::show_resource_usage
    fi
    
    return 0
}

# Show detailed service information
{{resource_name}}::show_info() {
    echo "=== {{DISPLAY_NAME}} Information ==="
    echo ""
    echo "Service: ${{{RESOURCE_NAME}}_SERVICE_NAME}"
    echo "Description: ${{{RESOURCE_NAME}}_DESCRIPTION}"
    echo "Category: ${{{RESOURCE_NAME}}_CATEGORY}"
    echo "${MSG_{{RESOURCE_NAME}}_INFO_VERSION}"
    echo ""
    echo "Configuration:"
    echo "  Port: ${{{RESOURCE_NAME}}_PORT}"
    echo "  Host: ${{{RESOURCE_NAME}}_HOST}"
    echo "  Protocol: ${{{RESOURCE_NAME}}_PROTOCOL}"
    echo "  Image: ${{{RESOURCE_NAME}}_IMAGE}:${{{RESOURCE_NAME}}_TAG}"
    echo "  Container: ${{{RESOURCE_NAME}}_CONTAINER_NAME}"
    echo "  Network: ${DOCKER_NETWORK}"
    echo ""
    echo "Directories:"
    echo "  Data: ${{{RESOURCE_NAME}}_DATA_DIR}"
    echo "  Config: ${{{RESOURCE_NAME}}_CONFIG_DIR}"
    echo "  Logs: ${{{RESOURCE_NAME}}_LOGS_DIR}"
    echo ""
    echo "Features:"
    echo "  Authentication: ${{{RESOURCE_NAME}}_ENABLE_AUTH}"
    echo "  SSL: ${{{RESOURCE_NAME}}_ENABLE_SSL}"
    echo "  Metrics: ${{{RESOURCE_NAME}}_ENABLE_METRICS}"
    echo "  Logging: ${{{RESOURCE_NAME}}_ENABLE_LOGGING}"
    echo ""
}

# Health check function
{{resource_name}}::health_check() {
    local url="${{{RESOURCE_NAME}}_HEALTH_CHECK_URL}"
    local timeout="${{{RESOURCE_NAME}}_HEALTH_CHECK_TIMEOUT}"
    
    echo "${MSG_{{RESOURCE_NAME}}_HEALTH_CHECK}"
    
    # Check if container is running first
    if [[ "$({{resource_name}}::docker_status)" != "running" ]]; then
        echo "${MSG_{{RESOURCE_NAME}}_NOT_RUNNING}"
        return 1
    fi
    
    # Perform health check
    if command -v curl >/dev/null 2>&1; then
        if curl -f -s --max-time "${timeout}" "${url}" >/dev/null 2>&1; then
            echo "${MSG_{{RESOURCE_NAME}}_HEALTHY}"
            return 0
        fi
    elif command -v wget >/dev/null 2>&1; then
        if wget -q --timeout="${timeout}" --spider "${url}" >/dev/null 2>&1; then
            echo "${MSG_{{RESOURCE_NAME}}_HEALTHY}"
            return 0
        fi
    else
        # Fallback: check if port is responding
        if timeout "${timeout}" bash -c "echo >/dev/tcp/${{{RESOURCE_NAME}}_HOST}/${{{RESOURCE_NAME}}_PORT}" 2>/dev/null; then
            echo "${MSG_{{RESOURCE_NAME}}_HEALTHY} (port check)"
            return 0
        fi
    fi
    
    echo "${MSG_{{RESOURCE_NAME}}_UNHEALTHY}"
    return 1
}

# Show service logs
{{resource_name}}::show_logs() {
    local lines="${1:-50}"
    local follow="${2:-false}"
    
    if [[ "$({{resource_name}}::docker_status)" == "not_found" ]]; then
        echo "${MSG_{{RESOURCE_NAME}}_NOT_INSTALLED}"
        return 1
    fi
    
    if [[ "${follow}" == "true" ]]; then
        docker logs -f --tail "${lines}" "${{{RESOURCE_NAME}}_CONTAINER_NAME}"
    else
        docker logs --tail "${lines}" "${{{RESOURCE_NAME}}_CONTAINER_NAME}"
    fi
}

# Show current configuration
{{resource_name}}::show_config() {
    echo "=== {{DISPLAY_NAME}} Configuration ==="
    echo ""
    
    if [[ -f "${{{RESOURCE_NAME}}_CONFIG_FILE}" ]]; then
        echo "Configuration file: ${{{RESOURCE_NAME}}_CONFIG_FILE}"
        echo ""
        cat "${{{RESOURCE_NAME}}_CONFIG_FILE}"
    else
        echo "No configuration file found at: ${{{RESOURCE_NAME}}_CONFIG_FILE}"
        echo ""
        echo "Using default configuration:"
        {{resource_name}}::export_config
    fi
}

# Get health status as string
{{resource_name}}::get_health_status() {
    if {{resource_name}}::health_check >/dev/null 2>&1; then
        echo "Healthy ✅"
    else
        echo "Unhealthy ❌"
    fi
}

# Get service uptime
{{resource_name}}::get_uptime() {
    local container_name="${{{RESOURCE_NAME}}_CONTAINER_NAME}"
    
    if [[ "$({{resource_name}}::docker_status)" != "running" ]]; then
        echo "Not running"
        return
    fi
    
    # Get container start time
    local start_time
    start_time=$(docker inspect -f '{{.State.StartedAt}}' "${container_name}" 2>/dev/null)
    
    if [[ -n "${start_time}" ]]; then
        # Convert to seconds since epoch and calculate uptime
        if command -v date >/dev/null 2>&1; then
            local start_epoch
            local current_epoch
            local uptime_seconds
            
            start_epoch=$(date -d "${start_time}" +%s 2>/dev/null)
            current_epoch=$(date +%s)
            
            if [[ -n "${start_epoch}" ]] && [[ -n "${current_epoch}" ]]; then
                uptime_seconds=$((current_epoch - start_epoch))
                {{resource_name}}::format_uptime "${uptime_seconds}"
            else
                echo "Unknown"
            fi
        else
            echo "Unknown"
        fi
    else
        echo "Unknown"
    fi
}

# Format uptime in human readable format
{{resource_name}}::format_uptime() {
    local seconds=$1
    local days=$((seconds / 86400))
    local hours=$(((seconds % 86400) / 3600))
    local minutes=$(((seconds % 3600) / 60))
    local secs=$((seconds % 60))
    
    if [[ ${days} -gt 0 ]]; then
        echo "${days}d ${hours}h ${minutes}m ${secs}s"
    elif [[ ${hours} -gt 0 ]]; then
        echo "${hours}h ${minutes}m ${secs}s"
    elif [[ ${minutes} -gt 0 ]]; then
        echo "${minutes}m ${secs}s"
    else
        echo "${secs}s"
    fi
}

# Show resource usage
{{resource_name}}::show_resource_usage() {
    local container_name="${{{RESOURCE_NAME}}_CONTAINER_NAME}"
    
    echo "Resource Usage:"
    
    # Get container stats
    if docker stats --no-stream --format "table {{.MemUsage}}\t{{.CPUPerc}}" "${container_name}" 2>/dev/null | tail -n 1 | read -r mem cpu; then
        echo "  ${MSG_{{RESOURCE_NAME}}_INFO_MEMORY}${mem}"
        echo "  ${MSG_{{RESOURCE_NAME}}_INFO_CPU}${cpu}"
    fi
    
    # Check disk usage for data directory
    if command -v du >/dev/null 2>&1 && [[ -d "${{{RESOURCE_NAME}}_DATA_DIR}" ]]; then
        local disk_usage
        disk_usage=$(du -sh "${{{RESOURCE_NAME}}_DATA_DIR}" 2>/dev/null | awk '{print $1}')
        if [[ -n "${disk_usage}" ]]; then
            echo "  ${MSG_{{RESOURCE_NAME}}_INFO_DISK}${disk_usage}"
        fi
    fi
    
    echo ""
}

# Check service connectivity
{{resource_name}}::check_connectivity() {
    local host="${{{RESOURCE_NAME}}_HOST}"
    local port="${{{RESOURCE_NAME}}_PORT}"
    local timeout=5
    
    if timeout "${timeout}" bash -c "echo >/dev/tcp/${host}/${port}" 2>/dev/null; then
        return 0
    else
        return 1
    fi
}

# Get service metrics (if metrics are enabled)
{{resource_name}}::get_metrics() {
    if [[ "${{{RESOURCE_NAME}}_ENABLE_METRICS}" != "true" ]]; then
        echo "Metrics are disabled"
        return 1
    fi
    
    local metrics_url="${{{RESOURCE_NAME}}_PROTOCOL}://${{{RESOURCE_NAME}}_HOST}:${{{RESOURCE_NAME}}_PORT}/metrics"
    
    if command -v curl >/dev/null 2>&1; then
        curl -s "${metrics_url}" 2>/dev/null || echo "Metrics endpoint not available"
    else
        echo "curl not available for metrics retrieval"
    fi
}