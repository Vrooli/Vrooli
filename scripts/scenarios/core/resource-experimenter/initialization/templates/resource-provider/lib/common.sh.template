#!/usr/bin/env bash
# {{RESOURCE_NAME}} Common Utilities
# Auto-generated by Resource Experimenter

# Global flags
VERBOSE=${VERBOSE:-false}
DRY_RUN=${DRY_RUN:-false}

# Logging functions
{{resource_name}}::log_info() {
    echo "[INFO] $*"
}

{{resource_name}}::log_warn() {
    echo "[WARN] $*" >&2
}

{{resource_name}}::log_error() {
    echo "[ERROR] $*" >&2
}

{{resource_name}}::log_debug() {
    if [[ "${VERBOSE}" == "true" ]]; then
        echo "[DEBUG] $*" >&2
    fi
}

# Utility functions
{{resource_name}}::confirm() {
    local message="$1"
    echo -n "${message} [y/N]: "
    read -r response
    case "${response}" in
        [yY]|[yY][eE][sS])
            return 0
            ;;
        *)
            return 1
            ;;
    esac
}

{{resource_name}}::is_root() {
    [[ $EUID -eq 0 ]]
}

{{resource_name}}::require_root() {
    if ! {{resource_name}}::is_root; then
        {{resource_name}}::log_error "This operation requires root privileges"
        exit 1
    fi
}

{{resource_name}}::command_exists() {
    command -v "$1" >/dev/null 2>&1
}

{{resource_name}}::wait_for_service() {
    local url="$1"
    local timeout="${2:-60}"
    local interval="${3:-5}"
    local elapsed=0
    
    {{resource_name}}::log_info "Waiting for service to be ready..."
    
    while [[ ${elapsed} -lt ${timeout} ]]; do
        if command -v curl >/dev/null 2>&1; then
            if curl -f -s --max-time 5 "${url}" >/dev/null 2>&1; then
                return 0
            fi
        elif command -v wget >/dev/null 2>&1; then
            if wget -q --timeout=5 --spider "${url}" >/dev/null 2>&1; then
                return 0
            fi
        fi
        
        sleep "${interval}"
        elapsed=$((elapsed + interval))
        echo -n "."
    done
    
    echo ""
    {{resource_name}}::log_error "Service did not become ready within ${timeout} seconds"
    return 1
}

{{resource_name}}::retry() {
    local max_attempts="$1"
    local delay="$2"
    shift 2
    local command=("$@")
    local attempt=1
    
    while [[ ${attempt} -le ${max_attempts} ]]; do
        if "${command[@]}"; then
            return 0
        fi
        
        {{resource_name}}::log_warn "Command failed (attempt ${attempt}/${max_attempts})"
        
        if [[ ${attempt} -lt ${max_attempts} ]]; then
            sleep "${delay}"
        fi
        
        attempt=$((attempt + 1))
    done
    
    {{resource_name}}::log_error "Command failed after ${max_attempts} attempts"
    return 1
}

{{resource_name}}::get_random_port() {
    local min_port="${1:-9000}"
    local max_port="${2:-9999}"
    local attempts=0
    local max_attempts=10
    
    while [[ ${attempts} -lt ${max_attempts} ]]; do
        local port=$((RANDOM % (max_port - min_port + 1) + min_port))
        
        if ! {{resource_name}}::port_in_use "${port}"; then
            echo "${port}"
            return 0
        fi
        
        attempts=$((attempts + 1))
    done
    
    {{resource_name}}::log_error "Could not find available port in range ${min_port}-${max_port}"
    return 1
}

{{resource_name}}::validate_port() {
    local port="$1"
    
    if ! [[ "${port}" =~ ^[0-9]+$ ]]; then
        return 1
    fi
    
    if [[ ${port} -lt 1 ]] || [[ ${port} -gt 65535 ]]; then
        return 1
    fi
    
    return 0
}

{{resource_name}}::validate_url() {
    local url="$1"
    
    # Basic URL validation
    if [[ "${url}" =~ ^https?:// ]]; then
        return 0
    else
        return 1
    fi
}

{{resource_name}}::get_host_ip() {
    # Try to get the host IP address
    if command -v ip >/dev/null 2>&1; then
        ip route get 1.1.1.1 | awk '{print $7; exit}' 2>/dev/null || echo "127.0.0.1"
    elif command -v hostname >/dev/null 2>&1; then
        hostname -I | awk '{print $1}' 2>/dev/null || echo "127.0.0.1"
    else
        echo "127.0.0.1"
    fi
}

{{resource_name}}::generate_password() {
    local length="${1:-16}"
    
    if command -v openssl >/dev/null 2>&1; then
        openssl rand -base64 "${length}" | tr -d "=+/" | cut -c1-"${length}"
    elif [[ -r /dev/urandom ]]; then
        tr -dc 'A-Za-z0-9' < /dev/urandom | head -c "${length}"
    else
        # Fallback to a simple method
        echo "$RANDOM$RANDOM$RANDOM" | md5sum | cut -c1-"${length}" 2>/dev/null || echo "changeme"
    fi
}

{{resource_name}}::create_backup() {
    local source_dir="$1"
    local backup_dir="${2:-${source_dir}.backup.$(date +%Y%m%d_%H%M%S)}"
    
    if [[ ! -d "${source_dir}" ]]; then
        {{resource_name}}::log_error "Source directory does not exist: ${source_dir}"
        return 1
    fi
    
    {{resource_name}}::log_info "Creating backup: ${backup_dir}"
    
    if [[ "${DRY_RUN}" == "true" ]]; then
        echo "Would create backup: cp -r ${source_dir} ${backup_dir}"
        return 0
    fi
    
    if cp -r "${source_dir}" "${backup_dir}"; then
        {{resource_name}}::log_info "Backup created successfully"
        echo "${backup_dir}"
        return 0
    else
        {{resource_name}}::log_error "Backup creation failed"
        return 1
    fi
}

{{resource_name}}::cleanup_backups() {
    local backup_base="$1"
    local retention_days="${2:-7}"
    
    {{resource_name}}::log_info "Cleaning up backups older than ${retention_days} days"
    
    if [[ "${DRY_RUN}" == "true" ]]; then
        echo "Would clean up backups: find ${backup_base}.backup.* -mtime +${retention_days} -delete"
        return 0
    fi
    
    # Find and remove old backups
    find "${backup_base}.backup."* -maxdepth 0 -mtime +${retention_days} -exec rm -rf {} \; 2>/dev/null
}

{{resource_name}}::get_file_hash() {
    local file="$1"
    
    if [[ ! -f "${file}" ]]; then
        return 1
    fi
    
    if command -v sha256sum >/dev/null 2>&1; then
        sha256sum "${file}" | awk '{print $1}'
    elif command -v shasum >/dev/null 2>&1; then
        shasum -a 256 "${file}" | awk '{print $1}'
    elif command -v openssl >/dev/null 2>&1; then
        openssl dgst -sha256 "${file}" | awk '{print $2}'
    else
        # Fallback to md5 if sha256 is not available
        if command -v md5sum >/dev/null 2>&1; then
            md5sum "${file}" | awk '{print $1}'
        else
            return 1
        fi
    fi
}

{{resource_name}}::format_bytes() {
    local bytes="$1"
    local units=("B" "KB" "MB" "GB" "TB")
    local unit=0
    
    while [[ ${bytes} -ge 1024 ]] && [[ ${unit} -lt 4 ]]; do
        bytes=$((bytes / 1024))
        unit=$((unit + 1))
    done
    
    echo "${bytes}${units[unit]}"
}

{{resource_name}}::get_system_info() {
    echo "System Information:"
    echo "  OS: $(uname -s)"
    echo "  Kernel: $(uname -r)"
    echo "  Architecture: $(uname -m)"
    
    if command -v lsb_release >/dev/null 2>&1; then
        echo "  Distribution: $(lsb_release -d | cut -f2)"
    fi
    
    if command -v docker >/dev/null 2>&1; then
        echo "  Docker: $(docker --version | cut -d' ' -f3 | tr -d ',')"
    fi
    
    if [[ -r /proc/meminfo ]]; then
        local total_mem
        total_mem=$(awk '/MemTotal/ {print $2}' /proc/meminfo)
        echo "  Memory: $(((total_mem / 1024))) MB"
    fi
    
    if command -v df >/dev/null 2>&1; then
        local disk_usage
        disk_usage=$(df -h / | awk 'NR==2 {print $4}')
        echo "  Available Disk: ${disk_usage}"
    fi
}

{{resource_name}}::check_network_connectivity() {
    local test_host="${1:-8.8.8.8}"
    local timeout="${2:-5}"
    
    if command -v ping >/dev/null 2>&1; then
        ping -c 1 -W "${timeout}" "${test_host}" >/dev/null 2>&1
    elif command -v nc >/dev/null 2>&1; then
        timeout "${timeout}" nc -z "${test_host}" 53 >/dev/null 2>&1
    else
        # Fallback: try to resolve DNS
        if command -v nslookup >/dev/null 2>&1; then
            timeout "${timeout}" nslookup google.com >/dev/null 2>&1
        else
            return 0  # Can't test, assume connectivity
        fi
    fi
}

# Performance monitoring
{{resource_name}}::get_load_average() {
    if [[ -r /proc/loadavg ]]; then
        cat /proc/loadavg | cut -d' ' -f1-3
    elif command -v uptime >/dev/null 2>&1; then
        uptime | awk -F'load average:' '{print $2}' | sed 's/^[[:space:]]*//'
    else
        echo "Unknown"
    fi
}

{{resource_name}}::monitor_resource() {
    local duration="${1:-60}"  # seconds
    local interval="${2:-5}"   # seconds
    local container_name="${{{RESOURCE_NAME}}_CONTAINER_NAME}"
    
    echo "Monitoring ${container_name} for ${duration} seconds..."
    echo "Time,CPU%,Memory"
    
    local elapsed=0
    while [[ ${elapsed} -lt ${duration} ]]; do
        if docker stats --no-stream --format "{{.CPUPerc}},{{.MemUsage}}" "${container_name}" 2>/dev/null | head -n 1 | read -r stats; then
            echo "$(date +%H:%M:%S),${stats}"
        fi
        
        sleep "${interval}"
        elapsed=$((elapsed + interval))
    done
}