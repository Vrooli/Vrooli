#!/usr/bin/env bash
# {{RESOURCE_NAME}} Installation Operations
# Auto-generated by Resource Experimenter

# Main installation function
{{resource_name}}::install_service() {
    echo "${MSG_{{RESOURCE_NAME}}_INSTALLING}"
    
    # Check prerequisites
    {{resource_name}}::check_prerequisites || return 1
    
    # Create necessary directories
    {{resource_name}}::create_directories || return 1
    
    # Pull Docker image
    {{resource_name}}::docker_pull || return 1
    
    # Create Docker network
    {{resource_name}}::docker_create_network || return 1
    
    # Generate configuration
    {{resource_name}}::generate_config || return 1
    
    # Start the service
    {{resource_name}}::start_service || return 1
    
    # Verify installation
    {{resource_name}}::verify_installation || return 1
    
    echo "${MSG_{{RESOURCE_NAME}}_INSTALLED}"
    echo "${MSG_{{RESOURCE_NAME}}_SUCCESS_READY}"
    
    # Show credentials if authentication is enabled
    if [[ "${{{RESOURCE_NAME}}_ENABLE_AUTH}" == "true" ]]; then
        echo "${MSG_{{RESOURCE_NAME}}_SUCCESS_CREDENTIALS}"
        echo "${MSG_{{RESOURCE_NAME}}_WARN_DEFAULT_PASSWORD}"
    fi
    
    return 0
}

# Main uninstallation function
{{resource_name}}::uninstall_service() {
    echo "${MSG_{{RESOURCE_NAME}}_UNINSTALLING}"
    
    # Stop the service
    {{resource_name}}::stop_service
    
    # Remove Docker container
    {{resource_name}}::docker_remove
    
    # Clean up directories (with confirmation)
    {{resource_name}}::cleanup_directories
    
    echo "${MSG_{{RESOURCE_NAME}}_UNINSTALLED}"
    return 0
}

# Start service function
{{resource_name}}::start_service() {
    {{resource_name}}::docker_start
}

# Stop service function
{{resource_name}}::stop_service() {
    {{resource_name}}::docker_stop
}

# Restart service function
{{resource_name}}::restart_service() {
    echo "${MSG_{{RESOURCE_NAME}}_RESTARTING}"
    {{resource_name}}::stop_service
    sleep 2
    {{resource_name}}::start_service
    echo "${MSG_{{RESOURCE_NAME}}_RESTARTED}"
}

# Check system prerequisites
{{resource_name}}::check_prerequisites() {
    local errors=0
    
    # Check Docker
    if ! {{resource_name}}::docker_check; then
        errors=$((errors + 1))
    fi
    
    # Check port availability
    if {{resource_name}}::port_in_use "${{{RESOURCE_NAME}}_PORT}"; then
        echo "${MSG_{{RESOURCE_NAME}}_ERROR_PORT_IN_USE}"
        errors=$((errors + 1))
    fi
    
    # Check available memory
    if ! {{resource_name}}::check_memory; then
        echo "${MSG_{{RESOURCE_NAME}}_ERROR_INSUFFICIENT_MEMORY}"
        errors=$((errors + 1))
    fi
    
    # Check disk space
    if ! {{resource_name}}::check_disk_space; then
        echo "${MSG_{{RESOURCE_NAME}}_WARN_DISK_SPACE}"
        # Warning, not an error
    fi
    
    # Check permissions
    if ! {{resource_name}}::check_permissions; then
        echo "${MSG_{{RESOURCE_NAME}}_ERROR_PERMISSION_DENIED}"
        errors=$((errors + 1))
    fi
    
    return ${errors}
}

# Create necessary directories
{{resource_name}}::create_directories() {
    local directories=(
        "${{{RESOURCE_NAME}}_DATA_DIR}"
        "${{{RESOURCE_NAME}}_CONFIG_DIR}"
        "${{{RESOURCE_NAME}}_LOGS_DIR}"
    )
    
    for dir in "${directories[@]}"; do
        if [[ ! -d "${dir}" ]]; then
            echo "${MSG_{{RESOURCE_NAME}}_DATA_DIR_CREATE} ${dir}"
            
            if [[ "${DRY_RUN:-false}" == "true" ]]; then
                echo "Would create: mkdir -p ${dir}"
                continue
            fi
            
            if ! mkdir -p "${dir}"; then
                echo "${MSG_{{RESOURCE_NAME}}_DATA_DIR_FAILED} ${dir}"
                return 1
            fi
            
            # Set appropriate permissions
            chmod 755 "${dir}"
        else
            [[ "${VERBOSE:-false}" == "true" ]] && echo "${MSG_{{RESOURCE_NAME}}_DATA_DIR_EXISTS} ${dir}"
        fi
    done
    
    return 0
}

# Clean up directories during uninstallation
{{resource_name}}::cleanup_directories() {
    local directories=(
        "${{{RESOURCE_NAME}}_DATA_DIR}"
        "${{{RESOURCE_NAME}}_CONFIG_DIR}"
        "${{{RESOURCE_NAME}}_LOGS_DIR}"
    )
    
    echo "${MSG_CONFIRM_CONTINUE}"
    read -r response
    
    if [[ "${response}" =~ ^[Yy]([Ee][Ss])?$ ]]; then
        for dir in "${directories[@]}"; do
            if [[ -d "${dir}" ]]; then
                if [[ "${DRY_RUN:-false}" == "true" ]]; then
                    echo "Would remove: rm -rf ${dir}"
                else
                    rm -rf "${dir}"
                fi
            fi
        done
    else
        echo "${MSG_OPERATION_CANCELLED}"
    fi
}

# Generate configuration file
{{resource_name}}::generate_config() {
    local config_file="${{{RESOURCE_NAME}}_CONFIG_FILE}"
    
    if [[ -f "${config_file}" ]] && [[ "${FORCE_CONFIG:-false}" != "true" ]]; then
        [[ "${VERBOSE:-false}" == "true" ]] && echo "Configuration file already exists: ${config_file}"
        return 0
    fi
    
    if [[ "${DRY_RUN:-false}" == "true" ]]; then
        echo "Would create config file: ${config_file}"
        return 0
    fi
    
    cat > "${config_file}" << EOF
# {{DISPLAY_NAME}} Configuration
# Generated by Resource Experimenter

# Service settings
{{RESOURCE_NAME}}_PORT=${{{RESOURCE_NAME}}_PORT}
{{RESOURCE_NAME}}_HOST=${{{RESOURCE_NAME}}_HOST}
{{RESOURCE_NAME}}_LOG_LEVEL=${{{RESOURCE_NAME}}_LOG_LEVEL}

# Authentication settings
{{RESOURCE_NAME}}_ENABLE_AUTH=${{{RESOURCE_NAME}}_ENABLE_AUTH}
{{RESOURCE_NAME}}_DEFAULT_USERNAME=${{{RESOURCE_NAME}}_DEFAULT_USERNAME}
{{RESOURCE_NAME}}_DEFAULT_PASSWORD=${{{RESOURCE_NAME}}_DEFAULT_PASSWORD}

# Feature toggles
{{RESOURCE_NAME}}_ENABLE_SSL=${{{RESOURCE_NAME}}_ENABLE_SSL}
{{RESOURCE_NAME}}_ENABLE_METRICS=${{{RESOURCE_NAME}}_ENABLE_METRICS}
{{RESOURCE_NAME}}_ENABLE_LOGGING=${{{RESOURCE_NAME}}_ENABLE_LOGGING}

# Performance settings
{{RESOURCE_NAME}}_MEMORY_LIMIT=${{{RESOURCE_NAME}}_MEMORY_LIMIT}
{{RESOURCE_NAME}}_CPU_LIMIT=${{{RESOURCE_NAME}}_CPU_LIMIT}
{{RESOURCE_NAME}}_MAX_CONNECTIONS=${{{RESOURCE_NAME}}_MAX_CONNECTIONS}

# Integration settings
{{RESOURCE_NAME}}_WEBHOOK_URL=${{{RESOURCE_NAME}}_WEBHOOK_URL}
{{RESOURCE_NAME}}_CALLBACK_URL=${{{RESOURCE_NAME}}_CALLBACK_URL}
EOF
    
    echo "${MSG_{{RESOURCE_NAME}}_CONFIG_CREATED}${config_file}"
    return 0
}

# Verify installation
{{resource_name}}::verify_installation() {
    local max_attempts=30
    local attempt=0
    
    echo "Verifying installation..."
    
    while [[ ${attempt} -lt ${max_attempts} ]]; do
        if {{resource_name}}::health_check >/dev/null 2>&1; then
            return 0
        fi
        
        attempt=$((attempt + 1))
        echo "Waiting for service to start... (${attempt}/${max_attempts})"
        sleep 2
    done
    
    echo "Installation verification failed - service may not be healthy"
    return 1
}

# Check if port is in use
{{resource_name}}::port_in_use() {
    local port="$1"
    
    if command -v netstat >/dev/null 2>&1; then
        netstat -ln | grep -q ":${port} "
    elif command -v ss >/dev/null 2>&1; then
        ss -ln | grep -q ":${port} "
    else
        # Fallback: try to bind to the port
        if timeout 1 bash -c "echo >/dev/tcp/127.0.0.1/${port}" 2>/dev/null; then
            return 0  # Port is in use
        else
            return 1  # Port is not in use
        fi
    fi
}

# Check available memory
{{resource_name}}::check_memory() {
    if ! command -v free >/dev/null 2>&1; then
        return 0  # Can't check, assume it's fine
    fi
    
    local available_mb
    available_mb=$(free -m | awk '/^Mem:/ {print $7}')  # Available memory
    
    if [[ -z "${available_mb}" ]]; then
        return 0  # Can't determine, assume it's fine
    fi
    
    local required_mb
    required_mb=${{{RESOURCE_NAME}}_MEMORY_LIMIT%m}  # Remove 'm' suffix
    
    if [[ ${available_mb} -lt ${required_mb} ]]; then
        return 1
    fi
    
    return 0
}

# Check available disk space
{{resource_name}}::check_disk_space() {
    local data_dir="${{{RESOURCE_NAME}}_DATA_DIR%/*}"  # Parent directory
    
    if ! command -v df >/dev/null 2>&1; then
        return 0  # Can't check, assume it's fine
    fi
    
    local available_gb
    available_gb=$(df -BG "${data_dir}" 2>/dev/null | awk 'NR==2 {print $4}' | sed 's/G//')
    
    if [[ -z "${available_gb}" ]]; then
        return 0  # Can't determine, assume it's fine
    fi
    
    # Require at least 5GB free space
    if [[ ${available_gb} -lt 5 ]]; then
        return 1
    fi
    
    return 0
}

# Check permissions
{{resource_name}}::check_permissions() {
    # Check if we can create directories
    local parent_dir="${{{RESOURCE_NAME}}_DATA_DIR%/*}"
    
    if [[ ! -w "${parent_dir}" ]] && [[ ! -d "${{{RESOURCE_NAME}}_DATA_DIR}" ]]; then
        return 1
    fi
    
    return 0
}