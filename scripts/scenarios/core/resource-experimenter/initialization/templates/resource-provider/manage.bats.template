#!/usr/bin/env bats
# {{RESOURCE_NAME}} Tests
# Auto-generated by Resource Experimenter
bats_require_minimum_version 1.5.0

# Load test infrastructure
setup_file() {
    # Set up test environment once for all tests
    export TEST_RESOURCE_NAME="{{resource_name}}"
    export TEST_CONTAINER_NAME="test-{{resource_name}}-${BATS_RUN_ID}"
    export TEST_PORT="9$(printf "%03d" $((RANDOM % 1000)))"
    export TEST_DATA_DIR="/tmp/test-{{resource_name}}-${BATS_RUN_ID}"
    export TEST_CONFIG_DIR="/tmp/test-{{resource_name}}-config-${BATS_RUN_ID}"
    export TEST_LOGS_DIR="/tmp/test-{{resource_name}}-logs-${BATS_RUN_ID}"
    
    # Override defaults for testing
    export {{RESOURCE_NAME}}_PORT="${TEST_PORT}"
    export {{RESOURCE_NAME}}_CONTAINER_NAME="${TEST_CONTAINER_NAME}"
    export {{RESOURCE_NAME}}_DATA_DIR="${TEST_DATA_DIR}"
    export {{RESOURCE_NAME}}_CONFIG_DIR="${TEST_CONFIG_DIR}"
    export {{RESOURCE_NAME}}_LOGS_DIR="${TEST_LOGS_DIR}"
    export {{RESOURCE_NAME}}_HEALTH_CHECK_TIMEOUT="30"
    export DRY_RUN=false
    
    # Load the manage script
    SCRIPT_DIR="$(cd "$(dirname "${BATS_TEST_FILENAME}")" && pwd)"
    source "${SCRIPT_DIR}/config/defaults.sh"
    source "${SCRIPT_DIR}/config/messages.sh"
    source "${SCRIPT_DIR}/lib/common.sh"
    source "${SCRIPT_DIR}/lib/docker.sh"
    source "${SCRIPT_DIR}/lib/install.sh"
    source "${SCRIPT_DIR}/lib/status.sh"
    source "${SCRIPT_DIR}/manage.sh"
    
    # Ensure Docker is available
    if ! docker --version >/dev/null 2>&1; then
        skip "Docker is not available"
    fi
    
    # Clean up any existing test containers
    docker rm -f "${TEST_CONTAINER_NAME}" 2>/dev/null || true
}

teardown_file() {
    # Clean up test environment
    if [[ -n "${TEST_CONTAINER_NAME}" ]]; then
        docker rm -f "${TEST_CONTAINER_NAME}" 2>/dev/null || true
    fi
    
    # Clean up test directories
    rm -rf "${TEST_DATA_DIR}" "${TEST_CONFIG_DIR}" "${TEST_LOGS_DIR}" 2>/dev/null || true
}

setup() {
    # Setup for each test
    load "/usr/lib/bats-support/load.bash"
    load "/usr/lib/bats-assert/load.bash"
}

# Basic functionality tests
@test "manage.sh shows usage when called with no arguments" {
    run {{resource_name}}::usage
    assert_success
    assert_output --partial "{{DISPLAY_NAME}}"
    assert_output --partial "SYNOPSIS"
    assert_output --partial "COMMANDS"
}

@test "manage.sh shows usage for help command" {
    run {{resource_name}}::main help
    assert_success
    assert_output --partial "{{DISPLAY_NAME}}"
}

@test "config loading works correctly" {
    assert_equal "${{{RESOURCE_NAME}}_SERVICE_NAME}" "{{resource_name}}"
    assert_equal "${{{RESOURCE_NAME}}_IMAGE}" "{{DOCKER_IMAGE}}"
    assert_equal "${{{RESOURCE_NAME}}_PORT}" "${TEST_PORT}"
}

# Docker functionality tests
@test "docker check passes when docker is available" {
    run {{resource_name}}::docker_check
    assert_success
}

@test "docker image pull works" {
    # Skip if image already exists to save time
    if {{resource_name}}::docker_image_exists; then
        skip "Docker image already exists locally"
    fi
    
    run {{resource_name}}::docker_pull
    assert_success
    assert_output --partial "${MSG_{{RESOURCE_NAME}}_DOCKER_PULLED}"
}

@test "docker network creation works" {
    run {{resource_name}}::docker_create_network
    assert_success
}

# Installation tests
@test "directory creation works" {
    run {{resource_name}}::create_directories
    assert_success
    
    # Verify directories were created
    assert [ -d "${TEST_DATA_DIR}" ]
    assert [ -d "${TEST_CONFIG_DIR}" ]
    assert [ -d "${TEST_LOGS_DIR}" ]
}

@test "configuration generation works" {
    # First create the config directory
    {{resource_name}}::create_directories
    
    run {{resource_name}}::generate_config
    assert_success
    assert_output --partial "${MSG_{{RESOURCE_NAME}}_CONFIG_CREATED}"
    
    # Verify config file was created
    assert [ -f "${{{RESOURCE_NAME}}_CONFIG_FILE}" ]
}

@test "port validation works correctly" {
    run {{resource_name}}::validate_port "8080"
    assert_success
    
    run {{resource_name}}::validate_port "invalid"
    assert_failure
    
    run {{resource_name}}::validate_port "70000"
    assert_failure
}

# Service lifecycle tests
@test "service installation works" {
    # Full installation test
    run timeout 120 {{resource_name}}::install_service
    assert_success
    assert_output --partial "${MSG_{{RESOURCE_NAME}}_INSTALLED}"
    
    # Verify container is running
    run docker ps --filter "name=${TEST_CONTAINER_NAME}" --format "{{.Names}}"
    assert_success
    assert_output "${TEST_CONTAINER_NAME}"
}

@test "service status shows correct information" {
    # Install first if not already installed
    if [[ "$({{resource_name}}::docker_status)" != "running" ]]; then
        {{resource_name}}::install_service
    fi
    
    run {{resource_name}}::show_status
    assert_success
    assert_output --partial "${MSG_{{RESOURCE_NAME}}_RUNNING}"
}

@test "health check works when service is running" {
    # Install first if not already installed
    if [[ "$({{resource_name}}::docker_status)" != "running" ]]; then
        {{resource_name}}::install_service
    fi
    
    # Wait a bit for service to be ready
    sleep 10
    
    run timeout 60 {{resource_name}}::health_check
    assert_success
    assert_output --partial "${MSG_{{RESOURCE_NAME}}_HEALTHY}"
}

@test "service info shows correct details" {
    run {{resource_name}}::show_info
    assert_success
    assert_output --partial "{{DISPLAY_NAME}}"
    assert_output --partial "${TEST_PORT}"
    assert_output --partial "{{DOCKER_IMAGE}}"
}

@test "service logs can be retrieved" {
    # Install first if not already installed
    if [[ "$({{resource_name}}::docker_status)" != "running" ]]; then
        {{resource_name}}::install_service
    fi
    
    run {{resource_name}}::show_logs 10
    assert_success
    # Logs should contain some output (even if empty, docker logs should succeed)
}

@test "service can be stopped" {
    # Install first if not already installed
    if [[ "$({{resource_name}}::docker_status)" != "running" ]]; then
        {{resource_name}}::install_service
    fi
    
    run {{resource_name}}::stop_service
    assert_success
    assert_output --partial "${MSG_{{RESOURCE_NAME}}_STOPPED}"
    
    # Verify container is stopped
    run docker ps --filter "name=${TEST_CONTAINER_NAME}" --format "{{.Names}}"
    assert_success
    refute_output "${TEST_CONTAINER_NAME}"
}

@test "service can be restarted" {
    # Install first if not already installed
    if [[ "$({{resource_name}}::docker_status)" != "running" ]]; then
        {{resource_name}}::install_service
    fi
    
    run {{resource_name}}::restart_service
    assert_success
    assert_output --partial "${MSG_{{RESOURCE_NAME}}_RESTARTED}"
    
    # Verify container is running
    run docker ps --filter "name=${TEST_CONTAINER_NAME}" --format "{{.Names}}"
    assert_success
    assert_output "${TEST_CONTAINER_NAME}"
}

# Integration tests
@test "full lifecycle: install -> health -> logs -> uninstall" {
    # Install
    run timeout 120 {{resource_name}}::install_service
    assert_success
    
    # Check health
    sleep 10
    run timeout 60 {{resource_name}}::health_check
    assert_success
    
    # Get logs
    run {{resource_name}}::show_logs 5
    assert_success
    
    # Uninstall
    run {{resource_name}}::uninstall_service
    assert_success
    assert_output --partial "${MSG_{{RESOURCE_NAME}}_UNINSTALLED}"
}

# Error handling tests
@test "health check fails when service is not running" {
    # Ensure service is stopped
    {{resource_name}}::stop_service 2>/dev/null || true
    
    run {{resource_name}}::health_check
    assert_failure
    assert_output --partial "${MSG_{{RESOURCE_NAME}}_NOT_RUNNING}"
}

@test "status shows correct message when service is not installed" {
    # Ensure service is not installed
    {{resource_name}}::uninstall_service 2>/dev/null || true
    
    run {{resource_name}}::show_status
    assert_success
    assert_output --partial "${MSG_{{RESOURCE_NAME}}_NOT_INSTALLED}"
}

# Performance tests
@test "service starts within reasonable time" {
    # Uninstall first to ensure clean state
    {{resource_name}}::uninstall_service 2>/dev/null || true
    
    # Time the installation
    start_time=$(date +%s)
    run timeout 120 {{resource_name}}::install_service
    end_time=$(date +%s)
    
    assert_success
    
    # Should complete within 2 minutes
    duration=$((end_time - start_time))
    assert [ ${duration} -lt 120 ]
}

@test "multiple rapid status checks work correctly" {
    # Install first if not already installed
    if [[ "$({{resource_name}}::docker_status)" != "running" ]]; then
        {{resource_name}}::install_service
    fi
    
    # Run multiple status checks rapidly
    for i in {1..5}; do
        run {{resource_name}}::show_status
        assert_success
    done
}

# Resource-specific tests (customize based on resource type)
@test "{{RESOURCE_TYPE}} specific functionality works" {
    # Install first if not already installed
    if [[ "$({{resource_name}}::docker_status)" != "running" ]]; then
        {{resource_name}}::install_service
    fi
    
    # Wait for service to be ready
    sleep 15
    
    # Test specific to {{RESOURCE_TYPE}} resources
    case "{{RESOURCE_TYPE}}" in
        "ai"|"automation"|"storage")
            # Test API endpoint if available
            if command -v curl >/dev/null 2>&1; then
                run curl -f -s --max-time 10 "http://localhost:${TEST_PORT}/{{API_ENDPOINT:-}}"
                # Don't assert success as API endpoint may not be available immediately
            fi
            ;;
        "monitoring")
            # Test metrics endpoint if available
            if command -v curl >/dev/null 2>&1; then
                run curl -f -s --max-time 10 "http://localhost:${TEST_PORT}/metrics"
            fi
            ;;
        "search")
            # Test search functionality if available
            if command -v curl >/dev/null 2>&1; then
                run curl -f -s --max-time 10 "http://localhost:${TEST_PORT}/search"
            fi
            ;;
        *)
            # Generic connectivity test
            run timeout 10 bash -c "echo >/dev/tcp/localhost/${TEST_PORT}"
            # May succeed or fail depending on the service
            ;;
    esac
    
    # This test always passes as we're just exercising the functionality
    assert_success
}