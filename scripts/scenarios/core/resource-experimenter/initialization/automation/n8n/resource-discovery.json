{
  "name": "Resource Discovery Workflow",
  "nodes": [
    {
      "parameters": {
        "rule": {
          "interval": [
            {
              "field": "hours",
              "hoursInterval": 6
            }
          ]
        }
      },
      "id": "schedule_trigger",
      "name": "Discovery Schedule",
      "type": "n8n-nodes-base.scheduleTrigger",
      "typeVersion": 1,
      "position": [250, 300]
    },
    {
      "parameters": {
        "functionCode": "// Define discovery sources\nconst sources = [\n  {\n    name: 'DockerHub',\n    url: 'https://hub.docker.com/search?q=&type=image&category=analytics',\n    type: 'docker'\n  },\n  {\n    name: 'Awesome Self-Hosted',\n    url: 'https://raw.githubusercontent.com/awesome-selfhosted/awesome-selfhosted/master/README.md',\n    type: 'markdown'\n  },\n  {\n    name: 'ArtifactHub',\n    url: 'https://artifacthub.io/api/v1/packages/search?kind=0&ts_query_web=ai',\n    type: 'api'\n  }\n];\n\nreturn sources.map(source => ({json: source}));"
      },
      "id": "prepare_sources",
      "name": "Prepare Sources",
      "type": "n8n-nodes-base.code",
      "typeVersion": 1,
      "position": [450, 300]
    },
    {
      "parameters": {
        "url": "={{ $json.url }}",
        "options": {
          "timeout": 30000
        }
      },
      "id": "fetch_source",
      "name": "Fetch Source Data",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 3,
      "position": [650, 300]
    },
    {
      "parameters": {
        "functionCode": "const sourceType = items[0].json.type;\nconst content = items[0].json.data || items[0].json;\nconst resources = [];\n\nif (sourceType === 'docker') {\n  // Parse DockerHub results\n  if (content.results && Array.isArray(content.results)) {\n    content.results.forEach(item => {\n      resources.push({\n        name: item.name,\n        display_name: item.name,\n        description: item.description || '',\n        source_url: `https://hub.docker.com/r/${item.name}`,\n        docker_image: item.name,\n        type: categorizeResource(item.name, item.description),\n        stars: item.star_count || 0,\n        last_updated: item.last_updated\n      });\n    });\n  }\n} else if (sourceType === 'markdown') {\n  // Parse Awesome Self-Hosted markdown\n  const lines = content.split('\\n');\n  const projectRegex = /^\\s*[-*]\\s*\\[([^\\]]+)\\]\\(([^)]+)\\)\\s*[-:]?\\s*(.*)$/;\n  \n  lines.forEach(line => {\n    const match = line.match(projectRegex);\n    if (match) {\n      resources.push({\n        name: match[1].toLowerCase().replace(/\\s+/g, '-'),\n        display_name: match[1],\n        description: match[3],\n        source_url: match[2],\n        repository_url: match[2].includes('github.com') ? match[2] : null,\n        type: categorizeResource(match[1], match[3])\n      });\n    }\n  });\n} else if (sourceType === 'api') {\n  // Parse API responses\n  if (content.packages && Array.isArray(content.packages)) {\n    content.packages.forEach(pkg => {\n      resources.push({\n        name: pkg.name,\n        display_name: pkg.display_name || pkg.name,\n        description: pkg.description,\n        source_url: pkg.links?.find(l => l.name === 'source')?.url,\n        repository_url: pkg.repository?.url,\n        helm_chart: pkg.repository?.kind === 'helm' ? pkg.name : null,\n        type: categorizeResource(pkg.name, pkg.description),\n        version: pkg.version\n      });\n    });\n  }\n}\n\n// Helper function to categorize resources\nfunction categorizeResource(name, description) {\n  const text = (name + ' ' + description).toLowerCase();\n  if (text.includes('ai') || text.includes('llm') || text.includes('ml')) return 'ai';\n  if (text.includes('workflow') || text.includes('automation')) return 'automation';\n  if (text.includes('database') || text.includes('storage')) return 'storage';\n  if (text.includes('monitor') || text.includes('metric')) return 'monitoring';\n  if (text.includes('search') || text.includes('elastic')) return 'search';\n  if (text.includes('execute') || text.includes('runtime')) return 'execution';\n  return 'other';\n}\n\nreturn resources.map(r => ({json: r}));"
      },
      "id": "parse_resources",
      "name": "Parse Resources",
      "type": "n8n-nodes-base.code",
      "typeVersion": 1,
      "position": [850, 300]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "SELECT name FROM resources WHERE name = '{{ $json.name }}'"
      },
      "id": "check_existing",
      "name": "Check Existing",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2,
      "position": [1050, 300],
      "continueOnFail": true
    },
    {
      "parameters": {
        "conditions": {
          "number": [
            {
              "value1": "={{ $json.length }}",
              "operation": "equal",
              "value2": 0
            }
          ]
        }
      },
      "id": "is_new_resource",
      "name": "Is New Resource?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 1,
      "position": [1250, 300]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "INSERT INTO discovery_queue (name, source_url, type, discovered_by, tags, priority) VALUES ('{{ $json.name }}', '{{ $json.source_url }}', '{{ $json.type }}', 'crawler', ARRAY['{{ $json.type }}'], {{ $json.stars > 1000 ? 8 : $json.stars > 100 ? 6 : 4 }}) ON CONFLICT (name) DO NOTHING RETURNING id"
      },
      "id": "add_to_queue",
      "name": "Add to Discovery Queue",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2,
      "position": [1450, 250]
    },
    {
      "parameters": {
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "ollama",
        "model": "llama3.2",
        "prompt": "Analyze this resource for Vrooli integration potential:\\n\\nName: {{ $json.name }}\\nDescription: {{ $json.description }}\\nType: {{ $json.type }}\\n\\nProvide a brief assessment of:\\n1. Integration complexity (trivial/easy/moderate/hard/extreme)\\n2. Estimated integration hours\\n3. Key benefits for Vrooli\\n4. Potential challenges\\n\\nBe concise."
      },
      "id": "ai_assessment",
      "name": "AI Assessment",
      "type": "@n8n/n8n-nodes-langchain.lmChatOllama",
      "typeVersion": 1,
      "position": [1650, 250]
    },
    {
      "parameters": {
        "functionCode": "const assessment = items[0].json.response || items[0].json.text || '';\nconst resource = items[0].json;\n\n// Parse AI assessment\nlet complexity = 'moderate';\nlet hours = 20;\n\nconst complexityMatch = assessment.match(/complexity[:\\s]+(trivial|easy|moderate|hard|extreme)/i);\nif (complexityMatch) {\n  complexity = complexityMatch[1].toLowerCase();\n}\n\nconst hoursMatch = assessment.match(/(\\d+)\\s*hours?/i);\nif (hoursMatch) {\n  hours = parseInt(hoursMatch[1]);\n}\n\nreturn [{json: {\n  ...resource,\n  integration_complexity: complexity,\n  estimated_hours: hours,\n  ai_assessment: assessment\n}}];"
      },
      "id": "parse_assessment",
      "name": "Parse Assessment",
      "type": "n8n-nodes-base.code",
      "typeVersion": 1,
      "position": [1850, 250]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "UPDATE discovery_queue SET notes = '{{ $json.ai_assessment }}', priority = CASE WHEN '{{ $json.integration_complexity }}' = 'trivial' THEN 9 WHEN '{{ $json.integration_complexity }}' = 'easy' THEN 8 ELSE priority END WHERE name = '{{ $json.name }}'"
      },
      "id": "update_queue_item",
      "name": "Update Queue Item",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2,
      "position": [2050, 250]
    },
    {
      "parameters": {
        "functionCode": "// Compile discovery report\nconst totalFound = items.length;\nconst newResources = items.filter(i => i.json.is_new).length;\n\nconst report = {\n  timestamp: new Date().toISOString(),\n  total_resources_found: totalFound,\n  new_resources_added: newResources,\n  summary: `Discovery run completed. Found ${totalFound} resources, ${newResources} new.`\n};\n\nreturn [{json: report}];"
      },
      "id": "compile_report",
      "name": "Compile Report",
      "type": "n8n-nodes-base.code",
      "typeVersion": 1,
      "position": [2250, 300]
    }
  ],
  "connections": {
    "schedule_trigger": {
      "main": [[{"node": "prepare_sources", "type": "main", "index": 0}]]
    },
    "prepare_sources": {
      "main": [[{"node": "fetch_source", "type": "main", "index": 0}]]
    },
    "fetch_source": {
      "main": [[{"node": "parse_resources", "type": "main", "index": 0}]]
    },
    "parse_resources": {
      "main": [[{"node": "check_existing", "type": "main", "index": 0}]]
    },
    "check_existing": {
      "main": [[{"node": "is_new_resource", "type": "main", "index": 0}]]
    },
    "is_new_resource": {
      "main": [
        [{"node": "add_to_queue", "type": "main", "index": 0}],
        [{"node": "compile_report", "type": "main", "index": 0}]
      ]
    },
    "add_to_queue": {
      "main": [[{"node": "ai_assessment", "type": "main", "index": 0}]]
    },
    "ai_assessment": {
      "main": [[{"node": "parse_assessment", "type": "main", "index": 0}]]
    },
    "parse_assessment": {
      "main": [[{"node": "update_queue_item", "type": "main", "index": 0}]]
    },
    "update_queue_item": {
      "main": [[{"node": "compile_report", "type": "main", "index": 0}]]
    }
  },
  "settings": {
    "executionOrder": "v1",
    "saveManualExecutions": true,
    "callerPolicy": "workflowsFromSameOwner"
  },
  "staticData": null,
  "pinData": {},
  "versionId": "v1.0.0"
}