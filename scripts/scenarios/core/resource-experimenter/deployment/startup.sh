#!/usr/bin/env bash
# Resource Experimenter - Startup Script
# Auto-generated by Resource Experimenter

set -euo pipefail

readonly SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
readonly SCENARIO_DIR="$(dirname "${SCRIPT_DIR}")"
readonly LOG_FILE="${SCENARIO_DIR}/startup.log"

# Logging functions
log_info() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] INFO: $*" | tee -a "${LOG_FILE}"
}

log_error() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] ERROR: $*" | tee -a "${LOG_FILE}" >&2
}

log_warn() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] WARN: $*" | tee -a "${LOG_FILE}"
}

# Check if a service is running
is_service_running() {
    local container_name="$1"
    docker ps --format "{{.Names}}" | grep -q "^${container_name}$"
}

# Wait for a service to be healthy
wait_for_service() {
    local service_name="$1"
    local health_url="$2"
    local timeout="${3:-120}"
    local interval="${4:-5}"
    
    log_info "Waiting for ${service_name} to be ready..."
    
    local elapsed=0
    while [[ ${elapsed} -lt ${timeout} ]]; do
        if curl -f -s --max-time 5 "${health_url}" >/dev/null 2>&1; then
            log_info "‚úÖ ${service_name} is ready"
            return 0
        fi
        
        sleep "${interval}"
        elapsed=$((elapsed + interval))
        echo -n "."
    done
    
    echo ""
    log_error "‚ùå ${service_name} failed to become ready within ${timeout} seconds"
    return 1
}

# Start PostgreSQL
start_postgresql() {
    log_info "Starting PostgreSQL..."
    
    if is_service_running "vrooli-postgres"; then
        log_info "PostgreSQL is already running"
        return 0
    fi
    
    # Create PostgreSQL container
    docker run -d \
        --name vrooli-postgres \
        --network vrooli-network \
        -p 5432:5432 \
        -e POSTGRES_USER=postgres \
        -e POSTGRES_PASSWORD=postgres \
        -e POSTGRES_DB=resource_experiments \
        -v "${HOME}/.vrooli/data/postgres:/var/lib/postgresql/data" \
        -v "${SCENARIO_DIR}/initialization/storage/postgres:/docker-entrypoint-initdb.d:ro" \
        --restart unless-stopped \
        postgres:15
    
    # Wait for PostgreSQL to be ready
    if ! wait_for_service "PostgreSQL" "postgresql://postgres:postgres@localhost:5432/resource_experiments" 60; then
        return 1
    fi
    
    log_info "‚úÖ PostgreSQL started successfully"
    return 0
}

# Start Redis
start_redis() {
    log_info "Starting Redis..."
    
    if is_service_running "vrooli-redis"; then
        log_info "Redis is already running"
        return 0
    fi
    
    docker run -d \
        --name vrooli-redis \
        --network vrooli-network \
        -p 6379:6379 \
        -v "${HOME}/.vrooli/data/redis:/data" \
        --restart unless-stopped \
        redis:7-alpine redis-server --appendonly yes
    
    # Wait for Redis to be ready
    local retries=12
    local count=0
    while [[ ${count} -lt ${retries} ]]; do
        if redis-cli -h localhost ping 2>/dev/null | grep -q "PONG"; then
            log_info "‚úÖ Redis started successfully"
            return 0
        fi
        sleep 5
        count=$((count + 1))
    done
    
    log_error "‚ùå Redis failed to start"
    return 1
}

# Start MinIO
start_minio() {
    log_info "Starting MinIO..."
    
    if is_service_running "vrooli-minio"; then
        log_info "MinIO is already running"
        return 0
    fi
    
    docker run -d \
        --name vrooli-minio \
        --network vrooli-network \
        -p 9000:9000 \
        -p 9001:9001 \
        -e MINIO_ROOT_USER=vrooli \
        -e MINIO_ROOT_PASSWORD=vrooli123 \
        -v "${HOME}/.vrooli/data/minio:/data" \
        --restart unless-stopped \
        minio/minio server /data --console-address ":9001"
    
    # Wait for MinIO to be ready
    if ! wait_for_service "MinIO" "http://localhost:9000/minio/health/live" 60; then
        return 1
    fi
    
    log_info "‚úÖ MinIO started successfully"
    return 0
}

# Start Qdrant
start_qdrant() {
    log_info "Starting Qdrant..."
    
    if is_service_running "vrooli-qdrant"; then
        log_info "Qdrant is already running"
        return 0
    fi
    
    docker run -d \
        --name vrooli-qdrant \
        --network vrooli-network \
        -p 6333:6333 \
        -p 6334:6334 \
        -v "${HOME}/.vrooli/data/qdrant:/qdrant/storage" \
        --restart unless-stopped \
        qdrant/qdrant
    
    # Wait for Qdrant to be ready
    if ! wait_for_service "Qdrant" "http://localhost:6333/health" 60; then
        return 1
    fi
    
    log_info "‚úÖ Qdrant started successfully"
    return 0
}

# Start Ollama
start_ollama() {
    log_info "Starting Ollama..."
    
    if is_service_running "vrooli-ollama"; then
        log_info "Ollama is already running"
        return 0
    fi
    
    docker run -d \
        --name vrooli-ollama \
        --network vrooli-network \
        -p 11434:11434 \
        -v "${HOME}/.vrooli/data/ollama:/root/.ollama" \
        --restart unless-stopped \
        ollama/ollama
    
    # Wait for Ollama to be ready
    if ! wait_for_service "Ollama" "http://localhost:11434/api/tags" 60; then
        return 1
    fi
    
    # Pull required models
    log_info "Pulling required Ollama models..."
    docker exec vrooli-ollama ollama pull llama3.2 || log_warn "Failed to pull llama3.2 model"
    docker exec vrooli-ollama ollama pull codellama || log_warn "Failed to pull codellama model"
    
    log_info "‚úÖ Ollama started successfully"
    return 0
}

# Start n8n
start_n8n() {
    log_info "Starting n8n..."
    
    if is_service_running "vrooli-n8n"; then
        log_info "n8n is already running"
        return 0
    fi
    
    docker run -d \
        --name vrooli-n8n \
        --network vrooli-network \
        -p 5678:5678 \
        -e N8N_HOST=localhost \
        -e N8N_PORT=5678 \
        -e N8N_PROTOCOL=http \
        -e NODE_ENV=production \
        -e WEBHOOK_URL=http://localhost:5678 \
        -e GENERIC_TIMEZONE=UTC \
        -e N8N_METRICS=true \
        -e DB_TYPE=postgresdb \
        -e DB_POSTGRESDB_HOST=vrooli-postgres \
        -e DB_POSTGRESDB_PORT=5432 \
        -e DB_POSTGRESDB_DATABASE=resource_experiments \
        -e DB_POSTGRESDB_USER=postgres \
        -e DB_POSTGRESDB_PASSWORD=postgres \
        -v "${HOME}/.vrooli/data/n8n:/home/node/.n8n" \
        -v "${SCENARIO_DIR}/initialization/automation/n8n:/home/node/.n8n/workflows" \
        --restart unless-stopped \
        n8nio/n8n
    
    # Wait for n8n to be ready
    if ! wait_for_service "n8n" "http://localhost:5678/healthz" 90; then
        return 1
    fi
    
    log_info "‚úÖ n8n started successfully"
    return 0
}

# Start Windmill
start_windmill() {
    log_info "Starting Windmill..."
    
    if is_service_running "vrooli-windmill"; then
        log_info "Windmill is already running"
        return 0
    fi
    
    docker run -d \
        --name vrooli-windmill \
        --network vrooli-network \
        -p 8000:8000 \
        -e DATABASE_URL=postgres://postgres:postgres@vrooli-postgres:5432/resource_experiments \
        -e MODE=server \
        -e RUST_LOG=info \
        -v "${HOME}/.vrooli/data/windmill:/tmp/windmill" \
        -v "/var/run/docker.sock:/var/run/docker.sock" \
        --restart unless-stopped \
        ghcr.io/windmill-labs/windmill:main
    
    # Wait for Windmill to be ready
    if ! wait_for_service "Windmill" "http://localhost:8000/api/version" 90; then
        return 1
    fi
    
    log_info "‚úÖ Windmill started successfully"
    return 0
}

# Create Docker network if it doesn't exist
create_docker_network() {
    log_info "Creating Docker network..."
    
    if docker network ls | grep -q "vrooli-network"; then
        log_info "Docker network already exists"
        return 0
    fi
    
    if docker network create vrooli-network; then
        log_info "‚úÖ Docker network created successfully"
        return 0
    else
        log_error "‚ùå Failed to create Docker network"
        return 1
    fi
}

# Create required directories
create_directories() {
    log_info "Creating required directories..."
    
    local directories=(
        "${HOME}/.vrooli/data/postgres"
        "${HOME}/.vrooli/data/redis"
        "${HOME}/.vrooli/data/minio"
        "${HOME}/.vrooli/data/qdrant"
        "${HOME}/.vrooli/data/ollama"
        "${HOME}/.vrooli/data/n8n"
        "${HOME}/.vrooli/data/windmill"
        "${HOME}/.vrooli/logs"
        "${HOME}/.vrooli/config"
    )
    
    for dir in "${directories[@]}"; do
        if [[ ! -d "${dir}" ]]; then
            if mkdir -p "${dir}"; then
                log_info "Created directory: ${dir}"
            else
                log_error "Failed to create directory: ${dir}"
                return 1
            fi
        fi
    done
    
    log_info "‚úÖ All directories created successfully"
    return 0
}

# Initialize storage systems
initialize_storage() {
    log_info "Initializing storage systems..."
    
    # Wait a bit for services to settle
    sleep 10
    
    # Initialize MinIO buckets
    log_info "Creating MinIO buckets..."
    docker run --rm --network vrooli-network \
        -e MC_HOST_minio=http://vrooli:vrooli123@vrooli-minio:9000 \
        minio/mc \
        sh -c "
            mc mb minio/generated-apps minio/resource-artifacts minio/test-reports || true
            mc anonymous set public minio/generated-apps || true
        " || log_warn "Failed to initialize MinIO buckets"
    
    # Initialize Qdrant collections
    log_info "Creating Qdrant collections..."
    local collections_config="${SCENARIO_DIR}/initialization/storage/qdrant/collections.json"
    if [[ -f "${collections_config}" ]]; then
        # This would normally be done via API calls, but we'll skip for now
        log_info "Qdrant collections configuration loaded"
    fi
    
    log_info "‚úÖ Storage initialization completed"
    return 0
}

# Show startup status
show_status() {
    log_info "Resource Experimenter Status:"
    log_info "=============================="
    
    local services=(
        "vrooli-postgres:PostgreSQL"
        "vrooli-redis:Redis"
        "vrooli-minio:MinIO"
        "vrooli-qdrant:Qdrant"
        "vrooli-ollama:Ollama"
        "vrooli-n8n:n8n"
        "vrooli-windmill:Windmill"
    )
    
    for service in "${services[@]}"; do
        IFS=':' read -r container_name display_name <<< "${service}"
        if is_service_running "${container_name}"; then
            log_info "‚úÖ ${display_name} is running"
        else
            log_info "‚ùå ${display_name} is not running"
        fi
    done
    
    echo ""
    log_info "Service URLs:"
    log_info "- Windmill Dashboard: http://localhost:8000"
    log_info "- n8n Workflows: http://localhost:5678"
    log_info "- MinIO Console: http://localhost:9001"
    log_info "- Qdrant API: http://localhost:6333"
    log_info "- Ollama API: http://localhost:11434"
}

# Main startup function
main() {
    log_info "üöÄ Starting Resource Experimenter..."
    log_info "====================================="
    
    # Clean up any existing log file
    > "${LOG_FILE}"
    
    # Create Docker network
    create_docker_network || exit 1
    
    # Create required directories
    create_directories || exit 1
    
    # Start core infrastructure services first
    start_postgresql || exit 1
    start_redis || exit 1
    start_minio || exit 1
    start_qdrant || exit 1
    
    # Start AI services
    start_ollama || exit 1
    
    # Start automation services
    start_n8n || exit 1
    start_windmill || exit 1
    
    # Initialize storage systems
    initialize_storage || exit 1
    
    log_info "‚úÖ All services started successfully!"
    echo ""
    
    show_status
    
    log_info ""
    log_info "üéâ Resource Experimenter is ready!"
    log_info "Check the logs at: ${LOG_FILE}"
}

# Cleanup function for graceful shutdown
cleanup() {
    log_info "Shutting down services..."
    docker stop vrooli-windmill vrooli-n8n vrooli-ollama vrooli-qdrant vrooli-minio vrooli-redis vrooli-postgres 2>/dev/null || true
}

# Set up signal handlers
trap cleanup EXIT INT TERM

# Handle command line arguments
case "${1:-start}" in
    start)
        main
        ;;
    status)
        show_status
        ;;
    stop)
        cleanup
        log_info "Services stopped"
        ;;
    *)
        echo "Usage: $0 {start|stop|status}"
        exit 1
        ;;
esac