#!/usr/bin/env bash
# Resource Experimenter - Startup Script
# Auto-generated by Resource Experimenter

set -euo pipefail

# Source var.sh first with proper relative path
# shellcheck disable=SC1091
source "$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)/../../../../lib/utils/var.sh"

# Source resources common for port management
# shellcheck disable=SC1091
source "$var_RESOURCES_COMMON_FILE"

readonly SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
readonly SCENARIO_DIR="$(dirname "${SCRIPT_DIR}")"
readonly LOG_FILE="${SCENARIO_DIR}/startup.log"

# Logging functions
startup::log_info() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] INFO: $*" | tee -a "${LOG_FILE}"
}

startup::log_error() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] ERROR: $*" | tee -a "${LOG_FILE}" >&2
}

startup::log_warn() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] WARN: $*" | tee -a "${LOG_FILE}"
}

# Check if a service is running
startup::is_service_running() {
    local container_name="$1"
    docker ps --format "{{.Names}}" | grep -q "^${container_name}$"
}

# Wait for a service to be healthy
startup::wait_for_service() {
    local service_name="$1"
    local health_url="$2"
    local timeout="${3:-120}"
    local interval="${4:-5}"
    
    startup::log_info "Waiting for ${service_name} to be ready..."
    
    local elapsed=0
    while [[ ${elapsed} -lt ${timeout} ]]; do
        if curl -f -s --max-time 5 "${health_url}" >/dev/null 2>&1; then
            startup::log_info "‚úÖ ${service_name} is ready"
            return 0
        fi
        
        sleep "${interval}"
        elapsed=$((elapsed + interval))
        echo -n "."
    done
    
    echo ""
    startup::log_error "‚ùå ${service_name} failed to become ready within ${timeout} seconds"
    return 1
}

# Start PostgreSQL
start_postgresql() {
    startup::log_info "Starting PostgreSQL..."
    
    if startup::is_service_running "vrooli-postgres"; then
        startup::log_info "PostgreSQL is already running"
        return 0
    fi
    
    # Get dynamic PostgreSQL port
    local postgres_port
    postgres_port=$(resources::get_default_port "postgres")
    
    # Create PostgreSQL container
    docker run -d \
        --name vrooli-postgres \
        --network vrooli-network \
        -p "${postgres_port}:5432" \
        -e POSTGRES_USER=postgres \
        -e POSTGRES_PASSWORD=postgres \
        -e POSTGRES_DB=resource_experiments \
        -v "$var_ROOT_DIR/.vrooli/data/postgres:/var/lib/postgresql/data" \
        -v "${SCENARIO_DIR}/initialization/storage/postgres:/docker-entrypoint-initdb.d:ro" \
        --restart unless-stopped \
        postgres:15
    
    # Wait for PostgreSQL to be ready
    if ! startup::wait_for_service "PostgreSQL" "postgresql://postgres:postgres@localhost:${postgres_port}/resource_experiments" 60; then
        return 1
    fi
    
    startup::log_info "‚úÖ PostgreSQL started successfully"
    return 0
}

# Start Redis
start_redis() {
    startup::log_info "Starting Redis..."
    
    if startup::is_service_running "vrooli-redis"; then
        startup::log_info "Redis is already running"
        return 0
    fi
    
    # Get dynamic Redis port
    local redis_port
    redis_port=$(resources::get_default_port "redis")
    
    docker run -d \
        --name vrooli-redis \
        --network vrooli-network \
        -p "${redis_port}:6379" \
        -v "$var_ROOT_DIR/.vrooli/data/redis:/data" \
        --restart unless-stopped \
        redis:7-alpine redis-server --appendonly yes
    
    # Wait for Redis to be ready
    local retries=12
    local count=0
    while [[ ${count} -lt ${retries} ]]; do
        if redis-cli -h localhost ping 2>/dev/null | grep -q "PONG"; then
            startup::log_info "‚úÖ Redis started successfully"
            return 0
        fi
        sleep 5
        count=$((count + 1))
    done
    
    startup::log_error "‚ùå Redis failed to start"
    return 1
}

# Start MinIO
start_minio() {
    startup::log_info "Starting MinIO..."
    
    if startup::is_service_running "vrooli-minio"; then
        startup::log_info "MinIO is already running"
        return 0
    fi
    
    # Get dynamic MinIO ports
    local minio_port
    local minio_console_port
    minio_port=$(resources::get_default_port "minio")
    minio_console_port=$((minio_port + 1))
    
    docker run -d \
        --name vrooli-minio \
        --network vrooli-network \
        -p "${minio_port}:9000" \
        -p "${minio_console_port}:9001" \
        -e MINIO_ROOT_USER=vrooli \
        -e MINIO_ROOT_PASSWORD=vrooli123 \
        -v "$var_ROOT_DIR/.vrooli/data/minio:/data" \
        --restart unless-stopped \
        minio/minio server /data --console-address ":9001"
    
    # Wait for MinIO to be ready
    if ! startup::wait_for_service "MinIO" "http://localhost:${minio_port}/minio/health/live" 60; then
        return 1
    fi
    
    startup::log_info "‚úÖ MinIO started successfully"
    return 0
}

# Start Qdrant
start_qdrant() {
    startup::log_info "Starting Qdrant..."
    
    if startup::is_service_running "vrooli-qdrant"; then
        startup::log_info "Qdrant is already running"
        return 0
    fi
    
    # Get dynamic Qdrant ports
    local qdrant_port
    local qdrant_grpc_port
    qdrant_port=$(resources::get_default_port "qdrant")
    qdrant_grpc_port=$((qdrant_port + 1))
    
    docker run -d \
        --name vrooli-qdrant \
        --network vrooli-network \
        -p "${qdrant_port}:6333" \
        -p "${qdrant_grpc_port}:6334" \
        -v "$var_ROOT_DIR/.vrooli/data/qdrant:/qdrant/storage" \
        --restart unless-stopped \
        qdrant/qdrant
    
    # Wait for Qdrant to be ready
    if ! startup::wait_for_service "Qdrant" "http://localhost:${qdrant_port}/health" 60; then
        return 1
    fi
    
    startup::log_info "‚úÖ Qdrant started successfully"
    return 0
}

# Start Ollama
start_ollama() {
    startup::log_info "Starting Ollama..."
    
    if startup::is_service_running "vrooli-ollama"; then
        startup::log_info "Ollama is already running"
        return 0
    fi
    
    # Get dynamic Ollama port
    local ollama_port
    ollama_port=$(resources::get_default_port "ollama")
    
    docker run -d \
        --name vrooli-ollama \
        --network vrooli-network \
        -p "${ollama_port}:11434" \
        -v "$var_ROOT_DIR/.vrooli/data/ollama:/root/.ollama" \
        --restart unless-stopped \
        ollama/ollama
    
    # Wait for Ollama to be ready
    if ! startup::wait_for_service "Ollama" "http://localhost:${ollama_port}/api/tags" 60; then
        return 1
    fi
    
    # Pull required models
    startup::log_info "Pulling required Ollama models..."
    docker exec vrooli-ollama ollama pull llama3.2 || startup::log_warn "Failed to pull llama3.2 model"
    docker exec vrooli-ollama ollama pull codellama || startup::log_warn "Failed to pull codellama model"
    
    startup::log_info "‚úÖ Ollama started successfully"
    return 0
}

# Start n8n
start_n8n() {
    startup::log_info "Starting n8n..."
    
    if startup::is_service_running "vrooli-n8n"; then
        startup::log_info "n8n is already running"
        return 0
    fi
    
    # Get dynamic n8n port
    local n8n_port
    n8n_port=$(resources::get_default_port "n8n")
    
    docker run -d \
        --name vrooli-n8n \
        --network vrooli-network \
        -p "${n8n_port}:5678" \
        -e N8N_HOST=localhost \
        -e N8N_PORT=5678 \
        -e N8N_PROTOCOL=http \
        -e NODE_ENV=production \
        -e WEBHOOK_URL="http://localhost:${n8n_port}" \
        -e GENERIC_TIMEZONE=UTC \
        -e N8N_METRICS=true \
        -e DB_TYPE=postgresdb \
        -e DB_POSTGRESDB_HOST=vrooli-postgres \
        -e DB_POSTGRESDB_PORT=5432 \
        -e DB_POSTGRESDB_DATABASE=resource_experiments \
        -e DB_POSTGRESDB_USER=postgres \
        -e DB_POSTGRESDB_PASSWORD=postgres \
        -v "$var_ROOT_DIR/.vrooli/data/n8n:/home/node/.n8n" \
        -v "${SCENARIO_DIR}/initialization/automation/n8n:/home/node/.n8n/workflows" \
        --restart unless-stopped \
        n8nio/n8n
    
    # Wait for n8n to be ready
    if ! startup::wait_for_service "n8n" "http://localhost:${n8n_port}/healthz" 90; then
        return 1
    fi
    
    startup::log_info "‚úÖ n8n started successfully"
    return 0
}

# Start Windmill
start_windmill() {
    startup::log_info "Starting Windmill..."
    
    if startup::is_service_running "vrooli-windmill"; then
        startup::log_info "Windmill is already running"
        return 0
    fi
    
    # Get dynamic Windmill port
    local windmill_port
    windmill_port=$(resources::get_default_port "windmill")
    
    docker run -d \
        --name vrooli-windmill \
        --network vrooli-network \
        -p "${windmill_port}:8000" \
        -e DATABASE_URL=postgres://postgres:postgres@vrooli-postgres:5432/resource_experiments \
        -e MODE=server \
        -e RUST_LOG=info \
        -v "$var_ROOT_DIR/.vrooli/data/windmill:/tmp/windmill" \
        -v "/var/run/docker.sock:/var/run/docker.sock" \
        --restart unless-stopped \
        ghcr.io/windmill-labs/windmill:main
    
    # Wait for Windmill to be ready
    if ! startup::wait_for_service "Windmill" "http://localhost:${windmill_port}/api/version" 90; then
        return 1
    fi
    
    startup::log_info "‚úÖ Windmill started successfully"
    return 0
}

# Create Docker network if it doesn't exist
create_docker_network() {
    startup::log_info "Creating Docker network..."
    
    if docker network ls | grep -q "vrooli-network"; then
        startup::log_info "Docker network already exists"
        return 0
    fi
    
    if docker network create vrooli-network; then
        startup::log_info "‚úÖ Docker network created successfully"
        return 0
    else
        startup::log_error "‚ùå Failed to create Docker network"
        return 1
    fi
}

# Create required directories
create_directories() {
    startup::log_info "Creating required directories..."
    
    local directories=(
        "$var_ROOT_DIR/.vrooli/data/postgres"
        "$var_ROOT_DIR/.vrooli/data/redis"
        "$var_ROOT_DIR/.vrooli/data/minio"
        "$var_ROOT_DIR/.vrooli/data/qdrant"
        "$var_ROOT_DIR/.vrooli/data/ollama"
        "$var_ROOT_DIR/.vrooli/data/n8n"
        "$var_ROOT_DIR/.vrooli/data/windmill"
        "$var_ROOT_DIR/.vrooli/logs"
        "$var_ROOT_DIR/.vrooli/config"
    )
    
    for dir in "${directories[@]}"; do
        if [[ ! -d "${dir}" ]]; then
            if mkdir -p "${dir}"; then
                startup::log_info "Created directory: ${dir}"
            else
                startup::log_error "Failed to create directory: ${dir}"
                return 1
            fi
        fi
    done
    
    startup::log_info "‚úÖ All directories created successfully"
    return 0
}

# Initialize storage systems
initialize_storage() {
    startup::log_info "Initializing storage systems..."
    
    # Wait a bit for services to settle
    sleep 10
    
    # Initialize MinIO buckets
    startup::log_info "Creating MinIO buckets..."
    docker run --rm --network vrooli-network \
        -e MC_HOST_minio=http://vrooli:vrooli123@vrooli-minio:9000 \
        minio/mc \
        sh -c "
            mc mb minio/generated-apps minio/resource-artifacts minio/test-reports || true
            mc anonymous set public minio/generated-apps || true
        " || startup::log_warn "Failed to initialize MinIO buckets"
    
    # Initialize Qdrant collections
    startup::log_info "Creating Qdrant collections..."
    local collections_config="${SCENARIO_DIR}/initialization/storage/qdrant/collections.json"
    if [[ -f "${collections_config}" ]]; then
        # This would normally be done via API calls, but we'll skip for now
        startup::log_info "Qdrant collections configuration loaded"
    fi
    
    startup::log_info "‚úÖ Storage initialization completed"
    return 0
}

# Show startup status
show_status() {
    startup::log_info "Resource Experimenter Status:"
    startup::log_info "=============================="
    
    local services=(
        "vrooli-postgres:PostgreSQL"
        "vrooli-redis:Redis"
        "vrooli-minio:MinIO"
        "vrooli-qdrant:Qdrant"
        "vrooli-ollama:Ollama"
        "vrooli-n8n:n8n"
        "vrooli-windmill:Windmill"
    )
    
    for service in "${services[@]}"; do
        IFS=':' read -r container_name display_name <<< "${service}"
        if startup::is_service_running "${container_name}"; then
            startup::log_info "‚úÖ ${display_name} is running"
        else
            startup::log_info "‚ùå ${display_name} is not running"
        fi
    done
    
    echo ""
    startup::log_info "Service URLs:"
    startup::log_info "- Windmill Dashboard: http://localhost:$(resources::get_default_port "windmill")"
    startup::log_info "- n8n Workflows: http://localhost:$(resources::get_default_port "n8n")"
    startup::log_info "- MinIO Console: http://localhost:$(($(resources::get_default_port "minio") + 1))"
    startup::log_info "- Qdrant API: http://localhost:$(resources::get_default_port "qdrant")"
    startup::log_info "- Ollama API: http://localhost:$(resources::get_default_port "ollama")"
}

# Main startup function
main() {
    startup::log_info "üöÄ Starting Resource Experimenter..."
    startup::log_info "====================================="
    
    # Clean up any existing log file
    > "${LOG_FILE}"
    
    # Create Docker network
    create_docker_network || exit 1
    
    # Create required directories
    create_directories || exit 1
    
    # Start core infrastructure services first
    start_postgresql || exit 1
    start_redis || exit 1
    start_minio || exit 1
    start_qdrant || exit 1
    
    # Start AI services
    start_ollama || exit 1
    
    # Start automation services
    start_n8n || exit 1
    start_windmill || exit 1
    
    # Initialize storage systems
    initialize_storage || exit 1
    
    startup::log_info "‚úÖ All services started successfully!"
    echo ""
    
    show_status
    
    startup::log_info ""
    startup::log_info "üéâ Resource Experimenter is ready!"
    startup::log_info "Check the logs at: ${LOG_FILE}"
}

# Cleanup function for graceful shutdown
cleanup() {
    startup::log_info "Shutting down services..."
    docker stop vrooli-windmill vrooli-n8n vrooli-ollama vrooli-qdrant vrooli-minio vrooli-redis vrooli-postgres 2>/dev/null || true
}

# Set up signal handlers
trap cleanup EXIT INT TERM

# Handle command line arguments
case "${1:-start}" in
    start)
        main
        ;;
    status)
        show_status
        ;;
    stop)
        cleanup
        startup::log_info "Services stopped"
        ;;
    *)
        echo "Usage: $0 {start|stop|status}"
        exit 1
        ;;
esac