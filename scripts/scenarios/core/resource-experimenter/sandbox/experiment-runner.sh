#!/usr/bin/env bash
# Resource Experimenter - Experiment Runner
# Auto-generated by Resource Experimenter

set -euo pipefail

readonly SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
readonly SCENARIO_DIR="$(dirname "${SCRIPT_DIR}")"
readonly EXPERIMENT_ID="${1:-$(date +%s)-$$}"
readonly RESOURCE_NAME="${2:-unknown}"
readonly DOCKER_IMAGE="${3:-}"

# Configuration
readonly SANDBOX_BASE="${HOME}/.vrooli/sandbox"
readonly SANDBOX_DIR="${SANDBOX_BASE}/experiment-${EXPERIMENT_ID}"
readonly PORT_RANGE_START=9000
readonly PORT_RANGE_END=9999
readonly EXPERIMENT_TIMEOUT=1800  # 30 minutes

# Logging functions
log_info() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] [${EXPERIMENT_ID}] INFO: $*"
}

log_error() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] [${EXPERIMENT_ID}] ERROR: $*" >&2
}

log_warn() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] [${EXPERIMENT_ID}] WARN: $*"
}

# Database functions
record_experiment_start() {
    local resource_name="$1"
    local docker_image="$2"
    
    docker exec vrooli-postgres psql -U postgres -d resource_experiments -c "
    INSERT INTO experiments (id, resource_name, docker_image, status, started_at, sandbox_path, docker_network, port_assigned) 
    VALUES (
        '${EXPERIMENT_ID}', 
        '${resource_name}', 
        '${docker_image}', 
        'running', 
        NOW(), 
        '${SANDBOX_DIR}', 
        'vrooli-network', 
        ${ASSIGNED_PORT}
    );" >/dev/null 2>&1 || log_warn "Failed to record experiment start in database"
}

record_experiment_result() {
    local status="$1"
    local notes="$2"
    
    docker exec vrooli-postgres psql -U postgres -d resource_experiments -c "
    UPDATE experiments 
    SET status='${status}', completed_at=NOW(), notes='${notes}' 
    WHERE id='${EXPERIMENT_ID}';" >/dev/null 2>&1 || log_warn "Failed to record experiment result in database"
}

record_test_result() {
    local test_name="$1"
    local test_type="$2"
    local result="$3"
    local execution_time_ms="$4"
    
    docker exec vrooli-postgres psql -U postgres -d resource_experiments -c "
    INSERT INTO experiment_tests (experiment_id, test_name, test_type, result, execution_time_ms, executed_at) 
    VALUES ('${EXPERIMENT_ID}', '${test_name}', '${test_type}', '${result}', ${execution_time_ms}, NOW());" >/dev/null 2>&1 || log_warn "Failed to record test result in database"
}

# Port allocation
find_available_port() {
    local port
    for port in $(seq ${PORT_RANGE_START} ${PORT_RANGE_END}); do
        if ! ss -ln | grep -q ":${port} "; then
            echo "${port}"
            return 0
        fi
    done
    
    log_error "No available ports in range ${PORT_RANGE_START}-${PORT_RANGE_END}"
    return 1
}

# Sandbox management
setup_sandbox() {
    log_info "Setting up sandbox environment..."
    
    # Create sandbox directory structure
    mkdir -p "${SANDBOX_DIR}"/{data,logs,config,tests,generated}
    
    # Find available port
    ASSIGNED_PORT=$(find_available_port)
    if [[ -z "${ASSIGNED_PORT}" ]]; then
        return 1
    fi
    
    log_info "Assigned port: ${ASSIGNED_PORT}"
    
    # Generate environment file
    cat > "${SANDBOX_DIR}/.env" << EOF
# Experiment ${EXPERIMENT_ID}
RESOURCE_NAME=${RESOURCE_NAME}
DOCKER_IMAGE=${DOCKER_IMAGE}
PORT=${ASSIGNED_PORT}
DATA_DIR=${SANDBOX_DIR}/data
LOGS_DIR=${SANDBOX_DIR}/logs
CONFIG_DIR=${SANDBOX_DIR}/config
EOF
    
    # Create basic docker-compose.yml template
    cat > "${SANDBOX_DIR}/docker-compose.yml" << EOF
version: '3.8'

services:
  ${RESOURCE_NAME}:
    image: ${DOCKER_IMAGE}
    container_name: experiment-${EXPERIMENT_ID}-${RESOURCE_NAME}
    networks:
      - vrooli-network
    ports:
      - "${ASSIGNED_PORT}:8080"  # Default port, will be updated by provider script
    volumes:
      - "./data:/data"
      - "./config:/config"
    environment:
      - NODE_ENV=production
    restart: "no"
    labels:
      - "experiment=true"
      - "experiment.id=${EXPERIMENT_ID}"
      - "experiment.resource=${RESOURCE_NAME}"

networks:
  vrooli-network:
    external: true
EOF
    
    log_info "‚úÖ Sandbox environment created"
    return 0
}

# Resource analysis
analyze_resource() {
    local docker_image="$1"
    
    log_info "Analyzing Docker image: ${docker_image}"
    
    # Pull image info
    local image_info
    if image_info=$(docker inspect "${docker_image}" 2>/dev/null); then
        # Extract exposed ports
        local exposed_ports
        exposed_ports=$(echo "${image_info}" | jq -r '.[0].Config.ExposedPorts | keys[]?' 2>/dev/null | head -5)
        
        # Extract environment variables
        local env_vars
        env_vars=$(echo "${image_info}" | jq -r '.[0].Config.Env[]?' 2>/dev/null | head -10)
        
        # Save analysis results
        cat > "${SANDBOX_DIR}/analysis.json" << EOF
{
  "image": "${docker_image}",
  "exposed_ports": $(echo "${exposed_ports}" | jq -R -s 'split("\n")[:-1]' 2>/dev/null || echo '[]'),
  "environment_variables": $(echo "${env_vars}" | jq -R -s 'split("\n")[:-1]' 2>/dev/null || echo '[]'),
  "analyzed_at": "$(date -u +%Y-%m-%dT%H:%M:%SZ)"
}
EOF
        
        log_info "‚úÖ Resource analysis completed"
        return 0
    else
        log_error "Failed to analyze Docker image: ${docker_image}"
        return 1
    fi
}

# Generate provider script using AI
generate_provider_script() {
    local resource_name="$1"
    local docker_image="$2"
    
    log_info "Generating provider script for ${resource_name}..."
    
    # Get resource type from templates or guess based on image
    local resource_type="other"
    if [[ "${docker_image}" =~ (ollama|llama|gpt|ai|ml) ]]; then
        resource_type="ai"
    elif [[ "${docker_image}" =~ (n8n|workflow|automation|huginn) ]]; then
        resource_type="automation"
    elif [[ "${docker_image}" =~ (postgres|mysql|mongo|redis|database) ]]; then
        resource_type="storage"
    elif [[ "${docker_image}" =~ (prometheus|grafana|monitor) ]]; then
        resource_type="monitoring"
    elif [[ "${docker_image}" =~ (elasticsearch|search|meilisearch) ]]; then
        resource_type="search"
    elif [[ "${docker_image}" =~ (jupyter|code|judge0|runner) ]]; then
        resource_type="execution"
    fi
    
    # Load template
    local template_file="${SCENARIO_DIR}/initialization/templates/resource-provider/manage.sh.template"
    if [[ ! -f "${template_file}" ]]; then
        log_error "Template file not found: ${template_file}"
        return 1
    fi
    
    # Generate provider script from template
    local provider_script="${SANDBOX_DIR}/generated/manage.sh"
    mkdir -p "$(dirname "${provider_script}")"
    
    # Replace template variables
    sed -e "s/{{resource_name}}/${resource_name}/g" \
        -e "s/{{docker_image}}/${docker_image}/g" \
        -e "s/{{resource_type}}/${resource_type}/g" \
        -e "s/{{port}}/${ASSIGNED_PORT}/g" \
        -e "s/{{data_dir}}/${SANDBOX_DIR//\//\\\/}\/data/g" \
        "${template_file}" > "${provider_script}"
    
    chmod +x "${provider_script}"
    
    # Generate docker-compose.yml from resource template
    local compose_template_query="SELECT docker_compose_template FROM resource_templates WHERE type='${resource_type}' LIMIT 1"
    local compose_template
    if compose_template=$(docker exec vrooli-postgres psql -U postgres -d resource_experiments -t -c "${compose_template_query}" 2>/dev/null); then
        # Replace template variables in compose template
        echo "${compose_template}" | sed -e "s/{{resource_name}}/${resource_name}/g" \
                                        -e "s/{{docker_image}}/${docker_image}/g" \
                                        -e "s/{{internal_port}}/8080/g" > "${SANDBOX_DIR}/docker-compose.generated.yml"
    fi
    
    log_info "‚úÖ Provider script generated"
    return 0
}

# Generate test suite
generate_test_suite() {
    local resource_name="$1"
    
    log_info "Generating test suite for ${resource_name}..."
    
    # Create bats test file
    cat > "${SANDBOX_DIR}/tests/${resource_name}.bats" << EOF
#!/usr/bin/env bats
# Auto-generated tests for ${resource_name}

setup() {
    load '/usr/lib/bats-support/load'
    load '/usr/lib/bats-assert/load'
}

@test "container should be running" {
    run docker ps --filter "name=experiment-${EXPERIMENT_ID}-${resource_name}" --format "{{.Status}}"
    assert_output --partial "Up"
}

@test "should respond to health check on port ${ASSIGNED_PORT}" {
    # Wait a bit for service to start
    sleep 5
    
    # Try common health check endpoints
    run curl -f -s --max-time 10 "http://localhost:${ASSIGNED_PORT}/health"
    if [[ \$status -ne 0 ]]; then
        run curl -f -s --max-time 10 "http://localhost:${ASSIGNED_PORT}/api/health"
    fi
    if [[ \$status -ne 0 ]]; then
        run curl -f -s --max-time 10 "http://localhost:${ASSIGNED_PORT}/"
    fi
    
    # At least one should succeed
    assert_success
}

@test "container logs should not contain errors" {
    run docker logs "experiment-${EXPERIMENT_ID}-${resource_name}" 2>&1
    refute_output --partial "ERROR"
    refute_output --partial "FATAL"
}

@test "service should be accessible from docker network" {
    run docker run --rm --network vrooli-network curlimages/curl:latest \\
        curl -f -s --max-time 10 "http://experiment-${EXPERIMENT_ID}-${resource_name}:8080/"
    
    # Should not fail with connection error
    refute_output --partial "Connection refused"
}

@test "container should have proper resource limits" {
    run docker stats "experiment-${EXPERIMENT_ID}-${resource_name}" --no-stream --format "{{.MemUsage}}"
    assert_success
    
    # Should not be using more than 1GB RAM (simple check)
    refute_output --partial "GiB"
}
EOF
    
    chmod +x "${SANDBOX_DIR}/tests/${resource_name}.bats"
    
    log_info "‚úÖ Test suite generated"
    return 0
}

# Run the experiment
run_experiment() {
    local resource_name="$1"
    local docker_image="$2"
    
    log_info "Running experiment for ${resource_name}..."
    
    cd "${SANDBOX_DIR}"
    
    # Start the service
    log_info "Starting service..."
    if ! docker compose up -d; then
        log_error "Failed to start service"
        return 1
    fi
    
    # Wait for service to be ready
    local wait_time=60
    local elapsed=0
    log_info "Waiting for service to be ready..."
    
    while [[ ${elapsed} -lt ${wait_time} ]]; do
        if docker ps --filter "name=experiment-${EXPERIMENT_ID}-${resource_name}" --format "{{.Status}}" | grep -q "Up"; then
            break
        fi
        sleep 5
        elapsed=$((elapsed + 5))
    done
    
    # Run the tests
    local test_start_time=$(date +%s%3N)
    local test_results=0
    
    if [[ -f "${SANDBOX_DIR}/tests/${resource_name}.bats" ]]; then
        log_info "Running bats tests..."
        
        # Run each test individually to record results
        local test_file="${SANDBOX_DIR}/tests/${resource_name}.bats"
        local test_names
        test_names=$(grep -E "^@test" "${test_file}" | sed 's/@test "\(.*\)" {/\1/')
        
        while IFS= read -r test_name; do
            local test_start=$(date +%s%3N)
            
            if timeout 60 bats --tap "${test_file}" --filter "${test_name}" > "${SANDBOX_DIR}/logs/${test_name// /_}.log" 2>&1; then
                local test_end=$(date +%s%3N)
                local test_duration=$((test_end - test_start))
                record_test_result "${test_name}" "bats" "pass" "${test_duration}"
                log_info "‚úÖ Test passed: ${test_name}"
            else
                local test_end=$(date +%s%3N)
                local test_duration=$((test_end - test_start))
                record_test_result "${test_name}" "bats" "fail" "${test_duration}"
                log_error "‚ùå Test failed: ${test_name}"
                test_results=$((test_results + 1))
            fi
        done <<< "${test_names}"
    fi
    
    local test_end_time=$(date +%s%3N)
    local total_test_time=$((test_end_time - test_start_time))
    
    # Collect logs and metrics
    docker logs "experiment-${EXPERIMENT_ID}-${resource_name}" > "${SANDBOX_DIR}/logs/container.log" 2>&1 || true
    docker stats "experiment-${EXPERIMENT_ID}-${resource_name}" --no-stream > "${SANDBOX_DIR}/logs/stats.log" 2>&1 || true
    
    # Stop the service
    docker compose down || true
    
    # Generate results summary
    cat > "${SANDBOX_DIR}/results.json" << EOF
{
  "experiment_id": "${EXPERIMENT_ID}",
  "resource_name": "${resource_name}",
  "docker_image": "${docker_image}",
  "assigned_port": ${ASSIGNED_PORT},
  "test_failures": ${test_results},
  "total_test_time_ms": ${total_test_time},
  "completed_at": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
  "success": $(if [[ ${test_results} -eq 0 ]]; then echo "true"; else echo "false"; fi)
}
EOF
    
    if [[ ${test_results} -eq 0 ]]; then
        log_info "‚úÖ Experiment completed successfully"
        return 0
    else
        log_error "‚ùå Experiment failed with ${test_results} test failures"
        return 1
    fi
}

# Cleanup function
cleanup_experiment() {
    log_info "Cleaning up experiment..."
    
    # Stop and remove containers
    if [[ -d "${SANDBOX_DIR}" ]]; then
        cd "${SANDBOX_DIR}"
        docker compose down --volumes --remove-orphans 2>/dev/null || true
    fi
    
    # Remove experiment container if it exists
    docker rm -f "experiment-${EXPERIMENT_ID}-${RESOURCE_NAME}" 2>/dev/null || true
    
    # Archive sandbox directory instead of deleting (for debugging)
    if [[ -d "${SANDBOX_DIR}" ]]; then
        local archive_dir="${SANDBOX_BASE}/archived"
        mkdir -p "${archive_dir}"
        tar -czf "${archive_dir}/experiment-${EXPERIMENT_ID}.tar.gz" -C "$(dirname "${SANDBOX_DIR}")" "$(basename "${SANDBOX_DIR}")" 2>/dev/null || true
        rm -rf "${SANDBOX_DIR}"
    fi
    
    log_info "‚úÖ Cleanup completed"
}

# Main function
main() {
    log_info "üß™ Starting Resource Experiment"
    log_info "Experiment ID: ${EXPERIMENT_ID}"
    log_info "Resource Name: ${RESOURCE_NAME}"
    log_info "Docker Image: ${DOCKER_IMAGE}"
    
    # Validate inputs
    if [[ -z "${DOCKER_IMAGE}" ]]; then
        log_error "Docker image is required"
        exit 1
    fi
    
    # Set up signal handlers for cleanup
    trap cleanup_experiment EXIT INT TERM
    
    # Create sandbox base directory
    mkdir -p "${SANDBOX_BASE}"
    
    # Record experiment start
    if ! setup_sandbox; then
        record_experiment_result "failed" "Failed to set up sandbox environment"
        exit 1
    fi
    
    if ! analyze_resource "${DOCKER_IMAGE}"; then
        record_experiment_result "failed" "Failed to analyze Docker image"
        exit 1
    fi
    
    record_experiment_start "${RESOURCE_NAME}" "${DOCKER_IMAGE}"
    
    if ! generate_provider_script "${RESOURCE_NAME}" "${DOCKER_IMAGE}"; then
        record_experiment_result "failed" "Failed to generate provider script"
        exit 1
    fi
    
    if ! generate_test_suite "${RESOURCE_NAME}"; then
        record_experiment_result "failed" "Failed to generate test suite"
        exit 1
    fi
    
    # Run the actual experiment with timeout
    if timeout "${EXPERIMENT_TIMEOUT}" run_experiment "${RESOURCE_NAME}" "${DOCKER_IMAGE}"; then
        record_experiment_result "successful" "All tests passed successfully"
        log_info "üéâ Experiment completed successfully!"
        
        # Save successful experiment for packaging
        echo "${SANDBOX_DIR}" > "${SANDBOX_BASE}/.successful-experiment"
        exit 0
    else
        record_experiment_result "failed" "Experiment failed or timed out"
        log_error "üí• Experiment failed!"
        exit 1
    fi
}

# Show help
if [[ "${1:-}" == "--help" || "${1:-}" == "-h" ]]; then
    cat << EOF
Resource Experimenter - Experiment Runner

USAGE:
    $0 [experiment_id] [resource_name] [docker_image]

PARAMETERS:
    experiment_id   Unique identifier for the experiment (default: auto-generated)
    resource_name   Name of the resource being tested (required)
    docker_image    Docker image to test (required)

EXAMPLES:
    $0 "" "ollama" "ollama/ollama"
    $0 "exp-123" "grafana" "grafana/grafana"

ENVIRONMENT VARIABLES:
    EXPERIMENT_TIMEOUT  Timeout in seconds (default: 1800)
    PORT_RANGE_START   Start of port range (default: 9000)
    PORT_RANGE_END     End of port range (default: 9999)

The experiment will:
1. Set up an isolated sandbox environment
2. Analyze the Docker image
3. Generate provider scripts and test suites
4. Run comprehensive tests
5. Record results to database
6. Clean up resources
EOF
    exit 0
fi

# Run main function
main "$@"