#!/usr/bin/env bash
# Resource Experimenter - App Packager
# Auto-generated by Resource Experimenter

set -euo pipefail

readonly SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
readonly SCENARIO_DIR="$(dirname "${SCRIPT_DIR}")"
readonly SANDBOX_BASE="${HOME}/.vrooli/sandbox"
readonly OUTPUT_BASE="${HOME}/.vrooli/generated-apps"

# Configuration
readonly APP_TEMPLATE_DIR="${SCENARIO_DIR}/initialization/templates/app-structure"
readonly CURRENT_DATE=$(date +%Y-%m-%d)
readonly CURRENT_TIMESTAMP=$(date +%Y%m%d-%H%M%S)

# Logging functions
log_info() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] INFO: $*"
}

log_error() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] ERROR: $*" >&2
}

log_warn() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] WARN: $*"
}

# Parse experiment results
parse_experiment_results() {
    local sandbox_dir="$1"
    
    if [[ ! -f "${sandbox_dir}/results.json" ]]; then
        log_error "No results.json found in ${sandbox_dir}"
        return 1
    fi
    
    # Extract key information from results
    RESOURCE_NAME=$(jq -r '.resource_name' "${sandbox_dir}/results.json" 2>/dev/null || echo "unknown")
    DOCKER_IMAGE=$(jq -r '.docker_image' "${sandbox_dir}/results.json" 2>/dev/null || echo "unknown")
    EXPERIMENT_ID=$(jq -r '.experiment_id' "${sandbox_dir}/results.json" 2>/dev/null || echo "unknown")
    SUCCESS=$(jq -r '.success' "${sandbox_dir}/results.json" 2>/dev/null || echo "false")
    
    if [[ "${SUCCESS}" != "true" ]]; then
        log_error "Cannot package failed experiment"
        return 1
    fi
    
    log_info "Packaging successful experiment for ${RESOURCE_NAME}"
    return 0
}

# Generate app metadata
generate_app_metadata() {
    local app_dir="$1"
    local resource_name="$2"
    local docker_image="$3"
    
    # Create service.json for the generated app
    cat > "${app_dir}/.vrooli/service.json" << EOF
{
  "name": "${resource_name}-app",
  "version": "1.0.0",
  "description": "Auto-generated application for ${resource_name} resource",
  "type": "standalone-app",
  "category": "resource-provider",
  "tags": ["auto-generated", "resource-experimenter", "${resource_name}"],
  "author": "Resource Experimenter",
  "generated_at": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
  "source_image": "${docker_image}",
  "experiment_id": "${EXPERIMENT_ID}",
  
  "lifecycle": {
    "setup": {
      "description": "Initialize the ${resource_name} application environment",
      "commands": ["./scripts/manage.sh setup --target docker"]
    },
    "start": {
      "description": "Start the ${resource_name} service",
      "commands": ["./scripts/manage.sh start"]
    },
    "stop": {
      "description": "Stop the ${resource_name} service", 
      "commands": ["./scripts/manage.sh stop"]
    },
    "test": {
      "description": "Run tests for ${resource_name}",
      "commands": ["./scripts/manage.sh test"]
    }
  },
  
  "resources": {
    "${resource_name}": {
      "enabled": true,
      "docker_image": "${docker_image}",
      "ports": {
        "primary": 8080
      },
      "volumes": {
        "data": "./data/${resource_name}",
        "config": "./config/${resource_name}"
      },
      "health_check": {
        "enabled": true,
        "endpoint": "/health",
        "timeout": 30,
        "retries": 3
      }
    }
  },
  
  "requirements": {
    "docker": ">=20.10.0",
    "memory_mb": 512,
    "disk_gb": 2,
    "network": true
  }
}
EOF

    # Create package.json for Node.js compatibility
    cat > "${app_dir}/package.json" << EOF
{
  "name": "${resource_name}-app",
  "version": "1.0.0",
  "description": "Auto-generated application for ${resource_name} resource",
  "main": "index.js",
  "scripts": {
    "start": "./scripts/manage.sh start",
    "stop": "./scripts/manage.sh stop",
    "test": "./scripts/manage.sh test",
    "setup": "./scripts/manage.sh setup"
  },
  "keywords": ["${resource_name}", "docker", "resource", "auto-generated"],
  "author": "Resource Experimenter",
  "license": "MIT",
  "engines": {
    "node": ">=16.0.0"
  }
}
EOF
}

# Create app directory structure  
create_app_structure() {
    local app_dir="$1"
    local resource_name="$2"
    
    log_info "Creating app directory structure..."
    
    # Create main directories
    mkdir -p "${app_dir}"/{.vrooli,scripts/{resources,scenarios,lib},data,config,logs,tests,docs}
    
    # Create resource-specific subdirectories
    mkdir -p "${app_dir}/data/${resource_name}"
    mkdir -p "${app_dir}/config/${resource_name}"
    mkdir -p "${app_dir}/scripts/resources/${resource_name}"
    mkdir -p "${app_dir}/tests/${resource_name}"
    
    # Create docs structure
    mkdir -p "${app_dir}/docs"/{setup,usage,troubleshooting}
    
    log_info "‚úÖ App directory structure created"
}

# Copy experiment artifacts
copy_experiment_artifacts() {
    local sandbox_dir="$1"
    local app_dir="$2"
    local resource_name="$3"
    
    log_info "Copying experiment artifacts..."
    
    # Copy generated provider script to resources directory
    if [[ -f "${sandbox_dir}/generated/manage.sh" ]]; then
        cp "${sandbox_dir}/generated/manage.sh" "${app_dir}/scripts/resources/${resource_name}/"
        chmod +x "${app_dir}/scripts/resources/${resource_name}/manage.sh"
    fi
    
    # Copy docker-compose files
    if [[ -f "${sandbox_dir}/docker-compose.yml" ]]; then
        cp "${sandbox_dir}/docker-compose.yml" "${app_dir}/scripts/resources/${resource_name}/"
    fi
    
    if [[ -f "${sandbox_dir}/docker-compose.generated.yml" ]]; then
        cp "${sandbox_dir}/docker-compose.generated.yml" "${app_dir}/scripts/resources/${resource_name}/docker-compose.yml"
    fi
    
    # Copy environment template
    if [[ -f "${sandbox_dir}/.env" ]]; then
        cp "${sandbox_dir}/.env" "${app_dir}/scripts/resources/${resource_name}/.env.example"
    fi
    
    # Copy test files
    if [[ -d "${sandbox_dir}/tests" ]]; then
        cp -r "${sandbox_dir}/tests/"* "${app_dir}/tests/${resource_name}/"
    fi
    
    # Copy analysis results
    if [[ -f "${sandbox_dir}/analysis.json" ]]; then
        cp "${sandbox_dir}/analysis.json" "${app_dir}/docs/analysis.json"
    fi
    
    # Copy logs for debugging
    if [[ -d "${sandbox_dir}/logs" ]]; then
        mkdir -p "${app_dir}/logs/experiment"
        cp -r "${sandbox_dir}/logs/"* "${app_dir}/logs/experiment/" || true
    fi
    
    log_info "‚úÖ Experiment artifacts copied"
}

# Generate main management script
generate_main_management_script() {
    local app_dir="$1"
    local resource_name="$2"
    
    log_info "Generating main management script..."
    
    cat > "${app_dir}/scripts/manage.sh" << 'EOF'
#!/usr/bin/env bash
# Auto-generated management script for {{RESOURCE_NAME}} application

set -euo pipefail

readonly SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
readonly APP_DIR="$(dirname "${SCRIPT_DIR}")"
readonly RESOURCE_NAME="{{RESOURCE_NAME}}"

# Import resource management functions
if [[ -f "${SCRIPT_DIR}/resources/${RESOURCE_NAME}/manage.sh" ]]; then
    source "${SCRIPT_DIR}/resources/${RESOURCE_NAME}/manage.sh"
else
    echo "Error: Resource management script not found"
    exit 1
fi

# Logging functions
log_info() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] INFO: $*"
}

log_error() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] ERROR: $*" >&2
}

# Setup function
setup_app() {
    local target="${1:-docker}"
    
    log_info "Setting up ${RESOURCE_NAME} application..."
    
    # Create required directories
    mkdir -p "${APP_DIR}"/{data,config,logs}/"${RESOURCE_NAME}"
    
    # Set up Docker network
    if ! docker network ls | grep -q "vrooli-network"; then
        docker network create vrooli-network || true
    fi
    
    # Call resource-specific setup
    if type setup_resource >/dev/null 2>&1; then
        setup_resource "${target}"
    fi
    
    log_info "‚úÖ Setup completed"
}

# Start function
start_app() {
    log_info "Starting ${RESOURCE_NAME} application..."
    
    cd "${SCRIPT_DIR}/resources/${RESOURCE_NAME}"
    
    # Call resource-specific start
    if type start_resource >/dev/null 2>&1; then
        start_resource
    else
        # Fallback to docker-compose
        if [[ -f "docker-compose.yml" ]]; then
            docker compose up -d
        else
            log_error "No start method available"
            exit 1
        fi
    fi
    
    log_info "‚úÖ ${RESOURCE_NAME} started successfully"
}

# Stop function
stop_app() {
    log_info "Stopping ${RESOURCE_NAME} application..."
    
    cd "${SCRIPT_DIR}/resources/${RESOURCE_NAME}"
    
    # Call resource-specific stop
    if type stop_resource >/dev/null 2>&1; then
        stop_resource
    else
        # Fallback to docker-compose
        if [[ -f "docker-compose.yml" ]]; then
            docker compose down
        fi
    fi
    
    log_info "‚úÖ ${RESOURCE_NAME} stopped"
}

# Status function
status_app() {
    log_info "Checking ${RESOURCE_NAME} status..."
    
    # Call resource-specific status
    if type status_resource >/dev/null 2>&1; then
        status_resource
    else
        # Fallback check
        if docker ps --format "table {{.Names}}\t{{.Status}}" | grep -q "${RESOURCE_NAME}"; then
            log_info "‚úÖ ${RESOURCE_NAME} is running"
        else
            log_info "‚ùå ${RESOURCE_NAME} is not running"
        fi
    fi
}

# Test function
test_app() {
    log_info "Running tests for ${RESOURCE_NAME}..."
    
    # Run bats tests if available
    if [[ -d "${APP_DIR}/tests/${RESOURCE_NAME}" ]]; then
        local test_files=("${APP_DIR}/tests/${RESOURCE_NAME}"/*.bats)
        
        for test_file in "${test_files[@]}"; do
            if [[ -f "${test_file}" ]]; then
                log_info "Running tests from $(basename "${test_file}")..."
                if ! bats "${test_file}"; then
                    log_error "Tests failed in $(basename "${test_file}")"
                    exit 1
                fi
            fi
        done
        
        log_info "‚úÖ All tests passed"
    else
        log_warn "No tests found for ${RESOURCE_NAME}"
    fi
}

# Show help
show_help() {
    cat << HELP
${RESOURCE_NAME} Application Management Script

USAGE:
    $0 <command> [options]

COMMANDS:
    setup [target]    Set up the application (target: docker, native)
    start             Start the application
    stop              Stop the application
    restart           Restart the application
    status            Show application status
    test              Run application tests
    logs              Show application logs
    help              Show this help message

EXAMPLES:
    $0 setup docker   # Set up with Docker
    $0 start          # Start the application
    $0 test           # Run tests
    $0 status         # Check status
HELP
}

# Show logs
show_logs() {
    log_info "Showing ${RESOURCE_NAME} logs..."
    
    cd "${SCRIPT_DIR}/resources/${RESOURCE_NAME}"
    
    # Call resource-specific logs function
    if type show_resource_logs >/dev/null 2>&1; then
        show_resource_logs
    else
        # Fallback to docker logs
        local container_name="${RESOURCE_NAME}"
        if docker ps --format "{{.Names}}" | grep -q "${container_name}"; then
            docker logs "${container_name}" --tail 100 --follow
        else
            log_warn "No logs available - container not running"
        fi
    fi
}

# Main function
main() {
    local command="${1:-help}"
    
    case "${command}" in
        setup)
            setup_app "${2:-docker}"
            ;;
        start)
            start_app
            ;;
        stop)
            stop_app
            ;;
        restart)
            stop_app
            start_app
            ;;
        status)
            status_app
            ;;
        test)
            test_app
            ;;
        logs)
            show_logs
            ;;
        help|--help|-h)
            show_help
            ;;
        *)
            echo "Unknown command: ${command}"
            show_help
            exit 1
            ;;
    esac
}

# Run main function
main "$@"
EOF

    # Replace template variables
    sed -i "s/{{RESOURCE_NAME}}/${resource_name}/g" "${app_dir}/scripts/manage.sh"
    chmod +x "${app_dir}/scripts/manage.sh"
    
    log_info "‚úÖ Main management script generated"
}

# Generate documentation
generate_documentation() {
    local app_dir="$1"
    local resource_name="$2"
    local docker_image="$3"
    
    log_info "Generating documentation..."
    
    # Create README.md
    cat > "${app_dir}/README.md" << EOF
# ${resource_name} Application

Auto-generated standalone application for the ${resource_name} resource.

## Overview

This application was automatically generated by the Vrooli Resource Experimenter and provides a complete, ready-to-deploy package for running ${resource_name} in a Docker environment.

**Source Docker Image:** \`${docker_image}\`
**Generated:** ${CURRENT_DATE}
**Experiment ID:** ${EXPERIMENT_ID}

## Quick Start

1. **Setup the application:**
   \`\`\`bash
   ./scripts/manage.sh setup
   \`\`\`

2. **Start the service:**
   \`\`\`bash
   ./scripts/manage.sh start
   \`\`\`

3. **Check status:**
   \`\`\`bash
   ./scripts/manage.sh status
   \`\`\`

4. **Run tests:**
   \`\`\`bash
   ./scripts/manage.sh test
   \`\`\`

## Directory Structure

\`\`\`
‚îú‚îÄ‚îÄ .vrooli/           # Application metadata
‚îú‚îÄ‚îÄ scripts/           # Management and resource scripts
‚îÇ   ‚îú‚îÄ‚îÄ manage.sh      # Main management script
‚îÇ   ‚îî‚îÄ‚îÄ resources/     # Resource-specific scripts
‚îú‚îÄ‚îÄ data/              # Persistent data storage
‚îú‚îÄ‚îÄ config/            # Configuration files
‚îú‚îÄ‚îÄ tests/             # Test suites
‚îú‚îÄ‚îÄ docs/              # Documentation
‚îî‚îÄ‚îÄ logs/              # Log files
\`\`\`

## Commands

- \`./scripts/manage.sh setup\` - Initialize the application
- \`./scripts/manage.sh start\` - Start the ${resource_name} service
- \`./scripts/manage.sh stop\` - Stop the ${resource_name} service
- \`./scripts/manage.sh restart\` - Restart the service
- \`./scripts/manage.sh status\` - Check service status
- \`./scripts/manage.sh test\` - Run test suite
- \`./scripts/manage.sh logs\` - View service logs

## Requirements

- Docker 20.10.0 or later
- Docker Compose
- Minimum 512MB RAM
- 2GB available disk space

## Configuration

Configuration files are located in the \`config/${resource_name}/\` directory. 
Default settings are provided but can be customized as needed.

## Testing

The application includes an automated test suite that validates:
- Service startup and health
- API endpoints and connectivity
- Resource utilization
- Container orchestration

Run tests with:
\`\`\`bash
./scripts/manage.sh test
\`\`\`

## Troubleshooting

### Service won't start
1. Check if Docker is running: \`docker info\`
2. Verify port availability: \`netstat -ln | grep 8080\`
3. Check logs: \`./scripts/manage.sh logs\`

### Tests failing
1. Ensure service is running: \`./scripts/manage.sh status\`
2. Check service health: \`curl -f http://localhost:8080/health\`
3. Review test logs in \`logs/\` directory

### Performance issues
1. Check resource usage: \`docker stats\`
2. Review configuration in \`config/${resource_name}/\`
3. Adjust memory limits in docker-compose.yml

## Generated by

This application was automatically generated by the [Vrooli Resource Experimenter](https://vrooli.com), which discovers, tests, and packages Docker-based resources into deployable applications.

For more information about Vrooli and its AI-powered resource discovery system, visit [vrooli.com](https://vrooli.com).
EOF

    # Create setup guide
    cat > "${app_dir}/docs/setup/README.md" << EOF
# Setup Guide

This guide walks you through setting up the ${resource_name} application.

## Prerequisites

- Docker 20.10.0 or later
- Docker Compose (included with Docker Desktop)
- At least 512MB available RAM
- 2GB available disk space

## Installation Steps

### 1. Initial Setup

Run the setup command to initialize the application:

\`\`\`bash
./scripts/manage.sh setup
\`\`\`

This will:
- Create required directories
- Set up Docker network
- Initialize configuration files
- Prepare the environment

### 2. Start the Service

\`\`\`bash
./scripts/manage.sh start
\`\`\`

The ${resource_name} service will be available on port 8080.

### 3. Verify Installation

\`\`\`bash
./scripts/manage.sh status
./scripts/manage.sh test
\`\`\`

## Configuration

Configuration files are located in \`config/${resource_name}/\`.
You can modify these files before starting the service.

## Next Steps

- Review the usage guide in \`docs/usage/\`
- Configure monitoring if needed
- Set up backups for persistent data
EOF

    # Create usage guide
    cat > "${app_dir}/docs/usage/README.md" << EOF
# Usage Guide

## Managing the ${resource_name} Service

### Starting and Stopping

\`\`\`bash
# Start the service
./scripts/manage.sh start

# Stop the service  
./scripts/manage.sh stop

# Restart the service
./scripts/manage.sh restart
\`\`\`

### Monitoring

Check service status:
\`\`\`bash
./scripts/manage.sh status
\`\`\`

View logs:
\`\`\`bash
./scripts/manage.sh logs
\`\`\`

### Testing

Run the test suite to validate functionality:
\`\`\`bash
./scripts/manage.sh test
\`\`\`

### Data Management

- Persistent data is stored in \`data/${resource_name}/\`
- Configuration files are in \`config/${resource_name}/\`
- Logs are written to \`logs/\`

### Backup and Restore

To backup your data:
\`\`\`bash
tar -czf ${resource_name}-backup-\$(date +%Y%m%d).tar.gz data/ config/
\`\`\`

To restore:
\`\`\`bash
tar -xzf ${resource_name}-backup-YYYYMMDD.tar.gz
\`\`\`
EOF

    # Create troubleshooting guide
    cat > "${app_dir}/docs/troubleshooting/README.md" << EOF
# Troubleshooting Guide

## Common Issues

### Service Won't Start

**Check Docker:**
\`\`\`bash
docker info
\`\`\`

**Check port availability:**
\`\`\`bash
netstat -ln | grep 8080
ss -ln | grep 8080
\`\`\`

**Check logs:**
\`\`\`bash
./scripts/manage.sh logs
\`\`\`

### Performance Issues

**Monitor resource usage:**
\`\`\`bash
docker stats
\`\`\`

**Check disk space:**
\`\`\`bash
df -h
\`\`\`

### Network Issues

**Verify Docker network:**
\`\`\`bash
docker network ls | grep vrooli
\`\`\`

**Test connectivity:**
\`\`\`bash
curl -f http://localhost:8080/health
\`\`\`

### Test Failures

1. Ensure service is running
2. Check service health endpoint
3. Review individual test logs in \`logs/\` directory
4. Verify port accessibility

## Getting Help

1. Check the logs: \`./scripts/manage.sh logs\`
2. Run diagnostics: \`./scripts/manage.sh status\`
3. Review configuration in \`config/${resource_name}/\`
4. Consult the Docker image documentation for ${docker_image}

## Reporting Issues

When reporting issues, please include:
- Output of \`./scripts/manage.sh status\`
- Relevant log files from \`logs/\`
- Your system information (\`docker version\`, \`docker info\`)
- Steps to reproduce the issue
EOF

    log_info "‚úÖ Documentation generated"
}

# Package the application
package_application() {
    local app_dir="$1"
    local app_name="$2"
    
    log_info "Packaging application..."
    
    local output_dir="${OUTPUT_BASE}/packaged/${app_name}-${CURRENT_TIMESTAMP}"
    mkdir -p "${output_dir}"
    
    cd "$(dirname "${app_dir}")"
    local app_basename="$(basename "${app_dir}")"
    
    # Create tar.gz archive
    log_info "Creating tar.gz archive..."
    tar -czf "${output_dir}/${app_name}-${CURRENT_TIMESTAMP}.tar.gz" "${app_basename}"
    
    # Create zip archive
    log_info "Creating zip archive..."
    zip -r "${output_dir}/${app_name}-${CURRENT_TIMESTAMP}.zip" "${app_basename}" >/dev/null
    
    # Generate checksums
    cd "${output_dir}"
    sha256sum "${app_name}-${CURRENT_TIMESTAMP}.tar.gz" > "${app_name}-${CURRENT_TIMESTAMP}.tar.gz.sha256"
    sha256sum "${app_name}-${CURRENT_TIMESTAMP}.zip" > "${app_name}-${CURRENT_TIMESTAMP}.zip.sha256"
    
    # Create package manifest
    cat > "${output_dir}/manifest.json" << EOF
{
  "name": "${app_name}",
  "version": "1.0.0",
  "generated_at": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
  "experiment_id": "${EXPERIMENT_ID}",
  "resource_name": "${RESOURCE_NAME}",
  "docker_image": "${DOCKER_IMAGE}",
  "files": {
    "tar_gz": "${app_name}-${CURRENT_TIMESTAMP}.tar.gz",
    "zip": "${app_name}-${CURRENT_TIMESTAMP}.zip",
    "tar_gz_checksum": "${app_name}-${CURRENT_TIMESTAMP}.tar.gz.sha256",
    "zip_checksum": "${app_name}-${CURRENT_TIMESTAMP}.zip.sha256"
  },
  "size_bytes": {
    "tar_gz": $(stat -c%s "${app_name}-${CURRENT_TIMESTAMP}.tar.gz"),
    "zip": $(stat -c%s "${app_name}-${CURRENT_TIMESTAMP}.zip")
  }
}
EOF

    echo "${output_dir}"
    log_info "‚úÖ Application packaged successfully"
}

# Upload to MinIO
upload_to_minio() {
    local package_dir="$1"
    local app_name="$2"
    
    log_info "Uploading packages to MinIO..."
    
    # Check if MinIO is available
    if ! curl -f -s --max-time 5 "http://localhost:9000/minio/health/live" >/dev/null 2>&1; then
        log_warn "MinIO not available, skipping upload"
        return 0
    fi
    
    # Upload files using MinIO client in Docker
    docker run --rm --network vrooli-network \
        -v "${package_dir}:/data:ro" \
        -e MC_HOST_minio=http://vrooli:vrooli123@vrooli-minio:9000 \
        minio/mc \
        sh -c "
            mc cp /data/*.tar.gz minio/generated-apps/${app_name}/ &&
            mc cp /data/*.zip minio/generated-apps/${app_name}/ &&
            mc cp /data/*.sha256 minio/generated-apps/${app_name}/ &&
            mc cp /data/manifest.json minio/generated-apps/${app_name}/
        " || log_warn "Failed to upload some files to MinIO"
    
    log_info "‚úÖ Upload completed"
}

# Main packaging function
package_experiment() {
    local experiment_input="$1"
    
    # Determine if input is sandbox directory or experiment ID
    local sandbox_dir
    if [[ -d "${experiment_input}" ]]; then
        sandbox_dir="${experiment_input}"
    elif [[ -d "${SANDBOX_BASE}/experiment-${experiment_input}" ]]; then
        sandbox_dir="${SANDBOX_BASE}/experiment-${experiment_input}"
    else
        # Check for successful experiment marker
        if [[ -f "${SANDBOX_BASE}/.successful-experiment" ]]; then
            sandbox_dir="$(cat "${SANDBOX_BASE}/.successful-experiment")"
        else
            log_error "No experiment found: ${experiment_input}"
            return 1
        fi
    fi
    
    if [[ ! -d "${sandbox_dir}" ]]; then
        log_error "Sandbox directory not found: ${sandbox_dir}"
        return 1
    fi
    
    # Parse experiment results
    if ! parse_experiment_results "${sandbox_dir}"; then
        return 1
    fi
    
    # Create app directory
    local app_name="${RESOURCE_NAME}-app"
    local app_dir="${OUTPUT_BASE}/${app_name}-${CURRENT_TIMESTAMP}"
    
    # Create the application structure
    create_app_structure "${app_dir}" "${RESOURCE_NAME}"
    generate_app_metadata "${app_dir}" "${RESOURCE_NAME}" "${DOCKER_IMAGE}"
    copy_experiment_artifacts "${sandbox_dir}" "${app_dir}" "${RESOURCE_NAME}"
    generate_main_management_script "${app_dir}" "${RESOURCE_NAME}"
    generate_documentation "${app_dir}" "${RESOURCE_NAME}" "${DOCKER_IMAGE}"
    
    # Package the application
    local package_dir
    package_dir=$(package_application "${app_dir}" "${app_name}")
    
    # Upload to MinIO
    upload_to_minio "${package_dir}" "${app_name}"
    
    # Clean up the temporary app directory
    rm -rf "${app_dir}"
    
    log_info "üéâ Successfully packaged ${app_name}"
    log_info "Package location: ${package_dir}"
    
    # Update database with generated app info
    docker exec vrooli-postgres psql -U postgres -d resource_experiments -c "
    UPDATE experiments 
    SET generated_app_path='${package_dir}', 
        generated_at=NOW() 
    WHERE id='${EXPERIMENT_ID}';" >/dev/null 2>&1 || log_warn "Failed to update database with app info"
}

# Show help
show_help() {
    cat << EOF
Resource Experimenter - App Packager

USAGE:
    $0 [experiment_id|sandbox_dir|latest]

PARAMETERS:
    experiment_id   ID of the experiment to package
    sandbox_dir     Path to sandbox directory
    latest          Package the most recent successful experiment

EXAMPLES:
    $0                              # Package latest successful experiment
    $0 latest                       # Package latest successful experiment  
    $0 exp-123                      # Package specific experiment
    $0 /path/to/sandbox/exp-123     # Package from specific directory

The packager will:
1. Parse experiment results and validate success
2. Create complete application directory structure
3. Copy all generated artifacts and scripts
4. Generate documentation and metadata
5. Package as tar.gz and zip archives
6. Upload to MinIO for distribution
7. Update database with app information

Generated applications include:
- Complete resource provider scripts
- Test suites and validation
- Documentation and setup guides
- Docker orchestration files
- Management scripts and utilities
EOF
}

# Main function
main() {
    local input="${1:-latest}"
    
    if [[ "${input}" == "--help" || "${input}" == "-h" ]]; then
        show_help
        exit 0
    fi
    
    log_info "üì¶ Resource Experimenter - App Packager"
    log_info "======================================"
    
    # Create output directories
    mkdir -p "${OUTPUT_BASE}"/{packaged,temp}
    
    # Handle 'latest' input
    if [[ "${input}" == "latest" ]]; then
        if [[ -f "${SANDBOX_BASE}/.successful-experiment" ]]; then
            input="$(cat "${SANDBOX_BASE}/.successful-experiment")"
            log_info "Using latest successful experiment: $(basename "${input}")"
        else
            log_error "No successful experiments found"
            exit 1
        fi
    fi
    
    # Package the experiment
    if package_experiment "${input}"; then
        log_info "‚úÖ Packaging completed successfully!"
        exit 0
    else
        log_error "‚ùå Packaging failed!"
        exit 1
    fi
}

# Run main function
main "$@"