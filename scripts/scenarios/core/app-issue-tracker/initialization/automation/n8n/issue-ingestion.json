{
  "name": "Issue Ingestion Pipeline",
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "ingest-issue",
        "responseMode": "responseNode",
        "options": {}
      },
      "id": "webhook_entry",
      "name": "Issue Webhook",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 1,
      "position": [250, 300]
    },
    {
      "parameters": {
        "functionCode": "// Validate and enrich incoming issue data\nconst issue = items[0].json;\n\n// Required fields validation\nconst required = ['app_id', 'title', 'description', 'type', 'priority'];\nfor (const field of required) {\n  if (!issue[field]) {\n    throw new Error(`Missing required field: ${field}`);\n  }\n}\n\n// Enrich with defaults\nissue.status = issue.status || 'open';\nissue.created_at = new Date().toISOString();\nissue.occurrence_count = 1;\nissue.tags = issue.tags || [];\n\n// Clean and normalize text\nissue.title = issue.title.trim().substring(0, 500);\nissue.description = issue.description.trim();\n\n// Extract keywords for pattern matching\nconst text = `${issue.title} ${issue.description} ${issue.error_message || ''}`;\nconst keywords = text.toLowerCase()\n  .split(/\\W+/)\n  .filter(word => word.length > 3)\n  .filter((word, index, self) => self.indexOf(word) === index)\n  .slice(0, 20);\n\nissue.extracted_keywords = keywords;\n\nreturn [{json: issue}];"
      },
      "id": "validate_enrich",
      "name": "Validate & Enrich",
      "type": "n8n-nodes-base.code",
      "typeVersion": 1,
      "position": [450, 300]
    },
    {
      "parameters": {
        "url": "http://ollama:11434/api/embeddings",
        "method": "POST",
        "body": "{\n  \"model\": \"nomic-embed-text\",\n  \"prompt\": \"{{ $json.title }} {{ $json.description }} {{ $json.error_message }}\"\n}",
        "options": {
          "timeout": 10000
        }
      },
      "id": "generate_embedding",
      "name": "Generate Embedding",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 3,
      "position": [650, 300]
    },
    {
      "parameters": {
        "functionCode": "// Check for duplicate issues using embeddings\nconst issue = items[0].json;\nconst embedding = items[0].json.embedding;\n\n// Query Qdrant for similar issues\nconst qdrantUrl = 'http://qdrant:6333/collections/issues/points/search';\nconst searchPayload = {\n  vector: embedding,\n  limit: 5,\n  with_payload: true,\n  score_threshold: 0.85\n};\n\n// Simulate search (in real implementation, use HTTP Request node)\nconst similarIssues = [];\n\nif (similarIssues.length > 0 && similarIssues[0].score > 0.95) {\n  // Very high similarity - likely duplicate\n  issue.is_duplicate = true;\n  issue.duplicate_of = similarIssues[0].id;\n  issue.similarity_score = similarIssues[0].score;\n} else if (similarIssues.length > 0) {\n  // Related but not duplicate\n  issue.related_issues = similarIssues.map(s => ({\n    id: s.id,\n    title: s.payload.title,\n    similarity: s.score\n  }));\n}\n\nreturn [{json: issue}];"
      },
      "id": "check_duplicates",
      "name": "Check Duplicates",
      "type": "n8n-nodes-base.code",
      "typeVersion": 1,
      "position": [850, 300]
    },
    {
      "parameters": {
        "conditions": {
          "boolean": [
            {
              "value1": "={{$json.is_duplicate}}",
              "value2": true
            }
          ]
        }
      },
      "id": "is_duplicate_check",
      "name": "Is Duplicate?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 1,
      "position": [1050, 300]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "UPDATE issues SET occurrence_count = occurrence_count + 1, last_seen_at = CURRENT_TIMESTAMP WHERE id = '{{ $json.duplicate_of }}' RETURNING *",
        "options": {}
      },
      "id": "update_duplicate",
      "name": "Update Duplicate Count",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2,
      "position": [1250, 200]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "INSERT INTO issues (app_id, title, description, type, priority, status, error_message, stack_trace, affected_files, tags, embedding, embedding_generated_at) VALUES ('{{ $json.app_id }}', '{{ $json.title }}', '{{ $json.description }}', '{{ $json.type }}', '{{ $json.priority }}', '{{ $json.status }}', '{{ $json.error_message }}', '{{ $json.stack_trace }}', ARRAY{{ $json.affected_files }}::text[], ARRAY{{ $json.tags }}::text[], '{{ $json.embedding }}', CURRENT_TIMESTAMP) RETURNING *",
        "options": {}
      },
      "id": "insert_new_issue",
      "name": "Insert New Issue",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2,
      "position": [1250, 400]
    },
    {
      "parameters": {
        "functionCode": "// Check if issue matches any pattern groups\nconst issue = items[0].json;\nconst keywords = issue.extracted_keywords || [];\n\n// Query pattern groups\nconst patterns = [\n  {\n    id: 'pg-001',\n    name: 'Authentication Errors',\n    keywords: ['auth', 'login', 'token', 'permission'],\n    threshold: 2\n  },\n  {\n    id: 'pg-002',\n    name: 'Database Issues',\n    keywords: ['database', 'connection', 'postgres', 'timeout'],\n    threshold: 2\n  }\n];\n\n// Find matching pattern\nfor (const pattern of patterns) {\n  const matches = keywords.filter(kw => \n    pattern.keywords.some(pk => kw.includes(pk))\n  );\n  \n  if (matches.length >= pattern.threshold) {\n    issue.pattern_group_id = pattern.id;\n    issue.pattern_group_name = pattern.name;\n    issue.pattern_match_keywords = matches;\n    break;\n  }\n}\n\nreturn [{json: issue}];"
      },
      "id": "pattern_matching",
      "name": "Pattern Matching",
      "type": "n8n-nodes-base.code",
      "typeVersion": 1,
      "position": [1450, 300]
    },
    {
      "parameters": {
        "url": "http://qdrant:6333/collections/issues/points",
        "method": "PUT",
        "body": "{\n  \"points\": [\n    {\n      \"id\": \"{{ $json.id }}\",\n      \"vector\": {{ $json.embedding }},\n      \"payload\": {\n        \"app_id\": \"{{ $json.app_id }}\",\n        \"title\": \"{{ $json.title }}\",\n        \"type\": \"{{ $json.type }}\",\n        \"priority\": \"{{ $json.priority }}\",\n        \"status\": \"{{ $json.status }}\",\n        \"pattern_group_id\": \"{{ $json.pattern_group_id }}\",\n        \"created_at\": \"{{ $json.created_at }}\"\n      }\n    }\n  ]\n}",
        "options": {}
      },
      "id": "store_vector",
      "name": "Store in Vector DB",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 3,
      "position": [1650, 300]
    },
    {
      "parameters": {
        "channel": "issue_tracker:events",
        "messageData": "{\n  \"event\": \"issue_created\",\n  \"issue_id\": \"{{ $json.id }}\",\n  \"app_id\": \"{{ $json.app_id }}\",\n  \"title\": \"{{ $json.title }}\",\n  \"type\": \"{{ $json.type }}\",\n  \"priority\": \"{{ $json.priority }}\",\n  \"pattern_group\": \"{{ $json.pattern_group_name }}\",\n  \"is_duplicate\": {{ $json.is_duplicate || false }}\n}"
      },
      "id": "publish_event",
      "name": "Publish Event",
      "type": "n8n-nodes-base.redis",
      "typeVersion": 1,
      "position": [1850, 300]
    },
    {
      "parameters": {
        "functionCode": "// Determine if auto-investigation should trigger\nconst issue = items[0].json;\n\nlet shouldInvestigate = false;\nlet investigationPriority = 'normal';\n\n// Auto-investigate critical issues\nif (issue.priority === 'critical') {\n  shouldInvestigate = true;\n  investigationPriority = 'high';\n}\n\n// Auto-investigate security issues\nif (issue.type === 'security') {\n  shouldInvestigate = true;\n  investigationPriority = 'high';\n}\n\n// Auto-investigate if part of a growing pattern\nif (issue.pattern_group_id && !issue.is_duplicate) {\n  shouldInvestigate = true;\n}\n\nissue.auto_investigate = shouldInvestigate;\nissue.investigation_priority = investigationPriority;\n\nreturn [{json: issue}];"
      },
      "id": "auto_investigate_check",
      "name": "Auto Investigation Check",
      "type": "n8n-nodes-base.code",
      "typeVersion": 1,
      "position": [2050, 300]
    },
    {
      "parameters": {
        "conditions": {
          "boolean": [
            {
              "value1": "={{$json.auto_investigate}}",
              "value2": true
            }
          ]
        }
      },
      "id": "should_investigate",
      "name": "Should Investigate?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 1,
      "position": [2250, 300]
    },
    {
      "parameters": {
        "url": "http://localhost:8000/api/w/issue_tracker/jobs/run/p/trigger-investigation",
        "method": "POST",
        "body": "{\n  \"issueId\": \"{{ $json.id }}\",\n  \"priority\": \"{{ $json.investigation_priority }}\"\n}",
        "options": {}
      },
      "id": "trigger_investigation",
      "name": "Trigger Investigation",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 3,
      "position": [2450, 200]
    },
    {
      "parameters": {
        "values": {
          "string": [
            {
              "name": "status",
              "value": "success"
            },
            {
              "name": "issue_id",
              "value": "={{ $json.id }}"
            },
            {
              "name": "is_duplicate",
              "value": "={{ $json.is_duplicate || false }}"
            },
            {
              "name": "pattern_group",
              "value": "={{ $json.pattern_group_name || 'none' }}"
            },
            {
              "name": "auto_investigation",
              "value": "={{ $json.auto_investigate || false }}"
            }
          ]
        }
      },
      "id": "prepare_response",
      "name": "Prepare Response",
      "type": "n8n-nodes-base.set",
      "typeVersion": 2,
      "position": [2650, 300]
    }
  ],
  "connections": {
    "webhook_entry": {
      "main": [[{"node": "validate_enrich", "type": "main", "index": 0}]]
    },
    "validate_enrich": {
      "main": [[{"node": "generate_embedding", "type": "main", "index": 0}]]
    },
    "generate_embedding": {
      "main": [[{"node": "check_duplicates", "type": "main", "index": 0}]]
    },
    "check_duplicates": {
      "main": [[{"node": "is_duplicate_check", "type": "main", "index": 0}]]
    },
    "is_duplicate_check": {
      "main": [
        [{"node": "update_duplicate", "type": "main", "index": 0}],
        [{"node": "insert_new_issue", "type": "main", "index": 0}]
      ]
    },
    "update_duplicate": {
      "main": [[{"node": "pattern_matching", "type": "main", "index": 0}]]
    },
    "insert_new_issue": {
      "main": [[{"node": "pattern_matching", "type": "main", "index": 0}]]
    },
    "pattern_matching": {
      "main": [[{"node": "store_vector", "type": "main", "index": 0}]]
    },
    "store_vector": {
      "main": [[{"node": "publish_event", "type": "main", "index": 0}]]
    },
    "publish_event": {
      "main": [[{"node": "auto_investigate_check", "type": "main", "index": 0}]]
    },
    "auto_investigate_check": {
      "main": [[{"node": "should_investigate", "type": "main", "index": 0}]]
    },
    "should_investigate": {
      "main": [
        [{"node": "trigger_investigation", "type": "main", "index": 0}],
        [{"node": "prepare_response", "type": "main", "index": 0}]
      ]
    },
    "trigger_investigation": {
      "main": [[{"node": "prepare_response", "type": "main", "index": 0}]]
    }
  },
  "settings": {
    "executionOrder": "v1",
    "saveManualExecutions": true,
    "callerPolicy": "workflowsFromSameOwner",
    "errorWorkflow": ""
  },
  "staticData": null,
  "pinData": {},
  "versionId": "v1.0.0",
  "triggerCount": 1
}