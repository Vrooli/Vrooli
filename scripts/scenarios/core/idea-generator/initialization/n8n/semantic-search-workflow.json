{
  "name": "Semantic Search Workflow",
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "semantic-search",
        "responseMode": "responseNode",
        "options": {}
      },
      "id": "webhook_trigger",
      "name": "Search Request Webhook",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 1,
      "position": [250, 300]
    },
    {
      "parameters": {},
      "id": "manual_trigger",
      "name": "Manual Trigger",
      "type": "n8n-nodes-base.manualTrigger",
      "typeVersion": 1,
      "position": [250, 150]
    },
    {
      "parameters": {
        "values": {
          "string": [
            {
              "name": "query",
              "value": "innovative marketing strategies"
            },
            {
              "name": "campaign_id",
              "value": "test-campaign-123"
            },
            {
              "name": "limit",
              "value": "10"
            }
          ]
        },
        "options": {}
      },
      "id": "manual_defaults",
      "name": "Manual Test Defaults",
      "type": "n8n-nodes-base.set",
      "typeVersion": 1,
      "position": [450, 150]
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// Prepare request for shared smart semantic search\nconst data = $input.item.json;\n\n// Validate required fields\nif (!data.query || typeof data.query !== 'string' || data.query.trim().length === 0) {\n  throw new Error('Search query is required');\n}\n\n// Build text for semantic search including campaign context if provided\nlet searchText = data.query.trim();\nif (data.campaign_id) {\n  searchText = `Campaign: ${data.campaign_id}\\nQuery: ${searchText}`;\n}\n\n// Determine search mode based on requested depth\nconst searchMode = data.deep_search ? 'comprehensive' : 'quick';\n\n// Prepare request for shared workflow\nconst searchRequest = {\n  text: searchText,\n  collection: 'ideas',  // Use ideas collection for this scenario\n  mode: searchMode,\n  max_results_per_query: Math.min(parseInt(data.limit) || 10, 20),\n  include_synthesis: true,\n  confidence_threshold: parseFloat(data.min_similarity) || 0.7\n};\n\n// Store original request data for later use\nreturn {\n  search_request: searchRequest,\n  original_query: data.query,\n  campaign_id: data.campaign_id || null,\n  user_id: data.user_id || null,\n  content_types: data.content_types || ['idea', 'document'],\n  filters: data.filters || {},\n  boost_recent: data.boost_recent !== false\n};"
      },
      "id": "prepare_search",
      "name": "Prepare Search Request",
      "type": "n8n-nodes-base.code",
      "typeVersion": 1,
      "position": [450, 300]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "${service.n8n.url}/webhook/smart-search",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "bodyContentType": "json",
        "jsonBody": "={{ JSON.stringify($json.search_request) }}",
        "options": {
          "timeout": 60000
        }
      },
      "id": "call_shared_search",
      "name": "Call Shared Smart Search",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [650, 300]
    },
    {
      "parameters": {
        "operation": "insert",
        "table": "search_queries",
        "columns": "user_id,campaign_id,query_text,results_count",
        "values": "={{ $json.user_id || 'NULL' }},={{ $json.campaign_id ? \"'\" + $json.campaign_id + \"'\" : 'NULL' }},'{{ $json.original_query }}',{{ $node['call_shared_search'].json.results ? $node['call_shared_search'].json.results.length : 0 }}",
        "returnFields": "*"
      },
      "id": "log_search",
      "name": "Log Search Query",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 1,
      "position": [850, 300],
      "continueOnFail": true
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// Process and enrich search results from shared workflow\nconst searchResponse = $node['call_shared_search'].json;\nconst originalData = $node['prepare_search'].json;\n\n// Extract results from shared workflow response\nlet results = [];\nif (searchResponse.results && Array.isArray(searchResponse.results)) {\n  results = searchResponse.results;\n} else if (searchResponse.search_results && Array.isArray(searchResponse.search_results)) {\n  results = searchResponse.search_results;\n}\n\n// Filter results based on campaign if specified\nif (originalData.campaign_id) {\n  results = results.filter(r => \n    !r.metadata || \n    !r.metadata.campaign_id || \n    r.metadata.campaign_id === originalData.campaign_id\n  );\n}\n\n// Filter by content types if specified\nif (originalData.content_types && originalData.content_types.length > 0) {\n  results = results.filter(r => {\n    const type = r.type || r.content_type || 'idea';\n    return originalData.content_types.includes(type);\n  });\n}\n\n// Apply boost for recent items if requested\nif (originalData.boost_recent) {\n  const now = new Date();\n  results = results.map(r => {\n    if (r.created_at) {\n      const created = new Date(r.created_at);\n      const daysSince = (now - created) / (1000 * 60 * 60 * 24);\n      // Boost score for items created within last 30 days\n      if (daysSince < 30) {\n        r.score = (r.score || 1) * (1 + (30 - daysSince) / 60);\n      }\n    }\n    return r;\n  });\n  \n  // Re-sort by boosted scores\n  results.sort((a, b) => (b.score || 0) - (a.score || 0));\n}\n\n// Build response\nconst response = {\n  query: originalData.original_query,\n  campaign_id: originalData.campaign_id,\n  results: results,\n  total_results: results.length,\n  search_metadata: {\n    mode: originalData.search_request.mode,\n    collection: originalData.search_request.collection,\n    synthesis: searchResponse.synthesis || null,\n    processing_time: searchResponse.metadata?.processing_time || null\n  }\n};\n\nreturn response;"
      },
      "id": "process_results",
      "name": "Process Search Results",
      "type": "n8n-nodes-base.code",
      "typeVersion": 1,
      "position": [1050, 300]
    },
    {
      "parameters": {
        "mode": "responseNode",
        "options": {}
      },
      "id": "respond_to_webhook",
      "name": "Respond to Webhook",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1,
      "position": [1250, 300]
    }
  ],
  "connections": {
    "webhook_trigger": {
      "main": [
        [
          {
            "node": "prepare_search",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "manual_trigger": {
      "main": [
        [
          {
            "node": "manual_defaults",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "manual_defaults": {
      "main": [
        [
          {
            "node": "prepare_search",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "prepare_search": {
      "main": [
        [
          {
            "node": "call_shared_search",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "call_shared_search": {
      "main": [
        [
          {
            "node": "log_search",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "log_search": {
      "main": [
        [
          {
            "node": "process_results",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "process_results": {
      "main": [
        [
          {
            "node": "respond_to_webhook",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": false,
  "settings": {},
  "id": "idea-generator-semantic-search",
  "tags": []
}