{
  "name": "Semantic Search Workflow",
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "semantic-search",
        "responseMode": "responseNode",
        "options": {}
      },
      "id": "webhook_trigger",
      "name": "Search Request Webhook",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 1,
      "position": [250, 300]
    },
    {
      "parameters": {
        "functionCode": "// Validate and process search request\nconst data = $json;\n\n// Check required fields\nif (!data.query || typeof data.query !== 'string' || data.query.trim().length === 0) {\n  throw new Error('Search query is required');\n}\n\n// Set defaults\nconst processedRequest = {\n  query: data.query.trim(),\n  campaign_id: data.campaign_id || null,\n  limit: Math.min(parseInt(data.limit) || 20, 50), // Max 50 results\n  content_types: data.content_types || ['idea', 'document'], // Default: both\n  filters: data.filters || {},\n  user_id: data.user_id || null,\n  include_similarity_scores: data.include_similarity_scores !== false,\n  min_similarity: parseFloat(data.min_similarity) || 0.7,\n  boost_recent: data.boost_recent !== false\n};\n\n// Validate content types\nconst validTypes = ['idea', 'document'];\nprocessedRequest.content_types = processedRequest.content_types.filter(type => validTypes.includes(type));\n\nif (processedRequest.content_types.length === 0) {\n  processedRequest.content_types = ['idea', 'document'];\n}\n\nreturn [{ json: processedRequest }];"
      },
      "id": "validate_search_request",
      "name": "Validate Search Request",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [450, 300]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "http://localhost:5678/webhook/embed",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "bodyContentType": "json",
        "jsonBody": "{\n  \"text\": \"={{ $json.query }}\",\n  \"model\": \"nomic-embed-text\",\n  \"store_in_qdrant\": false\n}",
        "options": {
          "timeout": 10000
        }
      },
      "id": "generate_query_embedding",
      "name": "Generate Query Embedding",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [650, 300]
    },
    {
      "parameters": {
        "operation": "insert",
        "table": "search_queries",
        "columns": "user_id,campaign_id,query_text,query_embedding",
        "returnFields": "*"
      },
      "id": "log_search_query",
      "name": "Log Search Query",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 1,
      "position": [850, 300]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "SELECT search_ideas_and_documents('{{ JSON.stringify($node['Generate Query Embedding'].json.embedding) }}'::vector, {{ $node['Validate Search Request'].json.campaign_id ? \"'\" + $node['Validate Search Request'].json.campaign_id + \"'\" : 'NULL' }}, {{ $node['Validate Search Request'].json.limit }})",
        "additionalFields": {}
      },
      "id": "semantic_search_db",
      "name": "Search Database with Embeddings",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 1,
      "position": [1050, 300],
      "continueOnFail": true
    },
    {
      "parameters": {
        "method": "POST",
        "url": "http://localhost:6333/collections/ideas/points/search",
        "authentication": "none",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "bodyContentType": "json",
        "jsonBody": "{\n  \"vector\": {{ JSON.stringify($node['Generate Query Embedding'].json.embedding) }},\n  \"limit\": {{ Math.floor($node['Validate Search Request'].json.limit / 2) }},\n  \"score_threshold\": {{ $node['Validate Search Request'].json.min_similarity }},\n  \"with_payload\": true,\n  \"with_vector\": false{{ $node['Validate Search Request'].json.campaign_id ? ',\\n  \"filter\": {\\n    \"must\": [{\\n      \"key\": \"campaign_id\",\\n      \"match\": { \"value\": \"' + $node['Validate Search Request'].json.campaign_id + '\" }\\n    }]\\n  }' : '' }}\n}"
      },
      "id": "search_ideas_qdrant",
      "name": "Search Ideas in Qdrant",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 1,
      "position": [1050, 200],
      "continueOnFail": true
    },
    {
      "parameters": {
        "method": "POST",
        "url": "http://localhost:6333/collections/documents/points/search",
        "authentication": "none",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "bodyContentType": "json",
        "jsonBody": "{\n  \"vector\": {{ JSON.stringify($node['Generate Query Embedding'].json.embedding) }},\n  \"limit\": {{ Math.floor($node['Validate Search Request'].json.limit / 2) }},\n  \"score_threshold\": {{ $node['Validate Search Request'].json.min_similarity }},\n  \"with_payload\": true,\n  \"with_vector\": false{{ $node['Validate Search Request'].json.campaign_id ? ',\\n  \"filter\": {\\n    \"must\": [{\\n      \"key\": \"campaign_id\",\\n      \"match\": { \"value\": \"' + $node['Validate Search Request'].json.campaign_id + '\" }\\n    }]\\n  }' : '' }}\n}"
      },
      "id": "search_documents_qdrant",
      "name": "Search Documents in Qdrant",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 1,
      "position": [1050, 400],
      "continueOnFail": true
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "SELECT i.id, i.title, i.content, i.category, i.tags, i.status, i.created_at, c.name as campaign_name, c.color as campaign_color FROM ideas i LEFT JOIN campaigns c ON i.campaign_id = c.id WHERE to_tsvector('english', i.title || ' ' || i.content) @@ plainto_tsquery('english', '{{ $node['Validate Search Request'].json.query }}') {{ $node['Validate Search Request'].json.campaign_id ? \"AND i.campaign_id = '\" + $node['Validate Search Request'].json.campaign_id + \"'\" : '' }} ORDER BY ts_rank(to_tsvector('english', i.title || ' ' || i.content), plainto_tsquery('english', '{{ $node['Validate Search Request'].json.query }}')) DESC LIMIT {{ Math.floor($node['Validate Search Request'].json.limit / 2) }}",
        "additionalFields": {}
      },
      "id": "keyword_search_ideas",
      "name": "Keyword Search Ideas",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 1,
      "position": [1050, 500],
      "continueOnFail": true
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "SELECT d.id, d.original_name as title, d.extracted_text as content, d.file_type, d.created_at, c.name as campaign_name, c.color as campaign_color FROM documents d LEFT JOIN campaigns c ON d.campaign_id = c.id WHERE d.processing_status = 'completed' AND to_tsvector('english', d.extracted_text) @@ plainto_tsquery('english', '{{ $node['Validate Search Request'].json.query }}') {{ $node['Validate Search Request'].json.campaign_id ? \"AND d.campaign_id = '\" + $node['Validate Search Request'].json.campaign_id + \"'\" : '' }} ORDER BY ts_rank(to_tsvector('english', d.extracted_text), plainto_tsquery('english', '{{ $node['Validate Search Request'].json.query }}')) DESC LIMIT {{ Math.floor($node['Validate Search Request'].json.limit / 2) }}",
        "additionalFields": {}
      },
      "id": "keyword_search_documents",
      "name": "Keyword Search Documents",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 1,
      "position": [1050, 600],
      "continueOnFail": true
    },
    {
      "parameters": {
        "functionCode": "// Combine and rank search results from multiple sources\nconst request = $node['Validate Search Request'].json;\nconst semanticIdeas = $node['Search Ideas in Qdrant']?.json?.result || [];\nconst semanticDocs = $node['Search Documents in Qdrant']?.json?.result || [];\nconst keywordIdeas = $node['Keyword Search Ideas']?.json || [];\nconst keywordDocs = $node['Keyword Search Documents']?.json || [];\n\n// Process semantic search results\nconst processSemanticResults = (results, type) => {\n  return results.map(result => ({\n    id: result.payload.idea_id || result.payload.document_id,\n    type: type,\n    title: result.payload.title,\n    content: result.payload.content?.substring(0, 300) + '...',\n    score: result.score,\n    search_type: 'semantic',\n    campaign_name: result.payload.campaign_name,\n    campaign_color: result.payload.campaign_color,\n    category: result.payload.category,\n    tags: result.payload.tags,\n    status: result.payload.status,\n    created_at: result.payload.created_at\n  }));\n};\n\n// Process keyword search results  \nconst processKeywordResults = (results, type) => {\n  return results.map(result => ({\n    id: result.id,\n    type: type,\n    title: result.title,\n    content: result.content?.substring(0, 300) + '...',\n    score: 0.8, // Default keyword score\n    search_type: 'keyword',\n    campaign_name: result.campaign_name,\n    campaign_color: result.campaign_color,\n    category: result.category,\n    tags: result.tags,\n    status: result.status,\n    file_type: result.file_type,\n    created_at: result.created_at\n  }));\n};\n\n// Combine all results\nlet allResults = [];\n\nif (request.content_types.includes('idea')) {\n  allResults = allResults.concat(\n    processSemanticResults(semanticIdeas, 'idea'),\n    processKeywordResults(keywordIdeas, 'idea')\n  );\n}\n\nif (request.content_types.includes('document')) {\n  allResults = allResults.concat(\n    processSemanticResults(semanticDocs, 'document'),\n    processKeywordResults(keywordDocs, 'document')\n  );\n}\n\n// Remove duplicates by ID and type\nconst uniqueResults = [];\nconst seen = new Set();\n\nfor (const result of allResults) {\n  const key = `${result.type}-${result.id}`;\n  if (!seen.has(key)) {\n    seen.add(key);\n    uniqueResults.push(result);\n  }\n}\n\n// Apply boost factors\nconst now = new Date();\nuniqueResults.forEach(result => {\n  // Boost recent items\n  if (request.boost_recent) {\n    const ageInDays = (now - new Date(result.created_at)) / (1000 * 60 * 60 * 24);\n    if (ageInDays < 7) {\n      result.score *= 1.2;\n    } else if (ageInDays < 30) {\n      result.score *= 1.1;\n    }\n  }\n\n  // Boost title matches\n  if (result.title.toLowerCase().includes(request.query.toLowerCase())) {\n    result.score *= 1.3;\n  }\n\n  // Boost semantic over keyword for high similarity\n  if (result.search_type === 'semantic' && result.score > 0.85) {\n    result.score *= 1.1;\n  }\n});\n\n// Sort by score and limit\nconst sortedResults = uniqueResults\n  .sort((a, b) => b.score - a.score)\n  .slice(0, request.limit);\n\nreturn [{\n  json: {\n    query: request.query,\n    results: sortedResults,\n    total_found: sortedResults.length,\n    search_metadata: {\n      semantic_ideas: semanticIdeas.length,\n      semantic_documents: semanticDocs.length,\n      keyword_ideas: keywordIdeas.length,\n      keyword_documents: keywordDocs.length,\n      campaign_filter: request.campaign_id,\n      content_types: request.content_types,\n      timestamp: new Date().toISOString()\n    }\n  }\n}];"
      },
      "id": "combine_rank_results",
      "name": "Combine and Rank Results",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [1250, 350]
    },
    {
      "parameters": {
        "operation": "update",
        "table": "search_queries",
        "updateKey": "id",
        "columns": "results_count,clicked_results",
        "additionalFields": {
          "values": {
            "results_count": "{{ $json.total_found }}",\n            "clicked_results": "[]"\n          }\n        }\n      },
      "id": "update_search_log",
      "name": "Update Search Log",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 1,
      "position": [1450, 350]
    },
    {
      "parameters": {
        "values": {\n          "string": [\n            {\n              "name": "status",\n              "value": "success"\n            },\n            {\n              "name": "query",\n              "value": "{{ $json.query }}"\n            },\n            {\n              "name": "results",\n              "value": "{{ JSON.stringify($json.results) }}"\n            },\n            {\n              "name": "total_found",\n              "value": "{{ $json.total_found }}"\n            },\n            {\n              "name": "search_metadata",\n              "value": "{{ JSON.stringify($json.search_metadata) }}"\n            }\n          ]\n        },\n        "options": {}\n      },\n      "id": "success_response",\n      "name": "Success Response",\n      "type": "n8n-nodes-base.set",\n      "typeVersion": 1,\n      "position": [1650, 350]\n    },\n    {\n      "parameters": {\n        "values": {\n          "string": [\n            {\n              "name": "status",\n              "value": "error"\n            },\n            {\n              "name": "message",\n              "value": "Search failed: {{ $json.error || 'Unknown error' }}"\n            },\n            {\n              "name": "query",\n              "value": "{{ $node['Validate Search Request'].json.query || 'unknown' }}"\n            }\n          ]\n        },\n        "options": {}\n      },\n      "id": "error_response",\n      "name": "Error Response",\n      "type": "n8n-nodes-base.set",\n      "typeVersion": 1,\n      "position": [1250, 550]\n    }\n  ],\n  "connections": {\n    "webhook_trigger": {\n      "main": [[{"node": "validate_search_request", "type": "main", "index": 0}]]\n    },\n    "validate_search_request": {\n      "main": [[{"node": "generate_query_embedding", "type": "main", "index": 0}]]\n    },\n    "generate_query_embedding": {\n      "main": [[{"node": "log_search_query", "type": "main", "index": 0}]]\n    },\n    "log_search_query": {\n      "main": [[\n        {"node": "search_ideas_qdrant", "type": "main", "index": 0},\n        {"node": "search_documents_qdrant", "type": "main", "index": 0},\n        {"node": "keyword_search_ideas", "type": "main", "index": 0},\n        {"node": "keyword_search_documents", "type": "main", "index": 0}\n      ]]\n    },\n    "search_ideas_qdrant": {\n      "main": [[{"node": "combine_rank_results", "type": "main", "index": 0}]]\n    },\n    "search_documents_qdrant": {\n      "main": [[{"node": "combine_rank_results", "type": "main", "index": 1}]]\n    },\n    "keyword_search_ideas": {\n      "main": [[{"node": "combine_rank_results", "type": "main", "index": 2}]]\n    },\n    "keyword_search_documents": {\n      "main": [[{"node": "combine_rank_results", "type": "main", "index": 3}]]\n    },\n    "combine_rank_results": {\n      "main": [\n        [{"node": "update_search_log", "type": "main", "index": 0}],\n        [{"node": "error_response", "type": "main", "index": 0}]\n      ]\n    },\n    "update_search_log": {\n      "main": [[{"node": "success_response", "type": "main", "index": 0}]]\n    }\n  },\n  "active": true,\n  "settings": {\n    "executionOrder": "v1",\n    "errorWorkflow": {\n      "continueOnFail": true\n    }\n  },\n  "id": "semantic-search-workflow"\n}