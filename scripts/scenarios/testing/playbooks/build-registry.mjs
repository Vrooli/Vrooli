#!/usr/bin/env node
/**
 * @deprecated This Node.js script is deprecated. Use the Go-based test-genie CLI instead:
 *
 *   test-genie registry build
 *
 * The test-genie CLI provides cross-platform support without requiring Node.js.
 * This script will be removed in a future release.
 *
 * Migration:
 *   OLD: node scripts/scenarios/testing/playbooks/build-registry.mjs --scenario scenarios/my-scenario
 *   NEW: cd scenarios/my-scenario && test-genie registry build
 *        OR: test-genie registry build --scenario /path/to/scenario
 */
import fs from 'node:fs';
import path from 'node:path';
import { fileURLToPath } from 'node:url';

console.warn('\x1b[33m⚠️  DEPRECATION WARNING: This script is deprecated.\x1b[0m');
console.warn('\x1b[33m   Use "test-genie registry build" instead (cross-platform, no Node.js required).\x1b[0m');
console.warn('');

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

function readJSON(filePath) {
  return JSON.parse(fs.readFileSync(filePath, 'utf8'));
}

function normalizePlaybookPath(scenarioRoot, absPath) {
  const rel = path.relative(scenarioRoot, absPath);
  return rel.split(path.sep).join('/');
}

function collectRequirementValidations(requirementsDir) {
  const indexPath = path.join(requirementsDir, 'index.json');
  if (!fs.existsSync(indexPath)) {
    return new Map();
  }
  const indexData = readJSON(indexPath);
  const imports = indexData.imports || [];
  const validationsByFile = new Map();

  for (const relModule of imports) {
    const modulePath = path.join(requirementsDir, relModule);
    if (!fs.existsSync(modulePath)) continue;
    const moduleData = readJSON(modulePath);
    for (const req of moduleData.requirements || []) {
      for (const validation of req.validation || []) {
        if (typeof validation.ref !== 'string') continue;
        if (!validation.ref.startsWith('test/playbooks/')) continue;
        const key = validation.ref;
        if (!validationsByFile.has(key)) {
          validationsByFile.set(key, new Set());
        }
        validationsByFile.get(key).add(req.id);
      }
    }
  }

  return validationsByFile;
}

function extractFixtureSlug(workflowId) {
  if (typeof workflowId !== 'string' || !workflowId.startsWith('@fixture/')) {
    return null;
  }
  const match = workflowId.trim().match(/^@fixture\/([A-Za-z0-9_.-]+)/);
  return match ? match[1] : null;
}

function getFixtures(playbook) {
  const fixtures = new Set();
  const nodes = Array.isArray(playbook.nodes) ? playbook.nodes : [];
  for (const node of nodes) {
    const workflowId = node?.data?.workflowId;
    const slug = extractFixtureSlug(workflowId);
    if (slug) {
      fixtures.add(slug);
    }
  }
  return Array.from(fixtures).sort();
}

function collectPlaybooks(playbooksRoot) {
  const collected = [];

  const traverse = (dir, segments) => {
    if (!fs.existsSync(dir)) return;
    const entries = fs.readdirSync(dir, { withFileTypes: true })
      .filter((entry) => !entry.name.startsWith('__'))
      .sort((a, b) => a.name.localeCompare(b.name));

    let index = 1;
    for (const entry of entries) {
      const segment = String(index).padStart(2, '0');
      const nextSegments = [...segments, segment];
      const absPath = path.join(dir, entry.name);
      if (entry.isDirectory()) {
        traverse(absPath, nextSegments);
      } else if (entry.isFile() && path.extname(entry.name) === '.json') {
        if (segments.length === 0 && entry.name === 'registry.json') {
          continue;
        }
        collected.push({ path: absPath, order: nextSegments.join('.') });
      }
      index += 1;
    }
  };

  traverse(playbooksRoot, []);
  return collected;
}

function parseArgs() {
  const args = process.argv.slice(2);
  const config = { scenario: null };
  for (let i = 0; i < args.length; i += 1) {
    const arg = args[i];
    if (arg === '--scenario' && i + 1 < args.length) {
      config.scenario = path.resolve(args[i + 1]);
      i += 1;
    }
  }
  if (!config.scenario) {
    config.scenario = process.cwd();
  }
  return config;
}

function ensureDirExists(dir, label) {
  if (!fs.existsSync(dir)) {
    console.warn(`[playbook-registry] Skipping: ${label} not found at ${dir}`);
    process.exit(0);
  }
}

(function main() {
  const { scenario } = parseArgs();
  const scenarioRoot = scenario;
  const playbooksRoot = path.join(scenarioRoot, 'test', 'playbooks');
  const requirementsDir = path.join(scenarioRoot, 'requirements');
  const registryPath = path.join(playbooksRoot, 'registry.json');
  const fixturesDir = path.join(playbooksRoot, '__subflows');

  ensureDirExists(playbooksRoot, 'test/playbooks directory');
  ensureDirExists(requirementsDir, 'requirements directory');

  const validationsByFile = collectRequirementValidations(requirementsDir);
  const playbookFiles = collectPlaybooks(playbooksRoot);

  const registry = {
    _note: 'AUTO-GENERATED by scripts/scenarios/testing/playbooks/build-registry.mjs — run this script (or make test) to refresh. Do not edit manually.',
    scenario: path.basename(scenarioRoot),
    generated_at: new Date().toISOString(),
    playbooks: []
  };

  const allowedResetValues = new Set(['none', 'full']);

  for (const entry of playbookFiles) {
    const relPath = normalizePlaybookPath(scenarioRoot, entry.path);
    const data = readJSON(entry.path);
    const fixtures = getFixtures(data);
    const metadata = data.metadata || {};
    const requirementSet = validationsByFile.get(relPath) || new Set();
    const requirementIds = Array.from(requirementSet.values()).sort();
    const resetRequirement = typeof metadata.reset === 'string' ? metadata.reset : 'none';

    if (!allowedResetValues.has(resetRequirement)) {
      console.error(
        `[playbook-registry] Invalid metadata.reset "${resetRequirement}" in ${relPath} (allowed: none, full)`
      );
      process.exit(1);
    }

    registry.playbooks.push({
      file: relPath,
      description: metadata.description || '',
      order: entry.order,
      requirements: requirementIds,
      fixtures,
      reset: resetRequirement,
    });
  }

  fs.writeFileSync(registryPath, JSON.stringify(registry, null, 2));
  console.log(`[playbook-registry] Updated ${path.relative(scenarioRoot, registryPath)} (${registry.playbooks.length} workflows)`);
})();
