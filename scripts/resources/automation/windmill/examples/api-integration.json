{
  "name": "API Integration Example",
  "description": "Example showing how to integrate with external APIs and handle authentication, error handling, and data transformation",
  "script_config": {
    "path": "f/integrations/api_client",
    "language": "typescript",
    "required_resources": [
      "api_key",
      "base_url"
    ],
    "required_variables": [
      "retry_attempts",
      "timeout_seconds"
    ]
  },
  "script_content": "/**\n * API Integration Client\n * \n * Demonstrates best practices for external API integration including:\n * - Authentication handling\n * - Retry logic with exponential backoff\n * - Error handling and logging\n * - Data transformation\n * - Rate limiting consideration\n */\n\ninterface ApiClientConfig {\n  base_url: string;\n  api_key: string;\n  timeout?: number;\n  retry_attempts?: number;\n}\n\ninterface ApiResponse<T = any> {\n  success: boolean;\n  data?: T;\n  error?: string;\n  status_code?: number;\n  response_time_ms?: number;\n}\n\nclass ApiClient {\n  private config: ApiClientConfig;\n  \n  constructor(config: ApiClientConfig) {\n    this.config = {\n      timeout: 30000,\n      retry_attempts: 3,\n      ...config\n    };\n  }\n\n  async get<T>(endpoint: string, params?: Record<string, string>): Promise<ApiResponse<T>> {\n    const url = new URL(endpoint, this.config.base_url);\n    \n    if (params) {\n      Object.entries(params).forEach(([key, value]) => {\n        url.searchParams.append(key, value);\n      });\n    }\n\n    return this.makeRequest('GET', url.toString());\n  }\n\n  async post<T>(endpoint: string, data?: any): Promise<ApiResponse<T>> {\n    const url = new URL(endpoint, this.config.base_url).toString();\n    return this.makeRequest('POST', url, data);\n  }\n\n  async put<T>(endpoint: string, data?: any): Promise<ApiResponse<T>> {\n    const url = new URL(endpoint, this.config.base_url).toString();\n    return this.makeRequest('PUT', url, data);\n  }\n\n  async delete<T>(endpoint: string): Promise<ApiResponse<T>> {\n    const url = new URL(endpoint, this.config.base_url).toString();\n    return this.makeRequest('DELETE', url);\n  }\n\n  private async makeRequest<T>(\n    method: string, \n    url: string, \n    data?: any\n  ): Promise<ApiResponse<T>> {\n    const startTime = Date.now();\n    \n    for (let attempt = 1; attempt <= this.config.retry_attempts!; attempt++) {\n      try {\n        console.log(`API ${method} ${url} (attempt ${attempt}/${this.config.retry_attempts})`);\n        \n        const headers: Record<string, string> = {\n          'Authorization': `Bearer ${this.config.api_key}`,\n          'Content-Type': 'application/json',\n          'User-Agent': 'Windmill-API-Client/1.0'\n        };\n\n        const requestConfig: RequestInit = {\n          method,\n          headers,\n          // Add timeout using AbortController\n          signal: AbortSignal.timeout(this.config.timeout!)\n        };\n\n        if (data && (method === 'POST' || method === 'PUT')) {\n          requestConfig.body = JSON.stringify(data);\n        }\n\n        const response = await fetch(url, requestConfig);\n        const responseTime = Date.now() - startTime;\n\n        if (!response.ok) {\n          // Handle different HTTP error codes\n          const errorBody = await response.text();\n          \n          if (response.status >= 500 && attempt < this.config.retry_attempts!) {\n            // Server error - retry with exponential backoff\n            const delay = Math.pow(2, attempt - 1) * 1000; // 1s, 2s, 4s, etc.\n            console.log(`Server error ${response.status}, retrying in ${delay}ms...`);\n            await this.sleep(delay);\n            continue;\n          }\n          \n          return {\n            success: false,\n            error: `HTTP ${response.status}: ${errorBody}`,\n            status_code: response.status,\n            response_time_ms: responseTime\n          };\n        }\n\n        const responseData = await response.json();\n        \n        return {\n          success: true,\n          data: responseData,\n          status_code: response.status,\n          response_time_ms: responseTime\n        };\n\n      } catch (error) {\n        const responseTime = Date.now() - startTime;\n        \n        if (error.name === 'TimeoutError' || error.name === 'AbortError') {\n          console.log(`Request timeout after ${this.config.timeout}ms`);\n          \n          if (attempt < this.config.retry_attempts!) {\n            const delay = Math.pow(2, attempt - 1) * 1000;\n            console.log(`Retrying in ${delay}ms...`);\n            await this.sleep(delay);\n            continue;\n          }\n        }\n        \n        return {\n          success: false,\n          error: `Network error: ${error.message}`,\n          response_time_ms: responseTime\n        };\n      }\n    }\n\n    return {\n      success: false,\n      error: `Failed after ${this.config.retry_attempts} attempts`\n    };\n  }\n\n  private sleep(ms: number): Promise<void> {\n    return new Promise(resolve => setTimeout(resolve, ms));\n  }\n}\n\n// Main function that Windmill will execute\nexport async function main(\n  operation: 'get' | 'post' | 'put' | 'delete',\n  endpoint: string,\n  data?: any,\n  params?: Record<string, string>\n) {\n  // Get configuration from Windmill resources and variables\n  const config: ApiClientConfig = {\n    base_url: process.env.API_BASE_URL || 'https://api.example.com',\n    api_key: process.env.API_KEY || '',\n    timeout: parseInt(process.env.TIMEOUT_SECONDS || '30') * 1000,\n    retry_attempts: parseInt(process.env.RETRY_ATTEMPTS || '3')\n  };\n\n  // Validate configuration\n  if (!config.api_key) {\n    throw new Error('API key is required. Set API_KEY resource.');\n  }\n\n  if (!config.base_url) {\n    throw new Error('Base URL is required. Set API_BASE_URL resource.');\n  }\n\n  // Create client and make request\n  const client = new ApiClient(config);\n  \n  let result: ApiResponse;\n  \n  switch (operation) {\n    case 'get':\n      result = await client.get(endpoint, params);\n      break;\n    case 'post':\n      result = await client.post(endpoint, data);\n      break;\n    case 'put':\n      result = await client.put(endpoint, data);\n      break;\n    case 'delete':\n      result = await client.delete(endpoint);\n      break;\n    default:\n      throw new Error(`Unsupported operation: ${operation}`);\n  }\n\n  // Log result for debugging\n  console.log(`API ${operation.toUpperCase()} ${endpoint}: ${result.success ? 'SUCCESS' : 'FAILED'}`);\n  if (result.response_time_ms) {\n    console.log(`Response time: ${result.response_time_ms}ms`);\n  }\n\n  if (!result.success) {\n    console.error(`API Error: ${result.error}`);\n  }\n\n  return result;\n}\n\n// Example usage functions for common API patterns\nexport async function getUserById(userId: string) {\n  return main('get', `/users/${userId}`);\n}\n\nexport async function createUser(userData: any) {\n  return main('post', '/users', userData);\n}\n\nexport async function updateUser(userId: string, userData: any) {\n  return main('put', `/users/${userId}`, userData);\n}\n\nexport async function deleteUser(userId: string) {\n  return main('delete', `/users/${userId}`);\n}\n\nexport async function searchUsers(query: string, limit?: number) {\n  const params: Record<string, string> = { q: query };\n  if (limit) {\n    params.limit = limit.toString();\n  }\n  return main('get', '/users/search', undefined, params);\n}",
  "usage_examples": {
    "get_request": {
      "description": "Fetch user data by ID",
      "input": {
        "operation": "get",
        "endpoint": "/users/123"
      },
      "expected_output": {
        "success": true,
        "data": {
          "id": "123",
          "name": "John Doe",
          "email": "john@example.com"
        },
        "status_code": 200,
        "response_time_ms": 245
      }
    },
    "post_request": {
      "description": "Create a new user",
      "input": {
        "operation": "post",
        "endpoint": "/users",
        "data": {
          "name": "Jane Smith",
          "email": "jane@example.com",
          "role": "user"
        }
      },
      "expected_output": {
        "success": true,
        "data": {
          "id": "456",
          "name": "Jane Smith",
          "email": "jane@example.com",
          "role": "user",
          "created_at": "2025-01-26T12:00:00Z"
        },
        "status_code": 201,
        "response_time_ms": 320
      }
    },
    "search_request": {
      "description": "Search users with parameters",
      "input": {
        "operation": "get",
        "endpoint": "/users/search",
        "params": {
          "q": "john",
          "limit": "10"
        }
      },
      "expected_output": {
        "success": true,
        "data": {
          "users": [],
          "total": 5,
          "page": 1,
          "limit": 10
        },
        "status_code": 200,
        "response_time_ms": 180
      }
    }
  },
  "required_resources": {
    "api_key": {
      "type": "secret",
      "description": "API authentication key",
      "example": "sk_test_1234567890abcdef"
    },
    "base_url": {
      "type": "string", 
      "description": "Base URL for the API",
      "example": "https://api.example.com"
    }
  },
  "required_variables": {
    "retry_attempts": {
      "type": "number",
      "description": "Number of retry attempts for failed requests",
      "default": 3
    },
    "timeout_seconds": {
      "type": "number", 
      "description": "Request timeout in seconds",
      "default": 30
    }
  },
  "setup_instructions": [
    "1. Create resources in Windmill workspace:",
    "   - api_key (secret): Your API authentication key",
    "   - base_url (string): Base URL of the API you're integrating with",
    "2. Create variables (optional):",
    "   - retry_attempts (number): Number of retry attempts (default: 3)",
    "   - timeout_seconds (number): Request timeout in seconds (default: 30)",
    "3. Create new script with path 'f/integrations/api_client'",
    "4. Copy the TypeScript code into the script editor",
    "5. Test with different operations and endpoints",
    "6. Monitor execution logs for debugging and performance metrics"
  ],
  "best_practices": [
    "Always validate API credentials and configuration",
    "Implement proper error handling and retry logic", 
    "Log important events for debugging and monitoring",
    "Use exponential backoff for retry attempts",
    "Set reasonable timeouts to prevent hanging requests",
    "Handle different HTTP status codes appropriately",
    "Consider rate limiting to respect API quotas",
    "Validate and sanitize input data",
    "Use environment variables for configuration",
    "Document expected input/output formats"
  ],
  "error_handling": {
    "network_errors": "Automatic retry with exponential backoff",
    "timeout_errors": "Configurable timeout with retry logic",
    "4xx_errors": "No retry, return error immediately",
    "5xx_errors": "Retry with backoff, log server errors",
    "authentication_errors": "No retry, check credentials",
    "rate_limit_errors": "Respect rate limit headers, implement backoff"
  }
}