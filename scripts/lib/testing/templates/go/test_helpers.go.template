// Package httptest provides portable HTTP testing utilities for Go scenarios
// This is a generalized version of the testing helpers from visited-tracker
package httptest

import (
	"bytes"
	"encoding/json"
	"fmt"
	"io/ioutil"
	"log"
	"net/http"
	"net/http/httptest"
	"os"
	"strings"
	"testing"
	"time"

	"github.com/gorilla/mux"
)

// TestLogger provides controlled logging during tests
type TestLogger struct {
	originalLogger *log.Logger
	cleanup        func()
}

// SetupTestLogger initializes a controlled logger for testing
// Returns a cleanup function that should be called when test completes
func SetupTestLogger(logPrefix string) func() {
	if logPrefix == "" {
		logPrefix = "[test] "
	}
	
	// This is a generic implementation - scenarios should adapt this
	// by replacing the global logger variable with their own
	testLogger := log.New(os.Stdout, logPrefix, log.LstdFlags)
	
	// Return a cleanup function that scenarios can customize
	return func() {
		// Scenarios should restore their original logger here
		_ = testLogger // Prevent unused variable warning
	}
}

// TestEnvironment manages isolated test environment
type TestEnvironment struct {
	TempDir    string
	OriginalWD string
	Cleanup    func()
}

// SetupTestDirectory creates an isolated test environment with proper cleanup
// initFunc should be a scenario-specific initialization function
func SetupTestDirectory(t *testing.T, initFunc func() error) *TestEnvironment {
	tempDir, err := ioutil.TempDir("", "scenario-test")
	if err != nil {
		t.Fatalf("Failed to create temp dir: %v", err)
	}

	originalWD, err := os.Getwd()
	if err != nil {
		t.Fatalf("Failed to get working directory: %v", err)
	}

	if err := os.Chdir(tempDir); err != nil {
		os.RemoveAll(tempDir)
		t.Fatalf("Failed to change to temp dir: %v", err)
	}

	// Run scenario-specific initialization
	if initFunc != nil {
		if err := initFunc(); err != nil {
			os.Chdir(originalWD)
			os.RemoveAll(tempDir)
			t.Fatalf("Failed to init test environment: %v", err)
		}
	}

	return &TestEnvironment{
		TempDir:    tempDir,
		OriginalWD: originalWD,
		Cleanup: func() {
			os.Chdir(originalWD)
			os.RemoveAll(tempDir)
		},
	}
}

// HTTPTestRequest represents an HTTP test request with full configuration
type HTTPTestRequest struct {
	Method      string
	Path        string
	Body        interface{}
	URLVars     map[string]string
	QueryParams map[string]string
	Headers     map[string]string
}

// MakeHTTPRequest creates and configures an HTTP test request
func MakeHTTPRequest(req HTTPTestRequest) (*http.Request, error) {
	var bodyReader *bytes.Reader

	if req.Body != nil {
		var bodyBytes []byte
		var err error

		switch v := req.Body.(type) {
		case string:
			bodyBytes = []byte(v)
		case []byte:
			bodyBytes = v
		default:
			bodyBytes, err = json.Marshal(v)
			if err != nil {
				return nil, fmt.Errorf("failed to marshal request body: %v", err)
			}
		}
		bodyReader = bytes.NewReader(bodyBytes)
	} else {
		bodyReader = bytes.NewReader([]byte{})
	}

	httpReq := httptest.NewRequest(req.Method, req.Path, bodyReader)

	// Set headers
	if req.Headers != nil {
		for key, value := range req.Headers {
			httpReq.Header.Set(key, value)
		}
	}

	// Set default content type for POST/PUT requests with body
	if req.Body != nil && httpReq.Header.Get("Content-Type") == "" {
		httpReq.Header.Set("Content-Type", "application/json")
	}

	// Set URL variables (for mux)
	if req.URLVars != nil {
		httpReq = mux.SetURLVars(httpReq, req.URLVars)
	}

	// Set query parameters
	if req.QueryParams != nil {
		q := httpReq.URL.Query()
		for key, value := range req.QueryParams {
			q.Set(key, value)
		}
		httpReq.URL.RawQuery = q.Encode()
	}

	return httpReq, nil
}

// ExecuteRequest executes an HTTP request against a handler and returns the response
func ExecuteRequest(handler http.HandlerFunc, req HTTPTestRequest) (*httptest.ResponseRecorder, error) {
	httpReq, err := MakeHTTPRequest(req)
	if err != nil {
		return nil, err
	}

	w := httptest.NewRecorder()
	handler(w, httpReq)
	return w, nil
}

// AssertJSONResponse validates JSON response structure and content
func AssertJSONResponse(t *testing.T, w *httptest.ResponseRecorder, expectedStatus int, expectedFields map[string]interface{}) map[string]interface{} {
	if w.Code != expectedStatus {
		t.Errorf("Expected status %d, got %d. Response: %s", expectedStatus, w.Code, w.Body.String())
		return nil
	}

	var response map[string]interface{}
	if err := json.Unmarshal(w.Body.Bytes(), &response); err != nil {
		t.Fatalf("Failed to parse JSON response: %v. Response: %s", err, w.Body.String())
		return nil
	}

	// Validate expected fields
	for key, expectedValue := range expectedFields {
		actualValue, exists := response[key]
		if !exists {
			t.Errorf("Expected field '%s' not found in response", key)
			continue
		}

		if expectedValue != nil && actualValue != expectedValue {
			t.Errorf("Expected field '%s' to be %v, got %v", key, expectedValue, actualValue)
		}
	}

	return response
}

// AssertJSONArray validates that response contains an array and returns it
func AssertJSONArray(t *testing.T, w *httptest.ResponseRecorder, expectedStatus int, arrayField string) []interface{} {
	response := AssertJSONResponse(t, w, expectedStatus, nil)
	if response == nil {
		return nil
	}

	array, ok := response[arrayField].([]interface{})
	if !ok {
		t.Errorf("Expected field '%s' to be an array, got %T", arrayField, response[arrayField])
		return nil
	}

	return array
}

// AssertErrorResponse validates error responses
func AssertErrorResponse(t *testing.T, w *httptest.ResponseRecorder, expectedStatus int, expectedErrorMessage string) {
	if w.Code != expectedStatus {
		t.Errorf("Expected status %d, got %d. Response: %s", expectedStatus, w.Code, w.Body.String())
		return
	}

	var response map[string]interface{}
	if err := json.Unmarshal(w.Body.Bytes(), &response); err != nil {
		t.Fatalf("Failed to parse JSON error response: %v. Response: %s", err, w.Body.String())
		return
	}

	errorMsg, exists := response["error"]
	if !exists {
		t.Error("Expected error field in response")
		return
	}

	if expectedErrorMessage != "" && !strings.Contains(errorMsg.(string), expectedErrorMessage) {
		t.Errorf("Expected error message to contain '%s', got '%s'", expectedErrorMessage, errorMsg)
	}
}

// AssertStatusCode validates HTTP status code
func AssertStatusCode(t *testing.T, w *httptest.ResponseRecorder, expectedStatus int) {
	if w.Code != expectedStatus {
		t.Errorf("Expected status %d, got %d. Response: %s", expectedStatus, w.Code, w.Body.String())
	}
}

// AssertContentType validates the Content-Type header
func AssertContentType(t *testing.T, w *httptest.ResponseRecorder, expectedContentType string) {
	contentType := w.Header().Get("Content-Type")
	if !strings.Contains(contentType, expectedContentType) {
		t.Errorf("Expected Content-Type to contain '%s', got '%s'", expectedContentType, contentType)
	}
}

// AssertResponseTime validates that response time is within acceptable limits
func AssertResponseTime(t *testing.T, duration time.Duration, maxDuration time.Duration) {
	if duration > maxDuration {
		t.Errorf("Response time %v exceeded maximum %v", duration, maxDuration)
	}
}

// PerformanceTestConfig defines configuration for performance testing
type PerformanceTestConfig struct {
	MaxResponseTime time.Duration
	Iterations      int
	Concurrency     int
}

// DefaultPerformanceConfig returns a sensible default configuration
func DefaultPerformanceConfig() PerformanceTestConfig {
	return PerformanceTestConfig{
		MaxResponseTime: 100 * time.Millisecond,
		Iterations:      10,
		Concurrency:     1,
	}
}

// TestHandlerPerformance runs basic performance tests against a handler
func TestHandlerPerformance(t *testing.T, handler http.HandlerFunc, req HTTPTestRequest, config PerformanceTestConfig) {
	if config.Iterations == 0 {
		config = DefaultPerformanceConfig()
	}

	totalDuration := time.Duration(0)
	
	for i := 0; i < config.Iterations; i++ {
		start := time.Now()
		
		w, err := ExecuteRequest(handler, req)
		if err != nil {
			t.Fatalf("Request %d failed: %v", i+1, err)
		}
		
		duration := time.Since(start)
		totalDuration += duration
		
		if w.Code >= 400 {
			t.Errorf("Request %d returned error status %d", i+1, w.Code)
		}
		
		if duration > config.MaxResponseTime {
			t.Errorf("Request %d took %v, exceeding max %v", i+1, duration, config.MaxResponseTime)
		}
	}
	
	avgDuration := totalDuration / time.Duration(config.Iterations)
	t.Logf("Performance test completed: %d requests, avg %v", config.Iterations, avgDuration)
}

// ConcurrencyTestResult holds results from concurrent testing
type ConcurrencyTestResult struct {
	Requests    int
	Errors      int
	AvgDuration time.Duration
	MaxDuration time.Duration
	MinDuration time.Duration
}

// TestHandlerConcurrency runs concurrency tests against a handler
func TestHandlerConcurrency(t *testing.T, handler http.HandlerFunc, req HTTPTestRequest, concurrency int, iterations int) ConcurrencyTestResult {
	if concurrency <= 0 {
		concurrency = 5
	}
	if iterations <= 0 {
		iterations = 20
	}

	results := make(chan time.Duration, iterations)
	errors := make(chan error, iterations)
	
	// Start concurrent requests
	for i := 0; i < iterations; i++ {
		go func(iteration int) {
			start := time.Now()
			
			w, err := ExecuteRequest(handler, req)
			duration := time.Since(start)
			
			if err != nil {
				errors <- fmt.Errorf("request %d failed: %v", iteration, err)
				results <- 0
				return
			}
			
			if w.Code >= 400 {
				errors <- fmt.Errorf("request %d returned status %d", iteration, w.Code)
			} else {
				errors <- nil
			}
			
			results <- duration
		}(i)
	}
	
	// Collect results
	var durations []time.Duration
	errorCount := 0
	totalDuration := time.Duration(0)
	minDuration := time.Duration(1<<63 - 1) // Max duration
	maxDuration := time.Duration(0)
	
	for i := 0; i < iterations; i++ {
		duration := <-results
		err := <-errors
		
		if err != nil {
			if duration > 0 { // Only log errors for actual failures
				t.Logf("Concurrency test error: %v", err)
			}
			errorCount++
		}
		
		if duration > 0 {
			durations = append(durations, duration)
			totalDuration += duration
			
			if duration < minDuration {
				minDuration = duration
			}
			if duration > maxDuration {
				maxDuration = duration
			}
		}
	}
	
	result := ConcurrencyTestResult{
		Requests: iterations,
		Errors:   errorCount,
	}
	
	if len(durations) > 0 {
		result.AvgDuration = totalDuration / time.Duration(len(durations))
		result.MinDuration = minDuration
		result.MaxDuration = maxDuration
	}
	
	return result
}

// TestDataGenerator provides utilities for generating common test data
type TestDataGenerator struct{}

// JSONPayload creates a JSON payload for testing
func (g *TestDataGenerator) JSONPayload(data interface{}) interface{} {
	return data
}

// InvalidJSON creates malformed JSON for error testing
func (g *TestDataGenerator) InvalidJSON() string {
	return `{"invalid": "json"`
}

// EmptyJSON creates empty JSON object
func (g *TestDataGenerator) EmptyJSON() interface{} {
	return map[string]interface{}{}
}

// CommonErrorTestCases returns common error test scenarios
func (g *TestDataGenerator) CommonErrorTestCases(basePath string) []HTTPTestRequest {
	return []HTTPTestRequest{
		{
			Method: "GET",
			Path:   strings.Replace(basePath, "{id}", "invalid-uuid", 1),
			URLVars: map[string]string{"id": "invalid-uuid"},
		},
		{
			Method: "POST",
			Path:   basePath,
			Body:   g.InvalidJSON(),
			Headers: map[string]string{"Content-Type": "application/json"},
		},
		{
			Method: "GET",
			Path:   basePath,
			Headers: map[string]string{"Accept": "invalid/type"},
		},
	}
}

// Global test data generator instance
var TestData = &TestDataGenerator{}

// HandlerTestSuite provides a framework for comprehensive handler testing
type HandlerTestSuite struct {
	Name        string
	Handler     http.HandlerFunc
	BaseURL     string
	TestData    interface{}
	SetupFunc   func(t *testing.T) interface{}
	CleanupFunc func(testData interface{})
}

// RunComprehensiveTests executes a full test suite for a handler
func (suite *HandlerTestSuite) RunComprehensiveTests(t *testing.T) {
	t.Run(fmt.Sprintf("%s_Comprehensive", suite.Name), func(t *testing.T) {
		// Setup
		var testData interface{}
		if suite.SetupFunc != nil {
			testData = suite.SetupFunc(t)
		}
		
		// Cleanup
		if suite.CleanupFunc != nil {
			defer suite.CleanupFunc(testData)
		}
		
		// Run test categories
		t.Run("SuccessCases", func(t *testing.T) {
			// Scenarios should implement success cases
			t.Log("Success cases should be implemented by scenarios")
		})
		
		t.Run("ErrorCases", func(t *testing.T) {
			errorCases := TestData.CommonErrorTestCases(suite.BaseURL)
			for i, testCase := range errorCases {
				t.Run(fmt.Sprintf("Error_%d", i), func(t *testing.T) {
					w, err := ExecuteRequest(suite.Handler, testCase)
					if err != nil {
						t.Fatalf("Failed to execute request: %v", err)
					}
					
					// Expect 4xx or 5xx status codes for error cases
					if w.Code < 400 {
						t.Errorf("Expected error status (4xx/5xx), got %d", w.Code)
					}
				})
			}
		})
		
		t.Run("Performance", func(t *testing.T) {
			// Basic performance test with minimal request
			req := HTTPTestRequest{
				Method: "GET",
				Path:   suite.BaseURL,
			}
			
			config := DefaultPerformanceConfig()
			TestHandlerPerformance(t, suite.Handler, req, config)
		})
	})
}