{
  "name": "Batch QR Processor",
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "batch-qr",
        "responseMode": "responseNode",
        "options": {}
      },
      "id": "webhook_trigger",
      "name": "Webhook Trigger",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 1.1,
      "position": [200, 300]
    },
    {
      "parameters": {},
      "id": "manual_trigger",
      "name": "Manual Trigger",
      "type": "n8n-nodes-base.manualTrigger",
      "typeVersion": 1,
      "position": [200, 500]
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// Provide test defaults for manual trigger\nreturn {\n  items: [\n    { text: 'https://vrooli.com', label: 'Vrooli Homepage' },\n    { text: 'https://github.com/Vrooli/Vrooli', label: 'GitHub Repo' },\n    { text: 'Contact: team@vrooli.com', label: 'Contact Email' },\n    { text: 'tel:+1-555-VROOLI', label: 'Support Phone' },\n    { text: 'Join the revolution of recursive intelligence!', label: 'Tagline' }\n  ],\n  options: {\n    size: 256,\n    color: '#00ff00',\n    background: '#000000',\n    errorCorrection: 'M',\n    format: 'png',\n    style: 'dots'\n  },\n  export_format: 'zip' // zip, json, or individual\n};"
      },
      "id": "set_test_batch",
      "name": "Set Test Batch",
      "type": "n8n-nodes-base.code",
      "typeVersion": 1,
      "position": [400, 500]
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// Validate batch input\nconst input = $input.item.json;\n\nif (!input.items || !Array.isArray(input.items) || input.items.length === 0) {\n  throw new Error('Missing or invalid items array');\n}\n\nif (input.items.length > 100) {\n  throw new Error('Batch too large (max 100 items)');\n}\n\n// Validate each item and add metadata\nconst validatedItems = input.items.map((item, index) => {\n  if (!item.text || typeof item.text !== 'string') {\n    throw new Error(`Invalid text at index ${index}`);\n  }\n  \n  // Auto-detect content type\n  const text = item.text.trim();\n  let contentType = 'text';\n  if (text.startsWith('http://') || text.startsWith('https://')) {\n    contentType = 'url';\n  } else if (text.includes('@') && text.includes('.')) {\n    contentType = 'email';\n  } else if (text.startsWith('tel:') || /^[+\\d\\s()-]+$/.test(text)) {\n    contentType = 'phone';\n  } else if (text.startsWith('WIFI:')) {\n    contentType = 'wifi';\n  } else if (text.startsWith('geo:')) {\n    contentType = 'location';\n  }\n  \n  return {\n    text: text,\n    label: item.label || `QR_${index + 1}`,\n    index: index,\n    contentType: contentType,\n    customOptions: item.customOptions || {}\n  };\n});\n\n// Get batch options with defaults\nconst options = input.options || {};\nconst batchId = 'batch_' + Date.now() + '_' + Math.random().toString(36).substring(2, 8);\n\n// Prepare batch metadata\nconst batchMetadata = {\n  batch_id: batchId,\n  items: validatedItems,\n  options: {\n    size: Math.min(1024, Math.max(64, parseInt(options.size) || 256)),\n    color: options.color || '#000000',\n    background: options.background || '#FFFFFF',\n    errorCorrection: ['L', 'M', 'Q', 'H'].includes(options.errorCorrection) ? options.errorCorrection : 'M',\n    format: ['png', 'svg', 'base64', 'ascii'].includes(options.format) ? options.format : 'png',\n    margin: Math.min(10, Math.max(0, parseInt(options.margin) || 1)),\n    style: options.style || 'square'\n  },\n  export_format: ['zip', 'json', 'individual'].includes(input.export_format) ? input.export_format : 'json',\n  total_count: validatedItems.length,\n  content_types: {\n    url: validatedItems.filter(i => i.contentType === 'url').length,\n    email: validatedItems.filter(i => i.contentType === 'email').length,\n    phone: validatedItems.filter(i => i.contentType === 'phone').length,\n    text: validatedItems.filter(i => i.contentType === 'text').length,\n    other: validatedItems.filter(i => !['url', 'email', 'phone', 'text'].includes(i.contentType)).length\n  },\n  started_at: new Date().toISOString()\n};\n\nreturn batchMetadata;"
      },
      "id": "validate_batch",
      "name": "Validate Batch",
      "type": "n8n-nodes-base.code",
      "typeVersion": 1,
      "position": [600, 400]
    },
    {
      "parameters": {
        "fieldToSplitOut": "items",
        "options": {}
      },
      "id": "split_items",
      "name": "Split Items",
      "type": "n8n-nodes-base.itemLists",
      "typeVersion": 1,
      "position": [800, 400]
    },
    {
      "parameters": {
        "workflowId": "qr-generator-workflow",
        "workflowParameters": {
          "text": "={{ $json.text }}",
          "size": "={{ $node['Validate Batch'].json.options.size }}",
          "color": "={{ $json.customOptions.color || $node['Validate Batch'].json.options.color }}",
          "background": "={{ $json.customOptions.background || $node['Validate Batch'].json.options.background }}",
          "errorCorrection": "={{ $json.customOptions.errorCorrection || $node['Validate Batch'].json.options.errorCorrection }}",
          "format": "={{ $node['Validate Batch'].json.options.format }}",
          "margin": "={{ $node['Validate Batch'].json.options.margin }}",
          "style": "={{ $json.customOptions.style || $node['Validate Batch'].json.options.style }}"
        },
        "options": {
          "waitForSubWorkflow": true
        }
      },
      "id": "generate_each_qr",
      "name": "Generate Each QR",
      "type": "n8n-nodes-base.executeWorkflow",
      "typeVersion": 1,
      "position": [1000, 400]
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// Add label, index and content type to each generated QR\nconst qrResult = $input.item.json;\nconst originalItem = $node['Split Items'].json;\n\n// Handle both success and error cases\nif (qrResult.success) {\n  return {\n    ...qrResult,\n    label: originalItem.label,\n    index: originalItem.index,\n    contentType: originalItem.contentType\n  };\n} else {\n  // Handle failed generation\n  return {\n    success: false,\n    label: originalItem.label,\n    index: originalItem.index,\n    contentType: originalItem.contentType,\n    text: originalItem.text,\n    error: qrResult.error || 'Generation failed',\n    qr_id: null\n  };\n}"
      },
      "id": "add_metadata",
      "name": "Add Metadata",
      "type": "n8n-nodes-base.code",
      "typeVersion": 1,
      "position": [1200, 400]
    },
    {
      "parameters": {
        "aggregate": "aggregateIndividualFields",
        "options": {}
      },
      "id": "aggregate_results",
      "name": "Aggregate Results",
      "type": "n8n-nodes-base.aggregate",
      "typeVersion": 1,
      "position": [1400, 400]
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// Prepare batch response with statistics\nconst batchInfo = $node['Validate Batch'].json;\nconst results = $input.item.json;\n\n// Ensure results is an array\nconst resultsArray = Array.isArray(results) ? results : [results];\n\n// Count successful and failed\nconst successful = resultsArray.filter(r => r.success === true);\nconst failed = resultsArray.filter(r => r.success !== true);\n\n// Calculate processing time\nconst processingTime = Date.now() - new Date(batchInfo.started_at).getTime();\n\n// Group by content type\nconst byType = {};\n['url', 'email', 'phone', 'text', 'wifi', 'location'].forEach(type => {\n  const items = successful.filter(r => r.contentType === type);\n  if (items.length > 0) {\n    byType[type] = items.length;\n  }\n});\n\n// Prepare downloadable formats based on export_format\nlet exportData = null;\nif (batchInfo.export_format === 'json') {\n  exportData = {\n    format: 'json',\n    data: successful.map(r => ({\n      label: r.label,\n      text: r.parameters?.text || '',\n      qr_id: r.qr_id,\n      download_url: r.download_url,\n      base64: r.base64\n    }))\n  };\n} else if (batchInfo.export_format === 'individual') {\n  exportData = {\n    format: 'individual',\n    files: successful.map(r => ({\n      filename: `${r.label.replace(/[^a-z0-9]/gi, '_')}.${batchInfo.options.format}`,\n      qr_id: r.qr_id,\n      download_url: r.download_url\n    }))\n  };\n} else if (batchInfo.export_format === 'zip') {\n  // For ZIP format, we'd need additional processing\n  exportData = {\n    format: 'zip',\n    message: 'ZIP export requires additional processing',\n    items: successful.length\n  };\n}\n\nreturn {\n  success: true,\n  batch_id: batchInfo.batch_id,\n  summary: {\n    total: batchInfo.total_count,\n    successful: successful.length,\n    failed: failed.length,\n    success_rate: Math.round((successful.length / batchInfo.total_count) * 100) + '%'\n  },\n  statistics: {\n    processing_time_ms: processingTime,\n    avg_time_per_qr: Math.round(processingTime / batchInfo.total_count),\n    by_content_type: byType\n  },\n  results: resultsArray.sort((a, b) => a.index - b.index),\n  export: exportData,\n  failed_items: failed.length > 0 ? failed.map(f => ({\n    label: f.label,\n    text: f.text,\n    error: f.error\n  })) : [],\n  options_used: batchInfo.options,\n  timestamps: {\n    started_at: batchInfo.started_at,\n    completed_at: new Date().toISOString()\n  },\n  message: failed.length === 0 \n    ? `All ${batchInfo.total_count} QR codes generated successfully!`\n    : `Batch processing completed: ${successful.length}/${batchInfo.total_count} QR codes generated successfully`\n};"
      },
      "id": "prepare_batch_response",
      "name": "Prepare Batch Response",
      "type": "n8n-nodes-base.code",
      "typeVersion": 1,
      "position": [1600, 400]
    },
    {
      "parameters": {
        "options": {}
      },
      "id": "respond_batch",
      "name": "Respond to Webhook",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1,
      "position": [1800, 300]
    }
  ],
  "connections": {
    "Webhook Trigger": {
      "main": [
        [
          {
            "node": "Validate Batch",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Manual Trigger": {
      "main": [
        [
          {
            "node": "Set Test Batch",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Set Test Batch": {
      "main": [
        [
          {
            "node": "Validate Batch",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Validate Batch": {
      "main": [
        [
          {
            "node": "Split Items",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Split Items": {
      "main": [
        [
          {
            "node": "Generate Each QR",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Generate Each QR": {
      "main": [
        [
          {
            "node": "Add Metadata",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Add Metadata": {
      "main": [
        [
          {
            "node": "Aggregate Results",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Aggregate Results": {
      "main": [
        [
          {
            "node": "Prepare Batch Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Batch Response": {
      "main": [
        [
          {
            "node": "Respond to Webhook",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": true,
  "settings": {
    "executionOrder": "v1"
  },
  "versionId": "1.0.0",
  "meta": {
    "templateCredsSetupCompleted": true,
    "instanceId": "qr-batch-processor"
  },
  "tags": ["batch-processing", "qr-code"]
}