import { app, BrowserWindow, net, shell, Menu, ipcMain, dialog, Tray, nativeImage, clipboard } from "electron";
import { type ChildProcess, fork, spawn } from "node:child_process";
import { promises as fs } from "node:fs";
import path from "node:path";
import process from "node:process";
import { autoUpdater } from "electron-updater";

// ===== TEMPLATE CONFIGURATION - GENERATED BY SCENARIO-TO-DESKTOP =====
// This configuration is automatically populated during generation
const APP_CONFIG = {
    // Application identity
    APP_NAME: "{{APP_NAME}}",
    APP_DISPLAY_NAME: "{{APP_DISPLAY_NAME}}",
    APP_VERSION: "{{VERSION}}",
    APP_URL: "{{APP_URL}}",
    
    // Server configuration
    SERVER_TYPE: "{{SERVER_TYPE}}", // Options: 'node', 'static', 'external', 'executable'
    SERVER_PORT: {{SERVER_PORT}},
    SERVER_PATH: "{{SERVER_PATH}}", // Path to server entry point (relative to app root)
    API_ENDPOINT: "{{API_ENDPOINT}}", // Scenario API endpoint
    DEPLOYMENT_MODE: "{{DEPLOYMENT_MODE}}", // external-server | cloud-api | bundled
    
    // Window configuration  
    WINDOW_WIDTH: {{WINDOW_WIDTH}},
    WINDOW_HEIGHT: {{WINDOW_HEIGHT}},
    WINDOW_BACKGROUND: "{{WINDOW_BACKGROUND}}",
    WINDOW_TITLE: "{{APP_DISPLAY_NAME}}",
    
    // Feature configuration
    ENABLE_SPLASH: {{ENABLE_SPLASH}},
    ENABLE_MENU: {{ENABLE_MENU}},
    ENABLE_SYSTEM_TRAY: {{ENABLE_SYSTEM_TRAY}},
    ENABLE_AUTO_UPDATER: {{ENABLE_AUTO_UPDATER}},
    ENABLE_SINGLE_INSTANCE: {{ENABLE_SINGLE_INSTANCE}},
    ENABLE_DEV_TOOLS: {{ENABLE_DEV_TOOLS}},
    
    // Timing configuration
    SERVER_CHECK_INTERVAL_MS: 500,
    SERVER_CHECK_TIMEOUT_MS: 30000,
};

const LOCAL_VROOLI_BOOTSTRAP = {
    ENABLE: {{AUTO_MANAGE_VROOLI}},
    SCENARIO_NAME: "{{SCENARIO_NAME}}",
    VROOLI_BINARY: "{{VROOLI_BINARY_PATH}}",
};
const BUNDLED_RUNTIME = {
	SUPPORTED: {{BUNDLED_RUNTIME_SUPPORTED}},
	ROOT: "{{BUNDLED_RUNTIME_ROOT}}",
	IPC_HOST: "{{BUNDLED_RUNTIME_IPC_HOST}}",
	IPC_PORT: {{BUNDLED_RUNTIME_IPC_PORT}},
	TOKEN_REL: "{{BUNDLED_RUNTIME_TOKEN_PATH}}",
	UI_SERVICE: "{{BUNDLED_RUNTIME_UI_SERVICE}}",
	UI_PORT_NAME: "{{BUNDLED_RUNTIME_UI_PORT_NAME}}",
	TELEMETRY_UPLOAD_URL: "{{BUNDLED_RUNTIME_TELEMETRY_UPLOAD_URL}}",
	DOCS_URL: "docs/deployment/tiers/tier-2-desktop.md",
};

// Update/auto-updater configuration
const UPDATE_CONFIG = {
    // Update channel: dev, beta, or stable
    CHANNEL: "{{UPDATE_CHANNEL}}" as "dev" | "beta" | "stable",
    // Provider: github, generic, or none
    PROVIDER: "{{UPDATE_PROVIDER}}" as "github" | "generic" | "none",
    // Whether to automatically check for updates on startup
    AUTO_CHECK: {{UPDATE_AUTO_CHECK}},
    // Update server URL (for display/logging purposes)
    SERVER_URL: "{{UPDATE_SERVER_URL}}",
};

let serverProcess: ChildProcess | null = null;
let runtimeProcess: ChildProcess | null = null;
let mainWindow: BrowserWindow | null = null;
let splashWindow: BrowserWindow | null = null;
let tray: Tray | null = null;

const SERVER_URL = APP_CONFIG.SERVER_TYPE === 'external' 
    ? APP_CONFIG.SERVER_PATH 
    : `http://localhost:${APP_CONFIG.SERVER_PORT}`;

type TelemetryDetails = Record<string, unknown>;
interface LocalVrooliBootstrapState {
    vrooliPath?: string;
    setupCompleted?: boolean;
}
interface CommandResult {
    success: boolean;
    stdout: string;
    stderr: string;
    code: number;
}

let telemetryFilePath: string | null = null;
let bootstrapStateCache: LocalVrooliBootstrapState | null = null;
let bootstrapStatePath: string | null = null;
let telemetryStateLoaded = false;
let lastTelemetrySignature: string | null = null;
let runtimeAppDataRoot: string | null = null;
const localVrooliRuntime = {
    startedByApp: false,
    vrooliBinary: "",
};
const shouldBootstrapLocalVrooli = APP_CONFIG.DEPLOYMENT_MODE === "external-server"
    && LOCAL_VROOLI_BOOTSTRAP.ENABLE
    && Boolean(LOCAL_VROOLI_BOOTSTRAP.SCENARIO_NAME);
const isBundledMode = APP_CONFIG.DEPLOYMENT_MODE === "bundled";

const runtimeControlEnabled = (isBundledMode && BUNDLED_RUNTIME.SUPPORTED) || Boolean(
	process.env.RUNTIME_CONTROL_HOST ||
	process.env.RUNTIME_CONTROL_PORT ||
	process.env.RUNTIME_CONTROL_TOKEN_PATH ||
	process.env.RUNTIME_TELEMETRY_UPLOAD_URL
);

const RUNTIME_CONTROL = {
	ENABLED: runtimeControlEnabled,
	HOST: process.env.RUNTIME_CONTROL_HOST || BUNDLED_RUNTIME.IPC_HOST || "127.0.0.1",
	PORT: Number(process.env.RUNTIME_CONTROL_PORT || BUNDLED_RUNTIME.IPC_PORT || 47710),
	TOKEN_PATH_ENV: process.env.RUNTIME_CONTROL_TOKEN_PATH || "",
	TELEMETRY_UPLOAD_URL: process.env.RUNTIME_TELEMETRY_UPLOAD_URL || BUNDLED_RUNTIME.TELEMETRY_UPLOAD_URL || "",
	LOG_LINES: Number(process.env.RUNTIME_CONTROL_LOG_LINES || 200),
};

type RuntimeSecret = {
    id: string;
    class: string;
    required: boolean;
    has_value: boolean;
    description?: string;
    prompt?: Record<string, string>;
};

type RuntimeSecretsResponse = {
    secrets: RuntimeSecret[];
};

type RuntimeGPUInfo = {
    available: boolean;
    method?: string;
    reason?: string;
    requirements?: Record<string, string>;
};

type RuntimeReadyResponse = {
    ready: boolean;
    details?: Record<string, { ready: boolean; message?: string; reason?: string }>;
    gpu?: RuntimeGPUInfo;
};

type RuntimePortsResponse = {
    services?: Record<string, Record<string, number>>;
    apiBase?: string;
};

type RuntimeTelemetryResponse = {
    path?: string;
    upload_url?: string;
};

type RuntimeDiagnostics = {
    ready: RuntimeReadyResponse;
    ports: RuntimePortsResponse;
    logs: Record<string, string>;
    gpu?: RuntimeGPUInfo;
    telemetryPath?: string;
    telemetryUploadUrl?: string;
};

type RuntimeRequestOptions = {
    expectText?: boolean;
    method?: string;
    body?: unknown;
};

// Bundle manifest types for pre-flight validation
type BundleManifest = {
    schema_version: string;
    target: string;
    app: { name: string; version: string };
    ipc: { host: string; port: number };
    services: BundleService[];
};

type BundleService = {
    id: string;
    binaries: Record<string, { path: string }>;
    assets?: { path: string; sha256?: string }[];
    health: { type: string };
    readiness: { type: string };
};

type BundleValidationResult = {
    valid: boolean;
    errors: string[];
    warnings: string[];
    missingBinaries: { serviceId: string; platform: string; path: string }[];
    missingAssets: { serviceId: string; path: string }[];
};

type RuntimeValidationResponse = {
    valid: boolean;
    errors?: Array<{ code: string; service?: string; path?: string; message: string }>;
    warnings?: Array<{ code: string; service?: string; path?: string; message: string }>;
    missing_binaries?: Array<{ service_id: string; platform: string; path: string }>;
    missing_assets?: Array<{ service_id: string; path: string }>;
    invalid_checksums?: Array<{ service_id: string; path: string; expected: string; actual: string }>;
};

function getRuntimeAppDataRoot(): string {
    if (runtimeAppDataRoot) return runtimeAppDataRoot;
    runtimeAppDataRoot = path.join(app.getPath("userData"), "runtime");
    return runtimeAppDataRoot;
}

async function initializeTelemetry() {
    try {
        const userData = app.getPath("userData");
        telemetryFilePath = path.join(userData, "deployment-telemetry.jsonl");
        await fs.appendFile(telemetryFilePath, "");
        console.log(`[Desktop App] Telemetry initialized at ${telemetryFilePath}`);
    } catch (error) {
        telemetryFilePath = null;
        console.warn("[Desktop App] Failed to initialize telemetry:", error);
    }
}

async function recordTelemetry(event: string, details: TelemetryDetails = {}): Promise<void> {
    if (!telemetryFilePath) return;
    const payload = {
        timestamp: new Date().toISOString(),
        event,
        deploymentMode: APP_CONFIG.DEPLOYMENT_MODE,
        serverType: APP_CONFIG.SERVER_TYPE,
        details,
    };

    try {
        await fs.appendFile(telemetryFilePath, JSON.stringify(payload) + "\n");
    } catch (error) {
        console.warn("[Desktop App] Failed to write telemetry entry:", error);
    }
}

async function loadTelemetryState(): Promise<void> {
    if (telemetryStateLoaded) return;
    try {
        const statePath = path.join(getRuntimeAppDataRoot(), "telemetry-upload.json");
        const raw = await fs.readFile(statePath, "utf-8");
        const parsed = JSON.parse(raw) as { lastSignature?: string };
        lastTelemetrySignature = parsed.lastSignature || null;
    } catch {
        // best-effort; missing state is fine
    } finally {
        telemetryStateLoaded = true;
    }
}

async function readTelemetryEvents(filePath: string, limit = 500): Promise<Array<Record<string, unknown>>> {
    const raw = await fs.readFile(filePath, "utf-8");
    const lines = raw
        .split(/\r?\n/)
        .map((line) => line.trim())
        .filter(Boolean)
        .slice(0, limit);

    const events: Array<Record<string, unknown>> = [];
    lines.forEach((line, index) => {
        try {
            const parsed = JSON.parse(line);
            if (parsed && typeof parsed === "object") {
                events.push(parsed as Record<string, unknown>);
            }
        } catch (error) {
            throw new Error(`Telemetry line ${index + 1} is invalid JSON: ${error}`);
        }
    });
    return events;
}

async function uploadTelemetryFile(filePath: string, uploadURL: string, reason: string, force = false): Promise<void> {
    await loadTelemetryState();
    const stats = await fs.stat(filePath);
    if (stats.size === 0) {
        throw new Error("Telemetry file is empty");
    }
    const signature = `${filePath}:${stats.mtimeMs}:${stats.size}:${uploadURL}`;
    if (!force && signature === lastTelemetrySignature) {
        console.log("[Desktop App] Telemetry already uploaded for this file signature");
        return;
    }

    const events = await readTelemetryEvents(filePath);
    if (events.length === 0) {
        throw new Error("No telemetry events found to upload");
    }

    const payload = {
        scenario_name: APP_CONFIG.SCENARIO_NAME || APP_CONFIG.APP_NAME,
        deployment_mode: APP_CONFIG.DEPLOYMENT_MODE,
        source: "desktop-runtime",
        events,
    };

    const res = await fetch(uploadURL, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(payload),
    });
    if (!res.ok) {
        const text = await res.text().catch(() => "");
        throw new Error(text || `Telemetry upload failed (${res.status})`);
    }

    lastTelemetrySignature = signature;
    try {
        const statePath = path.join(getRuntimeAppDataRoot(), "telemetry-upload.json");
        await fs.mkdir(path.dirname(statePath), { recursive: true });
        await fs.writeFile(statePath, JSON.stringify({ lastSignature: signature, reason }, null, 2));
    } catch {
        // best-effort persistence
    }
    await recordTelemetry("runtime_telemetry_uploaded", { uploadURL, events: events.length, reason });
}

async function autoUploadTelemetryIfConfigured(reason: string): Promise<boolean> {
    if (!RUNTIME_CONTROL.ENABLED) return false;
    let telemetryInfo: RuntimeTelemetryResponse | null = null;
    try {
        telemetryInfo = await runtimeRequest<RuntimeTelemetryResponse>("/telemetry");
    } catch (error) {
        console.warn("[Desktop App] Runtime telemetry endpoint unavailable:", error);
        return false;
    }

    const uploadURL = RUNTIME_CONTROL.TELEMETRY_UPLOAD_URL || telemetryInfo?.upload_url || "";
    const filePath = telemetryInfo?.path;
    if (!uploadURL || !filePath) {
        return false;
    }

    try {
        await uploadTelemetryFile(filePath, uploadURL, reason);
        return true;
    } catch (error) {
        console.warn("[Desktop App] Telemetry upload skipped:", error);
        return false;
    }
}

async function resolveRuntimeTokenPath(): Promise<string | null> {
	if (!RUNTIME_CONTROL.ENABLED) return null;
	if (RUNTIME_CONTROL.TOKEN_PATH_ENV) {
		return RUNTIME_CONTROL.TOKEN_PATH_ENV;
	}
	if (!app.isReady()) {
		await app.whenReady();
	}
	const rel = BUNDLED_RUNTIME.TOKEN_REL || "runtime/auth-token";
	return path.join(app.getPath("userData"), rel);
}

async function runtimeRequest<T = unknown>(endpoint: string, opts?: RuntimeRequestOptions): Promise<T | string> {
    if (!RUNTIME_CONTROL.ENABLED) {
        throw new Error("runtime control not enabled");
    }
    const tokenPath = await resolveRuntimeTokenPath();
    let token = "";
    if (tokenPath) {
        try {
            token = (await fs.readFile(tokenPath, "utf-8")).trim();
        } catch {
            // best-effort: runtime may still be starting
        }
    }

    const url = `http://${RUNTIME_CONTROL.HOST}:${RUNTIME_CONTROL.PORT}${endpoint}`;
    const headers: Record<string, string> = {};
    if (token && endpoint !== "/healthz") {
        headers.Authorization = `Bearer ${token}`;
    }

    const requestInit: RequestInit = {
        method: opts?.method || "GET",
        headers,
    };
    if (opts?.body !== undefined) {
        headers["Content-Type"] = "application/json";
        requestInit.body = JSON.stringify(opts.body);
    }

    const res = await fetch(url, requestInit);
    if (!res.ok) {
        const text = await res.text();
        throw new Error(`runtime request failed (${res.status}): ${text || res.statusText}`);
    }
    if (opts?.expectText) {
        return res.text();
    }
    return res.json();
}

async function waitForRuntimeControl(timeoutMs: number): Promise<void> {
    if (!RUNTIME_CONTROL.ENABLED) return;
    const url = `http://${RUNTIME_CONTROL.HOST}:${RUNTIME_CONTROL.PORT}/healthz`;
    const deadline = Date.now() + timeoutMs;
    while (Date.now() < deadline) {
        try {
            const res = await fetch(url);
            if (res.ok) {
                return;
            }
        } catch {
            // keep retrying
        }
        await new Promise((resolve) => setTimeout(resolve, 200));
    }
    throw new Error("Runtime control API did not respond before timeout");
}

async function collectRuntimeDiagnostics(): Promise<RuntimeDiagnostics> {
    const [ready, ports, telemetryInfo] = await Promise.all([
        runtimeRequest<RuntimeReadyResponse>("/readyz"),
        runtimeRequest<RuntimePortsResponse>("/ports"),
        runtimeRequest<RuntimeTelemetryResponse>("/telemetry"),
    ]);

    const logs: Record<string, string> = {};
    const services = new Set<string>();
    Object.keys(ready.details || {}).forEach((svc) => services.add(svc));
    Object.keys(ports.services || {}).forEach((svc) => services.add(svc));

    for (const serviceId of services) {
        try {
            const logData = await runtimeRequest<string>(`/logs/tail?serviceId=${encodeURIComponent(serviceId)}&lines=${RUNTIME_CONTROL.LOG_LINES}`, { expectText: true });
            if (typeof logData === "string") {
                logs[serviceId] = logData;
            }
        } catch (error) {
            logs[serviceId] = `Failed to load logs: ${error}`;
        }
    }

    return {
        ready,
        ports,
        logs,
        gpu: ready.gpu,
        telemetryPath: telemetryInfo?.path,
        telemetryUploadUrl: telemetryInfo?.upload_url,
    };
}

async function showRuntimeDiagnostics(): Promise<void> {
    if (!RUNTIME_CONTROL.ENABLED) {
        await dialog.showMessageBox({
            type: "info",
            title: "Runtime diagnostics unavailable",
            message: "Runtime control is disabled for this build.",
        });
        return;
    }

    try {
        const diagnostics = await collectRuntimeDiagnostics();
        const messageLines = [
            `Ready: ${diagnostics.ready.ready ? "yes" : "no"}`,
            `Services: ${Object.keys(diagnostics.ports.services || diagnostics.ready.details || {}).length}`,
        ];
        const detailLines: string[] = [];

        const gpuInfo = diagnostics.gpu || diagnostics.ready.gpu;
        if (gpuInfo) {
            const availability = gpuInfo.available ? "available" : "not available";
            const method = gpuInfo.method ? ` via ${gpuInfo.method}` : "";
            const reason = gpuInfo.reason ? ` (${gpuInfo.reason})` : "";
            detailLines.push(`GPU: ${availability}${method}${reason}`);
            const reqEntries = Object.entries(gpuInfo.requirements || {});
            if (reqEntries.length > 0) {
                detailLines.push("GPU requirements:");
                for (const [svc, req] of reqEntries) {
                    const status = gpuInfo.available || req !== "required" ? "ok" : "blocked";
                    detailLines.push(`- ${svc}: ${req} [${status}]`);
                }
            }
        }

        const readyDetails = diagnostics.ready.details || {};
        if (Object.keys(readyDetails).length > 0) {
            detailLines.push("Readiness:");
            for (const [svc, info] of Object.entries(readyDetails)) {
                detailLines.push(`- ${svc}: ${info.ready ? "ready" : "not ready"}${info.message ? ` (${info.message})` : info.reason ? ` (${info.reason})` : ""}`);
            }
        }

        if (diagnostics.ports.services) {
            detailLines.push("Ports:");
            for (const [svc, svcPorts] of Object.entries(diagnostics.ports.services)) {
                const portList = Object.entries(svcPorts as Record<string, number>).map(([name, value]) => `${name}=${value}`).join(", ");
                detailLines.push(`- ${svc}: ${portList}`);
            }
        }

        const logEntries = Object.entries(diagnostics.logs);
        if (logEntries.length > 0) {
            detailLines.push("Log tail:");
            for (const [svc, content] of logEntries) {
                detailLines.push(`--- ${svc} ---`);
                detailLines.push(content || "<no logs>");
            }
        }

        const buttons: string[] = ["Close"];
        const uploadURL = RUNTIME_CONTROL.TELEMETRY_UPLOAD_URL || diagnostics.telemetryUploadUrl || "";
        if (diagnostics.telemetryPath) {
            buttons.unshift("Copy telemetry path");
        }
        if (uploadURL && diagnostics.telemetryPath) {
            buttons.unshift("Upload telemetry");
        }

        const result = await dialog.showMessageBox({
            type: diagnostics.ready.ready ? "info" : "warning",
            title: "Bundled runtime diagnostics",
            message: messageLines.join("\n"),
            detail: detailLines.join("\n"),
            buttons,
            defaultId: buttons.length - 1,
        });

        const picked = buttons[result.response];
        if (picked === "Copy telemetry path" && diagnostics.telemetryPath) {
            clipboard.writeText(diagnostics.telemetryPath);
            void recordTelemetry("runtime_diag_copy_path", { path: diagnostics.telemetryPath });
        } else if (picked === "Upload telemetry" && diagnostics.telemetryPath && uploadURL) {
            try {
                await uploadTelemetryFile(diagnostics.telemetryPath, uploadURL, "manual", true);
                void recordTelemetry("runtime_diag_upload_success", { uploadURL });
                await dialog.showMessageBox({
                    type: "info",
                    title: "Telemetry uploaded",
                    message: "Runtime telemetry uploaded successfully.",
                });
            } catch (error) {
                void recordTelemetry("runtime_diag_upload_failed", { error: String(error) });
                await dialog.showMessageBox({
                    type: "error",
                    title: "Telemetry upload failed",
                    message: String(error),
                });
            }
        }
    } catch (error) {
        await dialog.showMessageBox({
            type: "error",
            title: "Runtime diagnostics",
            message: `Failed to query runtime: ${error}`,
        });
    }
}

function escapeHTML(input: string): string {
    return input.replace(/[&<>"']/g, (char) => {
        switch (char) {
            case "&":
                return "&amp;";
            case "<":
                return "&lt;";
            case ">":
                return "&gt;";
            case '"':
                return "&quot;";
            case "'":
                return "&#39;";
            default:
                return char;
        }
    });
}

async function promptForSecretValue(secret: RuntimeSecret): Promise<string | null> {
    const channel = `secret-submit-${Date.now()}-${Math.random().toString(16).slice(2)}`;
    const parent = mainWindow ?? undefined;
    const modal = new BrowserWindow({
        parent,
        modal: true,
        width: 460,
        height: 320,
        resizable: false,
        minimizable: false,
        maximizable: false,
        title: `Configure ${APP_CONFIG.APP_DISPLAY_NAME}`,
        webPreferences: {
            nodeIntegration: true,
            contextIsolation: false,
        },
        show: false,
    });

    const label = escapeHTML(secret.prompt?.label || secret.id);
    const description = escapeHTML(secret.prompt?.description || secret.description || "Enter a value for this secret.");
    const body = `
<!doctype html>
<html>
<body style="font-family: sans-serif; padding: 16px; background: #0f172a; color: #e2e8f0;">
  <h2 style="margin-top: 0;">${label}</h2>
  <p style="margin-bottom: 12px;">${description}</p>
  <form id="secret-form" style="display: flex; flex-direction: column; gap: 12px;">
    <input id="secret-value" type="password" placeholder="Value" autofocus
      style="padding: 10px 12px; border-radius: 8px; border: 1px solid #334155; background: #1e293b; color: #e2e8f0;">
    <div style="display: flex; justify-content: flex-end; gap: 8px;">
      <button type="button" id="cancel" style="padding: 8px 12px; border-radius: 6px; border: 1px solid #334155; background: #0f172a; color: #e2e8f0;">Cancel</button>
      <button type="submit" style="padding: 8px 12px; border-radius: 6px; border: none; background: #10b981; color: #0f172a; font-weight: 600;">Save</button>
    </div>
  </form>
  <script>
    const { ipcRenderer } = require('electron');
    const form = document.getElementById('secret-form');
    const input = document.getElementById('secret-value');
    form.addEventListener('submit', (event) => {
      event.preventDefault();
      ipcRenderer.send('${channel}', input.value);
    });
    document.getElementById('cancel').addEventListener('click', () => {
      ipcRenderer.send('${channel}', null);
    });
  </script>
</body>
</html>
    `;

    await modal.loadURL(`data:text/html;charset=utf-8,${encodeURIComponent(body)}`);
    modal.once("ready-to-show", () => modal.show());

    return await new Promise<string | null>((resolve) => {
        let settled = false;
        const finish = (value: string | null) => {
            if (settled) return;
            settled = true;
            ipcMain.removeAllListeners(channel);
            if (!modal.isDestroyed()) {
                modal.close();
            }
            resolve(value);
        };
        ipcMain.once(channel, (_event, value: string | null) => finish(value));
        modal.on("closed", () => finish(null));
    });
}

async function ensureRuntimeSecretsIfNeeded(): Promise<void> {
    if (!RUNTIME_CONTROL.ENABLED) return;
    try {
        const fetchSecrets = async (): Promise<RuntimeSecret[]> => {
            const status = await runtimeRequest<RuntimeSecretsResponse>("/secrets");
            return (status as RuntimeSecretsResponse | undefined)?.secrets || [];
        };

        const current = await fetchSecrets();
        const missing = current.filter(
            (sec) => sec.class === "user_prompt" && sec.required && !sec.has_value,
        );
        if (missing.length === 0) {
            return;
        }

        const collected: Record<string, string> = {};
        for (const secret of missing) {
            const value = await promptForSecretValue(secret);
            if (value && value.trim() !== "") {
                collected[secret.id] = value.trim();
            }
        }

        if (Object.keys(collected).length === 0) {
            throw new Error("Required secrets were not provided. Restart and enter the missing values to continue.");
        }

        await runtimeRequest("/secrets", { method: "POST", body: { secrets: collected } });

        const refreshed = await fetchSecrets();
        const stillMissing = refreshed.filter(
            (sec) => sec.class === "user_prompt" && sec.required && !sec.has_value,
        );
        if (stillMissing.length > 0) {
            const ids = stillMissing.map((s) => s.id).join(", ");
            throw new Error(`Secrets still missing after submission: ${ids}`);
        }
    } catch (error) {
        console.error("[Desktop App] Failed to sync runtime secrets:", error);
        dialog.showErrorBox("Secrets required", String(error));
        throw error;
    }
}

async function getBootstrapStatePath(): Promise<string> {
    if (!bootstrapStatePath) {
        if (!app.isReady()) {
            await app.whenReady();
        }
        bootstrapStatePath = path.join(app.getPath("userData"), "local-vrooli-bootstrap.json");
    }
    return bootstrapStatePath;
}

async function loadBootstrapState(): Promise<LocalVrooliBootstrapState> {
    if (bootstrapStateCache) {
        return bootstrapStateCache;
    }

    try {
        const statePath = await getBootstrapStatePath();
        const raw = await fs.readFile(statePath, "utf-8");
        bootstrapStateCache = JSON.parse(raw) as LocalVrooliBootstrapState;
    } catch {
        bootstrapStateCache = {};
    }

    return bootstrapStateCache;
}

async function saveBootstrapState(state: LocalVrooliBootstrapState): Promise<void> {
    bootstrapStateCache = state;
    const statePath = await getBootstrapStatePath();
    await fs.writeFile(statePath, JSON.stringify(state, null, 2));
}

async function pathExists(filePath: string): Promise<boolean> {
    try {
        await fs.access(filePath);
        return true;
    } catch {
        return false;
    }
}

// ===== BUNDLE VALIDATION FUNCTIONS =====

/**
 * Returns the platform key for the current OS/arch in the manifest format.
 * E.g., "linux-x64", "darwin-arm64", "win-x64"
 */
function getBundlePlatformKey(): string {
    const arch = process.arch === "x64" ? "x64" : process.arch;
    const os = process.platform === "darwin" ? "darwin" : process.platform === "win32" ? "win" : "linux";
    return `${os}-${arch}`;
}

/**
 * Returns platform key aliases for the manifest (e.g., "mac-x64" for "darwin-x64").
 */
function getPlatformKeyAliases(key: string): string[] {
    const keys = [key];
    if (key.startsWith("darwin-")) {
        keys.push("mac-" + key.slice(7));
    } else if (key.startsWith("mac-")) {
        keys.push("darwin-" + key.slice(4));
    } else if (key.startsWith("win-")) {
        keys.push("windows-" + key.slice(4));
    } else if (key.startsWith("windows-")) {
        keys.push("win-" + key.slice(8));
    }
    return keys;
}

/**
 * Loads and parses the bundle manifest from disk.
 */
async function loadBundleManifest(manifestPath: string): Promise<BundleManifest | null> {
    try {
        const raw = await fs.readFile(manifestPath, "utf-8");
        return JSON.parse(raw) as BundleManifest;
    } catch (error) {
        console.error("[Desktop App] Failed to load bundle manifest:", error);
        return null;
    }
}

/**
 * Performs pre-flight validation of the bundle manifest.
 * Checks that all required binaries and assets exist before spawning the runtime.
 * This is a fast, Electron-side check that catches obvious issues early.
 */
async function validateBundlePreFlight(bundleRoot: string, manifestPath: string): Promise<BundleValidationResult> {
    const result: BundleValidationResult = {
        valid: true,
        errors: [],
        warnings: [],
        missingBinaries: [],
        missingAssets: [],
    };

    // Load manifest
    const manifest = await loadBundleManifest(manifestPath);
    if (!manifest) {
        result.valid = false;
        result.errors.push("Failed to load or parse bundle manifest");
        return result;
    }

    // Validate schema version and target
    if (!manifest.schema_version) {
        result.valid = false;
        result.errors.push("Manifest missing schema_version");
    }
    if (manifest.target !== "desktop") {
        result.valid = false;
        result.errors.push(`Invalid manifest target: ${manifest.target} (expected 'desktop')`);
    }
    if (!manifest.app?.name || !manifest.app?.version) {
        result.valid = false;
        result.errors.push("Manifest missing app.name or app.version");
    }
    if (!manifest.ipc?.host || !manifest.ipc?.port) {
        result.valid = false;
        result.errors.push("Manifest missing ipc.host or ipc.port");
    }

    // Early exit if manifest is fundamentally broken
    if (!result.valid) {
        return result;
    }

    // Get platform keys to check
    const platformKey = getBundlePlatformKey();
    const platformKeys = getPlatformKeyAliases(platformKey);

    // Check each service
    for (const service of manifest.services || []) {
        // Check for service binary
        let binaryFound = false;
        let binaryPath = "";
        for (const pk of platformKeys) {
            const bin = service.binaries?.[pk];
            if (bin?.path) {
                const fullPath = path.join(bundleRoot, bin.path.replace(/\\/g, path.sep));
                if (await pathExists(fullPath)) {
                    binaryFound = true;
                    break;
                }
                binaryPath = bin.path;
            }
        }

        if (!binaryFound && Object.keys(service.binaries || {}).length > 0) {
            // Only flag as missing if binaries are defined but none match platform
            const anyBinary = Object.values(service.binaries || {})[0];
            result.missingBinaries.push({
                serviceId: service.id,
                platform: platformKey,
                path: binaryPath || anyBinary?.path || "<undefined>",
            });
            result.errors.push(`Binary missing for service ${service.id} on platform ${platformKey}`);
            result.valid = false;
        }

        // Check for service assets (existence only, checksums verified by runtime)
        for (const asset of service.assets || []) {
            const assetPath = path.join(bundleRoot, asset.path.replace(/\\/g, path.sep));
            if (!(await pathExists(assetPath))) {
                result.missingAssets.push({
                    serviceId: service.id,
                    path: asset.path,
                });
                result.errors.push(`Asset missing for service ${service.id}: ${asset.path}`);
                result.valid = false;
            }
        }
    }

    return result;
}

/**
 * Calls the runtime's /validate endpoint for comprehensive validation.
 * This includes checksum verification that Electron can't do efficiently.
 */
async function validateBundleViaRuntime(): Promise<RuntimeValidationResponse | null> {
    if (!RUNTIME_CONTROL.ENABLED) {
        return null;
    }
    try {
        const response = await runtimeRequest<RuntimeValidationResponse>("/validate");
        return response as RuntimeValidationResponse;
    } catch (error) {
        console.warn("[Desktop App] Runtime validation unavailable:", error);
        return null;
    }
}

/**
 * Formats bundle validation errors for display.
 */
function formatValidationErrors(result: BundleValidationResult): string {
    const lines: string[] = [];

    if (result.missingBinaries.length > 0) {
        lines.push("Missing binaries:");
        for (const mb of result.missingBinaries) {
            lines.push(`  - ${mb.serviceId}: ${mb.path} (${mb.platform})`);
        }
    }

    if (result.missingAssets.length > 0) {
        lines.push("Missing assets:");
        for (const ma of result.missingAssets) {
            lines.push(`  - ${ma.serviceId}: ${ma.path}`);
        }
    }

    if (result.errors.length > 0 && lines.length === 0) {
        lines.push("Validation errors:");
        for (const err of result.errors) {
            lines.push(`  - ${err}`);
        }
    }

    return lines.join("\n");
}

async function locateBinaryInPath(binary: string): Promise<string | null> {
    return new Promise((resolve) => {
        const locator = process.platform === "win32" ? "where" : "which";
        const checker = spawn(locator, [binary], { shell: false });
        let output = "";

        checker.stdout?.on("data", (data) => {
            output += data.toString();
        });

        checker.on("error", () => resolve(null));
        checker.on("close", (code) => {
            if (code === 0) {
                const line = output.split(/\r?\n/).find((item) => item.trim().length > 0);
                resolve(line?.trim() || binary);
            } else {
                resolve(null);
            }
        });
    });
}

async function promptForVrooliBinary(): Promise<string | null> {
    const response = await dialog.showMessageBox({
        type: "question",
        title: "Locate Vrooli",
        message: "The Vrooli CLI is required to start this scenario locally. Locate the vrooli binary or cancel to manage the server yourself.",
        buttons: ["Locate Vrooli", "Cancel"],
        defaultId: 0,
        cancelId: 1,
    });

    if (response.response !== 0) {
        return null;
    }

    const openResult = await dialog.showOpenDialog({
        title: "Select vrooli executable",
        properties: ["openFile"],
        filters: [
            { name: "Executable", extensions: process.platform === "win32" ? ["exe", "cmd", "bat"] : ["sh", ""] },
        ],
    });

    if (openResult.canceled || openResult.filePaths.length === 0) {
        return null;
    }

    return openResult.filePaths[0];
}

async function resolveVrooliCommand(): Promise<string | null> {
    if (!shouldBootstrapLocalVrooli) {
        return null;
    }

    if (localVrooliRuntime.vrooliBinary) {
        return localVrooliRuntime.vrooliBinary;
    }

    const preferred = LOCAL_VROOLI_BOOTSTRAP.VROOLI_BINARY?.trim();
    if (preferred && preferred !== "vrooli" && (preferred.includes(path.sep) || preferred.includes("/") || preferred.includes("\\"))) {
        if (await pathExists(preferred)) {
            localVrooliRuntime.vrooliBinary = preferred;
            return preferred;
        }
    } else if (preferred && preferred !== "" && preferred !== "vrooli") {
        localVrooliRuntime.vrooliBinary = preferred;
        return preferred;
    }

    const state = await loadBootstrapState();
    if (state.vrooliPath && await pathExists(state.vrooliPath)) {
        localVrooliRuntime.vrooliBinary = state.vrooliPath;
        return state.vrooliPath;
    }

    const located = await locateBinaryInPath("vrooli");
    if (located) {
        localVrooliRuntime.vrooliBinary = located;
        return located;
    }

    if (process.platform === "win32") {
        const locatedCmd = await locateBinaryInPath("vrooli.cmd");
        if (locatedCmd) {
            localVrooliRuntime.vrooliBinary = locatedCmd;
            return locatedCmd;
        }
    }

    const userSelection = await promptForVrooliBinary();
    if (userSelection) {
        const updatedState = await loadBootstrapState();
        updatedState.vrooliPath = userSelection;
        await saveBootstrapState(updatedState);
        localVrooliRuntime.vrooliBinary = userSelection;
        return userSelection;
    }

    return null;
}

async function runVrooliCommand(binary: string, args: string[], options: { timeoutMs?: number; ignoreErrors?: boolean } = {}): Promise<CommandResult> {
    return new Promise((resolve) => {
        const commandToRun = process.platform === "win32" && binary.includes(" ")
            ? `"${binary}"`
            : binary;
        const child = spawn(commandToRun, args, {
            shell: process.platform === "win32",
        });

        let stdout = "";
        let stderr = "";
        let finished = false;

        const timeout = options.timeoutMs
            ? setTimeout(() => {
                if (!finished) {
                    finished = true;
                    child.kill();
                    resolve({ success: false, stdout, stderr: `${stderr}\nCommand timed out`, code: -1 });
                }
            }, options.timeoutMs)
            : null;

        child.stdout?.on("data", (data) => {
            stdout += data.toString();
        });

        child.stderr?.on("data", (data) => {
            stderr += data.toString();
        });

        child.on("error", (error) => {
            if (timeout) {
                clearTimeout(timeout);
            }
            if (!finished) {
                finished = true;
                resolve({ success: false, stdout, stderr: error.message, code: -1 });
            }
        });

        child.on("close", (code) => {
            if (timeout) {
                clearTimeout(timeout);
            }
            if (finished) {
                return;
            }
            finished = true;
            const success = code === 0;
            if (!success && !options.ignoreErrors) {
                console.warn(`[Desktop App] Vrooli command failed: ${binary} ${args.join(" ")}`);
            }
            resolve({ success, stdout, stderr, code: code ?? -1 });
        });
    });
}

async function ensureVrooliSetup(vrooliBinary: string): Promise<boolean> {
    const state = await loadBootstrapState();
    if (state.setupCompleted) {
        return true;
    }

    void recordTelemetry("local_vrooli_setup_attempt");
    const setupResult = await runVrooliCommand(vrooliBinary, ["setup", "--yes", "yes", "--skip-sudo", "yes"], { timeoutMs: 5 * 60 * 1000 });
    if (!setupResult.success) {
        void recordTelemetry("local_vrooli_setup_failed", { stderr: setupResult.stderr });
        dialog.showErrorBox("Vrooli Setup Failed", "Unable to run 'vrooli setup'. Please run it manually and restart the desktop app.");
        return false;
    }

    state.setupCompleted = true;
    await saveBootstrapState(state);
    void recordTelemetry("local_vrooli_setup_completed");
    return true;
}

async function isScenarioRunning(vrooliBinary: string): Promise<boolean> {
    const statusResult = await runVrooliCommand(vrooliBinary, ["scenario", "status", LOCAL_VROOLI_BOOTSTRAP.SCENARIO_NAME!], { ignoreErrors: true, timeoutMs: 60 * 1000 });
    return statusResult.success;
}

async function waitForScenarioReady(vrooliBinary: string, attempts = 10): Promise<boolean> {
    for (let i = 0; i < attempts; i += 1) {
        if (await isScenarioRunning(vrooliBinary)) {
            return true;
        }
        await delay(3000);
    }
    return false;
}

async function ensureLocalVrooliReady(): Promise<void> {
    if (!shouldBootstrapLocalVrooli) {
        return;
    }

    const vrooliBinary = await resolveVrooliCommand();
    if (!vrooliBinary) {
        void recordTelemetry("local_vrooli_bootstrap_skipped", { reason: "vrooli_not_found" });
        dialog.showErrorBox("Vrooli CLI Missing", "Install the Vrooli CLI or run the scenario manually before launching the desktop app.");
        return;
    }

    if (!(await ensureVrooliSetup(vrooliBinary))) {
        return;
    }

    if (await isScenarioRunning(vrooliBinary)) {
        void recordTelemetry("local_vrooli_already_running");
        return;
    }

    void recordTelemetry("local_vrooli_start_attempt");
    const startResult = await runVrooliCommand(vrooliBinary, ["scenario", "start", LOCAL_VROOLI_BOOTSTRAP.SCENARIO_NAME!], { timeoutMs: 3 * 60 * 1000 });
    if (!startResult.success) {
        void recordTelemetry("local_vrooli_start_failed", { stderr: startResult.stderr });
        dialog.showErrorBox("Unable to Start Scenario", `vrooli failed to start ${LOCAL_VROOLI_BOOTSTRAP.SCENARIO_NAME}. Please inspect your Vrooli server.`);
        return;
    }

    localVrooliRuntime.startedByApp = true;
    const ready = await waitForScenarioReady(vrooliBinary);
    if (ready) {
        void recordTelemetry("local_vrooli_started");
    } else {
        void recordTelemetry("local_vrooli_start_timeout");
        dialog.showErrorBox("Scenario Not Ready", `${LOCAL_VROOLI_BOOTSTRAP.SCENARIO_NAME} did not become healthy in time. You may need to troubleshoot manually.`);
    }
}

async function shutdownLocalVrooli(): Promise<void> {
    if (!shouldBootstrapLocalVrooli || !localVrooliRuntime.startedByApp || !localVrooliRuntime.vrooliBinary) {
        return;
    }

    void recordTelemetry("local_vrooli_stop_attempt");
    await runVrooliCommand(localVrooliRuntime.vrooliBinary, ["scenario", "stop", LOCAL_VROOLI_BOOTSTRAP.SCENARIO_NAME!], { timeoutMs: 60 * 1000, ignoreErrors: true });
    localVrooliRuntime.startedByApp = false;
    void recordTelemetry("local_vrooli_stop_completed");
}

function delay(ms: number): Promise<void> {
    return new Promise((resolve) => {
        setTimeout(resolve, ms);
    });
}

// ===== UTILITY FUNCTIONS =====

function checkServerReady(url: string, timeout: number): Promise<void> {
    return new Promise((resolve, reject) => {
        let elapsedTime = 0;
        const interval = setInterval(() => {
            const request = net.request(url);
            request.on("response", (response) => {
                console.log(`[Desktop App] Server check successful (Status: ${response.statusCode}) at ${url}`);
                clearInterval(interval);
                request.abort();
                void recordTelemetry("server_ready", { url, statusCode: response.statusCode });
                resolve();
            });
            request.on("error", (error) => {
                if (!error.message.includes("ECONNREFUSED")) {
                    console.error(`[Desktop App] Server check error: ${error.message}`);
                }
                request.abort();
            });
            request.end();

            elapsedTime += APP_CONFIG.SERVER_CHECK_INTERVAL_MS;
            if (elapsedTime >= timeout) {
                clearInterval(interval);
                console.error(`[Desktop App] Server did not become ready at ${url} within ${timeout}ms.`);
                void recordTelemetry("dependency_unreachable", {
                    url,
                    timeoutMs: timeout,
                });
                reject(new Error(`Server not ready within timeout: ${url}`));
            }
        }, APP_CONFIG.SERVER_CHECK_INTERVAL_MS);
    });
}

function createSplashWindow() {
    if (!APP_CONFIG.ENABLE_SPLASH) return;
    
    console.log("[Desktop App] Creating splash window...");
    splashWindow = new BrowserWindow({
        width: 400,
        height: 300,
        frame: false,
        alwaysOnTop: true,
        transparent: true,
        webPreferences: {
            nodeIntegration: false,
            contextIsolation: true,
        },
    });

    splashWindow.loadFile(path.join(__dirname, "../splash.html"));
    
    splashWindow.on("closed", () => {
        splashWindow = null;
    });
}

async function createMainWindow() {
    console.log("[Desktop App] Creating main window (hidden)...");
    const appIcon = getAppIcon();
    mainWindow = new BrowserWindow({
        width: APP_CONFIG.WINDOW_WIDTH,
        height: APP_CONFIG.WINDOW_HEIGHT,
        show: false,
        backgroundColor: APP_CONFIG.WINDOW_BACKGROUND,
        title: APP_CONFIG.WINDOW_TITLE,
        webPreferences: {
            preload: path.join(__dirname, "preload.js"),
            nodeIntegration: false,
            contextIsolation: true,
        },
        ...(appIcon && { icon: appIcon }),
    });

    // Handle external link clicks
    mainWindow.webContents.setWindowOpenHandler(({ url }) => {
        shell.openExternal(url);
        return { action: 'deny' };
    });

    mainWindow.on("closed", () => {
        mainWindow = null;
    });

    // Enable DevTools in development
    if (APP_CONFIG.ENABLE_DEV_TOOLS && !app.isPackaged) {
        mainWindow.webContents.openDevTools();
    }

    return mainWindow;
}

function getAppIcon(): string | undefined {
    const iconPath = path.join(app.getAppPath(), "assets");
    
    if (process.platform === "win32") {
        return path.join(iconPath, "icon.ico");
    } else if (process.platform === "darwin") {
        return path.join(iconPath, "icon.icns");
    } else {
        return path.join(iconPath, "icon.png");
    }
}

function createSystemTray() {
    if (!APP_CONFIG.ENABLE_SYSTEM_TRAY) return;
    
    const iconPath = getAppIcon();
    if (!iconPath) return;
    
    try {
        const icon = nativeImage.createFromPath(iconPath);
        tray = new Tray(icon.resize({ width: 16, height: 16 }));
        
        const contextMenu = Menu.buildFromTemplate([
            {
                label: `Show ${APP_CONFIG.APP_DISPLAY_NAME}`,
                click: () => {
                    if (mainWindow) {
                        mainWindow.show();
                        mainWindow.focus();
                    }
                }
            },
            {
                label: `About ${APP_CONFIG.APP_DISPLAY_NAME}`,
                click: () => {
                    dialog.showMessageBox(mainWindow!, {
                        type: "info",
                        title: `About ${APP_CONFIG.APP_DISPLAY_NAME}`,
                        message: APP_CONFIG.APP_DISPLAY_NAME,
                        detail: `Version ${APP_CONFIG.APP_VERSION}\n\nBuilt with scenario-to-desktop`
                    });
                }
            },
            { type: "separator" },
            {
                label: "Quit",
                click: () => {
                    app.quit();
                }
            }
        ]);
        
        tray.setToolTip(APP_CONFIG.APP_DISPLAY_NAME);
        tray.setContextMenu(contextMenu);
        
        tray.on("double-click", () => {
            if (mainWindow) {
                mainWindow.show();
                mainWindow.focus();
            }
        });
    } catch (error) {
        console.error("[Desktop App] Failed to create system tray:", error);
    }
}

function createApplicationMenu() {
    if (!APP_CONFIG.ENABLE_MENU) return;
    
    const template: Electron.MenuItemConstructorOptions[] = [
        {
            label: "File",
            submenu: [
                {
                    label: "New",
                    accelerator: "CmdOrCtrl+N",
                    click: () => {
                        // Send message to renderer process
                        if (mainWindow) {
                            mainWindow.webContents.send("menu-action", { action: "new" });
                        }
                    }
                },
                {
                    label: "Open",
                    accelerator: "CmdOrCtrl+O",
                    click: async () => {
                        if (!mainWindow) return;
                        
                        const result = await dialog.showOpenDialog(mainWindow, {
                            properties: ["openFile"],
                            filters: [
                                { name: "All Files", extensions: ["*"] }
                            ]
                        });
                        
                        if (!result.canceled && result.filePaths.length > 0) {
                            mainWindow.webContents.send("menu-action", { 
                                action: "open", 
                                filePath: result.filePaths[0] 
                            });
                        }
                    }
                },
                { type: "separator" },
                process.platform === "darwin" ? { role: "close" } : { role: "quit" }
            ]
        },
        {
            label: "Edit",
            submenu: [
                { role: "undo" },
                { role: "redo" },
                { type: "separator" },
                { role: "cut" },
                { role: "copy" },
                { role: "paste" },
                { role: "selectAll" }
            ]
        },
        {
            label: "View",
            submenu: [
                { role: "reload" },
                { role: "forceReload" },
                { role: "toggleDevTools" },
                { type: "separator" },
                { role: "resetZoom" },
                { role: "zoomIn" },
                { role: "zoomOut" },
                { type: "separator" },
                { role: "togglefullscreen" },
                ...(RUNTIME_CONTROL.ENABLED ? [
                    { type: "separator" },
                    {
                        label: "Runtime Diagnostics",
                        click: () => {
                            void showRuntimeDiagnostics();
                        }
                    }
                ] : [])
            ]
        },
        {
            label: "Window",
            submenu: [
                { role: "minimize" },
                { role: "close" }
            ]
        },
        {
            label: "Help",
            submenu: [
                {
                    label: "Check for Updates...",
                    enabled: UPDATE_CONFIG.PROVIDER !== "none",
                    click: () => {
                        void checkForUpdatesManually();
                    }
                },
                { type: "separator" },
                {
                    label: `About ${APP_CONFIG.APP_DISPLAY_NAME}`,
                    click: () => {
                        const channelInfo = UPDATE_CONFIG.PROVIDER !== "none"
                            ? `\nUpdate Channel: ${UPDATE_CONFIG.CHANNEL}`
                            : "";
                        dialog.showMessageBox(mainWindow!, {
                            type: "info",
                            title: `About ${APP_CONFIG.APP_DISPLAY_NAME}`,
                            message: APP_CONFIG.APP_DISPLAY_NAME,
                            detail: `Version ${APP_CONFIG.APP_VERSION}${channelInfo}\n\nBuilt with scenario-to-desktop\n\n${APP_CONFIG.APP_URL || ""}`
                        });
                    }
                }
            ]
        }
    ];

    const menu = Menu.buildFromTemplate(template);
    Menu.setApplicationMenu(menu);
}

function runtimePlatformKey(): string {
	const arch = process.arch === "x64" ? "x64" : process.arch;
	const os = process.platform === "darwin" ? "mac" : process.platform === "win32" ? "win" : "linux";
	return `${os}-${arch}`;
}

async function resolveBundleRoot(): Promise<string | null> {
	const bundleRoot = BUNDLED_RUNTIME.ROOT || "bundle";
	const candidates = [
		path.join(process.resourcesPath, bundleRoot),
		path.join(app.getAppPath(), bundleRoot),
	];

	for (const candidate of candidates) {
		if (await pathExists(candidate)) {
			return candidate;
		}
	}

	return null;
}

async function waitForFile(filePath: string, timeoutMs = 15000): Promise<void> {
	const deadline = Date.now() + timeoutMs;
	while (Date.now() < deadline) {
		if (await pathExists(filePath)) {
			return;
		}
		await new Promise((resolve) => setTimeout(resolve, 150));
	}
	throw new Error(`file not found within timeout: ${filePath}`);
}

function normalizeBundlePath(bundleRoot: string, rel: string): string {
	return path.join(bundleRoot, rel.replace(/\\/g, path.sep));
}

async function findChromiumPath(bundleRoot: string, manifestPath: string): Promise<string | null> {
	const candidates: string[] = [];

	try {
		const raw = await fs.readFile(manifestPath, "utf-8");
		const manifest = JSON.parse(raw) as { services?: Array<{ assets?: Array<{ path: string }>; env?: Record<string, string> }> };
		for (const svc of manifest.services || []) {
			for (const asset of svc.assets || []) {
				if (asset.path?.toLowerCase().includes("chromium") || asset.path?.toLowerCase().includes("playwright")) {
					candidates.push(asset.path);
				}
			}
			for (const value of Object.values(svc.env || {})) {
				if (typeof value === "string" && value.toLowerCase().includes("chromium")) {
					candidates.push(value);
				}
			}
		}
	} catch (error) {
		console.warn("[Desktop App] Unable to parse bundle manifest for Chromium detection", error);
	}

	for (const rel of candidates) {
		const candidate = path.isAbsolute(rel) ? rel : normalizeBundlePath(bundleRoot, rel);
		if (await pathExists(candidate)) {
			return candidate;
		}
	}

	const electronCandidates: string[] = [process.execPath];
	if (process.platform === "darwin") {
		electronCandidates.push(
			path.join(process.resourcesPath, "..", "Frameworks", "Electron Framework.framework", "Versions", "Current", "Helpers", "Electron Helper (Renderer).app", "Contents", "MacOS", "Electron Helper (Renderer)"),
			path.join(process.resourcesPath, "..", "Frameworks", "Electron Framework.framework", "Versions", "Current", "Resources", "electron")
		);
	} else if (process.platform === "win32") {
		electronCandidates.push(path.join(path.dirname(process.execPath), "chrome.exe"));
	} else {
		electronCandidates.push(path.join(path.dirname(process.execPath), "chrome"));
	}

	for (const candidate of electronCandidates) {
		if (await pathExists(candidate)) {
			return candidate;
		}
	}

	return null;
}

async function startBundledRuntime(): Promise<string> {
	const bundleRoot = await resolveBundleRoot();
	if (!bundleRoot) {
		throw new Error("Bundled payload is missing. Regenerate or reinstall the desktop app.");
	}

	const manifestPath = path.join(bundleRoot, "bundle.json");
	if (!(await pathExists(manifestPath))) {
		throw new Error(`Bundled manifest missing at ${manifestPath}`);
	}

	// Pre-flight validation: check manifest structure and required files before spawning runtime
	console.log("[Desktop App] Performing pre-flight bundle validation...");
	const validationResult = await validateBundlePreFlight(bundleRoot, manifestPath);
	if (!validationResult.valid) {
		const errorDetails = formatValidationErrors(validationResult);
		await recordTelemetry("bundle_validation_failed", {
			errors: validationResult.errors,
			missingBinaries: validationResult.missingBinaries,
			missingAssets: validationResult.missingAssets,
		});
		throw new Error(`Bundle validation failed:\n${errorDetails}\n\nThe bundle may be corrupted or incomplete. Try regenerating or reinstalling the desktop app.`);
	}
	console.log("[Desktop App] Pre-flight bundle validation passed");

	const runtimePath = path.join(
		bundleRoot,
		"runtime",
		runtimePlatformKey(),
		process.platform === "win32" ? "runtime.exe" : "runtime",
	);
	if (!(await pathExists(runtimePath))) {
		throw new Error(`Bundled runtime binary not found for this platform (${runtimePath})`);
	}

	const appData = path.join(app.getPath("userData"), "runtime");
	await fs.mkdir(appData, { recursive: true });
	runtimeAppDataRoot = appData;

	const tokenRel = BUNDLED_RUNTIME.TOKEN_REL || "runtime/auth-token";
	const tokenPath = path.join(appData, tokenRel);
	RUNTIME_CONTROL.TOKEN_PATH_ENV = tokenPath;

	const args = [
		"--manifest",
		manifestPath,
		"--bundle-root",
		bundleRoot,
		"--app-data",
		appData,
		"--dry-run=false",
	];

	const chromiumPath = await findChromiumPath(bundleRoot, manifestPath);
	const runtimeEnv = { ...process.env };
	if (chromiumPath && !runtimeEnv.ELECTRON_CHROMIUM_PATH) {
		runtimeEnv.ELECTRON_CHROMIUM_PATH = chromiumPath;
	}

	runtimeProcess = spawn(runtimePath, args, {
		stdio: "inherit",
		env: runtimeEnv,
	});
	runtimeProcess.on("exit", (code, signal) => {
		void recordTelemetry("bundled_runtime_exit", { code, signal });
	});

	await waitForFile(tokenPath, APP_CONFIG.SERVER_CHECK_TIMEOUT_MS);
	await waitForRuntimeControl(APP_CONFIG.SERVER_CHECK_TIMEOUT_MS);

	// Comprehensive validation via runtime API (includes checksum verification)
	try {
		const runtimeValidation = await validateBundleViaRuntime();
		if (runtimeValidation && !runtimeValidation.valid) {
			const checksumErrors = runtimeValidation.invalid_checksums?.length || 0;
			const otherErrors = (runtimeValidation.errors?.length || 0) - checksumErrors;

			// Log validation issues
			console.warn("[Desktop App] Runtime validation found issues:", runtimeValidation);
			await recordTelemetry("runtime_validation_issues", {
				valid: false,
				errorCount: runtimeValidation.errors?.length || 0,
				warningCount: runtimeValidation.warnings?.length || 0,
				checksumMismatches: checksumErrors,
			});

			// If there are critical errors (beyond checksum mismatches), warn the user
			if (otherErrors > 0) {
				const errorMessages = runtimeValidation.errors
					?.filter(e => e.code !== "checksum_mismatch")
					.map(e => e.message)
					.join("\n") || "Unknown validation errors";
				console.error("[Desktop App] Critical validation errors:", errorMessages);
			}
		} else if (runtimeValidation?.valid) {
			console.log("[Desktop App] Runtime bundle validation passed");
		}
	} catch (error) {
		console.warn("[Desktop App] Runtime validation check failed (non-fatal):", error);
	}

	await ensureRuntimeSecretsIfNeeded();

	const readyDeadline = Date.now() + APP_CONFIG.SERVER_CHECK_TIMEOUT_MS;
	while (Date.now() < readyDeadline) {
		try {
			const ready = await runtimeRequest<{ ready: boolean }>("/readyz");
			if ((ready as any)?.ready) {
				break;
			}
		} catch {
			// runtime may still be starting
		}
		await new Promise((resolve) => setTimeout(resolve, 350));
	}

	const ports = await runtimeRequest<{ services: Record<string, Record<string, number>> }>("/ports");
	const serviceId = BUNDLED_RUNTIME.UI_SERVICE || Object.keys((ports as any).services || {})[0];
	const portName = BUNDLED_RUNTIME.UI_PORT_NAME || "http";
	const svcPorts = (ports as any).services?.[serviceId];
	const port = svcPorts?.[portName];
	if (!serviceId || !port) {
		throw new Error("Bundled runtime started but did not expose a UI port");
	}

	const url = `http://127.0.0.1:${port}/`;
	await recordTelemetry("bundled_runtime_ready", {
		bundleRoot,
		serviceId,
		portName,
		port,
	});
	void autoUploadTelemetryIfConfigured("startup");
	return url;
}

async function shutdownRuntime(): Promise<void> {
	if (RUNTIME_CONTROL.ENABLED) {
		void autoUploadTelemetryIfConfigured("shutdown");
		try {
			await runtimeRequest("/shutdown", { method: "POST" });
		} catch (error) {
			console.warn("[Desktop App] Failed to request runtime shutdown", error);
		}
	}
	if (runtimeProcess) {
		try {
			runtimeProcess.kill();
		} catch {
			// ignore
		}
		runtimeProcess = null;
	}
}

async function startScenarioServer() {
    if (APP_CONFIG.SERVER_TYPE === "external") {
        console.log(`[Desktop App] Using external server: ${APP_CONFIG.SERVER_PATH}`);
        void recordTelemetry("external_server_mode", {
            serverPath: APP_CONFIG.SERVER_PATH,
        });
        return;
    }
    
    if (APP_CONFIG.SERVER_TYPE === "static") {
        console.log("[Desktop App] Using static files, no server to start");
        return;
    }

    const serverPath = path.resolve(app.getAppPath(), APP_CONFIG.SERVER_PATH);
    console.log(`[Desktop App] Starting scenario server: ${serverPath}`);

    try {
        if (APP_CONFIG.SERVER_TYPE === "node") {
            serverProcess = fork(serverPath, [], {
                env: {
                    ...process.env,
                    PORT: APP_CONFIG.SERVER_PORT.toString(),
                    DESKTOP_MODE: "true",
                    API_ENDPOINT: APP_CONFIG.API_ENDPOINT,
                },
                stdio: "inherit",
            });
        } else if (APP_CONFIG.SERVER_TYPE === "executable") {
            serverProcess = spawn(serverPath, [], {
                env: {
                    ...process.env,
                    PORT: APP_CONFIG.SERVER_PORT.toString(),
                    DESKTOP_MODE: "true",
                    API_ENDPOINT: APP_CONFIG.API_ENDPOINT,
                },
                stdio: "inherit",
            });
        }

        void recordTelemetry("local_server_started", {
            mode: APP_CONFIG.SERVER_TYPE,
            serverPath,
        });

        if (serverProcess) {
            serverProcess.on("error", (error) => {
                console.error(`[Desktop App] Server process error: ${error}`);
                dialog.showErrorBox("Server Error", `Failed to start scenario server: ${error.message}`);
            });

            serverProcess.on("exit", (code, signal) => {
                console.log(`[Desktop App] Server process exited with code ${code} and signal ${signal}`);
            });
        }
    } catch (error) {
        console.error(`[Desktop App] Failed to start server: ${error}`);
        dialog.showErrorBox("Startup Error", `Failed to start scenario server: ${error}`);
    }
}

function setupAutoUpdater() {
    // Skip if auto-updater is disabled, not packaged, or no provider configured
    if (!APP_CONFIG.ENABLE_AUTO_UPDATER || !app.isPackaged) {
        console.log("[Desktop App] Auto-updater disabled (not packaged or feature disabled)");
        return;
    }

    if (UPDATE_CONFIG.PROVIDER === "none") {
        console.log("[Desktop App] Auto-updater disabled (no update provider configured)");
        return;
    }

    // Configure the updater
    autoUpdater.logger = console;
    autoUpdater.autoDownload = true;
    autoUpdater.autoInstallOnAppQuit = true;

    // Set the update channel - electron-updater uses this for GitHub prereleases
    // and generic server channel directories
    autoUpdater.channel = UPDATE_CONFIG.CHANNEL;

    // For beta/dev channels on GitHub, allow prereleases
    if (UPDATE_CONFIG.PROVIDER === "github") {
        autoUpdater.allowPrerelease = UPDATE_CONFIG.CHANNEL !== "stable";
    }

    console.log(`[Desktop App] Auto-updater configured:`);
    console.log(`  Provider: ${UPDATE_CONFIG.PROVIDER}`);
    console.log(`  Channel: ${UPDATE_CONFIG.CHANNEL}`);
    console.log(`  Server: ${UPDATE_CONFIG.SERVER_URL || "(configured in app-update.yml)"}`);

    // Event handlers
    autoUpdater.on("checking-for-update", () => {
        console.log("[Desktop App] Checking for update...");
        recordTelemetry("update_check_started", { channel: UPDATE_CONFIG.CHANNEL });
    });

    autoUpdater.on("update-available", (info) => {
        console.log("[Desktop App] Update available:", info.version);
        recordTelemetry("update_available", {
            version: info.version,
            channel: UPDATE_CONFIG.CHANNEL,
            releaseDate: info.releaseDate,
        });

        // Show notification to user
        if (mainWindow && !mainWindow.isDestroyed()) {
            dialog.showMessageBox(mainWindow, {
                type: "info",
                title: "Update Available",
                message: `A new version (${info.version}) is available and will be downloaded automatically.`,
                buttons: ["OK"],
            });
        }
    });

    autoUpdater.on("update-not-available", (info) => {
        console.log("[Desktop App] Already on latest version:", info.version);
    });

    autoUpdater.on("error", (err) => {
        console.error("[Desktop App] Update error:", err.message);
        recordTelemetry("update_error", {
            error: err.message,
            channel: UPDATE_CONFIG.CHANNEL
        });
    });

    autoUpdater.on("download-progress", (progressObj) => {
        const percent = Math.round(progressObj.percent);
        const speed = (progressObj.bytesPerSecond / 1024 / 1024).toFixed(2);
        console.log(`[Desktop App] Download progress: ${percent}% (${speed} MB/s)`);
    });

    autoUpdater.on("update-downloaded", (info) => {
        console.log("[Desktop App] Update downloaded:", info.version);
        recordTelemetry("update_downloaded", {
            version: info.version,
            channel: UPDATE_CONFIG.CHANNEL
        });

        // Prompt user to restart
        if (mainWindow && !mainWindow.isDestroyed()) {
            dialog.showMessageBox(mainWindow, {
                type: "info",
                title: "Update Ready",
                message: `Version ${info.version} has been downloaded. The application will restart to apply the update.`,
                buttons: ["Restart Now", "Later"],
                defaultId: 0,
            }).then(({ response }) => {
                if (response === 0) {
                    autoUpdater.quitAndInstall(false, true);
                }
            });
        } else {
            // No window available, just install on quit
            console.log("[Desktop App] Update will be installed on next restart");
        }
    });

    // Check for updates based on configuration
    if (UPDATE_CONFIG.AUTO_CHECK) {
        // Delay initial check slightly to let the app fully initialize
        setTimeout(() => {
            console.log("[Desktop App] Performing automatic update check...");
            autoUpdater.checkForUpdatesAndNotify().catch((err) => {
                console.error("[Desktop App] Failed to check for updates:", err.message);
            });
        }, 3000);
    } else {
        console.log("[Desktop App] Automatic update check disabled - use menu to check manually");
    }
}

// Manual update check (can be triggered from menu)
async function checkForUpdatesManually(): Promise<void> {
    if (UPDATE_CONFIG.PROVIDER === "none") {
        if (mainWindow && !mainWindow.isDestroyed()) {
            dialog.showMessageBox(mainWindow, {
                type: "info",
                title: "Updates Disabled",
                message: "Auto-updates are not configured for this application.",
                buttons: ["OK"],
            });
        }
        return;
    }

    try {
        console.log("[Desktop App] Manual update check triggered");
        const result = await autoUpdater.checkForUpdates();
        if (!result?.updateInfo) {
            if (mainWindow && !mainWindow.isDestroyed()) {
                dialog.showMessageBox(mainWindow, {
                    type: "info",
                    title: "No Updates",
                    message: "You are running the latest version.",
                    buttons: ["OK"],
                });
            }
        }
    } catch (err) {
        console.error("[Desktop App] Manual update check failed:", err);
        if (mainWindow && !mainWindow.isDestroyed()) {
            dialog.showMessageBox(mainWindow, {
                type: "error",
                title: "Update Check Failed",
                message: `Could not check for updates: ${err instanceof Error ? err.message : String(err)}`,
                buttons: ["OK"],
            });
        }
    }
}

// ===== IPC HANDLERS =====

// File operations
ipcMain.handle("file:save", async (event, data: { content: string; defaultPath?: string }) => {
    if (!mainWindow) return null;

    const dialogOptions: Electron.SaveDialogOptions = {
        filters: [
            { name: "All Files", extensions: ["*"] }
        ]
    };

    if (data.defaultPath) {
        dialogOptions.defaultPath = data.defaultPath;
    }

    const result = await dialog.showSaveDialog(mainWindow, dialogOptions);
    
    if (result.canceled) return null;
    
    const localFs = require("fs").promises;
    await localFs.writeFile(result.filePath, data.content);
    return result.filePath;
});

ipcMain.handle("file:open", async () => {
    if (!mainWindow) return null;
    
    const result = await dialog.showOpenDialog(mainWindow, {
        properties: ["openFile"],
        filters: [
            { name: "All Files", extensions: ["*"] }
        ]
    });
    
    if (result.canceled || result.filePaths.length === 0) return null;
    
    const localFs = require("fs").promises;
    const content = await localFs.readFile(result.filePaths[0], "utf-8");
    return { filePath: result.filePaths[0], content };
});

// System information
ipcMain.handle("system:info", () => {
    return {
        platform: process.platform,
        arch: process.arch,
        version: process.version,
        appVersion: APP_CONFIG.APP_VERSION,
        isPackaged: app.isPackaged,
    };
});

// Application control
ipcMain.handle("app:minimize", () => {
    if (mainWindow) {
        mainWindow.minimize();
    }
});

ipcMain.handle("app:maximize", () => {
    if (mainWindow) {
        if (mainWindow.isMaximized()) {
            mainWindow.unmaximize();
        } else {
            mainWindow.maximize();
        }
    }
});

ipcMain.handle("app:close", () => {
    if (mainWindow) {
        mainWindow.close();
    }
});

// ===== APP EVENT HANDLERS =====

app.whenReady().then(async () => {
    // Single instance lock
    if (APP_CONFIG.ENABLE_SINGLE_INSTANCE) {
        const gotTheLock = app.requestSingleInstanceLock();
        if (!gotTheLock) {
            app.quit();
            return;
        }
        
        app.on('second-instance', () => {
            if (mainWindow) {
                if (mainWindow.isMinimized()) mainWindow.restore();
                mainWindow.focus();
            }
        });
    }

    try {
        // Create splash screen
        createSplashWindow();
        
        // Set up auto updater
        setupAutoUpdater();
        
        // Create application menu
        createApplicationMenu();
        
        // Create system tray
        createSystemTray();
        
        await initializeTelemetry();
        await recordTelemetry("app_start", {
            deploymentMode: APP_CONFIG.DEPLOYMENT_MODE,
        });

		let targetUrl = SERVER_URL;

		if (isBundledMode) {
			if (!BUNDLED_RUNTIME.SUPPORTED) {
				const message = `Bundled builds require a bundle.json payload. Regenerate with DEPLOYMENT_MODE=external-server if you intended a thin client. Docs: ${BUNDLED_RUNTIME.DOCS_URL}`;
				dialog.showErrorBox("Bundled Mode Unavailable", message);
				void recordTelemetry("bundled_mode_blocked", {
					docsUrl: BUNDLED_RUNTIME.DOCS_URL,
				});
				app.quit();
				return;
			}

			try {
				targetUrl = await startBundledRuntime();
			} catch (startupError) {
				console.error("[Desktop App] Bundled runtime failed to start", startupError);
				await recordTelemetry("bundled_runtime_failed", { error: String(startupError) });
				dialog.showErrorBox("Bundled Startup Error", String(startupError));
				await shutdownRuntime();
				app.quit();
				return;
			}
		} else {
			if (shouldBootstrapLocalVrooli) {
				await ensureLocalVrooliReady();
			}

			// Start scenario server (thin client / embedded server modes)
			await startScenarioServer();
			if (RUNTIME_CONTROL.ENABLED) {
				try {
					await waitForRuntimeControl(APP_CONFIG.SERVER_CHECK_TIMEOUT_MS);
					await ensureRuntimeSecretsIfNeeded();
					void autoUploadTelemetryIfConfigured("startup");
				} catch (secretError) {
					await recordTelemetry("runtime_secrets_missing", { error: String(secretError) });
					dialog.showErrorBox("Secrets required", String(secretError));
					app.quit();
					return;
				}
			}
		}

		// Create main window
		await createMainWindow();

		// Wait for server/runtime to be ready
		if (APP_CONFIG.SERVER_TYPE !== "static" || isBundledMode) {
			await checkServerReady(targetUrl, APP_CONFIG.SERVER_CHECK_TIMEOUT_MS);
		}

		// Load the application
		if (APP_CONFIG.SERVER_TYPE === "static" && !isBundledMode) {
			const staticPath = path.resolve(app.getAppPath(), APP_CONFIG.SERVER_PATH);
			await mainWindow!.loadFile(staticPath);
		} else {
			await mainWindow!.loadURL(targetUrl);
		}
        
        // Close splash and show main window
        if (splashWindow) {
            splashWindow.close();
        }
        mainWindow!.show();
        mainWindow!.focus();
        
		console.log(`[Desktop App] ${APP_CONFIG.APP_DISPLAY_NAME} ready!`);
		void recordTelemetry("app_ready", {
			serverUrl: targetUrl,
			bundled: isBundledMode,
		});
        
	} catch (error) {
		console.error("[Desktop App] Startup error:", error);
		if (splashWindow) {
			splashWindow.close();
		}
		if (runtimeProcess) {
			await shutdownRuntime();
		}
		if (serverProcess) {
			serverProcess.kill();
			serverProcess = null;
		}
		dialog.showErrorBox("Startup Error", `Failed to start ${APP_CONFIG.APP_DISPLAY_NAME}: ${error}`);
		void recordTelemetry("startup_error", {
			message: String(error),
		});
        app.quit();
    }
});

app.on("window-all-closed", () => {
    // On macOS, keep app running even when all windows are closed
    if (process.platform !== "darwin" && !APP_CONFIG.ENABLE_SYSTEM_TRAY) {
        app.quit();
    }
});

app.on("activate", async () => {
    // On macOS, re-create window when dock icon is clicked
    if (BrowserWindow.getAllWindows().length === 0) {
        await createMainWindow();
    }
});

app.on("before-quit", () => {
    if (runtimeProcess) {
        void shutdownRuntime();
    }
    // Clean up server process
    if (serverProcess) {
        console.log("[Desktop App] Terminating server process...");
        serverProcess.kill();
        serverProcess = null;
    }

    void shutdownLocalVrooli();
    void recordTelemetry("app_shutdown");
});

// Handle protocol for deep linking (optional)
app.setAsDefaultProtocolClient(APP_CONFIG.APP_NAME.toLowerCase());
app.on('open-url', (event, url) => {
    event.preventDefault();
    console.log(`[Desktop App] Protocol URL received: ${url}`);
    if (mainWindow) {
        mainWindow.webContents.send("protocol-url", url);
    }
});

process.on("uncaughtException", (error) => {
    console.error("[Desktop App] Uncaught exception:", error);
    dialog.showErrorBox("Application Error", `An unexpected error occurred: ${error.message}`);
});

process.on("unhandledRejection", (reason, promise) => {
    console.error("[Desktop App] Unhandled rejection at:", promise, "reason:", reason);
});
