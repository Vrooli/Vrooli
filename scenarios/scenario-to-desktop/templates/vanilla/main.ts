import { app, BrowserWindow, net, shell, Menu, ipcMain, dialog, Tray, nativeImage, clipboard } from "electron";
import { type ChildProcess, fork, spawn } from "node:child_process";
import { promises as fs } from "node:fs";
import path from "node:path";
import process from "node:process";
import { autoUpdater } from "electron-updater";

// ===== TEMPLATE CONFIGURATION - GENERATED BY SCENARIO-TO-DESKTOP =====
// This configuration is automatically populated during generation
const APP_CONFIG = {
    // Application identity
    APP_NAME: "{{APP_NAME}}",
    APP_DISPLAY_NAME: "{{APP_DISPLAY_NAME}}",
    APP_VERSION: "{{VERSION}}",
    APP_URL: "{{APP_URL}}",
    
    // Server configuration
    SERVER_TYPE: "{{SERVER_TYPE}}", // Options: 'node', 'static', 'external', 'executable'
    SERVER_PORT: {{SERVER_PORT}},
    SERVER_PATH: "{{SERVER_PATH}}", // Path to server entry point (relative to app root)
    API_ENDPOINT: "{{API_ENDPOINT}}", // Scenario API endpoint
    DEPLOYMENT_MODE: "{{DEPLOYMENT_MODE}}", // external-server | cloud-api | bundled
    
    // Window configuration  
    WINDOW_WIDTH: {{WINDOW_WIDTH}},
    WINDOW_HEIGHT: {{WINDOW_HEIGHT}},
    WINDOW_BACKGROUND: "{{WINDOW_BACKGROUND}}",
    WINDOW_TITLE: "{{APP_DISPLAY_NAME}}",
    
    // Feature configuration
    ENABLE_SPLASH: {{ENABLE_SPLASH}},
    ENABLE_MENU: {{ENABLE_MENU}},
    ENABLE_SYSTEM_TRAY: {{ENABLE_SYSTEM_TRAY}},
    ENABLE_AUTO_UPDATER: {{ENABLE_AUTO_UPDATER}},
    ENABLE_SINGLE_INSTANCE: {{ENABLE_SINGLE_INSTANCE}},
    ENABLE_DEV_TOOLS: {{ENABLE_DEV_TOOLS}},
    
    // Timing configuration
    SERVER_CHECK_INTERVAL_MS: 500,
    SERVER_CHECK_TIMEOUT_MS: 30000,
};

const LOCAL_VROOLI_BOOTSTRAP = {
    ENABLE: {{AUTO_MANAGE_VROOLI}},
    SCENARIO_NAME: "{{SCENARIO_NAME}}",
    VROOLI_BINARY: "{{VROOLI_BINARY_PATH}}",
};
const BUNDLED_RUNTIME = {
	SUPPORTED: {{BUNDLED_RUNTIME_SUPPORTED}},
	ROOT: "{{BUNDLED_RUNTIME_ROOT}}",
	IPC_HOST: "{{BUNDLED_RUNTIME_IPC_HOST}}",
	IPC_PORT: {{BUNDLED_RUNTIME_IPC_PORT}},
	TOKEN_REL: "{{BUNDLED_RUNTIME_TOKEN_PATH}}",
	UI_SERVICE: "{{BUNDLED_RUNTIME_UI_SERVICE}}",
	UI_PORT_NAME: "{{BUNDLED_RUNTIME_UI_PORT_NAME}}",
	TELEMETRY_UPLOAD_URL: "{{BUNDLED_RUNTIME_TELEMETRY_UPLOAD_URL}}",
	DOCS_URL: "docs/deployment/tiers/tier-2-desktop.md",
};

let serverProcess: ChildProcess | null = null;
let runtimeProcess: ChildProcess | null = null;
let mainWindow: BrowserWindow | null = null;
let splashWindow: BrowserWindow | null = null;
let tray: Tray | null = null;

const SERVER_URL = APP_CONFIG.SERVER_TYPE === 'external' 
    ? APP_CONFIG.SERVER_PATH 
    : `http://localhost:${APP_CONFIG.SERVER_PORT}`;

type TelemetryDetails = Record<string, unknown>;
interface LocalVrooliBootstrapState {
    vrooliPath?: string;
    setupCompleted?: boolean;
}
interface CommandResult {
    success: boolean;
    stdout: string;
    stderr: string;
    code: number;
}

let telemetryFilePath: string | null = null;
let bootstrapStateCache: LocalVrooliBootstrapState | null = null;
let bootstrapStatePath: string | null = null;
const localVrooliRuntime = {
    startedByApp: false,
    vrooliBinary: "",
};
const shouldBootstrapLocalVrooli = APP_CONFIG.DEPLOYMENT_MODE === "external-server"
    && LOCAL_VROOLI_BOOTSTRAP.ENABLE
    && Boolean(LOCAL_VROOLI_BOOTSTRAP.SCENARIO_NAME);
const isBundledMode = APP_CONFIG.DEPLOYMENT_MODE === "bundled";

const runtimeControlEnabled = (isBundledMode && BUNDLED_RUNTIME.SUPPORTED) || Boolean(
	process.env.RUNTIME_CONTROL_HOST ||
	process.env.RUNTIME_CONTROL_PORT ||
	process.env.RUNTIME_CONTROL_TOKEN_PATH ||
	process.env.RUNTIME_TELEMETRY_UPLOAD_URL
);

const RUNTIME_CONTROL = {
	ENABLED: runtimeControlEnabled,
	HOST: process.env.RUNTIME_CONTROL_HOST || BUNDLED_RUNTIME.IPC_HOST || "127.0.0.1",
	PORT: Number(process.env.RUNTIME_CONTROL_PORT || BUNDLED_RUNTIME.IPC_PORT || 47710),
	TOKEN_PATH_ENV: process.env.RUNTIME_CONTROL_TOKEN_PATH || "",
	TELEMETRY_UPLOAD_URL: process.env.RUNTIME_TELEMETRY_UPLOAD_URL || BUNDLED_RUNTIME.TELEMETRY_UPLOAD_URL || "",
	LOG_LINES: Number(process.env.RUNTIME_CONTROL_LOG_LINES || 200),
};

type RuntimeSecret = {
    id: string;
    class: string;
    required: boolean;
    has_value: boolean;
    description?: string;
    prompt?: Record<string, string>;
};

type RuntimeSecretsResponse = {
    secrets: RuntimeSecret[];
};

type RuntimeRequestOptions = {
    expectText?: boolean;
    method?: string;
    body?: unknown;
};

async function initializeTelemetry() {
    try {
        const userData = app.getPath("userData");
        telemetryFilePath = path.join(userData, "deployment-telemetry.jsonl");
        await fs.appendFile(telemetryFilePath, "");
        console.log(`[Desktop App] Telemetry initialized at ${telemetryFilePath}`);
    } catch (error) {
        telemetryFilePath = null;
        console.warn("[Desktop App] Failed to initialize telemetry:", error);
    }
}

async function recordTelemetry(event: string, details: TelemetryDetails = {}): Promise<void> {
    if (!telemetryFilePath) return;
    const payload = {
        timestamp: new Date().toISOString(),
        event,
        deploymentMode: APP_CONFIG.DEPLOYMENT_MODE,
        serverType: APP_CONFIG.SERVER_TYPE,
        details,
    };

    try {
        await fs.appendFile(telemetryFilePath, JSON.stringify(payload) + "\n");
    } catch (error) {
        console.warn("[Desktop App] Failed to write telemetry entry:", error);
    }
}

async function resolveRuntimeTokenPath(): Promise<string | null> {
	if (!RUNTIME_CONTROL.ENABLED) return null;
	if (RUNTIME_CONTROL.TOKEN_PATH_ENV) {
		return RUNTIME_CONTROL.TOKEN_PATH_ENV;
	}
	if (!app.isReady()) {
		await app.whenReady();
	}
	const rel = BUNDLED_RUNTIME.TOKEN_REL || "runtime/auth-token";
	return path.join(app.getPath("userData"), rel);
}

async function runtimeRequest<T = unknown>(endpoint: string, opts?: RuntimeRequestOptions): Promise<T | string> {
    if (!RUNTIME_CONTROL.ENABLED) {
        throw new Error("runtime control not enabled");
    }
    const tokenPath = await resolveRuntimeTokenPath();
    let token = "";
    if (tokenPath) {
        try {
            token = (await fs.readFile(tokenPath, "utf-8")).trim();
        } catch {
            // best-effort: runtime may still be starting
        }
    }

    const url = `http://${RUNTIME_CONTROL.HOST}:${RUNTIME_CONTROL.PORT}${endpoint}`;
    const headers: Record<string, string> = {};
    if (token && endpoint !== "/healthz") {
        headers.Authorization = `Bearer ${token}`;
    }

    const requestInit: RequestInit = {
        method: opts?.method || "GET",
        headers,
    };
    if (opts?.body !== undefined) {
        headers["Content-Type"] = "application/json";
        requestInit.body = JSON.stringify(opts.body);
    }

    const res = await fetch(url, requestInit);
    if (!res.ok) {
        const text = await res.text();
        throw new Error(`runtime request failed (${res.status}): ${text || res.statusText}`);
    }
    if (opts?.expectText) {
        return res.text();
    }
    return res.json();
}

async function waitForRuntimeControl(timeoutMs: number): Promise<void> {
    if (!RUNTIME_CONTROL.ENABLED) return;
    const url = `http://${RUNTIME_CONTROL.HOST}:${RUNTIME_CONTROL.PORT}/healthz`;
    const deadline = Date.now() + timeoutMs;
    while (Date.now() < deadline) {
        try {
            const res = await fetch(url);
            if (res.ok) {
                return;
            }
        } catch {
            // keep retrying
        }
        await new Promise((resolve) => setTimeout(resolve, 200));
    }
    throw new Error("Runtime control API did not respond before timeout");
}

async function showRuntimeDiagnostics(): Promise<void> {
    if (!RUNTIME_CONTROL.ENABLED) {
        await dialog.showMessageBox({
            type: "info",
            title: "Runtime diagnostics unavailable",
            message: "Runtime control is disabled for this build.",
        });
        return;
    }

    try {
        const ready = await runtimeRequest<{ ready: boolean; details: Record<string, { ready: boolean; message?: string }> }>("/readyz");
        const ports = await runtimeRequest<{ services: Record<string, Record<string, number>> }>("/ports");
        const telemetryInfo = await runtimeRequest<{ path?: string; upload_url?: string }>("/telemetry");

        const serviceId = Object.keys((ports as any).services || {})[0] || Object.keys((ready as any).details || {})[0];
        let logSnippet = "";
        if (serviceId) {
            const logData = await runtimeRequest<string>(`/logs/tail?serviceId=${encodeURIComponent(serviceId)}&lines=${RUNTIME_CONTROL.LOG_LINES}`, { expectText: true });
            if (typeof logData === "string") {
                logSnippet = logData;
            }
        }

    const messageLines = [
        `Ready: ${(ready as any).ready ? "yes" : "no"}`,
        `Services: ${Object.keys((ready as any).details || {}).length || Object.keys((ports as any).services || {}).length}`,
    ];
        if ((ports as any).services) {
            messageLines.push("Ports:");
            for (const [svc, svcPorts] of Object.entries((ports as any).services)) {
                const portList = Object.entries(svcPorts as Record<string, number>).map(([name, value]) => `${name}=${value}`).join(", ");
                messageLines.push(`  - ${svc}: ${portList}`);
            }
        }

        const buttons: string[] = ["Close"];
        const uploadURL = RUNTIME_CONTROL.TELEMETRY_UPLOAD_URL || (telemetryInfo as any).upload_url || "";
        if ((telemetryInfo as any).path) {
            buttons.unshift("Copy telemetry path");
        }
        if (uploadURL && (telemetryInfo as any).path) {
            buttons.unshift("Upload telemetry");
        }

        const result = await dialog.showMessageBox({
            type: (ready as any).ready ? "info" : "warning",
            title: "Bundled runtime diagnostics",
            message: messageLines.join("\n"),
            detail: logSnippet ? `Log tail (${serviceId || "unknown"}):\n${logSnippet}` : undefined,
            buttons,
            defaultId: buttons.length - 1,
        });

        const picked = buttons[result.response];
        if (picked === "Copy telemetry path" && (telemetryInfo as any).path) {
            clipboard.writeText((telemetryInfo as any).path);
            void recordTelemetry("runtime_diag_copy_path", { path: telemetryInfo });
        } else if (picked === "Upload telemetry" && (telemetryInfo as any).path) {
            try {
                const body = await fs.readFile((telemetryInfo as any).path, "utf-8");
                const resp = await fetch(uploadURL, {
                    method: "POST",
                    headers: { "Content-Type": "application/jsonl" },
                    body,
                });
                if (!resp.ok) {
                    const text = await resp.text();
                    throw new Error(text || resp.statusText);
                }
                void recordTelemetry("runtime_diag_upload_success", { uploadURL });
                await dialog.showMessageBox({
                    type: "info",
                    title: "Telemetry uploaded",
                    message: "Runtime telemetry uploaded successfully.",
                });
            } catch (error) {
                void recordTelemetry("runtime_diag_upload_failed", { error: String(error) });
                await dialog.showMessageBox({
                    type: "error",
                    title: "Telemetry upload failed",
                    message: String(error),
                });
            }
        }
    } catch (error) {
        await dialog.showMessageBox({
            type: "error",
            title: "Runtime diagnostics",
            message: `Failed to query runtime: ${error}`,
        });
    }
}

function escapeHTML(input: string): string {
    return input.replace(/[&<>"']/g, (char) => {
        switch (char) {
            case "&":
                return "&amp;";
            case "<":
                return "&lt;";
            case ">":
                return "&gt;";
            case '"':
                return "&quot;";
            case "'":
                return "&#39;";
            default:
                return char;
        }
    });
}

async function promptForSecretValue(secret: RuntimeSecret): Promise<string | null> {
    const channel = `secret-submit-${Date.now()}-${Math.random().toString(16).slice(2)}`;
    const parent = mainWindow ?? undefined;
    const modal = new BrowserWindow({
        parent,
        modal: true,
        width: 460,
        height: 320,
        resizable: false,
        minimizable: false,
        maximizable: false,
        title: `Configure ${APP_CONFIG.APP_DISPLAY_NAME}`,
        webPreferences: {
            nodeIntegration: true,
            contextIsolation: false,
        },
        show: false,
    });

    const label = escapeHTML(secret.prompt?.label || secret.id);
    const description = escapeHTML(secret.prompt?.description || secret.description || "Enter a value for this secret.");
    const body = `
<!doctype html>
<html>
<body style="font-family: sans-serif; padding: 16px; background: #0f172a; color: #e2e8f0;">
  <h2 style="margin-top: 0;">${label}</h2>
  <p style="margin-bottom: 12px;">${description}</p>
  <form id="secret-form" style="display: flex; flex-direction: column; gap: 12px;">
    <input id="secret-value" type="password" placeholder="Value" autofocus
      style="padding: 10px 12px; border-radius: 8px; border: 1px solid #334155; background: #1e293b; color: #e2e8f0;">
    <div style="display: flex; justify-content: flex-end; gap: 8px;">
      <button type="button" id="cancel" style="padding: 8px 12px; border-radius: 6px; border: 1px solid #334155; background: #0f172a; color: #e2e8f0;">Cancel</button>
      <button type="submit" style="padding: 8px 12px; border-radius: 6px; border: none; background: #10b981; color: #0f172a; font-weight: 600;">Save</button>
    </div>
  </form>
  <script>
    const { ipcRenderer } = require('electron');
    const form = document.getElementById('secret-form');
    const input = document.getElementById('secret-value');
    form.addEventListener('submit', (event) => {
      event.preventDefault();
      ipcRenderer.send('${channel}', input.value);
    });
    document.getElementById('cancel').addEventListener('click', () => {
      ipcRenderer.send('${channel}', null);
    });
  </script>
</body>
</html>
    `;

    await modal.loadURL(`data:text/html;charset=utf-8,${encodeURIComponent(body)}`);
    modal.once("ready-to-show", () => modal.show());

    return await new Promise<string | null>((resolve) => {
        let settled = false;
        const finish = (value: string | null) => {
            if (settled) return;
            settled = true;
            ipcMain.removeAllListeners(channel);
            if (!modal.isDestroyed()) {
                modal.close();
            }
            resolve(value);
        };
        ipcMain.once(channel, (_event, value: string | null) => finish(value));
        modal.on("closed", () => finish(null));
    });
}

async function ensureRuntimeSecretsIfNeeded(): Promise<void> {
    if (!RUNTIME_CONTROL.ENABLED) return;
    try {
        const fetchSecrets = async (): Promise<RuntimeSecret[]> => {
            const status = await runtimeRequest<RuntimeSecretsResponse>("/secrets");
            return (status as RuntimeSecretsResponse | undefined)?.secrets || [];
        };

        const current = await fetchSecrets();
        const missing = current.filter(
            (sec) => sec.class === "user_prompt" && sec.required && !sec.has_value,
        );
        if (missing.length === 0) {
            return;
        }

        const collected: Record<string, string> = {};
        for (const secret of missing) {
            const value = await promptForSecretValue(secret);
            if (value && value.trim() !== "") {
                collected[secret.id] = value.trim();
            }
        }

        if (Object.keys(collected).length === 0) {
            throw new Error("Required secrets were not provided. Restart and enter the missing values to continue.");
        }

        await runtimeRequest("/secrets", { method: "POST", body: { secrets: collected } });

        const refreshed = await fetchSecrets();
        const stillMissing = refreshed.filter(
            (sec) => sec.class === "user_prompt" && sec.required && !sec.has_value,
        );
        if (stillMissing.length > 0) {
            const ids = stillMissing.map((s) => s.id).join(", ");
            throw new Error(`Secrets still missing after submission: ${ids}`);
        }
    } catch (error) {
        console.error("[Desktop App] Failed to sync runtime secrets:", error);
        dialog.showErrorBox("Secrets required", String(error));
        throw error;
    }
}

async function getBootstrapStatePath(): Promise<string> {
    if (!bootstrapStatePath) {
        if (!app.isReady()) {
            await app.whenReady();
        }
        bootstrapStatePath = path.join(app.getPath("userData"), "local-vrooli-bootstrap.json");
    }
    return bootstrapStatePath;
}

async function loadBootstrapState(): Promise<LocalVrooliBootstrapState> {
    if (bootstrapStateCache) {
        return bootstrapStateCache;
    }

    try {
        const statePath = await getBootstrapStatePath();
        const raw = await fs.readFile(statePath, "utf-8");
        bootstrapStateCache = JSON.parse(raw) as LocalVrooliBootstrapState;
    } catch {
        bootstrapStateCache = {};
    }

    return bootstrapStateCache;
}

async function saveBootstrapState(state: LocalVrooliBootstrapState): Promise<void> {
    bootstrapStateCache = state;
    const statePath = await getBootstrapStatePath();
    await fs.writeFile(statePath, JSON.stringify(state, null, 2));
}

async function pathExists(filePath: string): Promise<boolean> {
    try {
        await fs.access(filePath);
        return true;
    } catch {
        return false;
    }
}

async function locateBinaryInPath(binary: string): Promise<string | null> {
    return new Promise((resolve) => {
        const locator = process.platform === "win32" ? "where" : "which";
        const checker = spawn(locator, [binary], { shell: false });
        let output = "";

        checker.stdout?.on("data", (data) => {
            output += data.toString();
        });

        checker.on("error", () => resolve(null));
        checker.on("close", (code) => {
            if (code === 0) {
                const line = output.split(/\r?\n/).find((item) => item.trim().length > 0);
                resolve(line?.trim() || binary);
            } else {
                resolve(null);
            }
        });
    });
}

async function promptForVrooliBinary(): Promise<string | null> {
    const response = await dialog.showMessageBox({
        type: "question",
        title: "Locate Vrooli",
        message: "The Vrooli CLI is required to start this scenario locally. Locate the vrooli binary or cancel to manage the server yourself.",
        buttons: ["Locate Vrooli", "Cancel"],
        defaultId: 0,
        cancelId: 1,
    });

    if (response.response !== 0) {
        return null;
    }

    const openResult = await dialog.showOpenDialog({
        title: "Select vrooli executable",
        properties: ["openFile"],
        filters: [
            { name: "Executable", extensions: process.platform === "win32" ? ["exe", "cmd", "bat"] : ["sh", ""] },
        ],
    });

    if (openResult.canceled || openResult.filePaths.length === 0) {
        return null;
    }

    return openResult.filePaths[0];
}

async function resolveVrooliCommand(): Promise<string | null> {
    if (!shouldBootstrapLocalVrooli) {
        return null;
    }

    if (localVrooliRuntime.vrooliBinary) {
        return localVrooliRuntime.vrooliBinary;
    }

    const preferred = LOCAL_VROOLI_BOOTSTRAP.VROOLI_BINARY?.trim();
    if (preferred && preferred !== "vrooli" && (preferred.includes(path.sep) || preferred.includes("/") || preferred.includes("\\"))) {
        if (await pathExists(preferred)) {
            localVrooliRuntime.vrooliBinary = preferred;
            return preferred;
        }
    } else if (preferred && preferred !== "" && preferred !== "vrooli") {
        localVrooliRuntime.vrooliBinary = preferred;
        return preferred;
    }

    const state = await loadBootstrapState();
    if (state.vrooliPath && await pathExists(state.vrooliPath)) {
        localVrooliRuntime.vrooliBinary = state.vrooliPath;
        return state.vrooliPath;
    }

    const located = await locateBinaryInPath("vrooli");
    if (located) {
        localVrooliRuntime.vrooliBinary = located;
        return located;
    }

    if (process.platform === "win32") {
        const locatedCmd = await locateBinaryInPath("vrooli.cmd");
        if (locatedCmd) {
            localVrooliRuntime.vrooliBinary = locatedCmd;
            return locatedCmd;
        }
    }

    const userSelection = await promptForVrooliBinary();
    if (userSelection) {
        const updatedState = await loadBootstrapState();
        updatedState.vrooliPath = userSelection;
        await saveBootstrapState(updatedState);
        localVrooliRuntime.vrooliBinary = userSelection;
        return userSelection;
    }

    return null;
}

async function runVrooliCommand(binary: string, args: string[], options: { timeoutMs?: number; ignoreErrors?: boolean } = {}): Promise<CommandResult> {
    return new Promise((resolve) => {
        const commandToRun = process.platform === "win32" && binary.includes(" ")
            ? `"${binary}"`
            : binary;
        const child = spawn(commandToRun, args, {
            shell: process.platform === "win32",
        });

        let stdout = "";
        let stderr = "";
        let finished = false;

        const timeout = options.timeoutMs
            ? setTimeout(() => {
                if (!finished) {
                    finished = true;
                    child.kill();
                    resolve({ success: false, stdout, stderr: `${stderr}\nCommand timed out`, code: -1 });
                }
            }, options.timeoutMs)
            : null;

        child.stdout?.on("data", (data) => {
            stdout += data.toString();
        });

        child.stderr?.on("data", (data) => {
            stderr += data.toString();
        });

        child.on("error", (error) => {
            if (timeout) {
                clearTimeout(timeout);
            }
            if (!finished) {
                finished = true;
                resolve({ success: false, stdout, stderr: error.message, code: -1 });
            }
        });

        child.on("close", (code) => {
            if (timeout) {
                clearTimeout(timeout);
            }
            if (finished) {
                return;
            }
            finished = true;
            const success = code === 0;
            if (!success && !options.ignoreErrors) {
                console.warn(`[Desktop App] Vrooli command failed: ${binary} ${args.join(" ")}`);
            }
            resolve({ success, stdout, stderr, code: code ?? -1 });
        });
    });
}

async function ensureVrooliSetup(vrooliBinary: string): Promise<boolean> {
    const state = await loadBootstrapState();
    if (state.setupCompleted) {
        return true;
    }

    void recordTelemetry("local_vrooli_setup_attempt");
    const setupResult = await runVrooliCommand(vrooliBinary, ["setup", "--yes", "yes", "--skip-sudo", "yes"], { timeoutMs: 5 * 60 * 1000 });
    if (!setupResult.success) {
        void recordTelemetry("local_vrooli_setup_failed", { stderr: setupResult.stderr });
        dialog.showErrorBox("Vrooli Setup Failed", "Unable to run 'vrooli setup'. Please run it manually and restart the desktop app.");
        return false;
    }

    state.setupCompleted = true;
    await saveBootstrapState(state);
    void recordTelemetry("local_vrooli_setup_completed");
    return true;
}

async function isScenarioRunning(vrooliBinary: string): Promise<boolean> {
    const statusResult = await runVrooliCommand(vrooliBinary, ["scenario", "status", LOCAL_VROOLI_BOOTSTRAP.SCENARIO_NAME!], { ignoreErrors: true, timeoutMs: 60 * 1000 });
    return statusResult.success;
}

async function waitForScenarioReady(vrooliBinary: string, attempts = 10): Promise<boolean> {
    for (let i = 0; i < attempts; i += 1) {
        if (await isScenarioRunning(vrooliBinary)) {
            return true;
        }
        await delay(3000);
    }
    return false;
}

async function ensureLocalVrooliReady(): Promise<void> {
    if (!shouldBootstrapLocalVrooli) {
        return;
    }

    const vrooliBinary = await resolveVrooliCommand();
    if (!vrooliBinary) {
        void recordTelemetry("local_vrooli_bootstrap_skipped", { reason: "vrooli_not_found" });
        dialog.showErrorBox("Vrooli CLI Missing", "Install the Vrooli CLI or run the scenario manually before launching the desktop app.");
        return;
    }

    if (!(await ensureVrooliSetup(vrooliBinary))) {
        return;
    }

    if (await isScenarioRunning(vrooliBinary)) {
        void recordTelemetry("local_vrooli_already_running");
        return;
    }

    void recordTelemetry("local_vrooli_start_attempt");
    const startResult = await runVrooliCommand(vrooliBinary, ["scenario", "start", LOCAL_VROOLI_BOOTSTRAP.SCENARIO_NAME!], { timeoutMs: 3 * 60 * 1000 });
    if (!startResult.success) {
        void recordTelemetry("local_vrooli_start_failed", { stderr: startResult.stderr });
        dialog.showErrorBox("Unable to Start Scenario", `vrooli failed to start ${LOCAL_VROOLI_BOOTSTRAP.SCENARIO_NAME}. Please inspect your Vrooli server.`);
        return;
    }

    localVrooliRuntime.startedByApp = true;
    const ready = await waitForScenarioReady(vrooliBinary);
    if (ready) {
        void recordTelemetry("local_vrooli_started");
    } else {
        void recordTelemetry("local_vrooli_start_timeout");
        dialog.showErrorBox("Scenario Not Ready", `${LOCAL_VROOLI_BOOTSTRAP.SCENARIO_NAME} did not become healthy in time. You may need to troubleshoot manually.`);
    }
}

async function shutdownLocalVrooli(): Promise<void> {
    if (!shouldBootstrapLocalVrooli || !localVrooliRuntime.startedByApp || !localVrooliRuntime.vrooliBinary) {
        return;
    }

    void recordTelemetry("local_vrooli_stop_attempt");
    await runVrooliCommand(localVrooliRuntime.vrooliBinary, ["scenario", "stop", LOCAL_VROOLI_BOOTSTRAP.SCENARIO_NAME!], { timeoutMs: 60 * 1000, ignoreErrors: true });
    localVrooliRuntime.startedByApp = false;
    void recordTelemetry("local_vrooli_stop_completed");
}

function delay(ms: number): Promise<void> {
    return new Promise((resolve) => {
        setTimeout(resolve, ms);
    });
}

// ===== UTILITY FUNCTIONS =====

function checkServerReady(url: string, timeout: number): Promise<void> {
    return new Promise((resolve, reject) => {
        let elapsedTime = 0;
        const interval = setInterval(() => {
            const request = net.request(url);
            request.on("response", (response) => {
                console.log(`[Desktop App] Server check successful (Status: ${response.statusCode}) at ${url}`);
                clearInterval(interval);
                request.abort();
                void recordTelemetry("server_ready", { url, statusCode: response.statusCode });
                resolve();
            });
            request.on("error", (error) => {
                if (!error.message.includes("ECONNREFUSED")) {
                    console.error(`[Desktop App] Server check error: ${error.message}`);
                }
                request.abort();
            });
            request.end();

            elapsedTime += APP_CONFIG.SERVER_CHECK_INTERVAL_MS;
            if (elapsedTime >= timeout) {
                clearInterval(interval);
                console.error(`[Desktop App] Server did not become ready at ${url} within ${timeout}ms.`);
                void recordTelemetry("dependency_unreachable", {
                    url,
                    timeoutMs: timeout,
                });
                reject(new Error(`Server not ready within timeout: ${url}`));
            }
        }, APP_CONFIG.SERVER_CHECK_INTERVAL_MS);
    });
}

function createSplashWindow() {
    if (!APP_CONFIG.ENABLE_SPLASH) return;
    
    console.log("[Desktop App] Creating splash window...");
    splashWindow = new BrowserWindow({
        width: 400,
        height: 300,
        frame: false,
        alwaysOnTop: true,
        transparent: true,
        webPreferences: {
            nodeIntegration: false,
            contextIsolation: true,
        },
    });

    splashWindow.loadFile(path.join(__dirname, "../splash.html"));
    
    splashWindow.on("closed", () => {
        splashWindow = null;
    });
}

async function createMainWindow() {
    console.log("[Desktop App] Creating main window (hidden)...");
    const appIcon = getAppIcon();
    mainWindow = new BrowserWindow({
        width: APP_CONFIG.WINDOW_WIDTH,
        height: APP_CONFIG.WINDOW_HEIGHT,
        show: false,
        backgroundColor: APP_CONFIG.WINDOW_BACKGROUND,
        title: APP_CONFIG.WINDOW_TITLE,
        webPreferences: {
            preload: path.join(__dirname, "preload.js"),
            nodeIntegration: false,
            contextIsolation: true,
        },
        ...(appIcon && { icon: appIcon }),
    });

    // Handle external link clicks
    mainWindow.webContents.setWindowOpenHandler(({ url }) => {
        shell.openExternal(url);
        return { action: 'deny' };
    });

    mainWindow.on("closed", () => {
        mainWindow = null;
    });

    // Enable DevTools in development
    if (APP_CONFIG.ENABLE_DEV_TOOLS && !app.isPackaged) {
        mainWindow.webContents.openDevTools();
    }

    return mainWindow;
}

function getAppIcon(): string | undefined {
    const iconPath = path.join(app.getAppPath(), "assets");
    
    if (process.platform === "win32") {
        return path.join(iconPath, "icon.ico");
    } else if (process.platform === "darwin") {
        return path.join(iconPath, "icon.icns");
    } else {
        return path.join(iconPath, "icon.png");
    }
}

function createSystemTray() {
    if (!APP_CONFIG.ENABLE_SYSTEM_TRAY) return;
    
    const iconPath = getAppIcon();
    if (!iconPath) return;
    
    try {
        const icon = nativeImage.createFromPath(iconPath);
        tray = new Tray(icon.resize({ width: 16, height: 16 }));
        
        const contextMenu = Menu.buildFromTemplate([
            {
                label: `Show ${APP_CONFIG.APP_DISPLAY_NAME}`,
                click: () => {
                    if (mainWindow) {
                        mainWindow.show();
                        mainWindow.focus();
                    }
                }
            },
            {
                label: `About ${APP_CONFIG.APP_DISPLAY_NAME}`,
                click: () => {
                    dialog.showMessageBox(mainWindow!, {
                        type: "info",
                        title: `About ${APP_CONFIG.APP_DISPLAY_NAME}`,
                        message: APP_CONFIG.APP_DISPLAY_NAME,
                        detail: `Version ${APP_CONFIG.APP_VERSION}\n\nBuilt with scenario-to-desktop`
                    });
                }
            },
            { type: "separator" },
            {
                label: "Quit",
                click: () => {
                    app.quit();
                }
            }
        ]);
        
        tray.setToolTip(APP_CONFIG.APP_DISPLAY_NAME);
        tray.setContextMenu(contextMenu);
        
        tray.on("double-click", () => {
            if (mainWindow) {
                mainWindow.show();
                mainWindow.focus();
            }
        });
    } catch (error) {
        console.error("[Desktop App] Failed to create system tray:", error);
    }
}

function createApplicationMenu() {
    if (!APP_CONFIG.ENABLE_MENU) return;
    
    const template: Electron.MenuItemConstructorOptions[] = [
        {
            label: "File",
            submenu: [
                {
                    label: "New",
                    accelerator: "CmdOrCtrl+N",
                    click: () => {
                        // Send message to renderer process
                        if (mainWindow) {
                            mainWindow.webContents.send("menu-action", { action: "new" });
                        }
                    }
                },
                {
                    label: "Open",
                    accelerator: "CmdOrCtrl+O",
                    click: async () => {
                        if (!mainWindow) return;
                        
                        const result = await dialog.showOpenDialog(mainWindow, {
                            properties: ["openFile"],
                            filters: [
                                { name: "All Files", extensions: ["*"] }
                            ]
                        });
                        
                        if (!result.canceled && result.filePaths.length > 0) {
                            mainWindow.webContents.send("menu-action", { 
                                action: "open", 
                                filePath: result.filePaths[0] 
                            });
                        }
                    }
                },
                { type: "separator" },
                process.platform === "darwin" ? { role: "close" } : { role: "quit" }
            ]
        },
        {
            label: "Edit",
            submenu: [
                { role: "undo" },
                { role: "redo" },
                { type: "separator" },
                { role: "cut" },
                { role: "copy" },
                { role: "paste" },
                { role: "selectAll" }
            ]
        },
        {
            label: "View",
            submenu: [
                { role: "reload" },
                { role: "forceReload" },
                { role: "toggleDevTools" },
                { type: "separator" },
                { role: "resetZoom" },
                { role: "zoomIn" },
                { role: "zoomOut" },
                { type: "separator" },
                { role: "togglefullscreen" },
                ...(RUNTIME_CONTROL.ENABLED ? [
                    { type: "separator" },
                    {
                        label: "Runtime Diagnostics",
                        click: () => {
                            void showRuntimeDiagnostics();
                        }
                    }
                ] : [])
            ]
        },
        {
            label: "Window",
            submenu: [
                { role: "minimize" },
                { role: "close" }
            ]
        },
        {
            label: "Help",
            submenu: [
                {
                    label: `About ${APP_CONFIG.APP_DISPLAY_NAME}`,
                    click: () => {
                        dialog.showMessageBox(mainWindow!, {
                            type: "info",
                            title: `About ${APP_CONFIG.APP_DISPLAY_NAME}`,
                            message: APP_CONFIG.APP_DISPLAY_NAME,
                            detail: `Version ${APP_CONFIG.APP_VERSION}\n\nBuilt with scenario-to-desktop\n\n${APP_CONFIG.APP_URL || ""}`
                        });
                    }
                }
            ]
        }
    ];

    const menu = Menu.buildFromTemplate(template);
    Menu.setApplicationMenu(menu);
}

function runtimePlatformKey(): string {
	const arch = process.arch === "x64" ? "x64" : process.arch;
	const os = process.platform === "darwin" ? "mac" : process.platform === "win32" ? "win" : "linux";
	return `${os}-${arch}`;
}

async function resolveBundleRoot(): Promise<string | null> {
	const bundleRoot = BUNDLED_RUNTIME.ROOT || "bundle";
	const candidates = [
		path.join(process.resourcesPath, bundleRoot),
		path.join(app.getAppPath(), bundleRoot),
	];

	for (const candidate of candidates) {
		if (await pathExists(candidate)) {
			return candidate;
		}
	}

	return null;
}

async function waitForFile(filePath: string, timeoutMs = 15000): Promise<void> {
	const deadline = Date.now() + timeoutMs;
	while (Date.now() < deadline) {
		if (await pathExists(filePath)) {
			return;
		}
		await new Promise((resolve) => setTimeout(resolve, 150));
	}
	throw new Error(`file not found within timeout: ${filePath}`);
}

function normalizeBundlePath(bundleRoot: string, rel: string): string {
	return path.join(bundleRoot, rel.replace(/\\/g, path.sep));
}

async function findChromiumPath(bundleRoot: string, manifestPath: string): Promise<string | null> {
	const candidates: string[] = [];

	try {
		const raw = await fs.readFile(manifestPath, "utf-8");
		const manifest = JSON.parse(raw) as { services?: Array<{ assets?: Array<{ path: string }>; env?: Record<string, string> }> };
		for (const svc of manifest.services || []) {
			for (const asset of svc.assets || []) {
				if (asset.path?.toLowerCase().includes("chromium") || asset.path?.toLowerCase().includes("playwright")) {
					candidates.push(asset.path);
				}
			}
			for (const value of Object.values(svc.env || {})) {
				if (typeof value === "string" && value.toLowerCase().includes("chromium")) {
					candidates.push(value);
				}
			}
		}
	} catch (error) {
		console.warn("[Desktop App] Unable to parse bundle manifest for Chromium detection", error);
	}

	for (const rel of candidates) {
		const candidate = path.isAbsolute(rel) ? rel : normalizeBundlePath(bundleRoot, rel);
		if (await pathExists(candidate)) {
			return candidate;
		}
	}

	const electronCandidates: string[] = [process.execPath];
	if (process.platform === "darwin") {
		electronCandidates.push(
			path.join(process.resourcesPath, "..", "Frameworks", "Electron Framework.framework", "Versions", "Current", "Helpers", "Electron Helper (Renderer).app", "Contents", "MacOS", "Electron Helper (Renderer)"),
			path.join(process.resourcesPath, "..", "Frameworks", "Electron Framework.framework", "Versions", "Current", "Resources", "electron")
		);
	} else if (process.platform === "win32") {
		electronCandidates.push(path.join(path.dirname(process.execPath), "chrome.exe"));
	} else {
		electronCandidates.push(path.join(path.dirname(process.execPath), "chrome"));
	}

	for (const candidate of electronCandidates) {
		if (await pathExists(candidate)) {
			return candidate;
		}
	}

	return null;
}

async function startBundledRuntime(): Promise<string> {
	const bundleRoot = await resolveBundleRoot();
	if (!bundleRoot) {
		throw new Error("Bundled payload is missing. Regenerate or reinstall the desktop app.");
	}

	const manifestPath = path.join(bundleRoot, "bundle.json");
	if (!(await pathExists(manifestPath))) {
		throw new Error(`Bundled manifest missing at ${manifestPath}`);
	}

	const runtimePath = path.join(
		bundleRoot,
		"runtime",
		runtimePlatformKey(),
		process.platform === "win32" ? "runtime.exe" : "runtime",
	);
	if (!(await pathExists(runtimePath))) {
		throw new Error(`Bundled runtime binary not found for this platform (${runtimePath})`);
	}

	const appData = path.join(app.getPath("userData"), "runtime");
	await fs.mkdir(appData, { recursive: true });

	const tokenRel = BUNDLED_RUNTIME.TOKEN_REL || "runtime/auth-token";
	const tokenPath = path.join(appData, tokenRel);
	RUNTIME_CONTROL.TOKEN_PATH_ENV = tokenPath;

	const args = [
		"--manifest",
		manifestPath,
		"--bundle-root",
		bundleRoot,
		"--app-data",
		appData,
		"--dry-run=false",
	];

	const chromiumPath = await findChromiumPath(bundleRoot, manifestPath);
	const runtimeEnv = { ...process.env };
	if (chromiumPath && !runtimeEnv.ELECTRON_CHROMIUM_PATH) {
		runtimeEnv.ELECTRON_CHROMIUM_PATH = chromiumPath;
	}

	runtimeProcess = spawn(runtimePath, args, {
		stdio: "inherit",
		env: runtimeEnv,
	});
	runtimeProcess.on("exit", (code, signal) => {
		void recordTelemetry("bundled_runtime_exit", { code, signal });
	});

	await waitForFile(tokenPath, APP_CONFIG.SERVER_CHECK_TIMEOUT_MS);
	await waitForRuntimeControl(APP_CONFIG.SERVER_CHECK_TIMEOUT_MS);
	await ensureRuntimeSecretsIfNeeded();

	const readyDeadline = Date.now() + APP_CONFIG.SERVER_CHECK_TIMEOUT_MS;
	while (Date.now() < readyDeadline) {
		try {
			const ready = await runtimeRequest<{ ready: boolean }>("/readyz");
			if ((ready as any)?.ready) {
				break;
			}
		} catch {
			// runtime may still be starting
		}
		await new Promise((resolve) => setTimeout(resolve, 350));
	}

	const ports = await runtimeRequest<{ services: Record<string, Record<string, number>> }>("/ports");
	const serviceId = BUNDLED_RUNTIME.UI_SERVICE || Object.keys((ports as any).services || {})[0];
	const portName = BUNDLED_RUNTIME.UI_PORT_NAME || "http";
	const svcPorts = (ports as any).services?.[serviceId];
	const port = svcPorts?.[portName];
	if (!serviceId || !port) {
		throw new Error("Bundled runtime started but did not expose a UI port");
	}

	const url = `http://127.0.0.1:${port}/`;
	await recordTelemetry("bundled_runtime_ready", {
		bundleRoot,
		serviceId,
		portName,
		port,
	});
	return url;
}

async function shutdownRuntime(): Promise<void> {
	if (RUNTIME_CONTROL.ENABLED) {
		try {
			await runtimeRequest("/shutdown", { method: "POST" });
		} catch (error) {
			console.warn("[Desktop App] Failed to request runtime shutdown", error);
		}
	}
	if (runtimeProcess) {
		try {
			runtimeProcess.kill();
		} catch {
			// ignore
		}
		runtimeProcess = null;
	}
}

async function startScenarioServer() {
    if (APP_CONFIG.SERVER_TYPE === "external") {
        console.log(`[Desktop App] Using external server: ${APP_CONFIG.SERVER_PATH}`);
        void recordTelemetry("external_server_mode", {
            serverPath: APP_CONFIG.SERVER_PATH,
        });
        return;
    }
    
    if (APP_CONFIG.SERVER_TYPE === "static") {
        console.log("[Desktop App] Using static files, no server to start");
        return;
    }

    const serverPath = path.resolve(app.getAppPath(), APP_CONFIG.SERVER_PATH);
    console.log(`[Desktop App] Starting scenario server: ${serverPath}`);

    try {
        if (APP_CONFIG.SERVER_TYPE === "node") {
            serverProcess = fork(serverPath, [], {
                env: {
                    ...process.env,
                    PORT: APP_CONFIG.SERVER_PORT.toString(),
                    DESKTOP_MODE: "true",
                    API_ENDPOINT: APP_CONFIG.API_ENDPOINT,
                },
                stdio: "inherit",
            });
        } else if (APP_CONFIG.SERVER_TYPE === "executable") {
            serverProcess = spawn(serverPath, [], {
                env: {
                    ...process.env,
                    PORT: APP_CONFIG.SERVER_PORT.toString(),
                    DESKTOP_MODE: "true",
                    API_ENDPOINT: APP_CONFIG.API_ENDPOINT,
                },
                stdio: "inherit",
            });
        }

        void recordTelemetry("local_server_started", {
            mode: APP_CONFIG.SERVER_TYPE,
            serverPath,
        });

        if (serverProcess) {
            serverProcess.on("error", (error) => {
                console.error(`[Desktop App] Server process error: ${error}`);
                dialog.showErrorBox("Server Error", `Failed to start scenario server: ${error.message}`);
            });

            serverProcess.on("exit", (code, signal) => {
                console.log(`[Desktop App] Server process exited with code ${code} and signal ${signal}`);
            });
        }
    } catch (error) {
        console.error(`[Desktop App] Failed to start server: ${error}`);
        dialog.showErrorBox("Startup Error", `Failed to start scenario server: ${error}`);
    }
}

function setupAutoUpdater() {
    if (!APP_CONFIG.ENABLE_AUTO_UPDATER || !app.isPackaged) return;
    
    autoUpdater.logger = console;
    
    autoUpdater.on("checking-for-update", () => {
        console.log("[Desktop App] Checking for update...");
    });
    
    autoUpdater.on("update-available", (info) => {
        console.log("[Desktop App] Update available:", info);
    });
    
    autoUpdater.on("update-not-available", (info) => {
        console.log("[Desktop App] Update not available:", info);
    });
    
    autoUpdater.on("error", (err) => {
        console.error("[Desktop App] Update error:", err);
    });
    
    autoUpdater.on("download-progress", (progressObj) => {
        const logMessage = `Download speed: ${progressObj.bytesPerSecond} - Downloaded ${progressObj.percent}% (${progressObj.transferred}/${progressObj.total})`;
        console.log(logMessage);
    });
    
    autoUpdater.on("update-downloaded", (info) => {
        console.log("[Desktop App] Update downloaded");
        autoUpdater.quitAndInstall();
    });
    
    // Check for updates
    autoUpdater.checkForUpdatesAndNotify();
}

// ===== IPC HANDLERS =====

// File operations
ipcMain.handle("file:save", async (event, data: { content: string; defaultPath?: string }) => {
    if (!mainWindow) return null;

    const dialogOptions: Electron.SaveDialogOptions = {
        filters: [
            { name: "All Files", extensions: ["*"] }
        ]
    };

    if (data.defaultPath) {
        dialogOptions.defaultPath = data.defaultPath;
    }

    const result = await dialog.showSaveDialog(mainWindow, dialogOptions);
    
    if (result.canceled) return null;
    
    const localFs = require("fs").promises;
    await localFs.writeFile(result.filePath, data.content);
    return result.filePath;
});

ipcMain.handle("file:open", async () => {
    if (!mainWindow) return null;
    
    const result = await dialog.showOpenDialog(mainWindow, {
        properties: ["openFile"],
        filters: [
            { name: "All Files", extensions: ["*"] }
        ]
    });
    
    if (result.canceled || result.filePaths.length === 0) return null;
    
    const localFs = require("fs").promises;
    const content = await localFs.readFile(result.filePaths[0], "utf-8");
    return { filePath: result.filePaths[0], content };
});

// System information
ipcMain.handle("system:info", () => {
    return {
        platform: process.platform,
        arch: process.arch,
        version: process.version,
        appVersion: APP_CONFIG.APP_VERSION,
        isPackaged: app.isPackaged,
    };
});

// Application control
ipcMain.handle("app:minimize", () => {
    if (mainWindow) {
        mainWindow.minimize();
    }
});

ipcMain.handle("app:maximize", () => {
    if (mainWindow) {
        if (mainWindow.isMaximized()) {
            mainWindow.unmaximize();
        } else {
            mainWindow.maximize();
        }
    }
});

ipcMain.handle("app:close", () => {
    if (mainWindow) {
        mainWindow.close();
    }
});

// ===== APP EVENT HANDLERS =====

app.whenReady().then(async () => {
    // Single instance lock
    if (APP_CONFIG.ENABLE_SINGLE_INSTANCE) {
        const gotTheLock = app.requestSingleInstanceLock();
        if (!gotTheLock) {
            app.quit();
            return;
        }
        
        app.on('second-instance', () => {
            if (mainWindow) {
                if (mainWindow.isMinimized()) mainWindow.restore();
                mainWindow.focus();
            }
        });
    }

    try {
        // Create splash screen
        createSplashWindow();
        
        // Set up auto updater
        setupAutoUpdater();
        
        // Create application menu
        createApplicationMenu();
        
        // Create system tray
        createSystemTray();
        
        await initializeTelemetry();
        await recordTelemetry("app_start", {
            deploymentMode: APP_CONFIG.DEPLOYMENT_MODE,
        });

		let targetUrl = SERVER_URL;

		if (isBundledMode) {
			if (!BUNDLED_RUNTIME.SUPPORTED) {
				const message = `Bundled builds require a bundle.json payload. Regenerate with DEPLOYMENT_MODE=external-server if you intended a thin client. Docs: ${BUNDLED_RUNTIME.DOCS_URL}`;
				dialog.showErrorBox("Bundled Mode Unavailable", message);
				void recordTelemetry("bundled_mode_blocked", {
					docsUrl: BUNDLED_RUNTIME.DOCS_URL,
				});
				app.quit();
				return;
			}

			try {
				targetUrl = await startBundledRuntime();
			} catch (startupError) {
				console.error("[Desktop App] Bundled runtime failed to start", startupError);
				await recordTelemetry("bundled_runtime_failed", { error: String(startupError) });
				dialog.showErrorBox("Bundled Startup Error", String(startupError));
				await shutdownRuntime();
				app.quit();
				return;
			}
		} else {
			if (shouldBootstrapLocalVrooli) {
				await ensureLocalVrooliReady();
			}

			// Start scenario server (thin client / embedded server modes)
			await startScenarioServer();
			if (RUNTIME_CONTROL.ENABLED) {
				try {
					await waitForRuntimeControl(APP_CONFIG.SERVER_CHECK_TIMEOUT_MS);
					await ensureRuntimeSecretsIfNeeded();
				} catch (secretError) {
					await recordTelemetry("runtime_secrets_missing", { error: String(secretError) });
					dialog.showErrorBox("Secrets required", String(secretError));
					app.quit();
					return;
				}
			}
		}

		// Create main window
		await createMainWindow();

		// Wait for server/runtime to be ready
		if (APP_CONFIG.SERVER_TYPE !== "static" || isBundledMode) {
			await checkServerReady(targetUrl, APP_CONFIG.SERVER_CHECK_TIMEOUT_MS);
		}

		// Load the application
		if (APP_CONFIG.SERVER_TYPE === "static" && !isBundledMode) {
			const staticPath = path.resolve(app.getAppPath(), APP_CONFIG.SERVER_PATH);
			await mainWindow!.loadFile(staticPath);
		} else {
			await mainWindow!.loadURL(targetUrl);
		}
        
        // Close splash and show main window
        if (splashWindow) {
            splashWindow.close();
        }
        mainWindow!.show();
        mainWindow!.focus();
        
		console.log(`[Desktop App] ${APP_CONFIG.APP_DISPLAY_NAME} ready!`);
		void recordTelemetry("app_ready", {
			serverUrl: targetUrl,
			bundled: isBundledMode,
		});
        
	} catch (error) {
		console.error("[Desktop App] Startup error:", error);
		if (splashWindow) {
			splashWindow.close();
		}
		if (runtimeProcess) {
			await shutdownRuntime();
		}
		if (serverProcess) {
			serverProcess.kill();
			serverProcess = null;
		}
		dialog.showErrorBox("Startup Error", `Failed to start ${APP_CONFIG.APP_DISPLAY_NAME}: ${error}`);
		void recordTelemetry("startup_error", {
			message: String(error),
		});
        app.quit();
    }
});

app.on("window-all-closed", () => {
    // On macOS, keep app running even when all windows are closed
    if (process.platform !== "darwin" && !APP_CONFIG.ENABLE_SYSTEM_TRAY) {
        app.quit();
    }
});

app.on("activate", async () => {
    // On macOS, re-create window when dock icon is clicked
    if (BrowserWindow.getAllWindows().length === 0) {
        await createMainWindow();
    }
});

app.on("before-quit", () => {
    if (runtimeProcess) {
        void shutdownRuntime();
    }
    // Clean up server process
    if (serverProcess) {
        console.log("[Desktop App] Terminating server process...");
        serverProcess.kill();
        serverProcess = null;
    }

    void shutdownLocalVrooli();
    void recordTelemetry("app_shutdown");
});

// Handle protocol for deep linking (optional)
app.setAsDefaultProtocolClient(APP_CONFIG.APP_NAME.toLowerCase());
app.on('open-url', (event, url) => {
    event.preventDefault();
    console.log(`[Desktop App] Protocol URL received: ${url}`);
    if (mainWindow) {
        mainWindow.webContents.send("protocol-url", url);
    }
});

process.on("uncaughtException", (error) => {
    console.error("[Desktop App] Uncaught exception:", error);
    dialog.showErrorBox("Application Error", `An unexpected error occurred: ${error.message}`);
});

process.on("unhandledRejection", (reason, promise) => {
    console.error("[Desktop App] Unhandled rejection at:", promise, "reason:", reason);
});
