import { contextBridge, ipcRenderer } from "electron";

// ===== DESKTOP API BRIDGE - GENERATED BY SCENARIO-TO-DESKTOP =====
// This preload script provides secure access to desktop features for the web application

// ===== TYPE DEFINITIONS =====

/**
 * File entry returned by storage.listDir()
 */
interface StorageFileEntry {
    name: string;
    path: string;
    isDirectory: boolean;
    isFile: boolean;
    size: number;
    createdAt: number;
    modifiedAt: number;
}

/**
 * File statistics returned by storage.stat()
 */
interface StorageFileStat {
    size: number;
    createdAt: number;
    modifiedAt: number;
    isDirectory: boolean;
    isFile: boolean;
}

/**
 * Storage usage information returned by storage.getStorageInfo()
 */
interface StorageInfo {
    used: number;      // Bytes used in storage directory
    available: number; // Bytes available on disk (estimate)
    count: number;     // Number of files in storage
}

// Define the API interface
interface DesktopAPI {
    // File operations (dialog-based - user selects location)
    file: {
        save: (content: string, defaultPath?: string) => Promise<string | null>;
        open: () => Promise<{ filePath: string; content: string } | null>;
    };

    // Storage operations (app-managed - within userData directory)
    storage: {
        /**
         * Get the base storage path for this application.
         * All storage operations are relative to this path.
         * @returns Absolute path to app storage directory (e.g., userData/app-storage)
         */
        getStoragePath: () => Promise<string>;

        /**
         * Ensure a directory exists, creating it and parents if needed.
         * @param relativePath - Path relative to storage root
         */
        ensureDir: (relativePath: string) => Promise<void>;

        /**
         * Write data to a file. Creates parent directories if needed.
         * @param relativePath - Path relative to storage root
         * @param data - String or ArrayBuffer to write
         */
        writeFile: (relativePath: string, data: string | ArrayBuffer) => Promise<void>;

        /**
         * Read a file as ArrayBuffer.
         * @param relativePath - Path relative to storage root
         * @returns File contents as ArrayBuffer, or null if not found
         */
        readFile: (relativePath: string) => Promise<ArrayBuffer | null>;

        /**
         * Read a file as UTF-8 string.
         * @param relativePath - Path relative to storage root
         * @returns File contents as string, or null if not found
         */
        readTextFile: (relativePath: string) => Promise<string | null>;

        /**
         * Delete a file.
         * @param relativePath - Path relative to storage root
         * @returns true if deleted, false if not found
         */
        deleteFile: (relativePath: string) => Promise<boolean>;

        /**
         * Delete a directory and all its contents recursively.
         * @param relativePath - Path relative to storage root
         * @returns true if deleted, false if not found
         */
        deleteDir: (relativePath: string) => Promise<boolean>;

        /**
         * List contents of a directory.
         * @param relativePath - Path relative to storage root
         * @returns Array of file entries, or null if directory doesn't exist
         */
        listDir: (relativePath: string) => Promise<StorageFileEntry[] | null>;

        /**
         * Check if a path exists.
         * @param relativePath - Path relative to storage root
         */
        exists: (relativePath: string) => Promise<boolean>;

        /**
         * Get file/directory statistics.
         * @param relativePath - Path relative to storage root
         * @returns Stats object, or null if not found
         */
        stat: (relativePath: string) => Promise<StorageFileStat | null>;

        /**
         * Get storage usage information.
         */
        getStorageInfo: () => Promise<StorageInfo>;
    };

    // System information
    system: {
        info: () => Promise<{
            platform: string;
            arch: string;
            version: string;
            appVersion: string;
            isPackaged: boolean;
        }>;
    };

    // Application control
    app: {
        minimize: () => Promise<void>;
        maximize: () => Promise<void>;
        close: () => Promise<void>;
    };

    // Event listeners
    on: (channel: string, callback: (data: any) => void) => void;
    off: (channel: string, callback: (data: any) => void) => void;

    // Send messages to main process
    send: (channel: string, data: any) => void;

    // Utility functions
    utils: {
        openExternal: (url: string) => void;
        showNotification: (title: string, body: string) => void;
    };
}

// Validate allowed channels for security
const ALLOWED_CHANNELS = {
    TO_MAIN: [
        // File operations (dialog-based)
        "file:save",
        "file:open",
        // Storage operations (app-managed)
        "storage:get-path",
        "storage:ensure-dir",
        "storage:write-file",
        "storage:read-file",
        "storage:read-text-file",
        "storage:delete-file",
        "storage:delete-dir",
        "storage:list-dir",
        "storage:exists",
        "storage:stat",
        "storage:get-info",
        // System
        "system:info",
        // App control
        "app:minimize",
        "app:maximize",
        "app:close",
        // Events
        "menu-action",
        "notification:show"
    ],
    FROM_MAIN: [
        "menu-action",
        "protocol-url",
        "notification:clicked"
    ]
};

function isValidChannel(channel: string, direction: 'TO_MAIN' | 'FROM_MAIN'): boolean {
    return ALLOWED_CHANNELS[direction].includes(channel);
}

// Create the desktop API
const desktopAPI: DesktopAPI = {
    // File operations (dialog-based - user selects location)
    file: {
        save: async (content: string, defaultPath?: string) => {
            return ipcRenderer.invoke("file:save", { content, defaultPath });
        },

        open: async () => {
            return ipcRenderer.invoke("file:open");
        }
    },

    // Storage operations (app-managed - within userData directory)
    storage: {
        getStoragePath: async () => {
            return ipcRenderer.invoke("storage:get-path");
        },

        ensureDir: async (relativePath: string) => {
            return ipcRenderer.invoke("storage:ensure-dir", relativePath);
        },

        writeFile: async (relativePath: string, data: string | ArrayBuffer) => {
            // Convert ArrayBuffer to Uint8Array for IPC serialization
            const payload = data instanceof ArrayBuffer ? Array.from(new Uint8Array(data)) : data;
            return ipcRenderer.invoke("storage:write-file", { path: relativePath, data: payload, isBinary: data instanceof ArrayBuffer });
        },

        readFile: async (relativePath: string) => {
            const result = await ipcRenderer.invoke("storage:read-file", relativePath);
            if (result === null) return null;
            // Convert back from array to ArrayBuffer
            return new Uint8Array(result).buffer;
        },

        readTextFile: async (relativePath: string) => {
            return ipcRenderer.invoke("storage:read-text-file", relativePath);
        },

        deleteFile: async (relativePath: string) => {
            return ipcRenderer.invoke("storage:delete-file", relativePath);
        },

        deleteDir: async (relativePath: string) => {
            return ipcRenderer.invoke("storage:delete-dir", relativePath);
        },

        listDir: async (relativePath: string) => {
            return ipcRenderer.invoke("storage:list-dir", relativePath);
        },

        exists: async (relativePath: string) => {
            return ipcRenderer.invoke("storage:exists", relativePath);
        },

        stat: async (relativePath: string) => {
            return ipcRenderer.invoke("storage:stat", relativePath);
        },

        getStorageInfo: async () => {
            return ipcRenderer.invoke("storage:get-info");
        }
    },

    // System information
    system: {
        info: async () => {
            return ipcRenderer.invoke("system:info");
        }
    },
    
    // Application control
    app: {
        minimize: async () => {
            return ipcRenderer.invoke("app:minimize");
        },
        
        maximize: async () => {
            return ipcRenderer.invoke("app:maximize");
        },
        
        close: async () => {
            return ipcRenderer.invoke("app:close");
        }
    },
    
    // Event listeners
    on: (channel: string, callback: (data: any) => void) => {
        if (isValidChannel(channel, 'FROM_MAIN')) {
            ipcRenderer.on(channel, (_, data) => callback(data));
        } else {
            console.warn(`[Desktop API] Invalid channel for listening: ${channel}`);
        }
    },
    
    off: (channel: string, callback: (data: any) => void) => {
        if (isValidChannel(channel, 'FROM_MAIN')) {
            ipcRenderer.off(channel, callback);
        } else {
            console.warn(`[Desktop API] Invalid channel for removal: ${channel}`);
        }
    },
    
    // Send messages to main process
    send: (channel: string, data: any) => {
        if (isValidChannel(channel, 'TO_MAIN')) {
            ipcRenderer.send(channel, data);
        } else {
            console.warn(`[Desktop API] Invalid channel for sending: ${channel}`);
        }
    },
    
    // Utility functions
    utils: {
        openExternal: (url: string) => {
            // This is handled by the main process through webContents.setWindowOpenHandler
            window.open(url, '_blank');
        },
        
        showNotification: (title: string, body: string) => {
            if ('Notification' in window) {
                // Use web notifications if available
                if (Notification.permission === 'granted') {
                    new Notification(title, { body });
                } else if (Notification.permission !== 'denied') {
                    Notification.requestPermission().then(permission => {
                        if (permission === 'granted') {
                            new Notification(title, { body });
                        }
                    });
                }
            } else {
                // Fallback: send to main process for native notification
                ipcRenderer.send("notification:show", { title, body });
            }
        }
    }
};

// Additional utility functions for common desktop app patterns
const desktopUtils = {
    // Check if running in desktop mode
    isDesktop: true,

    // Get desktop app information
    getAppInfo: async () => {
        return desktopAPI.system.info();
    },

    // Save data to a file with JSON serialization (dialog-based)
    saveJSON: async (data: any, defaultFilename?: string) => {
        const json = JSON.stringify(data, null, 2);
        const defaultPath = defaultFilename ? defaultFilename.endsWith('.json') ? defaultFilename : `${defaultFilename}.json` : undefined;
        return desktopAPI.file.save(json, defaultPath);
    },

    // Load and parse JSON data from a file (dialog-based)
    loadJSON: async () => {
        const result = await desktopAPI.file.open();
        if (!result) return null;

        try {
            const data = JSON.parse(result.content);
            return { filePath: result.filePath, data };
        } catch (error) {
            console.error('[Desktop Utils] Failed to parse JSON:', error);
            return null;
        }
    },

    // ===== Storage utilities (app-managed, within userData) =====

    /**
     * Store JSON data in app storage (no dialog, persistent).
     * @param relativePath - Path relative to storage root (e.g., "settings/preferences.json")
     * @param data - Any JSON-serializable data
     */
    storeJSON: async (relativePath: string, data: any) => {
        const json = JSON.stringify(data, null, 2);
        await desktopAPI.storage.writeFile(relativePath, json);
    },

    /**
     * Load JSON data from app storage.
     * @param relativePath - Path relative to storage root
     * @returns Parsed JSON data, or null if not found/invalid
     */
    loadStoredJSON: async (relativePath: string) => {
        const content = await desktopAPI.storage.readTextFile(relativePath);
        if (!content) return null;

        try {
            return JSON.parse(content);
        } catch (error) {
            console.error('[Desktop Utils] Failed to parse stored JSON:', error);
            return null;
        }
    },

    /**
     * Store binary data (e.g., images) in app storage.
     * @param relativePath - Path relative to storage root (e.g., "assets/logo.png")
     * @param data - ArrayBuffer or Blob
     */
    storeBlob: async (relativePath: string, data: ArrayBuffer | Blob) => {
        const buffer = data instanceof Blob ? await data.arrayBuffer() : data;
        await desktopAPI.storage.writeFile(relativePath, buffer);
    },

    /**
     * Load binary data from app storage as Blob.
     * @param relativePath - Path relative to storage root
     * @param mimeType - MIME type for the Blob (e.g., "image/png")
     * @returns Blob, or null if not found
     */
    loadStoredBlob: async (relativePath: string, mimeType: string = 'application/octet-stream') => {
        const buffer = await desktopAPI.storage.readFile(relativePath);
        if (!buffer) return null;
        return new Blob([buffer], { type: mimeType });
    },

    /**
     * Get a URL for a stored file (creates object URL from blob).
     * Remember to call URL.revokeObjectURL() when done to avoid memory leaks.
     * @param relativePath - Path relative to storage root
     * @param mimeType - MIME type for the Blob
     * @returns Object URL, or null if not found
     */
    getStoredFileUrl: async (relativePath: string, mimeType: string = 'application/octet-stream') => {
        const blob = await desktopUtils.loadStoredBlob(relativePath, mimeType);
        if (!blob) return null;
        return URL.createObjectURL(blob);
    },

    // Show a simple notification
    notify: (message: string, title: string = 'Notification') => {
        desktopAPI.utils.showNotification(title, message);
    },

    // Handle menu actions (common pattern for desktop apps)
    onMenuAction: (callback: (action: string, data?: any) => void) => {
        desktopAPI.on('menu-action', callback);
    },

    // Handle protocol URLs (deep linking)
    onProtocolUrl: (callback: (url: string) => void) => {
        desktopAPI.on('protocol-url', callback);
    }
};

// Expose the API to the renderer process
contextBridge.exposeInMainWorld("desktopAPI", desktopAPI);
contextBridge.exposeInMainWorld("desktopUtils", desktopUtils);

// Also expose some common patterns for easier use
contextBridge.exposeInMainWorld("desktop", {
    // Quick access to common functions (dialog-based file operations)
    save: desktopAPI.file.save,
    open: desktopAPI.file.open,
    saveJSON: desktopUtils.saveJSON,
    loadJSON: desktopUtils.loadJSON,

    // App-managed storage (within userData directory)
    storage: desktopAPI.storage,
    storeJSON: desktopUtils.storeJSON,
    loadStoredJSON: desktopUtils.loadStoredJSON,
    storeBlob: desktopUtils.storeBlob,
    loadStoredBlob: desktopUtils.loadStoredBlob,
    getStoredFileUrl: desktopUtils.getStoredFileUrl,

    // App control & utilities
    notify: desktopUtils.notify,
    minimize: desktopAPI.app.minimize,
    maximize: desktopAPI.app.maximize,
    close: desktopAPI.app.close,
    getInfo: desktopAPI.system.info,
    onMenuAction: desktopUtils.onMenuAction,
    onProtocolUrl: desktopUtils.onProtocolUrl,

    // Feature flags
    features: {
        fileSystem: true,
        appStorage: true,
        notifications: true,
        systemTray: {{ENABLE_SYSTEM_TRAY}},
        autoUpdater: {{ENABLE_AUTO_UPDATER}},
        multiWindow: false // Can be enabled in advanced templates
    }
});

// Add TypeScript declarations for window object (for development)
declare global {
    interface Window {
        desktopAPI: typeof desktopAPI;
        desktopUtils: typeof desktopUtils;
        desktop: {
            // Dialog-based file operations
            save: typeof desktopAPI.file.save;
            open: typeof desktopAPI.file.open;
            saveJSON: typeof desktopUtils.saveJSON;
            loadJSON: typeof desktopUtils.loadJSON;
            // App-managed storage
            storage: typeof desktopAPI.storage;
            storeJSON: typeof desktopUtils.storeJSON;
            loadStoredJSON: typeof desktopUtils.loadStoredJSON;
            storeBlob: typeof desktopUtils.storeBlob;
            loadStoredBlob: typeof desktopUtils.loadStoredBlob;
            getStoredFileUrl: typeof desktopUtils.getStoredFileUrl;
            // App control & utilities
            notify: typeof desktopUtils.notify;
            minimize: typeof desktopAPI.app.minimize;
            maximize: typeof desktopAPI.app.maximize;
            close: typeof desktopAPI.app.close;
            getInfo: typeof desktopAPI.system.info;
            onMenuAction: typeof desktopUtils.onMenuAction;
            onProtocolUrl: typeof desktopUtils.onProtocolUrl;
            features: {
                fileSystem: boolean;
                appStorage: boolean;
                notifications: boolean;
                systemTray: boolean;
                autoUpdater: boolean;
                multiWindow: boolean;
            };
        };
        // Export storage types for external use
        StorageFileEntry: StorageFileEntry;
        StorageFileStat: StorageFileStat;
        StorageInfo: StorageInfo;
    }
}

// Log successful initialization
console.log('[Desktop API] Preload script initialized successfully');
console.log('[Desktop API] Available features:', {
    fileSystem: true,
    appStorage: true,
    notifications: true,
    systemTray: {{ENABLE_SYSTEM_TRAY}},
    autoUpdater: {{ENABLE_AUTO_UPDATER}},
    multiWindow: false
});