#!/bin/bash

# scenario-to-desktop CLI
# Transform Vrooli scenarios into professional desktop applications

set -e  # Exit on error

# Configuration
CLI_VERSION="1.0.0"
# Use environment variable for API URL, fallback to default port (middle of range 15000-19999)
API_PORT="${API_PORT:-${PORT:-15200}}"
API_BASE_URL="${API_BASE_URL:-http://localhost:${API_PORT}}"
DEFAULT_OUTPUT_DIR="./desktop-app"
DEFAULT_FRAMEWORK="electron"
DEFAULT_TEMPLATE="basic"
DEFAULT_PLATFORMS="win,mac,linux"
DEFAULT_SERVER_TYPE="external"
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
REPO_ROOT="${REPO_ROOT_OVERRIDE:-$(cd "${SCRIPT_DIR}/../.." && pwd)}"
SCENARIOS_DIR="${SCENARIOS_DIR_OVERRIDE:-${REPO_ROOT}/scenarios}"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
PURPLE='\033[0;35m'
CYAN='\033[0;36m'
WHITE='\033[1;37m'
NC='\033[0m' # No Color

# Helper functions
log() {
    echo -e "${GREEN}[$(date +'%Y-%m-%d %H:%M:%S')]${NC} $1"
}

warn() {
    echo -e "${YELLOW}[WARN]${NC} $1" >&2
}

error() {
    echo -e "${RED}[ERROR]${NC} $1" >&2
}

info() {
    echo -e "${BLUE}[INFO]${NC} $1"
}

success() {
    echo -e "${GREEN}[SUCCESS]${NC} $1"
}

prompt_for_value() {
    local prompt_text="$1"
    local value=""
    if [ -t 0 ]; then
        read -r -p "$prompt_text: " value
    fi
    echo "$value"
}

load_saved_desktop_config() {
    local scenario_name="$1"
    local config_file="${SCENARIOS_DIR}/${scenario_name}/.vrooli/desktop-config.json"
    if [ -f "$config_file" ]; then
        cat "$config_file"
    fi
}

# Check dependencies
check_dependencies() {
    local missing_deps=()
    
    # Check Node.js
    if ! command -v node &> /dev/null; then
        missing_deps+=("node")
    else
        local node_version=$(node --version | sed 's/v//')
        local required_version="18.0.0"
        if ! version_gte "$node_version" "$required_version"; then
            missing_deps+=("node (>= $required_version, found $node_version)")
        fi
    fi
    
    # Check npm
    if ! command -v npm &> /dev/null; then
        missing_deps+=("npm")
    fi
    
    # Check curl for API calls
    if ! command -v curl &> /dev/null; then
        missing_deps+=("curl")
    fi
    
    # Check jq for JSON processing
    if ! command -v jq &> /dev/null; then
        missing_deps+=("jq")
    fi
    
    if [ ${#missing_deps[@]} -ne 0 ]; then
        error "Missing dependencies:"
        for dep in "${missing_deps[@]}"; do
            echo "  - $dep"
        done
        echo
        echo "Please install the missing dependencies and try again."
        exit 1
    fi
}

# Version comparison helper
version_gte() {
    printf '%s\n%s\n' "$2" "$1" | sort -V -C
}

# API helper functions
api_call() {
    local method=$1
    local endpoint=$2
    local data=${3:-}
    local headers=${4:-}
    
    local url="${API_BASE_URL}${endpoint}"
    local curl_args=(-s -X "$method")
    
    if [ -n "$headers" ]; then
        curl_args+=(-H "$headers")
    fi
    
    if [ -n "$data" ]; then
        curl_args+=(-H "Content-Type: application/json" -d "$data")
    fi
    
    curl_args+=("$url")
    
    curl "${curl_args[@]}"
}

check_api_health() {
    local response
    response=$(api_call "GET" "/api/v1/health" 2>/dev/null) || {
        error "Cannot connect to scenario-to-desktop API at $API_BASE_URL"
        echo "Please ensure the API server is running:"
        echo "  cd api && make run"
        exit 1
    }
    
    local status
    status=$(echo "$response" | jq -r '.status // empty')
    if [ "$status" != "healthy" ]; then
        error "API health check failed"
        exit 1
    fi
}

# Command functions
cmd_help() {
    cat << 'EOF'
scenario-to-desktop - Transform Vrooli scenarios into professional desktop applications

USAGE:
    scenario-to-desktop <COMMAND> [OPTIONS]

COMMANDS:
    help                Show this help message
    version             Show version information
    status              Show desktop generation system status
    templates           List available desktop application templates
    
    generate <scenario> Generate desktop application for a scenario
    build <path>        Build a desktop application project
    test <path>         Test desktop application functionality
    package <path>      Package desktop application for distribution
    telemetry           Collect and upload deployment telemetry from built apps

GLOBAL OPTIONS:
    --verbose, -v       Enable verbose output
    --json             Output in JSON format (where applicable)
    --api-url <url>    API base URL (default: http://localhost:${API_PORT})
    --help, -h         Show help for specific command

EXAMPLES:
    # Generate desktop app for picker-wheel scenario
    scenario-to-desktop generate picker-wheel

    # Generate with specific options
    scenario-to-desktop generate picker-wheel \
        --framework electron \
        --template advanced \
        --platforms win,mac \
        --output ./my-desktop-app

    # Build generated desktop app
    scenario-to-desktop build ./my-desktop-app

    # Test desktop app functionality
    scenario-to-desktop test ./my-desktop-app --headless

    # Package for distribution
    scenario-to-desktop package ./my-desktop-app --store microsoft

For more information about a specific command:
    scenario-to-desktop <command> --help

Visit https://vrooli.com/scenarios/scenario-to-desktop for documentation.
EOF
}

cmd_version() {
    if [ "$FORMAT" = "json" ]; then
        cat << EOF
{
  "version": "$CLI_VERSION",
  "api_url": "$API_BASE_URL",
  "framework_support": ["electron", "tauri", "neutralino"],
  "template_support": ["basic", "advanced", "multi_window", "kiosk"]
}
EOF
    else
        echo "scenario-to-desktop CLI v$CLI_VERSION"
        echo "API URL: $API_BASE_URL"
        echo "Framework support: electron, tauri, neutralino"
        echo "Template support: basic, advanced, multi_window, kiosk"
    fi
}

cmd_status() {
	check_api_health

	if [ "$server_type" = "external" ]; then
		if [ -z "$server_url" ] || [ -z "$api_url" ]; then
			error "Thin clients require --server-url and --api-url so the desktop wrapper knows where to connect."
			exit 1
		fi
	fi

	if [ "$deployment_mode" != "external-server" ]; then
		warn "Deployment mode '$deployment_mode' isn't supported yet. Using thin client (external-server)."
		deployment_mode="external-server"
	fi
    
    local response
    response=$(api_call "GET" "/api/v1/status")
    
    if [ "$FORMAT" = "json" ]; then
        echo "$response" | jq .
    else
        local service_name service_version service_status
        service_name=$(echo "$response" | jq -r '.service.name')
        service_version=$(echo "$response" | jq -r '.service.version')
        service_status=$(echo "$response" | jq -r '.service.status')
        
        echo -e "${WHITE}Desktop Generation System Status${NC}"
        echo "================================="
        echo "Service: $service_name v$service_version"
        echo "Status: $service_status"
        echo
        
        echo -e "${WHITE}Statistics:${NC}"
        echo "$response" | jq -r '.statistics | to_entries[] | "  \(.key): \(.value)"'
        echo
        
        echo -e "${WHITE}Capabilities:${NC}"
        echo "$response" | jq -r '.capabilities[] | "  - \(.)"'
        echo
        
        echo -e "${WHITE}Supported Frameworks:${NC}"
        echo "$response" | jq -r '.supported_frameworks[] | "  - \(.)"'
        echo
        
        echo -e "${WHITE}Supported Templates:${NC}"
        echo "$response" | jq -r '.supported_templates[] | "  - \(.)"'
    fi
}

cmd_templates() {
    check_api_health
    
    local response
    response=$(api_call "GET" "/api/v1/templates")
    
    if [ "$FORMAT" = "json" ]; then
        echo "$response" | jq .
    else
        local count
        count=$(echo "$response" | jq -r '.count')
        
        echo -e "${WHITE}Available Desktop Application Templates${NC}"
        echo "======================================"
        echo "Total templates: $count"
        echo
        
        echo "$response" | jq -r '.templates[] | "
\u001b[1;37m\(.name)\u001b[0m (\(.type))
  Description: \(.description)
  Framework: \(.framework)
  Complexity: \(.complexity)
  Use cases: \(.use_cases | join(", "))
  Features: \(.features | join(", "))
  Examples: \(.examples | join(", "))
"'
    fi
}

cmd_generate() {
    if [ $# -eq 0 ]; then
        error "Scenario name is required"
        echo "Usage: scenario-to-desktop generate <scenario-name> [OPTIONS]"
        echo "Run 'scenario-to-desktop generate --help' for more information"
        exit 1
    fi
    
	local scenario_name="$1"
	shift
    
    # Parse options
	local framework="$DEFAULT_FRAMEWORK"
	local template="$DEFAULT_TEMPLATE"
	local platforms="$DEFAULT_PLATFORMS"
	local output="$DEFAULT_OUTPUT_DIR"
	local features=""
	local config_file=""
	local deployment_mode="external-server"
	local server_type="$DEFAULT_SERVER_TYPE"
	local server_url=""
	local api_url=""
	local proxy_url=""
	local auto_manage_vrooli="false"
	local vrooli_binary_path="vrooli"
    
	while [[ $# -gt 0 ]]; do
		case $1 in
			--framework)
				framework="$2"
				shift 2
                ;;
            --template)
                template="$2"
                shift 2
                ;;
            --platforms)
                platforms="$2"
                shift 2
                ;;
            --output)
                output="$2"
                shift 2
                ;;
            --features)
                features="$2"
                shift 2
                ;;
			--config)
				config_file="$2"
				shift 2
				;;
			--deployment-mode)
				deployment_mode="$2"
				shift 2
				;;
			--server-type)
				server_type="$2"
				shift 2
				;;
			--server-url)
				server_url="$2"
				shift 2
				;;
			--api-url)
				api_url="$2"
				shift 2
				;;
			--proxy-url)
				proxy_url="$2"
				shift 2
				;;
			--auto-manage-vrooli|--auto-manage-tier1)
				auto_manage_vrooli="true"
				shift 1
				;;
			--vrooli-binary)
				vrooli_binary_path="$2"
				shift 2
				;;
            --help|-h)
                cmd_generate_help
                exit 0
                ;;
            *)
                error "Unknown option: $1"
                exit 1
                ;;
        esac
	done

	local saved_config_file="${SCENARIOS_DIR}/${scenario_name}/.vrooli/desktop-config.json"
	local saved_config_json=""
	if [ -f "$saved_config_file" ]; then
		saved_config_json=$(cat "$saved_config_file")
	fi

	if [ -z "$server_url" ] && [ -n "$saved_config_json" ]; then
		server_url=$(echo "$saved_config_json" | jq -r '.server_url // empty')
	fi
	if [ -z "$api_url" ] && [ -n "$saved_config_json" ]; then
		api_url=$(echo "$saved_config_json" | jq -r '.api_url // empty')
	fi
	if [ -z "$proxy_url" ] && [ -n "$saved_config_json" ]; then
		proxy_url=$(echo "$saved_config_json" | jq -r '.proxy_url // .server_url // empty')
	fi
	if [ "$deployment_mode" = "external-server" ] && [ -n "$saved_config_json" ]; then
		local saved_mode=$(echo "$saved_config_json" | jq -r '.deployment_mode // empty')
		if [ -n "$saved_mode" ]; then
			deployment_mode="$saved_mode"
		fi
	fi
	if [ "$auto_manage_vrooli" = "false" ] && [ -n "$saved_config_json" ]; then
		local saved_auto=$(echo "$saved_config_json" | jq -r '.auto_manage_vrooli // empty')
		if [ "$saved_auto" = "true" ]; then
			auto_manage_vrooli="true"
		fi
	fi
	if [ "$vrooli_binary_path" = "vrooli" ] && [ -n "$saved_config_json" ]; then
		local saved_cli=$(echo "$saved_config_json" | jq -r '.vrooli_binary_path // empty')
		if [ -n "$saved_cli" ]; then
			vrooli_binary_path="$saved_cli"
		fi
	fi
	if [ "$server_type" = "$DEFAULT_SERVER_TYPE" ] && [ -n "$saved_config_json" ]; then
		local saved_server_type=$(echo "$saved_config_json" | jq -r '.server_type // empty')
		if [ -n "$saved_server_type" ]; then
			server_type="$saved_server_type"
		fi
	fi

	if [ -z "$proxy_url" ] && [ -n "$server_url" ]; then
		proxy_url="$server_url"
	fi

	check_api_health

	if [ "$server_type" = "external" ]; then
		if [ -z "$proxy_url" ]; then
			proxy_url=$(prompt_for_value "Enter the proxy URL you already open in a browser (e.g. https://app-monitor.example.dev/apps/${scenario_name}/proxy/)")
		fi
		if [ -z "$proxy_url" ]; then
			error "Missing proxy URL. Provide --proxy-url or configure ${saved_config_file}."
			exit 1
		fi
		proxy_url="${proxy_url%/}/"
		server_url="$proxy_url"
		api_url="${proxy_url}api"
	fi
    
    # Build configuration
    local config
	local server_path_value="ui/server.js"
	local api_endpoint_value="http://localhost:3001/api"
	if [ "$server_type" = "external" ]; then
		server_path_value="$server_url"
		api_endpoint_value="$api_url"
	fi

	if [ -n "$config_file" ] && [ -f "$config_file" ]; then
        info "Using configuration file: $config_file"
        config=$(cat "$config_file")
    else
        # Build default configuration
        local platform_array
        IFS=',' read -ra ADDR <<< "$platforms"
        platform_array=$(printf '%s\n' "${ADDR[@]}" | jq -R . | jq -s .)
        
		config=$(cat << EOF
{
  "app_name": "${scenario_name}",
  "app_display_name": "${scenario_name^} Desktop",
  "app_description": "Desktop application for ${scenario_name} scenario",
  "version": "1.0.0",
  "author": "Vrooli Platform",
  "license": "MIT",
  "app_id": "com.vrooli.${scenario_name//-/.}",
  "server_type": "${server_type}",
  "server_port": 3000,
  "server_path": "${server_path_value}",
  "api_endpoint": "${api_endpoint_value}",
  "framework": "$framework",
  "template_type": "$template",
  "platforms": $platform_array,
  "output_path": "$output",
  "features": {
    "splash": true,
    "autoUpdater": true,
    "devTools": true
  },
  "window": {
    "width": 1200,
    "height": 800,
    "background": "#f5f5f5"
  },
  "deployment_mode": "${deployment_mode}",
  "proxy_url": "${proxy_url}",
  "auto_manage_vrooli": ${auto_manage_vrooli},
  "vrooli_binary_path": "${vrooli_binary_path}",
  "external_server_url": "${server_url}",
  "external_api_url": "${api_url}"
}
EOF
)
    fi
    
	log "Generating desktop application for $scenario_name..."
	log "Framework: $framework"
	log "Template: $template"
	log "Platforms: $platforms"
	log "Output: $output"
	log "Server type: $server_type"
	log "Deployment mode: $deployment_mode"
    
    local response
    response=$(api_call "POST" "/api/v1/desktop/generate" "$config")
    
    local build_id status desktop_path
    build_id=$(echo "$response" | jq -r '.build_id')
    status=$(echo "$response" | jq -r '.status')
    desktop_path=$(echo "$response" | jq -r '.desktop_path')
    
    if [ "$status" = "building" ]; then
        info "Build started with ID: $build_id"
        info "Desktop path: $desktop_path"
        
        # Poll for completion
        cmd_wait_for_build "$build_id"
    else
        error "Failed to start build"
        echo "$response" | jq .
        exit 1
    fi
}

cmd_generate_help() {
    cat << 'EOF'
Generate desktop application for a scenario

USAGE:
    scenario-to-desktop generate <scenario-name> [OPTIONS]

OPTIONS:
    --framework <framework>    Desktop framework (electron, tauri, neutralino) [default: electron]
    --template <template>      Application template (basic, advanced, multi_window, kiosk) [default: basic]
    --platforms <platforms>    Target platforms, comma-separated (win,mac,linux) [default: win,mac,linux]
    --output <path>           Output directory for generated application [default: ./desktop-app]
    --features <features>     Comma-separated list of features (tray,updater,menus)
    --config <file>           Use JSON configuration file instead of command-line options
    --deployment-mode <mode>  Deployment intent (external-server|cloud-api|bundled) [default: external-server]
    --server-type <type>      Server strategy (external|node|static|executable) [default: external]
    --proxy-url <url>         Proxy/Cloudflare URL you already open in a browser (preferred)
    --server-url <url>        Legacy alias for --proxy-url
    --api-url <url>           Legacy alias for --proxy-url + /api
    --auto-manage-vrooli      Let the desktop app run `vrooli setup/start/stop` locally (advanced)
    --vrooli-binary <path>    Path to vrooli CLI when auto-managing the scenario [default: vrooli]

EXAMPLES:
    # Basic generation
    scenario-to-desktop generate picker-wheel

    # Advanced configuration
    scenario-to-desktop generate picker-wheel \
        --framework electron \
        --template advanced \
        --platforms win,mac \
        --output ./picker-wheel-desktop \
        --features tray,updater,menus

    # Using configuration file
    scenario-to-desktop generate picker-wheel --config config.json

CONFIGURATION FILE FORMAT:
    {
      "app_name": "picker-wheel",
      "app_display_name": "Picker Wheel Desktop",
      "app_description": "Desktop picker wheel application",
      "version": "1.0.0",
      "author": "Your Name",
      "framework": "electron",
      "template_type": "basic",
      "platforms": ["win", "mac", "linux"],
      "output_path": "./desktop-app"
    }
EOF
}

cmd_build() {
    if [ $# -eq 0 ]; then
        error "Desktop application path is required"
        echo "Usage: scenario-to-desktop build <desktop-path> [OPTIONS]"
        exit 1
    fi
    
    local desktop_path="$1"
    shift
    
    # Parse options
    local platforms=""
    local sign=false
    local publish=false
    
    while [[ $# -gt 0 ]]; do
        case $1 in
            --platforms)
                platforms="$2"
                shift 2
                ;;
            --sign)
                sign=true
                shift
                ;;
            --publish)
                publish=true
                shift
                ;;
            --help|-h)
                cmd_build_help
                exit 0
                ;;
            *)
                error "Unknown option: $1"
                exit 1
                ;;
        esac
    done
    
    check_api_health
    
    if [ ! -d "$desktop_path" ]; then
        error "Desktop application directory not found: $desktop_path"
        exit 1
    fi
    
    local platform_array
    if [ -n "$platforms" ]; then
        IFS=',' read -ra ADDR <<< "$platforms"
        platform_array=$(printf '%s\n' "${ADDR[@]}" | jq -R . | jq -s .)
    else
        platform_array='["win", "mac", "linux"]'
    fi
    
    local config
    config=$(cat << EOF
{
  "desktop_path": "$desktop_path",
  "platforms": $platform_array,
  "sign": $sign,
  "publish": $publish
}
EOF
)
    
    log "Building desktop application at $desktop_path..."
    
    local response
    response=$(api_call "POST" "/api/v1/desktop/build" "$config")
    
    local build_id status
    build_id=$(echo "$response" | jq -r '.build_id')
    status=$(echo "$response" | jq -r '.status')
    
    if [ "$status" = "building" ]; then
        info "Build started with ID: $build_id"
        cmd_wait_for_build "$build_id"
    else
        error "Failed to start build"
        echo "$response" | jq .
        exit 1
    fi
}

cmd_build_help() {
    cat << 'EOF'
Build a desktop application project

USAGE:
    scenario-to-desktop build <desktop-path> [OPTIONS]

OPTIONS:
    --platforms <platforms>    Platforms to build for (win,mac,linux or 'all') [default: all]
    --sign                     Code sign the applications (requires certificates)
    --publish                  Publish to configured distribution channels

EXAMPLES:
    # Build for all platforms
    scenario-to-desktop build ./my-desktop-app

    # Build for specific platforms
    scenario-to-desktop build ./my-desktop-app --platforms win,mac

    # Build with code signing
    scenario-to-desktop build ./my-desktop-app --sign

    # Build and publish
    scenario-to-desktop build ./my-desktop-app --sign --publish
EOF
}

cmd_test() {
    if [ $# -eq 0 ]; then
        error "Desktop application path is required"
        echo "Usage: scenario-to-desktop test <app-path> [OPTIONS]"
        exit 1
    fi
    
    local app_path="$1"
    shift
    
    # Parse options
    local platforms=""
    local headless=false
    
    while [[ $# -gt 0 ]]; do
        case $1 in
            --platforms)
                platforms="$2"
                shift 2
                ;;
            --headless)
                headless=true
                shift
                ;;
            --help|-h)
                cmd_test_help
                exit 0
                ;;
            *)
                error "Unknown option: $1"
                exit 1
                ;;
        esac
    done
    
    check_api_health
    
    local platform_array
    if [ -n "$platforms" ]; then
        IFS=',' read -ra ADDR <<< "$platforms"
        platform_array=$(printf '%s\n' "${ADDR[@]}" | jq -R . | jq -s .)
    else
        platform_array='[]'
    fi
    
    local config
    config=$(cat << EOF
{
  "app_path": "$app_path",
  "platforms": $platform_array,
  "headless": $headless
}
EOF
)
    
    log "Testing desktop application at $app_path..."
    
    local response
    response=$(api_call "POST" "/api/v1/desktop/test" "$config")
    
    local status
    status=$(echo "$response" | jq -r '.status')
    
    if [ "$status" = "completed" ]; then
        success "Tests completed successfully"
        if [ "$FORMAT" = "json" ]; then
            echo "$response" | jq .
        else
            echo -e "${WHITE}Test Results:${NC}"
            echo "$response" | jq -r '.test_results | to_entries[] | "  \(.key): \(.value)"'
        fi
    else
        error "Tests failed"
        echo "$response" | jq .
        exit 1
    fi
}

cmd_test_help() {
    cat << 'EOF'
Test desktop application functionality

USAGE:
    scenario-to-desktop test <app-path> [OPTIONS]

OPTIONS:
    --platforms <platforms>    Platforms to test on (current platform by default)
    --headless                 Run tests in headless mode

EXAMPLES:
    # Test desktop application
    scenario-to-desktop test ./my-desktop-app

    # Test in headless mode
    scenario-to-desktop test ./my-desktop-app --headless

    # Test on specific platforms
    scenario-to-desktop test ./my-desktop-app --platforms linux
EOF
}

cmd_package() {
    if [ $# -eq 0 ]; then
        error "Desktop application path is required"
        echo "Usage: scenario-to-desktop package <app-path> [OPTIONS]"
        exit 1
    fi
    
    local app_path="$1"
    shift
    
    # Parse options
    local store=""
    local enterprise=false
    
    while [[ $# -gt 0 ]]; do
        case $1 in
            --store)
                store="$2"
                shift 2
                ;;
            --enterprise)
                enterprise=true
                shift
                ;;
            --help|-h)
                cmd_package_help
                exit 0
                ;;
            *)
                error "Unknown option: $1"
                exit 1
                ;;
        esac
    done
    
    check_api_health
    
    local config
    config=$(cat << EOF
{
  "app_path": "$app_path",
  "store": "$store",
  "enterprise": $enterprise
}
EOF
)
    
    log "Packaging desktop application at $app_path..."
    
    local response
    response=$(api_call "POST" "/api/v1/desktop/package" "$config")
    
    local status
    status=$(echo "$response" | jq -r '.status')
    
    if [ "$status" = "completed" ]; then
        success "Packaging completed successfully"
        if [ "$FORMAT" = "json" ]; then
            echo "$response" | jq .
        else
            echo -e "${WHITE}Package Results:${NC}"
            echo "$response" | jq -r '.packages[] | "  - \(.)"'
        fi
    else
        error "Packaging failed"
        echo "$response" | jq .
        exit 1
    fi
}

cmd_package_help() {
    cat << 'EOF'
Package desktop application for distribution

USAGE:
    scenario-to-desktop package <app-path> [OPTIONS]

OPTIONS:
    --store <store>       Target store (microsoft, mac, snap, all)
    --enterprise          Create enterprise deployment packages

EXAMPLES:
    # Package for all stores
    scenario-to-desktop package ./my-desktop-app

    # Package for specific store
    scenario-to-desktop package ./my-desktop-app --store microsoft

    # Create enterprise packages
    scenario-to-desktop package ./my-desktop-app --enterprise
EOF
}

cmd_wait_for_build() {
    local build_id="$1"
    local max_wait=600  # 10 minutes
    local wait_interval=5
    local elapsed=0
    
    info "Waiting for build to complete..."
    
    while [ $elapsed -lt $max_wait ]; do
        local response
        response=$(api_call "GET" "/api/v1/desktop/status/$build_id")
        
        local status
        status=$(echo "$response" | jq -r '.status')
        
        case $status in
            "building")
                printf "."
                sleep $wait_interval
                elapsed=$((elapsed + wait_interval))
                ;;
            "ready")
                echo
                success "Build completed successfully!"
                
                local output_path
                output_path=$(echo "$response" | jq -r '.output_path // empty')
                if [ -n "$output_path" ]; then
                    echo
                    echo -e "${WHITE}Next steps:${NC}"
                    echo "  cd $output_path"
                    echo "  npm run dev"
                    echo
                    echo -e "${WHITE}Build for distribution:${NC}"
                    echo "  npm run dist"
                fi
                return 0
                ;;
            "failed")
                echo
                error "Build failed!"
                local error_log
                error_log=$(echo "$response" | jq -r '.error_log[]? // empty')
                if [ -n "$error_log" ]; then
                    echo -e "${RED}Error details:${NC}"
                    echo "$error_log"
                fi
                exit 1
                ;;
            *)
                echo
                error "Unknown build status: $status"
                exit 1
                ;;
        esac
    done
    
    echo
    error "Build timed out after $max_wait seconds"
    exit 1
}

cmd_telemetry() {
    if [ $# -eq 0 ] || [[ $1 = "help" || $1 = "--help" || $1 = "-h" ]]; then
        cmd_telemetry_help
        return
    fi

    case $1 in
        collect)
            shift
            cmd_telemetry_collect "$@"
            ;;
        *)
            error "Unknown telemetry subcommand: $1"
            cmd_telemetry_help
            exit 1
            ;;
    esac
}

cmd_telemetry_collect() {
    local scenario=""
    local file_path=""
    local deployment_mode="external-server"

    while [[ $# -gt 0 ]]; do
        case $1 in
            --scenario)
                scenario="$2"
                shift 2
                ;;
            --file)
                file_path="$2"
                shift 2
                ;;
            --deployment-mode)
                deployment_mode="$2"
                shift 2
                ;;
            --help|-h)
                cmd_telemetry_help
                exit 0
                ;;
            *)
                error "Unknown option: $1"
                exit 1
                ;;
        esac
    done

    if [ -z "$scenario" ]; then
        error "--scenario is required"
        exit 1
    fi
    if [ -z "$file_path" ]; then
        error "--file is required"
        exit 1
    fi
    if [ ! -f "$file_path" ]; then
        error "Telemetry file not found: $file_path"
        exit 1
    fi

    local events_json
    if ! events_json=$(jq -Rs 'split("\n") | map(select(length > 0) | (try (fromjson) catch {"raw": .}))' "$file_path"); then
        error "Failed to parse telemetry JSONL at $file_path"
        exit 1
    fi

    local payload
    payload=$(jq -n --arg scenario "$scenario" --arg mode "$deployment_mode" --arg source "$file_path" --argjson events "$events_json" '{scenario_name:$scenario,deployment_mode:$mode,source:$source,events:$events}')

    local response
    response=$(api_call "POST" "/api/v1/deployment/telemetry" "$payload")
    success "Uploaded telemetry for $scenario"
    echo "$response" | jq .
}

cmd_telemetry_help() {
    cat << 'EOF'
Telemetry commands

USAGE:
    scenario-to-desktop telemetry collect --scenario <name> --file <deployment-telemetry.jsonl>

OPTIONS:
    --scenario <name>         Scenario name the telemetry belongs to
    --file <path>             Path to deployment-telemetry.jsonl generated by the desktop app
    --deployment-mode <mode>  Override deployment mode metadata (default: external-server)

EXAMPLE:
    scenario-to-desktop telemetry collect \
        --scenario picker-wheel \
        --file "$HOME/Library/Application Support/Picker Wheel/deployment-telemetry.jsonl"
EOF
}

# Main function
main() {
    # Global options
    VERBOSE=false
    FORMAT="text"
    
    # Parse global options
    while [[ $# -gt 0 ]]; do
        case $1 in
            --verbose|-v)
                VERBOSE=true
                shift
                ;;
            --json)
                FORMAT="json"
                shift
                ;;
            --api-url)
                API_BASE_URL="$2"
                shift 2
                ;;
            --help|-h)
                cmd_help
                exit 0
                ;;
            *)
                break
                ;;
        esac
    done
    
    # Check for command
    if [ $# -eq 0 ]; then
        cmd_help
        exit 1
    fi
    
    local command="$1"
    shift
    
    # Check dependencies for most commands
    case $command in
        help|version)
            # These commands don't need dependencies
            ;;
        *)
            check_dependencies
            ;;
    esac
    
    # Route to appropriate command
    case $command in
        help|--help|-h)
            cmd_help
            ;;
        version|--version|-V)
            cmd_version
            ;;
        status)
            cmd_status "$@"
            ;;
        templates)
            cmd_templates "$@"
            ;;
        generate)
            cmd_generate "$@"
            ;;
        build)
            cmd_build "$@"
            ;;
        test)
            cmd_test "$@"
            ;;
        package)
            cmd_package "$@"
            ;;
        telemetry)
            cmd_telemetry "$@"
            ;;
        *)
            error "Unknown command: $command"
            echo "Run 'scenario-to-desktop help' for available commands"
            exit 1
            ;;
    esac
}

# Execute main function with all arguments
main "$@"
