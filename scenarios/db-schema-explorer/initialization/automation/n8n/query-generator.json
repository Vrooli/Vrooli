{
  "name": "Natural Language to SQL Generator",
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "query/generate",
        "responseMode": "responseNode",
        "options": {}
      },
      "id": "webhook_trigger",
      "name": "Webhook Trigger",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 1.1,
      "position": [200, 300]
    },
    {
      "parameters": {},
      "id": "manual_trigger",
      "name": "Manual Trigger",
      "type": "n8n-nodes-base.manualTrigger",
      "typeVersion": 1,
      "position": [200, 500]
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// Return test defaults for manual trigger\nreturn {\n  natural_language: 'Show me all tables with more than 10 columns',\n  database_context: 'main',\n  schema_name: 'public',\n  include_explanation: true\n};"
      },
      "id": "set_test_defaults",
      "name": "Set Test Defaults",
      "type": "n8n-nodes-base.code",
      "typeVersion": 1,
      "position": [400, 500]
    },
    {
      "parameters": {},
      "id": "merge_triggers",
      "name": "Merge Triggers",
      "type": "n8n-nodes-base.merge",
      "typeVersion": 2.1,
      "position": [600, 400]
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// Validate input and prepare for SQL generation\nconst input = $input.item.json;\n\n// Validate natural language query\nif (!input.natural_language || typeof input.natural_language !== 'string') {\n  throw new Error('natural_language is required');\n}\n\nconst naturalLanguage = input.natural_language.trim();\nif (naturalLanguage.length < 3) {\n  throw new Error('Query too short');\n}\nif (naturalLanguage.length > 1000) {\n  throw new Error('Query too long (max 1000 characters)');\n}\n\n// Get context parameters\nconst databaseContext = (input.database_context || 'main').trim();\nconst schemaName = (input.schema_name || 'public').trim();\nconst includeExplanation = input.include_explanation !== false;\n\n// First, we need to get the schema context for better SQL generation\nconst schemaQuery = `\nSELECT json_build_object(\n  'tables', (\n    SELECT json_agg(json_build_object(\n      'name', table_name,\n      'columns', (\n        SELECT json_agg(json_build_object(\n          'name', column_name,\n          'type', data_type,\n          'nullable', is_nullable\n        ) ORDER BY ordinal_position)\n        FROM information_schema.columns\n        WHERE table_schema = t.table_schema\n          AND table_name = t.table_name\n      )\n    ))\n    FROM information_schema.tables t\n    WHERE table_schema = '${schemaName}'\n      AND table_type = 'BASE TABLE'\n    LIMIT 20\n  )\n) as schema_context;\n`;\n\nconst timestamp = Date.now();\nconst randomId = Math.random().toString(36).substring(2, 8);\nconst schemaFile = `/tmp/schema_context_${timestamp}_${randomId}.sql`;\n\n// Escape the query for shell\nconst escapedSchemaQuery = schemaQuery.replace(/'/g, \"'\\\"'\\\"'\");\n\n// Build command to get schema context\nconst schemaCommand = `\nquery_file=\"${schemaFile}\"\necho '${escapedSchemaQuery}' > \"$query_file\"\nschema_json=$(vrooli resource postgres query \"$(cat \"$query_file\")\" --database \"${databaseContext}\" --format json 2>/dev/null | grep -o '{.*}' | head -1)\nrm -f \"$query_file\"\necho \"$schema_json\"\n`;\n\nreturn {\n  schema_command: schemaCommand,\n  query_params: {\n    natural_language: naturalLanguage,\n    database_context: databaseContext,\n    schema_name: schemaName,\n    include_explanation: includeExplanation,\n    execution_id: `query_gen_${timestamp}_${randomId}`,\n    timestamp: new Date().toISOString()\n  }\n};"
      },
      "id": "validate_input",
      "name": "Validate Input",
      "type": "n8n-nodes-base.code",
      "typeVersion": 1,
      "position": [800, 400]
    },
    {
      "parameters": {
        "command": "={{ $json.schema_command }}",
        "options": {
          "timeout": 10000
        }
      },
      "id": "get_schema_context",
      "name": "Get Schema Context",
      "type": "n8n-nodes-base.executeCommand",
      "typeVersion": 1,
      "position": [1000, 400]
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// Build prompt for Ollama with schema context\nconst schemaResult = $input.item.json;\nconst queryParams = $('Validate Input').item.json.query_params;\n\n// Parse schema context\nlet schemaContext = 'Schema information unavailable';\ntry {\n  if (schemaResult.stdout) {\n    const parsed = JSON.parse(schemaResult.stdout.trim());\n    if (parsed.schema_context && parsed.schema_context.tables) {\n      const tables = parsed.schema_context.tables;\n      schemaContext = 'Available tables and columns:\\n';\n      tables.forEach(table => {\n        schemaContext += `\\nTable: ${table.name}\\n`;\n        if (table.columns && table.columns.length > 0) {\n          table.columns.slice(0, 10).forEach(col => {\n            schemaContext += `  - ${col.name} (${col.type}${col.nullable === 'NO' ? ', NOT NULL' : ''})\\n`;\n          });\n          if (table.columns.length > 10) {\n            schemaContext += `  ... and ${table.columns.length - 10} more columns\\n`;\n          }\n        }\n      });\n    }\n  }\n} catch (e) {\n  console.log('Could not parse schema context:', e.message);\n}\n\n// Build the prompt for SQL generation\nconst prompt = `You are a PostgreSQL expert. Convert the following natural language query to SQL.\n\nDatabase Context:\n- Database: ${queryParams.database_context}\n- Schema: ${queryParams.schema_name}\n\n${schemaContext}\n\nNatural Language Query: \"${queryParams.natural_language}\"\n\nRequirements:\n1. Generate valid PostgreSQL SQL\n2. Use the ${queryParams.schema_name} schema\n3. Only reference tables and columns that exist in the schema\n4. Add appropriate JOINs if multiple tables are needed\n5. Include reasonable LIMIT clauses for SELECT queries (default to 100)\n${queryParams.include_explanation ? '6. Provide a brief explanation of what the query does' : ''}\n\nResponse format:\n{\n  \"sql\": \"Your SQL query here\",\n  ${queryParams.include_explanation ? '\"explanation\": \"Brief explanation of the query\",\\n  ' : ''}\n  \"tables_used\": [\"list\", \"of\", \"tables\"],\n  \"query_type\": \"SELECT|INSERT|UPDATE|DELETE|DDL\"\n}\n\nRespond ONLY with valid JSON, no additional text.`;\n\n// Build Ollama command using the shared workflow\nconst timestamp = Date.now();\nconst randomId = Math.random().toString(36).substring(2, 8);\nconst promptFile = `/tmp/sql_prompt_${timestamp}_${randomId}.txt`;\n\n// Escape prompt for shell\nconst escapedPrompt = prompt.replace(/'/g, \"'\\\"'\\\"'\");\n\nconst ollamaCommand = `\nprompt_file=\"${promptFile}\"\necho '${escapedPrompt}' > \"$prompt_file\"\nresult=$(vrooli resource ollama generate \"$(cat \"$prompt_file\")\" --model codellama --type code --quiet)\nrm -f \"$prompt_file\"\necho \"$result\"\n`;\n\nreturn {\n  ollama_command: ollamaCommand,\n  query_params: queryParams,\n  schema_available: schemaContext !== 'Schema information unavailable'\n};"
      },
      "id": "build_prompt",
      "name": "Build Prompt",
      "type": "n8n-nodes-base.code",
      "typeVersion": 1,
      "position": [1200, 400]
    },
    {
      "parameters": {
        "command": "={{ $json.ollama_command }}",
        "options": {
          "timeout": 30000
        }
      },
      "id": "generate_sql",
      "name": "Generate SQL",
      "type": "n8n-nodes-base.executeCommand",
      "typeVersion": 1,
      "position": [1400, 400]
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// Process SQL generation results\nconst ollamaResult = $input.item.json;\nconst queryParams = $('Validate Input').item.json.query_params;\nconst schemaAvailable = $('Build Prompt').item.json.schema_available;\n\n// Initialize result\nlet result = {\n  success: false,\n  natural_language: queryParams.natural_language,\n  database_context: queryParams.database_context,\n  schema_name: queryParams.schema_name,\n  sql: null,\n  explanation: null,\n  tables_used: [],\n  query_type: null,\n  confidence: 0,\n  schema_context_available: schemaAvailable,\n  execution: {\n    execution_id: queryParams.execution_id,\n    timestamp: queryParams.timestamp,\n    generation_time_ms: Date.now() - new Date(queryParams.timestamp).getTime()\n  },\n  error: null\n};\n\n// Process Ollama output\nif (ollamaResult.exitCode === 0 && ollamaResult.stdout) {\n  try {\n    const output = ollamaResult.stdout.trim();\n    \n    // Try to extract JSON from the output\n    let jsonStr = output;\n    \n    // Find JSON object in the output\n    const jsonMatch = output.match(/{[^}]*\"sql\"[^}]*}/s);\n    if (jsonMatch) {\n      jsonStr = jsonMatch[0];\n    }\n    \n    const parsed = JSON.parse(jsonStr);\n    \n    if (parsed.sql) {\n      result.success = true;\n      result.sql = parsed.sql;\n      result.explanation = parsed.explanation || null;\n      result.tables_used = parsed.tables_used || [];\n      result.query_type = parsed.query_type || 'SELECT';\n      \n      // Calculate confidence based on various factors\n      let confidence = 70; // Base confidence\n      if (schemaAvailable) confidence += 20; // Schema context available\n      if (parsed.explanation) confidence += 5; // Has explanation\n      if (result.tables_used.length > 0) confidence += 5; // Identified tables\n      result.confidence = Math.min(100, confidence);\n      \n      // Basic SQL validation\n      const sqlLower = result.sql.toLowerCase();\n      const hasSelect = sqlLower.includes('select');\n      const hasFrom = sqlLower.includes('from');\n      const hasSemicolon = result.sql.includes(';');\n      \n      if (result.query_type === 'SELECT' && (!hasSelect || !hasFrom)) {\n        result.confidence -= 30;\n        result.warning = 'Generated SQL may be incomplete or invalid';\n      }\n      \n      // Add semicolon if missing\n      if (!hasSemicolon && result.sql.trim().length > 0) {\n        result.sql = result.sql.trim() + ';';\n      }\n    } else {\n      throw new Error('No SQL generated in response');\n    }\n  } catch (error) {\n    result.error = {\n      message: 'Failed to generate SQL: ' + error.message,\n      raw_output: ollamaResult.stdout,\n      stderr: ollamaResult.stderr\n    };\n  }\n} else {\n  result.error = {\n    message: 'SQL generation failed',\n    exit_code: ollamaResult.exitCode,\n    stderr: ollamaResult.stderr || 'No error details available'\n  };\n}\n\n// Add similar queries suggestion (mock for now, would use Qdrant in production)\nif (result.success) {\n  result.similar_queries = [\n    {\n      natural_language: 'Show all tables in the database',\n      sql: \"SELECT table_name FROM information_schema.tables WHERE table_schema = 'public';\",\n      usage_count: 42\n    }\n  ];\n}\n\nreturn result;"
      },
      "id": "process_results",
      "name": "Process Results",
      "type": "n8n-nodes-base.code",
      "typeVersion": 1,
      "position": [1600, 400]
    },
    {
      "parameters": {
        "conditions": {
          "boolean": [
            {
              "value1": "={{ $json.success }}",
              "value2": true
            }
          ]
        }
      },
      "id": "check_success",
      "name": "Success Check",
      "type": "n8n-nodes-base.if",
      "typeVersion": 1,
      "position": [1800, 400]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ JSON.stringify($json, null, 2) }}"
      },
      "id": "success_response",
      "name": "Success Response",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1,
      "position": [2000, 300]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseCode": 500,
        "responseBody": "={{ JSON.stringify($json, null, 2) }}"
      },
      "id": "error_response",
      "name": "Error Response",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1,
      "position": [2000, 500]
    }
  ],
  "connections": {
    "Webhook Trigger": {
      "main": [
        [
          {
            "node": "Merge Triggers",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Manual Trigger": {
      "main": [
        [
          {
            "node": "Set Test Defaults",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Set Test Defaults": {
      "main": [
        [
          {
            "node": "Merge Triggers",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Merge Triggers": {
      "main": [
        [
          {
            "node": "Validate Input",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Validate Input": {
      "main": [
        [
          {
            "node": "Get Schema Context",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get Schema Context": {
      "main": [
        [
          {
            "node": "Build Prompt",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build Prompt": {
      "main": [
        [
          {
            "node": "Generate SQL",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Generate SQL": {
      "main": [
        [
          {
            "node": "Process Results",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Process Results": {
      "main": [
        [
          {
            "node": "Success Check",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Success Check": {
      "main": [
        [
          {
            "node": "Success Response",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Error Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "settings": {
    "executionOrder": "v1"
  },
  "staticData": null,
  "tags": [],
  "triggerCount": 0,
  "updatedAt": "2025-01-06T00:00:00.000Z",
  "versionId": "db-schema-explorer-v1"
}