#!/bin/bash
################################################################################
# AI Model Orchestra Controller CLI - Lightweight API Wrapper
# 
# Intelligent AI model routing and resource management system for optimal 
# performance and cost efficiency. Port discovery uses vrooli scenario port 
# command for dynamic allocation.
################################################################################

set -e

# Configuration
SCENARIO_NAME="ai-model-orchestra-controller"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
PURPLE='\033[0;35m'
NC='\033[0m' # No Color

################################################################################
# Port Discovery - Dynamic port lookup
################################################################################
get_api_url() {
    # Use vrooli scenario port command for dynamic port lookup
    local api_port
    api_port=$(vrooli scenario port "${SCENARIO_NAME}" API_PORT 2>/dev/null)
    
    if [[ -z "$api_port" ]]; then
        echo -e "${RED}âŒ Error: ${SCENARIO_NAME} is not running${NC}" >&2
        echo "   Start it with: vrooli scenario run ${SCENARIO_NAME}" >&2
        exit 1
    fi
    
    echo "http://localhost:${api_port}"
}

################################################################################
# Helper Functions
################################################################################
show_help() {
    echo -e "${CYAN}ðŸŽ›ï¸  AI Model Orchestra Controller CLI${NC}"
    echo "Intelligent AI model routing and resource management for optimal performance"
    echo ""
    echo "Usage: ai-orchestra [command] [options]"
    echo ""
    echo "Commands:"
    echo -e "  ${GREEN}select${NC} TASK_TYPE              Select optimal model for given task type"
    echo -e "  ${GREEN}route${NC} TASK_TYPE PROMPT        Route complete AI request through orchestrator"  
    echo -e "  ${GREEN}models${NC}                         List available models with status"
    echo -e "  ${GREEN}resources${NC}                      Show system resource usage and pressure"
    echo -e "  ${GREEN}health${NC}                         Check orchestrator system health"
    echo -e "  ${GREEN}status${NC}                         Show orchestration status and model availability"
    echo -e "  ${GREEN}help${NC}                           Show this help message"
    echo -e "  ${GREEN}version${NC}                        Show version information"
    echo ""
    echo "Task Types:"
    echo "  completion, reasoning, code, embedding, analysis"
    echo ""
    echo "Options:"
    echo "  --complexity LEVEL               Task complexity (simple/moderate/complex)"
    echo "  --priority LEVEL                 Request priority (low/normal/high/critical)"
    echo "  --cost-limit AMOUNT              Maximum cost per request"
    echo "  --max-tokens N                   Maximum tokens to generate"
    echo "  --temperature N                  Sampling temperature (0.0-1.0)"
    echo "  --retry-attempts N               Number of retry attempts"
    echo "  --include-metrics                Include performance metrics"
    echo "  --hours N                        Hours of history to include"
    echo "  --json                           Output raw JSON"
    echo ""
    echo "Examples:"
    echo "  ai-orchestra select completion --complexity moderate --priority high"
    echo "  ai-orchestra route reasoning 'Explain quantum computing' --max-tokens 500"
    echo "  ai-orchestra models --include-metrics"
    echo "  ai-orchestra resources --hours 24"
    echo "  ai-orchestra health --json"
}

show_version() {
    local api_url
    api_url=$(get_api_url 2>/dev/null || echo "API not running")
    echo "ai-orchestra CLI v1.0.0"
    echo "API: ${api_url}"
    echo "Scenario: ${SCENARIO_NAME}"
}

# Format JSON output if jq is available
format_json() {
    if command -v jq >/dev/null 2>&1; then
        jq .
    else
        cat
    fi
}

# Make API request
api_request() {
    local method="$1"
    local endpoint="$2"
    local data="${3:-}"
    local api_url
    
    # Get the current API URL
    api_url=$(get_api_url)
    
    local curl_args=(-s)
    
    if [[ "$method" != "GET" ]]; then
        curl_args+=(-X "$method")
    fi
    
    if [[ -n "$data" ]]; then
        curl_args+=(-H "Content-Type: application/json" -d "$data")
    fi
    
    local response
    response=$(curl "${curl_args[@]}" "${api_url}${endpoint}")
    
    # Check for error
    if echo "$response" | grep -q '"error"'; then
        echo -e "${RED}Error:${NC}" >&2
        echo "$response" | format_json >&2
        exit 1
    fi
    
    echo "$response"
}

################################################################################
# Command Handlers
################################################################################
select_model() {
    local task_type="$1"
    local complexity=""
    local priority=""
    local cost_limit=""
    local max_tokens=""
    local quality_requirement=""
    local json_output=false
    
    shift
    while [[ $# -gt 0 ]]; do
        case $1 in
            --complexity)
                complexity="$2"
                shift 2
                ;;
            --priority)
                priority="$2"
                shift 2
                ;;
            --cost-limit)
                cost_limit="$2"
                shift 2
                ;;
            --max-tokens)
                max_tokens="$2"
                shift 2
                ;;
            --quality)
                quality_requirement="$2"
                shift 2
                ;;
            --json)
                json_output=true
                shift
                ;;
            *)
                shift
                ;;
        esac
    done
    
    if [[ -z "$task_type" ]]; then
        echo -e "${RED}Error: Task type required${NC}" >&2
        echo "Usage: ai-orchestra select TASK_TYPE [options]" >&2
        echo "Task types: completion, reasoning, code, embedding, analysis" >&2
        exit 1
    fi
    
    # Build JSON payload
    local requirements
    requirements=$(jq -n \
        --arg complexity "$complexity" \
        --arg priority "$priority" \
        --arg cost_limit "$cost_limit" \
        --arg max_tokens "$max_tokens" \
        --arg quality "$quality_requirement" \
        '{
            complexity: (if $complexity == "" then null else $complexity end),
            priority: (if $priority == "" then null else $priority end),
            costLimit: (if $cost_limit == "" then null else ($cost_limit | tonumber) end),
            maxTokens: (if $max_tokens == "" then null else ($max_tokens | tonumber) end),
            qualityRequirement: (if $quality == "" then null else $quality end)
        }')
    
    local payload
    payload=$(jq -n \
        --arg task_type "$task_type" \
        --argjson requirements "$requirements" \
        '{
            taskType: $task_type,
            requirements: $requirements
        }')
    
    local response
    response=$(api_request "POST" "/api/v1/ai/select-model" "$payload")
    
    if [[ "$json_output" == "true" ]]; then
        echo "$response" | format_json
    else
        echo -e "${GREEN}âœ“ Model selected successfully${NC}"
        echo "$response" | jq -r '"Selected model: \(.selectedModel)\nRequest ID: \(.requestId)\nFallback used: \(.fallbackUsed)"'
        
        echo ""
        echo -e "${BLUE}System Metrics:${NC}"
        echo "$response" | jq -r '.systemMetrics | "  Memory pressure: \(.memoryPressure * 100 | round)%\n  Available memory: \(.availableMemoryGb | round)GB\n  CPU usage: \(.cpuUsage | round)%"'
        
        echo ""
        echo -e "${PURPLE}Model Info:${NC}"
        echo "$response" | jq -r '.modelInfo | "  Capabilities: \(.capabilities | join(", "))\n  Speed: \(.speed)\n  Quality tier: \(.quality_tier)"'
        
        local alternatives
        alternatives=$(echo "$response" | jq -r '.alternatives[]?' 2>/dev/null || echo "")
        if [[ -n "$alternatives" ]]; then
            echo ""
            echo -e "${YELLOW}Alternative models:${NC} $alternatives"
        fi
    fi
}

route_request() {
    local task_type="$1"
    local prompt="$2"
    local max_tokens=""
    local temperature=""
    local priority=""
    local retry_attempts=""
    local json_output=false
    
    shift 2
    while [[ $# -gt 0 ]]; do
        case $1 in
            --max-tokens)
                max_tokens="$2"
                shift 2
                ;;
            --temperature)
                temperature="$2"
                shift 2
                ;;
            --priority)
                priority="$2"
                shift 2
                ;;
            --retry-attempts)
                retry_attempts="$2"
                shift 2
                ;;
            --json)
                json_output=true
                shift
                ;;
            *)
                shift
                ;;
        esac
    done
    
    if [[ -z "$task_type" || -z "$prompt" ]]; then
        echo -e "${RED}Error: Task type and prompt required${NC}" >&2
        echo "Usage: ai-orchestra route TASK_TYPE PROMPT [options]" >&2
        exit 1
    fi
    
    # Build JSON payload
    local requirements
    requirements=$(jq -n \
        --arg max_tokens "$max_tokens" \
        --arg temperature "$temperature" \
        --arg priority "$priority" \
        '{
            maxTokens: (if $max_tokens == "" then null else ($max_tokens | tonumber) end),
            temperature: (if $temperature == "" then null else ($temperature | tonumber) end),
            priority: (if $priority == "" then null else $priority end)
        }')
    
    local payload
    payload=$(jq -n \
        --arg task_type "$task_type" \
        --arg prompt "$prompt" \
        --argjson requirements "$requirements" \
        --arg retry_attempts "$retry_attempts" \
        '{
            taskType: $task_type,
            prompt: $prompt,
            requirements: $requirements,
            retryAttempts: (if $retry_attempts == "" then null else ($retry_attempts | tonumber) end)
        }')
    
    echo -e "${BLUE}ðŸ”„ Routing request through orchestrator...${NC}"
    
    local response
    response=$(api_request "POST" "/api/v1/ai/route-request" "$payload")
    
    if [[ "$json_output" == "true" ]]; then
        echo "$response" | format_json
    else
        echo -e "${GREEN}âœ“ Request completed successfully${NC}"
        echo ""
        
        echo -e "${CYAN}Response:${NC}"
        echo "$response" | jq -r '.response'
        echo ""
        
        echo -e "${BLUE}Request Details:${NC}"
        echo "$response" | jq -r '"Request ID: \(.requestId)\nModel used: \(.selectedModel)\nFallback used: \(.fallbackUsed)"'
        
        echo ""
        echo -e "${PURPLE}Performance Metrics:${NC}"
        echo "$response" | jq -r '.metrics | "  Response time: \(.responseTimeMs)ms\n  Memory pressure: \(.memoryPressure * 100 | round)%\n  Tokens generated: \(.tokensGenerated // "N/A")\n  Prompt tokens: \(.promptTokens // "N/A")"'
    fi
}

list_models() {
    local include_metrics=false
    local json_output=false
    local query_params=""
    
    while [[ $# -gt 0 ]]; do
        case $1 in
            --include-metrics)
                include_metrics=true
                shift
                ;;
            --json)
                json_output=true
                shift
                ;;
            *)
                shift
                ;;
        esac
    done
    
    if [[ "$include_metrics" == "true" ]]; then
        query_params="?includeMetrics=true"
    fi
    
    local response
    response=$(api_request "GET" "/api/v1/ai/models/status${query_params}")
    
    if [[ "$json_output" == "true" ]]; then
        echo "$response" | format_json
    else
        echo -e "${CYAN}ðŸ¤– Available AI Models${NC}"
        echo ""
        
        local total_models
        local healthy_models
        total_models=$(echo "$response" | jq -r '.totalModels // 0')
        healthy_models=$(echo "$response" | jq -r '.healthyModels // 0')
        
        echo -e "${GREEN}Status Overview:${NC}"
        echo "  Total models: $total_models"
        echo "  Healthy models: $healthy_models"
        echo ""
        
        echo -e "${BLUE}Model Details:${NC}"
        echo "$response" | jq -r '.models[]? | "  \(.model_name):\n    Requests: \(.request_count // 0)\n    Success rate: \(if .request_count > 0 then ((.success_count // 0) / .request_count * 100 | round) else 100 end)%\n    Avg response: \(.avg_response_time_ms // 0 | round)ms\n    Last used: \(.last_used // "Never")"'
    fi
}

show_resources() {
    local hours=""
    local json_output=false
    local query_params=""
    
    while [[ $# -gt 0 ]]; do
        case $1 in
            --hours)
                hours="$2"
                shift 2
                ;;
            --json)
                json_output=true
                shift
                ;;
            *)
                shift
                ;;
        esac
    done
    
    if [[ -n "$hours" ]]; then
        query_params="?hours=$hours"
    fi
    
    local response
    response=$(api_request "GET" "/api/v1/ai/resources/metrics${query_params}")
    
    if [[ "$json_output" == "true" ]]; then
        echo "$response" | format_json
    else
        echo -e "${CYAN}ðŸ’¾ System Resources${NC}"
        echo ""
        
        echo -e "${GREEN}Current Status:${NC}"
        echo "$response" | jq -r '.current | "  Memory available: \(.memory.available_gb | round)GB\n  Memory total: \(.memory.total_gb | round)GB\n  Memory usage: \((1 - .memory.available_gb / .memory.total_gb) * 100 | round)%\n  CPU usage: \(.cpu.usage | round)%"'
        
        local memory_pressure
        memory_pressure=$(echo "$response" | jq -r '.memoryPressure // 0')
        echo "  Memory pressure: $(echo "$memory_pressure * 100" | bc 2>/dev/null || echo "N/A")%"
        
        # Show pressure level with color coding
        if (( $(echo "$memory_pressure > 0.8" | bc -l 2>/dev/null || echo 0) )); then
            echo -e "  ${RED}âš ï¸  High memory pressure - performance may be impacted${NC}"
        elif (( $(echo "$memory_pressure > 0.6" | bc -l 2>/dev/null || echo 0) )); then
            echo -e "  ${YELLOW}âš ï¸  Moderate memory pressure${NC}"
        else
            echo -e "  ${GREEN}âœ“ Memory pressure normal${NC}"
        fi
        
        local history_count
        history_count=$(echo "$response" | jq -r '.history | length')
        if [[ "$history_count" -gt 0 ]]; then
            echo ""
            echo -e "${BLUE}History:${NC} $history_count data points available"
        fi
    fi
}

check_health() {
    local json_output=false
    
    while [[ $# -gt 0 ]]; do
        case $1 in
            --json)
                json_output=true
                shift
                ;;
            *)
                shift
                ;;
        esac
    done
    
    local response
    response=$(api_request "GET" "/api/v1/health")
    
    if [[ "$json_output" == "true" ]]; then
        echo "$response" | format_json
    else
        local status
        status=$(echo "$response" | jq -r '.status')
        
        if [[ "$status" == "healthy" ]]; then
            echo -e "${GREEN}âœ“ System Status: HEALTHY${NC}"
        else
            echo -e "${RED}âŒ System Status: $status${NC}"
        fi
        
        echo ""
        echo -e "${BLUE}Service Health:${NC}"
        echo "$response" | jq -r '.services | to_entries[] | "  \(.key): \(if .value == "ok" then "âœ“" else "âŒ" end) \(.value)"'
        
        echo ""
        echo -e "${PURPLE}System Metrics:${NC}"
        echo "$response" | jq -r '.system | "  Memory pressure: \(.memory_pressure * 100 | round)%\n  Available models: \(.available_models)\n  Available memory: \(.memory_available_gb | round)GB\n  CPU usage: \(.cpu_usage_percent | round)%"'
        
        echo ""
        local timestamp
        timestamp=$(echo "$response" | jq -r '.timestamp')
        echo -e "${CYAN}Last check: $timestamp${NC}"
    fi
}

show_status() {
    local api_url
    api_url=$(get_api_url)
    
    echo -e "${CYAN}ðŸŽ›ï¸  AI Model Orchestra Controller Status${NC}"
    echo ""
    
    # Get health status
    local health_response
    health_response=$(curl -s "${api_url}/api/v1/health" 2>/dev/null)
    
    if [[ $? -eq 0 ]] && echo "$health_response" | jq empty 2>/dev/null; then
        local status
        status=$(echo "$health_response" | jq -r '.status')
        
        echo -e "${BLUE}Orchestrator Status:${NC} $status"
        echo "$health_response" | jq -r '.services | to_entries[] | "  \(.key): \(.value)"'
        
        echo ""
        echo -e "${GREEN}System Overview:${NC}"
        echo "$health_response" | jq -r '.system | "  Available models: \(.available_models)\n  Memory pressure: \(.memory_pressure * 100 | round)%\n  Available memory: \(.memory_available_gb | round)GB"'
    else
        echo -e "${RED}âŒ Unable to connect to orchestrator API${NC}"
    fi
    
    # Show API endpoint
    echo ""
    echo -e "${PURPLE}API Endpoint:${NC} $api_url"
    echo -e "${PURPLE}Dashboard:${NC} ${api_url}/dashboard"
}

################################################################################
# Main Command Router
################################################################################
case "${1:-}" in
    select)
        shift
        select_model "$@"
        ;;
    route)
        shift
        route_request "$@"
        ;;
    models)
        shift
        list_models "$@"
        ;;
    resources)
        shift
        show_resources "$@"
        ;;
    health)
        shift
        check_health "$@"
        ;;
    status)
        show_status
        ;;
    version|--version|-v)
        show_version
        ;;
    help|--help|-h|"")
        show_help
        ;;
    *)
        echo -e "${RED}Error: Unknown command '$1'${NC}" >&2
        echo "Run 'ai-orchestra help' for usage information" >&2
        exit 1
        ;;
esac