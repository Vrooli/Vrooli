{
  "name": "Agent Scheduler",
  "meta": {
    "templateCredsSetupCompleted": true
  },
  "nodes": [
    {
      "parameters": {
        "rule": {
          "interval": [{"field": "minutes", "triggerAtMinute": 5}]
        }
      },
      "name": "Schedule Trigger",
      "type": "n8n-nodes-base.scheduleTrigger",
      "position": [250, 300],
      "id": "scheduler-trigger"
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "SELECT ag.*, a.name as application_name, a.repository_url, a.documentation_path FROM agents ag JOIN applications a ON ag.application_id = a.id WHERE ag.enabled = true AND (ag.next_run IS NULL OR ag.next_run <= NOW()) AND a.active = true",
        "options": {}
      },
      "name": "Get Active Agents",
      "type": "n8n-nodes-base.postgres",
      "position": [450, 300],
      "id": "get-agents"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "id": "has-agents",
              "leftValue": "={{ $json.length }}",
              "rightValue": 0,
              "operator": {
                "type": "number",
                "operation": "gt"
              }
            }
          ],
          "combinator": "and"
        }
      },
      "name": "Check Agents Exist",
      "type": "n8n-nodes-base.if",
      "position": [650, 300],
      "id": "check-agents"
    },
    {
      "parameters": {
        "batchSize": 1,
        "options": {}
      },
      "name": "Process Each Agent",
      "type": "n8n-nodes-base.splitInBatches",
      "position": [850, 300],
      "id": "split-agents"
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "agent-context",
              "name": "agent_context",
              "value": "={\n  \"agent_id\": $json.id,\n  \"agent_name\": $json.name,\n  \"agent_type\": $json.type,\n  \"application_id\": $json.application_id,\n  \"application_name\": $json.application_name,\n  \"repository_url\": $json.repository_url,\n  \"documentation_path\": $json.documentation_path,\n  \"config\": $json.config,\n  \"last_run\": $json.last_run\n}",
              "type": "object"
            }
          ]
        },
        "options": {}
      },
      "name": "Prepare Agent Context",
      "type": "n8n-nodes-base.set",
      "position": [1050, 300],
      "id": "prepare-context"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "id": "agent-type-switch",
              "leftValue": "={{ $json.agent_context.agent_type }}",
              "rightValue": "drift_detector",
              "operator": {
                "type": "string",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        }
      },
      "name": "Route by Agent Type",
      "type": "n8n-nodes-base.switch",
      "position": [1250, 300],
      "id": "route-agent-type"
    },
    {
      "parameters": {
        "workflowId": "ollama",
        "body": {
          "prompt": "=You are a documentation drift detection agent. Analyze the documentation for:\n\nApplication: {{ $json.agent_context.application_name }}\nRepository: {{ $json.agent_context.repository_url }}\nDocs Path: {{ $json.agent_context.documentation_path }}\n\nAgent Configuration:\n{{ JSON.stringify($json.agent_context.config, null, 2) }}\n\nDetect any documentation that is out of sync with the codebase. Focus on:\n- API endpoints that changed\n- Function signatures that no longer match\n- Deprecated features still documented\n- Missing documentation for new features\n\nReturn your findings as a JSON array with this structure:\n[{\n  \"type\": \"outdated_content|missing_documentation|broken_reference\",\n  \"severity\": \"critical|high|medium|low\",\n  \"title\": \"Brief description\",\n  \"description\": \"Detailed explanation\",\n  \"location\": \"file path or section\",\n  \"suggested_fix\": {\n    \"action\": \"update|add|remove\",\n    \"details\": \"Specific changes needed\",\n    \"confidence\": 0.85\n  }\n}]",
          "model": "llama3.2"
        },
        "options": {}
      },
      "name": "Drift Detection Analysis",
      "type": "n8n-nodes-base.executeWorkflow",
      "position": [1450, 200],
      "id": "drift-analysis"
    },
    {
      "parameters": {
        "workflowId": "ollama",
        "body": {
          "prompt": "=You are a link validation agent. Check all links in the documentation for:\n\nApplication: {{ $json.agent_context.application_name }}\nRepository: {{ $json.agent_context.repository_url }}\nDocs Path: {{ $json.agent_context.documentation_path }}\n\nAgent Configuration:\n{{ JSON.stringify($json.agent_context.config, null, 2) }}\n\nValidate:\n- Internal documentation links\n- External reference links\n- Image and asset references\n- Anchor links within pages\n\nReturn findings as JSON array:\n[{\n  \"type\": \"broken_link|missing_anchor|invalid_reference\",\n  \"severity\": \"critical|high|medium|low\", \n  \"title\": \"Brief description\",\n  \"description\": \"Detailed explanation\",\n  \"location\": \"file and line number\",\n  \"suggested_fix\": {\n    \"old_url\": \"broken URL\",\n    \"new_url\": \"corrected URL if known\",\n    \"confidence\": 0.95\n  }\n}]",
          "model": "llama3.2"
        },
        "options": {}
      },
      "name": "Link Validation Analysis",
      "type": "n8n-nodes-base.executeWorkflow", 
      "position": [1450, 400],
      "id": "link-analysis"
    },
    {
      "parameters": {
        "workflowId": "ollama",
        "body": {
          "prompt": "=You are a documentation coverage analysis agent. Analyze code coverage for:\n\nApplication: {{ $json.agent_context.application_name }}\nRepository: {{ $json.agent_context.repository_url }}\nDocs Path: {{ $json.agent_context.documentation_path }}\n\nAgent Configuration:\n{{ JSON.stringify($json.agent_context.config, null, 2) }}\n\nIdentify:\n- Undocumented public functions/classes\n- Missing API endpoint documentation\n- Code without usage examples\n- Configuration options not documented\n\nReturn findings as JSON array:\n[{\n  \"type\": \"missing_documentation|incomplete_examples|undocumented_api\",\n  \"severity\": \"critical|high|medium|low\",\n  \"title\": \"Brief description\", \n  \"description\": \"What needs documentation\",\n  \"location\": \"code file or section\",\n  \"suggested_fix\": {\n    \"documentation_needed\": \"Description of required docs\",\n    \"template\": \"Suggested documentation template\",\n    \"confidence\": 0.8\n  }\n}]",
          "model": "llama3.2"
        },
        "options": {}
      },
      "name": "Coverage Analysis", 
      "type": "n8n-nodes-base.executeWorkflow",
      "position": [1450, 600],
      "id": "coverage-analysis"
    },
    {
      "parameters": {
        "jsCode": "// Parse AI response and prepare improvements for queueing\nconst agentContext = items[0].json.agent_context;\n// Handle response from the shared Ollama workflow\nconst ollamaResponse = items[0].json;\nconst aiResponse = ollamaResponse.response || ollamaResponse.data?.response || '';\n\nlet findings = [];\ntry {\n  // Parse the AI response JSON\n  const responseText = aiResponse.includes('```json') ? \n    aiResponse.split('```json')[1].split('```')[0] : aiResponse;\n  findings = JSON.parse(responseText);\n} catch (error) {\n  console.log('Failed to parse AI response:', error);\n  findings = [{\n    type: 'analysis_error',\n    severity: 'low',\n    title: 'Agent analysis parsing failed',\n    description: `Failed to parse response from ${agentContext.agent_type} agent: ${error.message}`,\n    location: 'system',\n    suggested_fix: {\n      action: 'manual_review',\n      details: 'Review agent configuration and AI model response format',\n      confidence: 0.5\n    }\n  }];\n}\n\n// Transform findings into improvement queue format\nconst improvements = findings.map((finding, index) => ({\n  agent_id: agentContext.agent_id,\n  application_id: agentContext.application_id, \n  type: finding.type,\n  severity: finding.severity,\n  title: finding.title,\n  description: finding.description,\n  suggested_fix: JSON.stringify(finding.suggested_fix),\n  created_at: new Date().toISOString(),\n  status: 'pending'\n}));\n\n// Update agent's last_run and next_run\nconst nextRun = new Date();\nif (agentContext.config && agentContext.config.schedule_cron) {\n  // Simple next run calculation (in real implementation, use cron parser)\n  nextRun.setHours(nextRun.getHours() + 6); \n}\n\nreturn [\n  {\n    json: {\n      improvements,\n      agent_update: {\n        agent_id: agentContext.agent_id,\n        last_run: new Date().toISOString(),\n        next_run: nextRun.toISOString(),\n        last_performance_score: Math.max(0.1, Math.min(1.0, improvements.length > 0 ? 0.8 : 0.9))\n      },\n      metrics: {\n        agent_id: agentContext.agent_id,\n        suggestions_count: improvements.length,\n        execution_time_ms: 15000, // Simulated\n        result: 'success'\n      }\n    }\n  }\n];"
      },
      "name": "Process Analysis Results",
      "type": "n8n-nodes-base.code", 
      "position": [1650, 300],
      "id": "process-results"
    },
    {
      "parameters": {
        "operation": "insert",
        "table": "improvement_queue",
        "columns": "agent_id,application_id,type,severity,title,description,suggested_fix,created_at,status",
        "returnFields": "*",
        "options": {}
      },
      "name": "Queue Improvements",
      "type": "n8n-nodes-base.postgres",
      "position": [1850, 200], 
      "id": "queue-improvements"
    },
    {
      "parameters": {
        "operation": "update",
        "table": "agents",
        "updateKey": "id",
        "columns": "last_run,next_run,last_performance_score",
        "options": {}
      },
      "name": "Update Agent Status",
      "type": "n8n-nodes-base.postgres",
      "position": [1850, 400],
      "id": "update-agent"
    },
    {
      "parameters": {
        "operation": "insert", 
        "table": "action_history",
        "columns": "agent_id,action_type,action_data,result,execution_time_ms,created_at",
        "options": {}
      },
      "name": "Log Execution",
      "type": "n8n-nodes-base.postgres",
      "position": [1850, 600],
      "id": "log-execution"
    },
    {
      "parameters": {
        "channel": "agent-notifications",
        "message": "={{ $json.improvements.length }} new improvement suggestions from {{ $json.agent_context.agent_name }}"
      },
      "name": "Notify via Redis",
      "type": "n8n-nodes-base.redis",
      "position": [2050, 300],
      "id": "notify-redis"
    }
  ],
  "connections": {
    "Schedule Trigger": {"main": [[{"node": "Get Active Agents", "type": "main", "index": 0}]]},
    "Get Active Agents": {"main": [[{"node": "Check Agents Exist", "type": "main", "index": 0}]]},
    "Check Agents Exist": {
      "main": [
        [{"node": "Process Each Agent", "type": "main", "index": 0}],
        []
      ]
    },
    "Process Each Agent": {"main": [[{"node": "Prepare Agent Context", "type": "main", "index": 0}]]},
    "Prepare Agent Context": {"main": [[{"node": "Route by Agent Type", "type": "main", "index": 0}]]},
    "Route by Agent Type": {
      "main": [
        [{"node": "Drift Detection Analysis", "type": "main", "index": 0}],
        [{"node": "Link Validation Analysis", "type": "main", "index": 0}],
        [{"node": "Coverage Analysis", "type": "main", "index": 0}]
      ]
    },
    "Drift Detection Analysis": {"main": [[{"node": "Process Analysis Results", "type": "main", "index": 0}]]},
    "Link Validation Analysis": {"main": [[{"node": "Process Analysis Results", "type": "main", "index": 0}]]},  
    "Coverage Analysis": {"main": [[{"node": "Process Analysis Results", "type": "main", "index": 0}]]},
    "Process Analysis Results": {
      "main": [
        [
          {"node": "Queue Improvements", "type": "main", "index": 0},
          {"node": "Update Agent Status", "type": "main", "index": 0},
          {"node": "Log Execution", "type": "main", "index": 0}
        ]
      ]
    },
    "Queue Improvements": {"main": [[{"node": "Notify via Redis", "type": "main", "index": 0}]]},
    "Update Agent Status": {"main": [[]]},
    "Log Execution": {"main": [[]]}
  },
  "settings": {
    "executionOrder": "v1"
  },
  "staticData": null,
  "tags": ["documentation", "automation", "ai"],
  "triggerCount": 0,
  "updatedAt": "2024-01-15T10:00:00.000Z",
  "versionId": "v2.0"
}