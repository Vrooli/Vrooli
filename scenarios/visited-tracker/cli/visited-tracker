#!/bin/bash
################################################################################
# Visited Tracker CLI - Lightweight API Wrapper
# 
# Persistent file visit tracking with staleness detection for systematic code analysis
# Port discovery uses vrooli scenario port command for dynamic allocation
################################################################################

set -e

# Configuration
SCENARIO_NAME="visited-tracker"
CAMPAIGN_ID="${VISITED_TRACKER_CAMPAIGN_ID:-}"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
PURPLE='\033[0;35m'
NC='\033[0m' # No Color

################################################################################
# Port Discovery - Dynamic port lookup
################################################################################
get_api_url() {
    # Use vrooli scenario port command for dynamic port lookup
    local api_port
    api_port=$(vrooli scenario port "${SCENARIO_NAME}" API_PORT 2>/dev/null)
    
    if [[ -z "$api_port" ]]; then
        echo -e "${RED}‚ùå Error: ${SCENARIO_NAME} is not running${NC}" >&2
        echo "   Start it with: vrooli scenario run ${SCENARIO_NAME}" >&2
        exit 1
    fi
    
    echo "http://localhost:${api_port}"
}

################################################################################
# Helper Functions
################################################################################
show_help() {
    echo -e "${CYAN}üîç Visited Tracker CLI${NC}"
    echo "Persistent file visit tracking with staleness detection for systematic code analysis"
    echo ""
    echo "Usage: visited-tracker [global options] [command] [options]"
    echo ""
    echo "Global Options:"
    echo "  --campaign-id ID           Campaign ID to target (overrides VISITED_TRACKER_CAMPAIGN_ID)"
    echo ""
    echo "Commands:"
    echo -e "  ${GREEN}visit${NC} FILE1 [FILE2...]       Record file visit(s) with optional context"
    echo -e "  ${GREEN}sync${NC}                         Sync file structure and detect changes"
    echo -e "  ${GREEN}least-visited${NC}                Get prioritized list of least visited files"
    echo -e "  ${GREEN}most-stale${NC}                   Get files with highest staleness scores"
    echo -e "  ${GREEN}coverage${NC}                     Show visit coverage statistics"
    echo -e "  ${GREEN}campaigns${NC}                    Manage campaigns (list, create, delete)"
    echo -e "  ${GREEN}import${NC} FILE                  Import visited data from file"
    echo -e "  ${GREEN}export${NC} FILE                  Export visited data to file"
    echo -e "  ${GREEN}status${NC}                       Show tracking status and coverage summary"
    echo -e "  ${GREEN}help${NC}                         Show this help message"
    echo -e "  ${GREEN}version${NC}                      Show version information"
    echo ""
    echo "Visit Context Values:"
    echo "  security, performance, bug, docs, general"
    echo ""
    echo "Options:"
    echo "  --context CONTEXT            Visit context (security/performance/bug/docs)"
    echo "  --agent AGENT                AI model or agent name"
    echo "  --conversation ID            Conversation ID for grouping visits"
    echo "  --limit N                    Number of files to return"
    echo "  --threshold N                Minimum staleness score"
    echo "  --patterns PATTERN           Glob patterns for filtering"
    echo "  --include-unvisited          Include never-visited files"
    echo "  --remove-deleted             Remove deleted files from tracking"
    echo "  --group-by TYPE              Group coverage by directory/extension/context"
    echo "  --json                       Output raw JSON"
    echo ""
    echo "Examples:"
    echo "  visited-tracker visit 'src/**/*.js' --context security"
    echo "  visited-tracker least-visited --limit 10 --context security"
    echo "  visited-tracker most-stale --threshold 5.0"
    echo "  visited-tracker coverage --group-by directory"
    echo "  visited-tracker sync --patterns '**/*.js' --remove-deleted"
}

show_version() {
    local api_url
    api_url=$(get_api_url 2>/dev/null || echo "API not running")
    echo "visited-tracker CLI v1.0.0"
    echo "API: ${api_url}"
}

# Format JSON output if jq is available
format_json() {
    if command -v jq >/dev/null 2>&1; then
        jq .
    else
        cat
    fi
}

ensure_campaign_id() {
    if [ -n "${CAMPAIGN_ID:-}" ]; then
        return 0
    fi

    local campaigns_json=""
    if ! campaigns_json=$(api_request "GET" "/api/v1/campaigns" "" true); then
        echo -e "${RED}Error: No campaign selected and unable to list campaigns.${NC}" >&2
        echo "       Set VISITED_TRACKER_CAMPAIGN_ID or create one with 'visited-tracker campaigns create'." >&2
        return 1
    fi

    local first_campaign
    first_campaign=$(echo "$campaigns_json" | jq -r '.campaigns[0].id // empty' 2>/dev/null || echo "")
    if [ -z "$first_campaign" ]; then
        echo -e "${RED}Error: No campaigns available.${NC}" >&2
        echo "       Create one with: visited-tracker campaigns create --name <name> --pattern '**/*.js'" >&2
        return 1
    fi

    CAMPAIGN_ID="$first_campaign"
    export VISITED_TRACKER_CAMPAIGN_ID="$CAMPAIGN_ID"
    return 0
}

campaign_endpoint() {
    local suffix="$1"
    ensure_campaign_id || exit 1
    echo "/api/v1/campaigns/${CAMPAIGN_ID}${suffix}"
}

# Make API request
api_request() {
    local method="$1"
    local endpoint="$2"
    local data="${3:-}"
    local allow_failure="${4:-false}"
    local api_url
    
    # Get the current API URL
    api_url=$(get_api_url)
    
    local curl_args=(-sS)
    
    if [[ "$method" != "GET" ]]; then
        curl_args+=(-X "$method")
    fi
    
    if [[ -n "$data" ]]; then
        curl_args+=(-H "Content-Type: application/json" -d "$data")
    fi

    local tmp_body
    tmp_body=$(mktemp)
    local http_code
    local curl_exit=0

    http_code=$(curl "${curl_args[@]}" -w "%{http_code}" -o "$tmp_body" "${api_url}${endpoint}") || curl_exit=$?
    local body
    body=$(cat "$tmp_body")
    rm -f "$tmp_body"

    # curl command failed (network error, etc.)
    if [ $curl_exit -ne 0 ]; then
        if [ "$allow_failure" = "true" ]; then
            printf '%s' "$body"
            return $curl_exit
        fi
        echo -e "${RED}Error: Request to ${endpoint} failed (curl exit $curl_exit).${NC}" >&2
        printf '%s\n' "$body" >&2
        exit 1
    fi

    # HTTP error handling
    if [[ "$http_code" =~ ^[0-9]+$ ]] && [ "$http_code" -ge 400 ]; then
        if [ "$allow_failure" = "true" ]; then
            printf '%s' "$body"
            return 1
        fi
        echo -e "${RED}Error: API responded with status $http_code for ${endpoint}.${NC}" >&2
        if [ -n "$body" ]; then
            printf '%s\n' "$body" | format_json >&2
        fi
        exit 1
    fi

    printf '%s' "$body"
}

################################################################################
# Command Handlers
################################################################################
record_visit() {
    local files=()
    local context=""
    local agent=""
    local conversation=""
    local json_output=false
    
    while [[ $# -gt 0 ]]; do
        case $1 in
            --context)
                context="$2"
                shift 2
                ;;
            --agent)
                agent="$2"
                shift 2
                ;;
            --conversation)
                conversation="$2"
                shift 2
                ;;
            --json)
                json_output=true
                shift
                ;;
            *)
                files+=("$1")
                shift
                ;;
        esac
    done
    
    if [[ ${#files[@]} -eq 0 ]]; then
        echo -e "${RED}Error: At least one file required${NC}" >&2
        echo "Usage: visited-tracker visit FILE1 [FILE2...] [--context CONTEXT]" >&2
        exit 1
    fi
    
    # Build JSON payload
    local files_json
    files_json=$(printf '%s\n' "${files[@]}" | jq -R . | jq -s .)
    
    local payload
    payload=$(jq -n \
        --argjson files "$files_json" \
        --arg context "$context" \
        --arg agent "$agent" \
        --arg conversation_id "$conversation" \
        '{
            files: $files,
            context: (if $context == "" then null else $context end),
            agent: (if $agent == "" then null else $agent end),
            conversation_id: (if $conversation_id == "" then null else $conversation_id end)
        }')
    
    local response
    response=$(api_request "POST" "$(campaign_endpoint "/visit")" "$payload")
    
    if [[ "$json_output" == "true" ]]; then
        echo "$response" | format_json
    else
        local recorded
        recorded=$(echo "$response" | jq -r '.recorded')
        
        echo -e "${GREEN}‚úì Visit recorded successfully${NC}"
        echo "Files recorded: $recorded"
        
        # Show visit counts for each file
        echo "$response" | jq -r '.files[]? | "  \(.file_path): \(.visit_count) visits"'
    fi
}

sync_structure() {
    local patterns=()
    local structure=""
    local remove_deleted=false
    local json_output=false
    
    while [[ $# -gt 0 ]]; do
        case $1 in
            --patterns)
                IFS=',' read -ra ADDR <<< "$2"
                for i in "${ADDR[@]}"; do
                    patterns+=("$i")
                done
                shift 2
                ;;
            --structure)
                structure="$2"
                shift 2
                ;;
            --remove-deleted)
                remove_deleted=true
                shift
                ;;
            --json)
                json_output=true
                shift
                ;;
            *)
                shift
                ;;
        esac
    done
    
    # Build JSON payload
    local patterns_json
    if [[ ${#patterns[@]} -gt 0 ]]; then
        patterns_json=$(printf '%s\n' "${patterns[@]}" | jq -R . | jq -s .)
    else
        patterns_json="null"
    fi
    
    local payload
    payload=$(jq -n \
        --argjson patterns "$patterns_json" \
        --argjson remove_deleted "$remove_deleted" \
        '{
            patterns: $patterns,
            remove_deleted: $remove_deleted
        }')
    
    local response
    response=$(api_request "POST" "$(campaign_endpoint "/structure/sync")" "$payload")
    
    if [[ "$json_output" == "true" ]]; then
        echo "$response" | format_json
    else
        echo -e "${GREEN}‚úì Structure synchronized${NC}"
        echo "$response" | jq -r '"Added: \(.added) files\nRemoved: \(.removed) files\nTotal: \(.total) files"'
    fi
}

get_least_visited() {
    local limit=""
    local context=""
    local include_unvisited=true
    local patterns=()
    local json_output=false
    local query_params=""
    
    while [[ $# -gt 0 ]]; do
        case $1 in
            --limit)
                limit="$2"
                shift 2
                ;;
            --context)
                context="$2"
                shift 2
                ;;
            --no-unvisited)
                include_unvisited=false
                shift
                ;;
            --patterns)
                IFS=',' read -ra ADDR <<< "$2"
                for i in "${ADDR[@]}"; do
                    patterns+=("$i")
                done
                shift 2
                ;;
            --json)
                json_output=true
                shift
                ;;
            *)
                shift
                ;;
        esac
    done
    
    # Build query parameters
    if [[ -n "$limit" ]]; then
        if ! [[ "$limit" =~ ^[0-9]+$ ]]; then
            echo -e "${RED}Error: --limit must be a positive integer.${NC}" >&2
            return 1
        fi
        query_params="?limit=$limit"
    fi
    
    if [[ -n "$context" ]]; then
        if [[ -z "$query_params" ]]; then
            query_params="?context=$context"
        else
            query_params="${query_params}&context=$context"
        fi
    fi
    
    if [[ "$include_unvisited" == "false" ]]; then
        if [[ -z "$query_params" ]]; then
            query_params="?include_unvisited=false"
        else
            query_params="${query_params}&include_unvisited=false"
        fi
    fi
    
    local response
    response=$(api_request "GET" "$(campaign_endpoint "/prioritize/least-visited")${query_params}")
    
    if [[ "$json_output" == "true" ]]; then
        echo "$response" | format_json
    else
        echo -e "${CYAN}üìä Least Visited Files${NC}"
        local files_output
        files_output=$(echo "$response" | jq -r '(.files // [])[] | "  \(.file_path): \(.visit_count // 0) visits"')
        if [ -n "$files_output" ]; then
            echo "$files_output"
        else
            echo "  No tracked files yet"
        fi
        echo ""
        echo -e "${BLUE}Coverage Statistics:${NC}"
        echo "$response" | jq -r '(.coverage // {visited:0,unvisited:0,percentage:0}) | "  Visited: \(.visited // 0) files\n  Unvisited: \(.unvisited // 0) files\n  Coverage: \((.percentage // 0) | round)%"'
    fi
}

get_most_stale() {
    local limit=""
    local threshold=""
    local json_output=false
    local query_params=""
    
    while [[ $# -gt 0 ]]; do
        case $1 in
            --limit)
                limit="$2"
                shift 2
                ;;
            --threshold)
                threshold="$2"
                shift 2
                ;;
            --json)
                json_output=true
                shift
                ;;
            *)
                shift
                ;;
        esac
    done
    
    # Build query parameters
    if [[ -n "$limit" ]]; then
        query_params="?limit=$limit"
    fi
    
    if [[ -n "$threshold" ]]; then
        if ! [[ "$threshold" =~ ^[0-9]+(\.[0-9]+)?$ ]]; then
            echo -e "${RED}Error: --threshold must be numeric.${NC}" >&2
            return 1
        fi
        if [[ -z "$query_params" ]]; then
            query_params="?threshold=$threshold"
        else
            query_params="${query_params}&threshold=$threshold"
        fi
    fi
    
    local response
    response=$(api_request "GET" "$(campaign_endpoint "/prioritize/most-stale")${query_params}")
    
    if [[ "$json_output" == "true" ]]; then
        echo "$response" | format_json
    else
        echo -e "${YELLOW}‚ö†Ô∏è  Most Stale Files${NC}"
        local stale_output
        stale_output=$(echo "$response" | jq -r '(.files // [])[] | "  \(.file_path): staleness=\((.staleness_score // 0) | round), visits=\(.visit_count // 0)"')
        if [ -n "$stale_output" ]; then
            echo "$stale_output"
        else
            echo "  No stale files detected"
        fi
        echo ""
        echo -e "${BLUE}Staleness Analysis:${NC}"
        echo "$response" | jq -r '"  Average staleness: \(((.average_staleness // 0) | round))\n  Critical files: \(.critical_count // 0)"'
    fi
}

get_coverage() {
    local patterns=()
    local group_by=""
    local json_output=false
    local query_params=""
    
    while [[ $# -gt 0 ]]; do
        case $1 in
            --patterns)
                IFS=',' read -ra ADDR <<< "$2"
                for i in "${ADDR[@]}"; do
                    patterns+=("$i")
                done
                shift 2
                ;;
            --group-by)
                group_by="$2"
                shift 2
                ;;
            --json)
                json_output=true
                shift
                ;;
            *)
                shift
                ;;
        esac
    done
    
    # Build query parameters
    if [[ ${#patterns[@]} -gt 0 ]]; then
        for pattern in "${patterns[@]}"; do
            if [[ -z "$query_params" ]]; then
                query_params="?patterns=$pattern"
            else
                query_params="${query_params}&patterns=$pattern"
            fi
        done
    fi
    
    if [[ -n "$group_by" ]]; then
        if [[ -z "$query_params" ]]; then
            query_params="?group_by=$group_by"
        else
            query_params="${query_params}&group_by=$group_by"
        fi
    fi
    
    local response
    response=$(api_request "GET" "$(campaign_endpoint "/coverage")${query_params}")
    
    if [[ "$json_output" == "true" ]]; then
        echo "$response" | format_json
    else
        echo -e "${GREEN}üìà Coverage Report${NC}"
        echo "$response" | jq -r '"Total files: \(.total_files // 0)\nVisited: \(.visited_files // 0) (\((.coverage_percentage // 0) | round)%)\nUnvisited: \(.unvisited_files // 0)\nAverage visits: \((.average_visits // 0) | round)\nAverage staleness: \((.average_staleness // 0) | round)"'
        
        if [[ -n "$group_by" ]]; then
            echo ""
            echo -e "${BLUE}Grouped by $group_by:${NC}"
            echo "$response" | jq -r '(.groups // [])'
        fi
    fi
}

campaigns_command() {
    local subcommand="${1:-list}"
    shift || true

    case "$subcommand" in
        list)
            local response
            response=$(api_request "GET" "/api/v1/campaigns")
            echo "$response" | format_json
            ;;
        create)
            local name=""
            local from_agent="cli"
            local description=""
            local patterns=()
            local metadata="{}"
            local json_output=false

            while [[ $# -gt 0 ]]; do
                case $1 in
                    --name)
                        name="$2"
                        shift 2
                        ;;
                    --pattern)
                        patterns+=("$2")
                        shift 2
                        ;;
                    --patterns)
                        IFS=',' read -ra ADDR <<< "$2"
                        for i in "${ADDR[@]}"; do
                            patterns+=("$i")
                        done
                        shift 2
                        ;;
                    --from-agent)
                        from_agent="$2"
                        shift 2
                        ;;
                    --description)
                        description="$2"
                        shift 2
                        ;;
                    --metadata)
                        metadata="$2"
                        shift 2
                        ;;
                    --json)
                        json_output=true
                        shift
                        ;;
                    *)
                        echo -e "${RED}Error: Unknown option '$1' for campaigns create.${NC}" >&2
                        echo "Usage: visited-tracker campaigns create --name <name> --pattern '<glob>'" >&2
                        return 1
                        ;;
                esac
            done

            if [ -z "$name" ]; then
                echo -e "${RED}Error: --name is required for campaigns create.${NC}" >&2
                return 1
            fi

            if [ ${#patterns[@]} -eq 0 ]; then
                echo -e "${RED}Error: At least one --pattern or --patterns value is required.${NC}" >&2
                return 1
            fi

            local patterns_json
            patterns_json=$(printf '%s\n' "${patterns[@]}" | jq -R . | jq -s .)

            local payload
            if [ -n "$description" ]; then
                payload=$(jq -n \
                    --arg name "$name" \
                    --arg from_agent "$from_agent" \
                    --arg description "$description" \
                    --argjson patterns "$patterns_json" \
                    --argjson metadata "$metadata" \
                    '{name: $name, from_agent: $from_agent, description: $description, patterns: $patterns, metadata: $metadata}')
            else
                payload=$(jq -n \
                    --arg name "$name" \
                    --arg from_agent "$from_agent" \
                    --argjson patterns "$patterns_json" \
                    --argjson metadata "$metadata" \
                    '{name: $name, from_agent: $from_agent, patterns: $patterns, metadata: $metadata}')
            fi

            local response
            response=$(api_request "POST" "/api/v1/campaigns" "$payload")
            local new_id
            new_id=$(echo "$response" | jq -r '.id // empty')
            if [ -n "$new_id" ]; then
                CAMPAIGN_ID="$new_id"
                export VISITED_TRACKER_CAMPAIGN_ID="$CAMPAIGN_ID"
            fi

            if [ "$json_output" = true ]; then
                echo "$response" | format_json
            else
                echo -e "${GREEN}‚úì Campaign created:${NC} $name"
                echo "ID: ${new_id}"
                echo "Patterns: ${patterns[*]}"
            fi
            ;;
        delete)
            local target_id=""
            local json_output=false

            if [[ $# -gt 0 ]]; then
                target_id="$1"
                shift
            fi

            while [[ $# -gt 0 ]]; do
                case $1 in
                    --json)
                        json_output=true
                        shift
                        ;;
                    *)
                        echo -e "${RED}Error: Unknown option '$1' for campaigns delete.${NC}" >&2
                        return 1
                        ;;
                esac
            done

            if [ -z "$target_id" ]; then
                echo -e "${RED}Error: campaigns delete requires a campaign ID.${NC}" >&2
                return 1
            fi

            local response
            response=$(api_request "DELETE" "/api/v1/campaigns/$target_id")

            if [ "$CAMPAIGN_ID" = "$target_id" ]; then
                CAMPAIGN_ID=""
                unset VISITED_TRACKER_CAMPAIGN_ID
            fi

            if [ "$json_output" = true ]; then
                echo "$response" | format_json
            else
                echo -e "${GREEN}‚úì Campaign deleted:${NC} $target_id"
            fi
            ;;
        *)
            echo -e "${RED}Error: Unknown campaigns subcommand '$subcommand'.${NC}" >&2
            echo "Available subcommands: list, create, delete" >&2
            return 1
            ;;
    esac
}

show_status() {
    local api_url
    api_url=$(get_api_url)
    
    # Get health status
    local health_response
    if ! health_response=$(curl -sS "${api_url}/health" 2>/dev/null); then
        echo -e "${RED}Error: Unable to reach Visited Tracker API at ${api_url}/health.${NC}" >&2
        return 1
    fi
    
    echo -e "${CYAN}üîç Visited Tracker Status${NC}"
    echo "$health_response" | jq -r '"Service: \(.service)\nVersion: \(.version)\nStatus: \(.status)\nUptime: \(.metrics.uptime_seconds // 0 | floor)s"'
    
    # Get coverage stats (if endpoint exists)
    echo ""
    echo -e "${BLUE}Coverage Overview:${NC}"
    if ensure_campaign_id; then
        local coverage_response=""
        local coverage_status=0
        coverage_response=$(api_request "GET" "/api/v1/campaigns/${CAMPAIGN_ID}/coverage" "" true) || coverage_status=$?
        if [ $coverage_status -eq 0 ] && echo "$coverage_response" | jq empty 2>/dev/null; then
            echo "$coverage_response" | jq -r '"Total files: \(.total_files // 0)\nVisited: \(.visited_files // 0) (\(.coverage_percentage // 0 | round)%)\nUnvisited: \(.unvisited_files // 0)"'
        else
            echo "Coverage data not available (campaign request failed)"
        fi
    else
        echo "Coverage data not available (no campaigns found)"
    fi
}

import_data() {
    local file="$1"
    local format="json"
    local merge_strategy="combine"
    local json_output=false
    
    shift
    while [[ $# -gt 0 ]]; do
        case $1 in
            --format)
                format="$2"
                shift 2
                ;;
            --merge)
                merge_strategy="$2"
                shift 2
                ;;
            --json)
                json_output=true
                shift
                ;;
            *)
                shift
                ;;
        esac
    done
    
    if [[ ! -f "$file" ]]; then
        echo -e "${RED}Error: File not found: $file${NC}" >&2
        exit 1
    fi
    
    local message
    message=$(jq -n --arg msg "Import command placeholder ‚Äì API import endpoint not yet implemented" '{message: $msg}')

    if [[ "$json_output" == "true" ]]; then
        echo "$message" | format_json
    else
        echo -e "${YELLOW}‚ö† Import placeholder${NC}"
        echo "$message" | jq -r '.message'
    fi
}

export_data() {
    local file="$1"
    local format="json"
    local include_history=false
    local patterns=()
    local query_params=""
    
    shift
    while [[ $# -gt 0 ]]; do
        case $1 in
            --format)
                format="$2"
                shift 2
                ;;
            --include-history)
                include_history=true
                shift
                ;;
            --patterns)
                IFS=',' read -ra ADDR <<< "$2"
                for i in "${ADDR[@]}"; do
                    patterns+=("$i")
                done
                shift 2
                ;;
            *)
                shift
                ;;
        esac
    done
    
    # Build query parameters
    query_params="?format=$format"
    
    if [[ "$include_history" == "true" ]]; then
        query_params="${query_params}&include_history=true"
    fi
    
    if [[ ${#patterns[@]} -gt 0 ]]; then
        for pattern in "${patterns[@]}"; do
            query_params="${query_params}&patterns=$pattern"
        done
    fi
    
    local response
    response=$(api_request "GET" "$(campaign_endpoint "/export")${query_params}")
    
    # Save to file
    echo "$response" > "$file"
    
    echo -e "${GREEN}‚úì Export completed${NC}"
    echo "$response" | jq -r '"Exported \(.exported_count) files to: '"$file"'"'
}

################################################################################
# Main Command Router
################################################################################

while [[ $# -gt 0 ]]; do
    case $1 in
        --campaign|--campaign-id)
            if [[ $# -lt 2 ]]; then
                echo -e "${RED}Error: --campaign-id requires an argument.${NC}" >&2
                exit 1
            fi
            CAMPAIGN_ID="$2"
            export VISITED_TRACKER_CAMPAIGN_ID="$CAMPAIGN_ID"
            shift 2
            ;;
        --campaign=*|--campaign-id=*)
            CAMPAIGN_ID="${1#*=}"
            export VISITED_TRACKER_CAMPAIGN_ID="$CAMPAIGN_ID"
            shift
            ;;
        --)
            shift
            break
            ;;
        *)
            break
            ;;
    esac
done

COMMAND="${1:-help}"
if [[ $# -gt 0 ]]; then
    shift
fi

case "$COMMAND" in
    visit)
        record_visit "$@"
        ;;
    sync)
        sync_structure "$@"
        ;;
    least-visited)
        get_least_visited "$@"
        ;;
    most-stale)
        get_most_stale "$@"
        ;;
    coverage)
        get_coverage "$@"
        ;;
    campaigns)
        campaigns_command "$@"
        ;;
    import)
        import_data "$@"
        ;;
    export)
        export_data "$@"
        ;;
    status)
        show_status
        ;;
    version|--version|-v)
        show_version
        ;;
    help|--help|-h|"")
        show_help
        ;;
    *)
        echo -e "${RED}Error: Unknown command '$COMMAND'${NC}" >&2
        echo "Run 'visited-tracker help' for usage information" >&2
        exit 1
        ;;
esac
