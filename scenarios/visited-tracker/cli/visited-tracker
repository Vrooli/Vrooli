#!/bin/bash
################################################################################
# Visited Tracker CLI - Lightweight API Wrapper
# 
# Persistent file visit tracking with staleness detection for systematic code analysis
# Port discovery uses vrooli scenario port command for dynamic allocation
################################################################################

set -e

# Configuration
SCENARIO_NAME="visited-tracker"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
PURPLE='\033[0;35m'
NC='\033[0m' # No Color

################################################################################
# Port Discovery - Dynamic port lookup
################################################################################
get_api_url() {
    # Use vrooli scenario port command for dynamic port lookup
    local api_port
    api_port=$(vrooli scenario port "${SCENARIO_NAME}" API_PORT 2>/dev/null)
    
    if [[ -z "$api_port" ]]; then
        echo -e "${RED}âŒ Error: ${SCENARIO_NAME} is not running${NC}" >&2
        echo "   Start it with: vrooli scenario run ${SCENARIO_NAME}" >&2
        exit 1
    fi
    
    echo "http://localhost:${api_port}"
}

################################################################################
# Helper Functions
################################################################################
show_help() {
    echo -e "${CYAN}ðŸ” Visited Tracker CLI${NC}"
    echo "Persistent file visit tracking with staleness detection for systematic code analysis"
    echo ""
    echo "Usage: visited-tracker [command] [options]"
    echo ""
    echo "Commands:"
    echo -e "  ${GREEN}visit${NC} FILE1 [FILE2...]       Record file visit(s) with optional context"
    echo -e "  ${GREEN}sync${NC}                         Sync file structure and detect changes"
    echo -e "  ${GREEN}least-visited${NC}                Get prioritized list of least visited files"
    echo -e "  ${GREEN}most-stale${NC}                   Get files with highest staleness scores"
    echo -e "  ${GREEN}coverage${NC}                     Show visit coverage statistics"
    echo -e "  ${GREEN}import${NC} FILE                  Import visited data from file"
    echo -e "  ${GREEN}export${NC} FILE                  Export visited data to file"
    echo -e "  ${GREEN}status${NC}                       Show tracking status and coverage summary"
    echo -e "  ${GREEN}help${NC}                         Show this help message"
    echo -e "  ${GREEN}version${NC}                      Show version information"
    echo ""
    echo "Visit Context Values:"
    echo "  security, performance, bug, docs, general"
    echo ""
    echo "Options:"
    echo "  --context CONTEXT            Visit context (security/performance/bug/docs)"
    echo "  --agent AGENT                AI model or agent name"
    echo "  --conversation ID            Conversation ID for grouping visits"
    echo "  --limit N                    Number of files to return"
    echo "  --threshold N                Minimum staleness score"
    echo "  --patterns PATTERN           Glob patterns for filtering"
    echo "  --include-unvisited          Include never-visited files"
    echo "  --remove-deleted             Remove deleted files from tracking"
    echo "  --group-by TYPE              Group coverage by directory/extension/context"
    echo "  --json                       Output raw JSON"
    echo ""
    echo "Examples:"
    echo "  visited-tracker visit 'src/**/*.js' --context security"
    echo "  visited-tracker least-visited --limit 10 --context security"
    echo "  visited-tracker most-stale --threshold 5.0"
    echo "  visited-tracker coverage --group-by directory"
    echo "  visited-tracker sync --patterns '**/*.js' --remove-deleted"
}

show_version() {
    local api_url
    api_url=$(get_api_url 2>/dev/null || echo "API not running")
    echo "visited-tracker CLI v1.0.0"
    echo "API: ${api_url}"
}

# Format JSON output if jq is available
format_json() {
    if command -v jq >/dev/null 2>&1; then
        jq .
    else
        cat
    fi
}

# Make API request
api_request() {
    local method="$1"
    local endpoint="$2"
    local data="${3:-}"
    local api_url
    
    # Get the current API URL
    api_url=$(get_api_url)
    
    local curl_args=(-s)
    
    if [[ "$method" != "GET" ]]; then
        curl_args+=(-X "$method")
    fi
    
    if [[ -n "$data" ]]; then
        curl_args+=(-H "Content-Type: application/json" -d "$data")
    fi
    
    local response
    response=$(curl "${curl_args[@]}" "${api_url}${endpoint}")
    
    # Check for error
    if echo "$response" | grep -q '"error"'; then
        echo -e "${RED}Error:${NC}" >&2
        echo "$response" | format_json >&2
        exit 1
    fi
    
    echo "$response"
}

################################################################################
# Command Handlers
################################################################################
record_visit() {
    local files=()
    local context=""
    local agent=""
    local conversation=""
    local json_output=false
    
    while [[ $# -gt 0 ]]; do
        case $1 in
            --context)
                context="$2"
                shift 2
                ;;
            --agent)
                agent="$2"
                shift 2
                ;;
            --conversation)
                conversation="$2"
                shift 2
                ;;
            --json)
                json_output=true
                shift
                ;;
            *)
                files+=("$1")
                shift
                ;;
        esac
    done
    
    if [[ ${#files[@]} -eq 0 ]]; then
        echo -e "${RED}Error: At least one file required${NC}" >&2
        echo "Usage: visited-tracker visit FILE1 [FILE2...] [--context CONTEXT]" >&2
        exit 1
    fi
    
    # Build JSON payload
    local files_json
    files_json=$(printf '%s\n' "${files[@]}" | jq -R . | jq -s .)
    
    local payload
    payload=$(jq -n \
        --argjson files "$files_json" \
        --arg context "$context" \
        --arg agent "$agent" \
        --arg conversation_id "$conversation" \
        '{
            files: $files,
            context: (if $context == "" then null else $context end),
            agent: (if $agent == "" then null else $agent end),
            conversation_id: (if $conversation_id == "" then null else $conversation_id end)
        }')
    
    local response
    response=$(api_request "POST" "/api/v1/visit" "$payload")
    
    if [[ "$json_output" == "true" ]]; then
        echo "$response" | format_json
    else
        local recorded
        recorded=$(echo "$response" | jq -r '.recorded')
        
        echo -e "${GREEN}âœ“ Visit recorded successfully${NC}"
        echo "Files recorded: $recorded"
        
        # Show visit counts for each file
        echo "$response" | jq -r '.files[]? | "  \(.file_path): \(.visit_count) visits"'
    fi
}

sync_structure() {
    local patterns=()
    local structure=""
    local remove_deleted=false
    local json_output=false
    
    while [[ $# -gt 0 ]]; do
        case $1 in
            --patterns)
                IFS=',' read -ra ADDR <<< "$2"
                for i in "${ADDR[@]}"; do
                    patterns+=("$i")
                done
                shift 2
                ;;
            --structure)
                structure="$2"
                shift 2
                ;;
            --remove-deleted)
                remove_deleted=true
                shift
                ;;
            --json)
                json_output=true
                shift
                ;;
            *)
                shift
                ;;
        esac
    done
    
    # Build JSON payload
    local patterns_json
    if [[ ${#patterns[@]} -gt 0 ]]; then
        patterns_json=$(printf '%s\n' "${patterns[@]}" | jq -R . | jq -s .)
    else
        patterns_json="null"
    fi
    
    local payload
    payload=$(jq -n \
        --argjson patterns "$patterns_json" \
        --argjson remove_deleted "$remove_deleted" \
        '{
            patterns: $patterns,
            remove_deleted: $remove_deleted
        }')
    
    local response
    response=$(api_request "POST" "/api/v1/structure/sync" "$payload")
    
    if [[ "$json_output" == "true" ]]; then
        echo "$response" | format_json
    else
        echo -e "${GREEN}âœ“ Structure synchronized${NC}"
        echo "$response" | jq -r '"Added: \(.added) files\nRemoved: \(.removed) files\nTotal: \(.total) files"'
    fi
}

get_least_visited() {
    local limit=""
    local context=""
    local include_unvisited=true
    local patterns=()
    local json_output=false
    local query_params=""
    
    while [[ $# -gt 0 ]]; do
        case $1 in
            --limit)
                limit="$2"
                shift 2
                ;;
            --context)
                context="$2"
                shift 2
                ;;
            --no-unvisited)
                include_unvisited=false
                shift
                ;;
            --patterns)
                IFS=',' read -ra ADDR <<< "$2"
                for i in "${ADDR[@]}"; do
                    patterns+=("$i")
                done
                shift 2
                ;;
            --json)
                json_output=true
                shift
                ;;
            *)
                shift
                ;;
        esac
    done
    
    # Build query parameters
    if [[ -n "$limit" ]]; then
        query_params="?limit=$limit"
    fi
    
    if [[ -n "$context" ]]; then
        if [[ -z "$query_params" ]]; then
            query_params="?context=$context"
        else
            query_params="${query_params}&context=$context"
        fi
    fi
    
    if [[ "$include_unvisited" == "false" ]]; then
        if [[ -z "$query_params" ]]; then
            query_params="?include_unvisited=false"
        else
            query_params="${query_params}&include_unvisited=false"
        fi
    fi
    
    local response
    response=$(api_request "GET" "/api/v1/prioritize/least-visited${query_params}")
    
    if [[ "$json_output" == "true" ]]; then
        echo "$response" | format_json
    else
        echo -e "${CYAN}ðŸ“Š Least Visited Files${NC}"
        echo "$response" | jq -r '.files[]? | "  \(.file_path): \(.visit_count) visits"'
        echo ""
        echo -e "${BLUE}Coverage Statistics:${NC}"
        echo "$response" | jq -r '.coverage | "  Visited: \(.visited) files\n  Unvisited: \(.unvisited) files\n  Coverage: \(.percentage | round)%"'
    fi
}

get_most_stale() {
    local limit=""
    local threshold=""
    local json_output=false
    local query_params=""
    
    while [[ $# -gt 0 ]]; do
        case $1 in
            --limit)
                limit="$2"
                shift 2
                ;;
            --threshold)
                threshold="$2"
                shift 2
                ;;
            --json)
                json_output=true
                shift
                ;;
            *)
                shift
                ;;
        esac
    done
    
    # Build query parameters
    if [[ -n "$limit" ]]; then
        query_params="?limit=$limit"
    fi
    
    if [[ -n "$threshold" ]]; then
        if [[ -z "$query_params" ]]; then
            query_params="?threshold=$threshold"
        else
            query_params="${query_params}&threshold=$threshold"
        fi
    fi
    
    local response
    response=$(api_request "GET" "/api/v1/prioritize/most-stale${query_params}")
    
    if [[ "$json_output" == "true" ]]; then
        echo "$response" | format_json
    else
        echo -e "${YELLOW}âš ï¸  Most Stale Files${NC}"
        echo "$response" | jq -r '.files[]? | "  \(.file_path): staleness=\(.staleness_score | round), visits=\(.visit_count)"'
        echo ""
        echo -e "${BLUE}Staleness Analysis:${NC}"
        echo "$response" | jq -r '"  Average staleness: \(.average_staleness | round)\n  Critical files: \(.critical_count)"'
    fi
}

get_coverage() {
    local patterns=()
    local group_by=""
    local json_output=false
    local query_params=""
    
    while [[ $# -gt 0 ]]; do
        case $1 in
            --patterns)
                IFS=',' read -ra ADDR <<< "$2"
                for i in "${ADDR[@]}"; do
                    patterns+=("$i")
                done
                shift 2
                ;;
            --group-by)
                group_by="$2"
                shift 2
                ;;
            --json)
                json_output=true
                shift
                ;;
            *)
                shift
                ;;
        esac
    done
    
    # Build query parameters
    if [[ ${#patterns[@]} -gt 0 ]]; then
        for pattern in "${patterns[@]}"; do
            if [[ -z "$query_params" ]]; then
                query_params="?patterns=$pattern"
            else
                query_params="${query_params}&patterns=$pattern"
            fi
        done
    fi
    
    if [[ -n "$group_by" ]]; then
        if [[ -z "$query_params" ]]; then
            query_params="?group_by=$group_by"
        else
            query_params="${query_params}&group_by=$group_by"
        fi
    fi
    
    local response
    response=$(api_request "GET" "/api/v1/coverage${query_params}")
    
    if [[ "$json_output" == "true" ]]; then
        echo "$response" | format_json
    else
        echo -e "${GREEN}ðŸ“ˆ Coverage Report${NC}"
        echo "$response" | jq -r '"Total files: \(.total_files)\nVisited: \(.visited_files) (\(.coverage_percentage | round)%)\nUnvisited: \(.unvisited_files)\nAverage visits: \(.average_visits | round)\nAverage staleness: \(.average_staleness | round)"'
        
        if [[ -n "$group_by" ]]; then
            echo ""
            echo -e "${BLUE}Grouped by $group_by:${NC}"
            echo "$response" | jq -r '.groups'
        fi
    fi
}

show_status() {
    local api_url
    api_url=$(get_api_url)
    
    # Get health status
    local health_response
    health_response=$(curl -s "${api_url}/health")
    
    echo -e "${CYAN}ðŸ” Visited Tracker Status${NC}"
    echo "$health_response" | jq -r '"Service: \(.service)\nVersion: \(.version)\nStatus: \(.status)\nDatabase: \(.database)"'
    
    # Get coverage stats
    echo ""
    echo -e "${BLUE}Coverage Overview:${NC}"
    local coverage_response
    coverage_response=$(api_request "GET" "/api/v1/coverage")
    echo "$coverage_response" | jq -r '"Total files: \(.total_files)\nVisited: \(.visited_files) (\(.coverage_percentage | round)%)\nUnvisited: \(.unvisited_files)"'
}

import_data() {
    local file="$1"
    local format="json"
    local merge_strategy="combine"
    local json_output=false
    
    shift
    while [[ $# -gt 0 ]]; do
        case $1 in
            --format)
                format="$2"
                shift 2
                ;;
            --merge)
                merge_strategy="$2"
                shift 2
                ;;
            --json)
                json_output=true
                shift
                ;;
            *)
                shift
                ;;
        esac
    done
    
    if [[ ! -f "$file" ]]; then
        echo -e "${RED}Error: File not found: $file${NC}" >&2
        exit 1
    fi
    
    local data
    data=$(cat "$file")
    
    local payload
    payload=$(jq -n \
        --arg format "$format" \
        --arg merge_strategy "$merge_strategy" \
        --argjson data "$data" \
        '{
            format: $format,
            merge_strategy: $merge_strategy,
            data: $data
        }')
    
    local response
    response=$(api_request "POST" "/api/v1/import" "$payload")
    
    if [[ "$json_output" == "true" ]]; then
        echo "$response" | format_json
    else
        echo -e "${GREEN}âœ“ Import completed${NC}"
        echo "$response" | jq -r '"Imported: \(.imported)\nUpdated: \(.updated)\nConflicts: \(.conflicts)"'
    fi
}

export_data() {
    local file="$1"
    local format="json"
    local include_history=false
    local patterns=()
    local query_params=""
    
    shift
    while [[ $# -gt 0 ]]; do
        case $1 in
            --format)
                format="$2"
                shift 2
                ;;
            --include-history)
                include_history=true
                shift
                ;;
            --patterns)
                IFS=',' read -ra ADDR <<< "$2"
                for i in "${ADDR[@]}"; do
                    patterns+=("$i")
                done
                shift 2
                ;;
            *)
                shift
                ;;
        esac
    done
    
    # Build query parameters
    query_params="?format=$format"
    
    if [[ "$include_history" == "true" ]]; then
        query_params="${query_params}&include_history=true"
    fi
    
    if [[ ${#patterns[@]} -gt 0 ]]; then
        for pattern in "${patterns[@]}"; do
            query_params="${query_params}&patterns=$pattern"
        done
    fi
    
    local response
    response=$(api_request "GET" "/api/v1/export${query_params}")
    
    # Save to file
    echo "$response" > "$file"
    
    echo -e "${GREEN}âœ“ Export completed${NC}"
    echo "$response" | jq -r '"Exported \(.exported_count) files to: '"$file"'"'
}

################################################################################
# Main Command Router
################################################################################
case "${1:-}" in
    visit)
        shift
        record_visit "$@"
        ;;
    sync)
        shift
        sync_structure "$@"
        ;;
    least-visited)
        shift
        get_least_visited "$@"
        ;;
    most-stale)
        shift
        get_most_stale "$@"
        ;;
    coverage)
        shift
        get_coverage "$@"
        ;;
    import)
        shift
        import_data "$@"
        ;;
    export)
        shift
        export_data "$@"
        ;;
    status)
        show_status
        ;;
    version|--version|-v)
        show_version
        ;;
    help|--help|-h|"")
        show_help
        ;;
    *)
        echo -e "${RED}Error: Unknown command '$1'${NC}" >&2
        echo "Run 'visited-tracker help' for usage information" >&2
        exit 1
        ;;
esac