#!/bin/bash
################################################################################
# Visited Tracker CLI - Lightweight API Wrapper
# 
# Persistent file visit tracking with staleness detection for systematic code analysis
# Port discovery uses vrooli scenario port command for dynamic allocation
################################################################################

set -e

# Configuration
SCENARIO_NAME="visited-tracker"
CAMPAIGN_ID="${VISITED_TRACKER_CAMPAIGN_ID:-}"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
PURPLE='\033[0;35m'
NC='\033[0m' # No Color

################################################################################
# Port Discovery - Dynamic port lookup
################################################################################
get_api_url() {
    # Use vrooli scenario port command for dynamic port lookup
    local api_port
    api_port=$(vrooli scenario port "${SCENARIO_NAME}" API_PORT 2>/dev/null)
    
    if [[ -z "$api_port" ]]; then
        echo -e "${RED}‚ùå Error: ${SCENARIO_NAME} is not running${NC}" >&2
        echo "   Start it with: vrooli scenario run ${SCENARIO_NAME}" >&2
        exit 1
    fi
    
    echo "http://localhost:${api_port}"
}

################################################################################
# Helper Functions
################################################################################
show_help() {
    echo -e "${CYAN}üîç Visited Tracker CLI${NC}"
    echo "Persistent file visit tracking with staleness detection for systematic code analysis"
    echo ""
    echo "Usage: visited-tracker [global options] [command] [options]"
    echo ""
    echo "Global Options:"
    echo "  --campaign-id ID           Campaign ID to target (overrides VISITED_TRACKER_CAMPAIGN_ID)"
    echo ""
    echo "Commands:"
    echo -e "  ${GREEN}visit${NC} FILE1 [FILE2...]       Record file visit(s) with optional notes"
    echo -e "  ${GREEN}exclude${NC} FILE1 [FILE2...]     Mark files as complete/excluded"
    echo -e "  ${GREEN}least-visited${NC}                Get prioritized list of least visited files"
    echo -e "  ${GREEN}most-stale${NC}                   Get files with highest staleness scores"
    echo -e "  ${GREEN}sync${NC}                         Sync file structure and detect changes"
    echo -e "  ${GREEN}coverage${NC}                     Show visit coverage statistics"
    echo -e "  ${GREEN}campaigns${NC} [subcommand]       Manage campaigns (list, create, delete, note, reset)"
    echo -e "  ${GREEN}import${NC} FILE                  Import visited data from file"
    echo -e "  ${GREEN}export${NC} FILE                  Export visited data to file"
    echo -e "  ${GREEN}status${NC}                       Show tracking status and coverage summary"
    echo -e "  ${GREEN}help${NC}                         Show this help message"
    echo -e "  ${GREEN}version${NC}                      Show version information"
    echo ""
    echo "Auto-Creation Options (for visit, exclude, least-visited, campaigns note/reset):"
    echo "  --location PATH              Campaign location (e.g., scenarios/X/ui)"
    echo "  --tag TAG                    Campaign tag (e.g., ux, refactor, test)"
    echo "  --pattern GLOB               File pattern (default: **/*)"
    echo "  Note: When --location and --tag are provided, campaign is auto-created if needed"
    echo ""
    echo "Visit Options:"
    echo "  --note TEXT                  Add note to visited file(s)"
    echo "  --context CONTEXT            Visit context (security/performance/bug/docs)"
    echo "  --agent AGENT                AI model or agent name"
    echo "  --conversation ID            Conversation ID for grouping visits"
    echo ""
    echo "Exclude Options:"
    echo "  --reason TEXT                Reason for exclusion (stored as file note)"
    echo ""
    echo "Query Options:"
    echo "  --limit N                    Number of files to return"
    echo "  --threshold N                Minimum staleness score"
    echo "  --patterns PATTERN           Glob patterns for filtering"
    echo "  --include-unvisited          Include never-visited files"
    echo "  --remove-deleted             Remove deleted files from tracking"
    echo "  --group-by TYPE              Group coverage by directory/extension/context"
    echo "  --json                       Output raw JSON"
    echo ""
    echo "Examples:"
    echo ""
    echo "  # Auto-creation pattern - zero-friction agent workflow"
    echo "  visited-tracker least-visited --location scenarios/X/ui --tag ux --pattern '**/*.tsx' --limit 5"
    echo "  visited-tracker visit ui/src/App.tsx --tag ux --location scenarios/X/ui --note 'Improved accessibility'"
    echo "  visited-tracker exclude ui/src/App.tsx --tag ux --location scenarios/X/ui --reason 'All UX work complete'"
    echo "  visited-tracker campaigns note --location scenarios/X/ui --tag ux --note 'Handoff: focus on state mgmt'"
    echo ""
    echo "  # Traditional workflow with explicit campaign ID"
    echo "  visited-tracker campaigns create --name my-review --pattern '**/*.js'"
    echo "  visited-tracker visit src/main.js --note 'Refactored validation logic'"
    echo "  visited-tracker coverage --group-by directory"
}

show_version() {
    local api_url
    api_url=$(get_api_url 2>/dev/null || echo "API not running")
    echo "visited-tracker CLI v1.0.0"
    echo "API: ${api_url}"
}

# Format JSON output if jq is available
format_json() {
    if command -v jq >/dev/null 2>&1; then
        jq .
    else
        cat
    fi
}

ensure_campaign_id() {
    if [ -n "${CAMPAIGN_ID:-}" ]; then
        return 0
    fi

    local campaigns_json=""
    if ! campaigns_json=$(api_request "GET" "/api/v1/campaigns" "" true); then
        echo -e "${RED}Error: No campaign selected and unable to list campaigns.${NC}" >&2
        echo "       Set VISITED_TRACKER_CAMPAIGN_ID or create one with 'visited-tracker campaigns create'." >&2
        return 1
    fi

    local first_campaign
    first_campaign=$(echo "$campaigns_json" | jq -r '.campaigns[0].id // empty' 2>/dev/null || echo "")
    if [ -z "$first_campaign" ]; then
        echo -e "${RED}Error: No campaigns available.${NC}" >&2
        echo "       Create one with: visited-tracker campaigns create --name <name> --pattern '**/*.js'" >&2
        return 1
    fi

    CAMPAIGN_ID="$first_campaign"
    export VISITED_TRACKER_CAMPAIGN_ID="$CAMPAIGN_ID"
    return 0
}

# Find or create campaign by location + tag
# Returns campaign ID in CAMPAIGN_ID variable
find_or_create_campaign() {
    local location="$1"
    local tag="$2"
    local pattern="${3:-**/*}"

    if [ -z "$location" ] || [ -z "$tag" ]; then
        echo -e "${RED}Error: Both --location and --tag are required for auto-creation.${NC}" >&2
        return 1
    fi

    # List all campaigns and search for matching location + tag
    local campaigns_json
    campaigns_json=$(api_request "GET" "/api/v1/campaigns" "" true) || return 1

    # Search for campaign with matching location and tag
    local found_id
    found_id=$(echo "$campaigns_json" | jq -r --arg loc "$location" --arg t "$tag" '
        .campaigns[]?
        | select(.location == $loc and .tag == $t)
        | .id' | head -1)

    if [ -n "$found_id" ]; then
        CAMPAIGN_ID="$found_id"
        export VISITED_TRACKER_CAMPAIGN_ID="$CAMPAIGN_ID"
        return 0
    fi

    # Campaign not found - create it
    local campaign_name="${tag}-$(basename "$location")"
    local payload
    payload=$(jq -n \
        --arg name "$campaign_name" \
        --arg from_agent "cli-auto" \
        --arg location "$location" \
        --arg tag "$tag" \
        --arg pattern "$pattern" \
        '{
            name: $name,
            from_agent: $from_agent,
            location: $location,
            tag: $tag,
            patterns: [$pattern]
        }')

    local response
    response=$(api_request "POST" "/api/v1/campaigns" "$payload") || return 1

    local new_id
    new_id=$(echo "$response" | jq -r '.id // empty')
    if [ -z "$new_id" ]; then
        echo -e "${RED}Error: Failed to create campaign.${NC}" >&2
        return 1
    fi

    CAMPAIGN_ID="$new_id"
    export VISITED_TRACKER_CAMPAIGN_ID="$CAMPAIGN_ID"
    echo -e "${GREEN}‚úì Auto-created campaign:${NC} $campaign_name (ID: $new_id)" >&2
    return 0
}

# Find file in campaign by path and return file_id
# Usage: find_file_in_campaign CAMPAIGN_ID FILE_PATH
find_file_in_campaign() {
    local camp_id="$1"
    local file_path="$2"

    # Get absolute path for comparison
    local abs_path
    if [[ "$file_path" = /* ]]; then
        abs_path="$file_path"
    else
        abs_path="$(cd "$(dirname "$file_path")" 2>/dev/null && pwd)/$(basename "$file_path")"
        if [ -z "$abs_path" ] || [ "$abs_path" = "/$(basename "$file_path")" ]; then
            # File doesn't exist yet, construct path from cwd
            abs_path="$(pwd)/$file_path"
        fi
    fi

    # Get campaign and search for file
    local campaign_json
    campaign_json=$(api_request "GET" "/api/v1/campaigns/$camp_id" "" true) || return 1

    # Try to find file by absolute path or relative path
    local file_id
    file_id=$(echo "$campaign_json" | jq -r --arg path "$file_path" --arg abs "$abs_path" '
        .tracked_files[]?
        | select(.file_path == $path or .absolute_path == $abs)
        | .id' | head -1)

    if [ -z "$file_id" ]; then
        return 1
    fi

    echo "$file_id"
    return 0
}

campaign_endpoint() {
    local suffix="$1"
    ensure_campaign_id || exit 1
    echo "/api/v1/campaigns/${CAMPAIGN_ID}${suffix}"
}

# Make API request
api_request() {
    local method="$1"
    local endpoint="$2"
    local data="${3:-}"
    local allow_failure="${4:-false}"
    local api_url
    
    # Get the current API URL
    api_url=$(get_api_url)
    
    local curl_args=(-sS)
    
    if [[ "$method" != "GET" ]]; then
        curl_args+=(-X "$method")
    fi
    
    if [[ -n "$data" ]]; then
        curl_args+=(-H "Content-Type: application/json" -d "$data")
    fi

    local tmp_body
    tmp_body=$(mktemp)
    local http_code
    local curl_exit=0

    http_code=$(curl "${curl_args[@]}" -w "%{http_code}" -o "$tmp_body" "${api_url}${endpoint}") || curl_exit=$?
    local body
    body=$(cat "$tmp_body")
    rm -f "$tmp_body"

    # curl command failed (network error, etc.)
    if [ $curl_exit -ne 0 ]; then
        if [ "$allow_failure" = "true" ]; then
            printf '%s' "$body"
            return $curl_exit
        fi
        echo -e "${RED}Error: Request to ${endpoint} failed (curl exit $curl_exit).${NC}" >&2
        printf '%s\n' "$body" >&2
        exit 1
    fi

    # HTTP error handling
    if [[ "$http_code" =~ ^[0-9]+$ ]] && [ "$http_code" -ge 400 ]; then
        if [ "$allow_failure" = "true" ]; then
            printf '%s' "$body"
            return 1
        fi
        echo -e "${RED}Error: API responded with status $http_code for ${endpoint}.${NC}" >&2
        if [ -n "$body" ]; then
            printf '%s\n' "$body" | format_json >&2
        fi
        exit 1
    fi

    printf '%s' "$body"
}

################################################################################
# Command Handlers
################################################################################
record_visit() {
    local files=()
    local context=""
    local agent=""
    local conversation=""
    local note=""
    local location=""
    local tag=""
    local pattern="**/*"
    local json_output=false

    while [[ $# -gt 0 ]]; do
        case $1 in
            --context)
                context="$2"
                shift 2
                ;;
            --agent)
                agent="$2"
                shift 2
                ;;
            --conversation)
                conversation="$2"
                shift 2
                ;;
            --note)
                note="$2"
                shift 2
                ;;
            --location)
                location="$2"
                shift 2
                ;;
            --tag)
                tag="$2"
                shift 2
                ;;
            --pattern)
                pattern="$2"
                shift 2
                ;;
            --json)
                json_output=true
                shift
                ;;
            *)
                files+=("$1")
                shift
                ;;
        esac
    done

    if [[ ${#files[@]} -eq 0 ]]; then
        echo -e "${RED}Error: At least one file required${NC}" >&2
        echo "Usage: visited-tracker visit FILE1 [FILE2...] [--note NOTE] [--tag TAG] [--location LOCATION]" >&2
        exit 1
    fi

    # Auto-create or find campaign if location + tag provided
    if [[ -n "$location" ]] && [[ -n "$tag" ]]; then
        find_or_create_campaign "$location" "$tag" "$pattern" || exit 1
    fi

    # Build JSON payload
    local files_json
    files_json=$(printf '%s\n' "${files[@]}" | jq -R . | jq -s .)

    local payload
    payload=$(jq -n \
        --argjson files "$files_json" \
        --arg context "$context" \
        --arg agent "$agent" \
        --arg conversation_id "$conversation" \
        '{
            files: $files,
            context: (if $context == "" then null else $context end),
            agent: (if $agent == "" then null else $agent end),
            conversation_id: (if $conversation_id == "" then null else $conversation_id end)
        }')

    local response
    response=$(api_request "POST" "$(campaign_endpoint "/visit")" "$payload")

    # If note provided, update file notes for each file
    if [[ -n "$note" ]]; then
        for file in "${files[@]}"; do
            local file_id
            if file_id=$(find_file_in_campaign "$CAMPAIGN_ID" "$file" 2>/dev/null); then
                local note_payload
                note_payload=$(jq -n --arg notes "$note" '{notes: $notes}')
                api_request "PATCH" "/api/v1/campaigns/${CAMPAIGN_ID}/files/${file_id}/notes" "$note_payload" true >/dev/null || true
            fi
        done
    fi

    if [[ "$json_output" == "true" ]]; then
        echo "$response" | format_json
    else
        local recorded
        recorded=$(echo "$response" | jq -r '.recorded')

        echo -e "${GREEN}‚úì Visit recorded successfully${NC}"
        echo "Files recorded: $recorded"

        if [[ -n "$note" ]]; then
            echo -e "${BLUE}Note:${NC} $note"
        fi

        # Show visit counts for each file
        echo "$response" | jq -r '
            (.files // [])
            | map(
                if type == "object" then
                    "  \(.file_path // .path // .file): \(.visit_count // 0) visits"
                else
                    "  \(.): recorded"
                end
            )[]'
    fi
}

sync_structure() {
    local patterns=()
    local structure=""
    local remove_deleted=false
    local json_output=false
    
    while [[ $# -gt 0 ]]; do
        case $1 in
            --patterns)
                IFS=',' read -ra ADDR <<< "$2"
                for i in "${ADDR[@]}"; do
                    patterns+=("$i")
                done
                shift 2
                ;;
            --structure)
                structure="$2"
                shift 2
                ;;
            --remove-deleted)
                remove_deleted=true
                shift
                ;;
            --json)
                json_output=true
                shift
                ;;
            *)
                shift
                ;;
        esac
    done
    
    # Build JSON payload
    local patterns_json
    if [[ ${#patterns[@]} -gt 0 ]]; then
        patterns_json=$(printf '%s\n' "${patterns[@]}" | jq -R . | jq -s .)
    else
        patterns_json="null"
    fi
    
    local payload
    payload=$(jq -n \
        --argjson patterns "$patterns_json" \
        --argjson remove_deleted "$remove_deleted" \
        '{
            patterns: $patterns,
            remove_deleted: $remove_deleted
        }')
    
    local response
    response=$(api_request "POST" "$(campaign_endpoint "/structure/sync")" "$payload")
    
    if [[ "$json_output" == "true" ]]; then
        echo "$response" | format_json
    else
        echo -e "${GREEN}‚úì Structure synchronized${NC}"
        echo "$response" | jq -r '"Added: \(.added) files\nRemoved: \(.removed) files\nTotal: \(.total) files"'
    fi
}

exclude_file() {
    local files=()
    local reason=""
    local location=""
    local tag=""
    local pattern="**/*"
    local json_output=false

    while [[ $# -gt 0 ]]; do
        case $1 in
            --reason)
                reason="$2"
                shift 2
                ;;
            --location)
                location="$2"
                shift 2
                ;;
            --tag)
                tag="$2"
                shift 2
                ;;
            --pattern)
                pattern="$2"
                shift 2
                ;;
            --json)
                json_output=true
                shift
                ;;
            *)
                files+=("$1")
                shift
                ;;
        esac
    done

    if [[ ${#files[@]} -eq 0 ]]; then
        echo -e "${RED}Error: At least one file required${NC}" >&2
        echo "Usage: visited-tracker exclude FILE1 [FILE2...] [--reason REASON] [--tag TAG] [--location LOCATION]" >&2
        exit 1
    fi

    # Auto-create or find campaign if location + tag provided
    if [[ -n "$location" ]] && [[ -n "$tag" ]]; then
        find_or_create_campaign "$location" "$tag" "$pattern" || exit 1
    fi

    local excluded_count=0
    for file in "${files[@]}"; do
        local file_id
        if file_id=$(find_file_in_campaign "$CAMPAIGN_ID" "$file" 2>/dev/null); then
            # Mark file as excluded
            local exclude_payload
            exclude_payload=$(jq -n '{excluded: true}')
            api_request "PATCH" "/api/v1/campaigns/${CAMPAIGN_ID}/files/${file_id}/exclude" "$exclude_payload" true >/dev/null

            # Add reason as note if provided
            if [[ -n "$reason" ]]; then
                local note_payload
                note_payload=$(jq -n --arg notes "$reason" '{notes: $notes}')
                api_request "PATCH" "/api/v1/campaigns/${CAMPAIGN_ID}/files/${file_id}/notes" "$note_payload" true >/dev/null || true
            fi

            ((excluded_count++))
        else
            echo -e "${YELLOW}‚ö† File not found in campaign:${NC} $file" >&2
        fi
    done

    if [[ "$json_output" == "true" ]]; then
        jq -n --argjson count "$excluded_count" --argjson files "$(printf '%s\n' "${files[@]}" | jq -R . | jq -s .)" \
            '{excluded: $count, files: $files}'
    else
        echo -e "${GREEN}‚úì Excluded $excluded_count file(s)${NC}"
        if [[ -n "$reason" ]]; then
            echo -e "${BLUE}Reason:${NC} $reason"
        fi
        for file in "${files[@]}"; do
            echo "  $file"
        done
    fi
}

get_least_visited() {
    local limit=""
    local context=""
    local include_unvisited=true
    local location=""
    local tag=""
    local pattern="**/*"
    local patterns=()
    local json_output=false
    local query_params=""

    while [[ $# -gt 0 ]]; do
        case $1 in
            --limit)
                limit="$2"
                shift 2
                ;;
            --context)
                context="$2"
                shift 2
                ;;
            --no-unvisited)
                include_unvisited=false
                shift
                ;;
            --location)
                location="$2"
                shift 2
                ;;
            --tag)
                tag="$2"
                shift 2
                ;;
            --pattern)
                pattern="$2"
                shift 2
                ;;
            --patterns)
                IFS=',' read -ra ADDR <<< "$2"
                for i in "${ADDR[@]}"; do
                    patterns+=("$i")
                done
                shift 2
                ;;
            --json)
                json_output=true
                shift
                ;;
            *)
                shift
                ;;
        esac
    done

    # Auto-create or find campaign if location + tag provided
    if [[ -n "$location" ]] && [[ -n "$tag" ]]; then
        find_or_create_campaign "$location" "$tag" "$pattern" || exit 1
    fi

    # Build query parameters
    if [[ -n "$limit" ]]; then
        if ! [[ "$limit" =~ ^[0-9]+$ ]]; then
            echo -e "${RED}Error: --limit must be a positive integer.${NC}" >&2
            return 1
        fi
        query_params="?limit=$limit"
    fi

    if [[ -n "$context" ]]; then
        if [[ -z "$query_params" ]]; then
            query_params="?context=$context"
        else
            query_params="${query_params}&context=$context"
        fi
    fi

    if [[ "$include_unvisited" == "false" ]]; then
        if [[ -z "$query_params" ]]; then
            query_params="?include_unvisited=false"
        else
            query_params="${query_params}&include_unvisited=false"
        fi
    fi

    local response
    response=$(api_request "GET" "$(campaign_endpoint "/prioritize/least-visited")${query_params}")

    if [[ "$json_output" == "true" ]]; then
        echo "$response" | format_json
    else
        echo -e "${CYAN}üìä Least Visited Files${NC}"
        local files_output
        files_output=$(echo "$response" | jq -r '(.files // [])[] | "  \(.file_path): \(.visit_count // 0) visits"')
        if [ -n "$files_output" ]; then
            echo "$files_output"
        else
            echo "  No tracked files yet"
        fi
        echo ""
        echo -e "${BLUE}Coverage Statistics:${NC}"
        echo "$response" | jq -r '(.coverage // {visited:0,unvisited:0,percentage:0}) | "  Visited: \(.visited // 0) files\n  Unvisited: \(.unvisited // 0) files\n  Coverage: \((.percentage // 0) | round)%"'
    fi
}

get_most_stale() {
    local limit=""
    local threshold=""
    local json_output=false
    local query_params=""
    
    while [[ $# -gt 0 ]]; do
        case $1 in
            --limit)
                limit="$2"
                shift 2
                ;;
            --threshold)
                threshold="$2"
                shift 2
                ;;
            --json)
                json_output=true
                shift
                ;;
            *)
                shift
                ;;
        esac
    done
    
    # Build query parameters
    if [[ -n "$limit" ]]; then
        query_params="?limit=$limit"
    fi
    
    if [[ -n "$threshold" ]]; then
        if ! [[ "$threshold" =~ ^[0-9]+(\.[0-9]+)?$ ]]; then
            echo -e "${RED}Error: --threshold must be numeric.${NC}" >&2
            return 1
        fi
        if [[ -z "$query_params" ]]; then
            query_params="?threshold=$threshold"
        else
            query_params="${query_params}&threshold=$threshold"
        fi
    fi
    
    local response
    response=$(api_request "GET" "$(campaign_endpoint "/prioritize/most-stale")${query_params}")
    
    if [[ "$json_output" == "true" ]]; then
        echo "$response" | format_json
    else
        echo -e "${YELLOW}‚ö†Ô∏è  Most Stale Files${NC}"
        local stale_output
        stale_output=$(echo "$response" | jq -r '(.files // [])[] | "  \(.file_path): staleness=\((.staleness_score // 0) | round), visits=\(.visit_count // 0)"')
        if [ -n "$stale_output" ]; then
            echo "$stale_output"
        else
            echo "  No stale files detected"
        fi
        echo ""
        echo -e "${BLUE}Staleness Analysis:${NC}"
        echo "$response" | jq -r '"  Average staleness: \(((.average_staleness // 0) | round))\n  Critical files: \(.critical_count // 0)"'
    fi
}

get_coverage() {
    local patterns=()
    local group_by=""
    local json_output=false
    local query_params=""
    
    while [[ $# -gt 0 ]]; do
        case $1 in
            --patterns)
                IFS=',' read -ra ADDR <<< "$2"
                for i in "${ADDR[@]}"; do
                    patterns+=("$i")
                done
                shift 2
                ;;
            --group-by)
                group_by="$2"
                shift 2
                ;;
            --json)
                json_output=true
                shift
                ;;
            *)
                shift
                ;;
        esac
    done
    
    # Build query parameters
    if [[ ${#patterns[@]} -gt 0 ]]; then
        for pattern in "${patterns[@]}"; do
            if [[ -z "$query_params" ]]; then
                query_params="?patterns=$pattern"
            else
                query_params="${query_params}&patterns=$pattern"
            fi
        done
    fi
    
    if [[ -n "$group_by" ]]; then
        if [[ -z "$query_params" ]]; then
            query_params="?group_by=$group_by"
        else
            query_params="${query_params}&group_by=$group_by"
        fi
    fi
    
    local response
    response=$(api_request "GET" "$(campaign_endpoint "/coverage")${query_params}")
    
    if [[ "$json_output" == "true" ]]; then
        echo "$response" | format_json
    else
        echo -e "${GREEN}üìà Coverage Report${NC}"
        echo "$response" | jq -r '"Total files: \(.total_files // 0)\nVisited: \(.visited_files // 0) (\((.coverage_percentage // 0) | round)%)\nUnvisited: \(.unvisited_files // 0)\nAverage visits: \((.average_visits // 0) | round)\nAverage staleness: \((.average_staleness // 0) | round)"'
        
        if [[ -n "$group_by" ]]; then
            echo ""
            echo -e "${BLUE}Grouped by $group_by:${NC}"
            echo "$response" | jq -r '(.groups // [])'
        fi
    fi
}

campaigns_command() {
    local subcommand="${1:-list}"
    shift || true

    case "$subcommand" in
        list)
            local response
            response=$(api_request "GET" "/api/v1/campaigns")
            echo "$response" | format_json
            ;;
        note)
            local note=""
            local location=""
            local tag=""
            local pattern="**/*"
            local json_output=false

            while [[ $# -gt 0 ]]; do
                case $1 in
                    --note)
                        note="$2"
                        shift 2
                        ;;
                    --location)
                        location="$2"
                        shift 2
                        ;;
                    --tag)
                        tag="$2"
                        shift 2
                        ;;
                    --pattern)
                        pattern="$2"
                        shift 2
                        ;;
                    --json)
                        json_output=true
                        shift
                        ;;
                    *)
                        echo -e "${RED}Error: Unknown option '$1' for campaigns note.${NC}" >&2
                        return 1
                        ;;
                esac
            done

            if [ -z "$note" ]; then
                echo -e "${RED}Error: --note is required for campaigns note.${NC}" >&2
                return 1
            fi

            # Auto-create or find campaign if location + tag provided
            if [[ -n "$location" ]] && [[ -n "$tag" ]]; then
                find_or_create_campaign "$location" "$tag" "$pattern" || exit 1
            elif [ -z "$CAMPAIGN_ID" ]; then
                ensure_campaign_id || exit 1
            fi

            # Update campaign notes
            local payload
            payload=$(jq -n --arg notes "$note" '{notes: $notes}')
            local response
            response=$(api_request "PATCH" "/api/v1/campaigns/${CAMPAIGN_ID}" "$payload")

            if [ "$json_output" = true ]; then
                echo "$response" | format_json
            else
                echo -e "${GREEN}‚úì Campaign note updated${NC}"
                echo -e "${BLUE}Note:${NC} $note"
            fi
            ;;
        reset)
            local location=""
            local tag=""
            local pattern="**/*"
            local json_output=false

            while [[ $# -gt 0 ]]; do
                case $1 in
                    --location)
                        location="$2"
                        shift 2
                        ;;
                    --tag)
                        tag="$2"
                        shift 2
                        ;;
                    --pattern)
                        pattern="$2"
                        shift 2
                        ;;
                    --json)
                        json_output=true
                        shift
                        ;;
                    *)
                        echo -e "${RED}Error: Unknown option '$1' for campaigns reset.${NC}" >&2
                        return 1
                        ;;
                esac
            done

            # Auto-create or find campaign if location + tag provided
            if [[ -n "$location" ]] && [[ -n "$tag" ]]; then
                find_or_create_campaign "$location" "$tag" "$pattern" || exit 1
            elif [ -z "$CAMPAIGN_ID" ]; then
                ensure_campaign_id || exit 1
            fi

            # Get campaign details for recreation
            local campaign_json
            campaign_json=$(api_request "GET" "/api/v1/campaigns/${CAMPAIGN_ID}")
            local name
            name=$(echo "$campaign_json" | jq -r '.name')
            local from_agent
            from_agent=$(echo "$campaign_json" | jq -r '.from_agent // "cli"')
            local patterns_json
            patterns_json=$(echo "$campaign_json" | jq -c '.patterns')
            local camp_location
            camp_location=$(echo "$campaign_json" | jq -r '.location // empty')
            local camp_tag
            camp_tag=$(echo "$campaign_json" | jq -r '.tag // empty')

            # Delete old campaign
            api_request "DELETE" "/api/v1/campaigns/${CAMPAIGN_ID}" >/dev/null

            # Create fresh campaign
            local payload
            if [ -n "$camp_location" ] && [ -n "$camp_tag" ]; then
                payload=$(jq -n \
                    --arg name "$name" \
                    --arg from_agent "$from_agent" \
                    --arg loc "$camp_location" \
                    --arg t "$camp_tag" \
                    --argjson patterns "$patterns_json" \
                    '{name: $name, from_agent: $from_agent, location: $loc, tag: $t, patterns: $patterns}')
            else
                payload=$(jq -n \
                    --arg name "$name" \
                    --arg from_agent "$from_agent" \
                    --argjson patterns "$patterns_json" \
                    '{name: $name, from_agent: $from_agent, patterns: $patterns}')
            fi

            local response
            response=$(api_request "POST" "/api/v1/campaigns" "$payload")
            local new_id
            new_id=$(echo "$response" | jq -r '.id')

            CAMPAIGN_ID="$new_id"
            export VISITED_TRACKER_CAMPAIGN_ID="$CAMPAIGN_ID"

            if [ "$json_output" = true ]; then
                echo "$response" | format_json
            else
                echo -e "${GREEN}‚úì Campaign reset:${NC} $name"
                echo "New ID: $new_id"
                echo "All visit tracking has been cleared"
            fi
            ;;
        create)
            local name=""
            local from_agent="cli"
            local description=""
            local patterns=()
            local metadata="{}"
            local json_output=false

            while [[ $# -gt 0 ]]; do
                case $1 in
                    --name)
                        name="$2"
                        shift 2
                        ;;
                    --pattern)
                        patterns+=("$2")
                        shift 2
                        ;;
                    --patterns)
                        IFS=',' read -ra ADDR <<< "$2"
                        for i in "${ADDR[@]}"; do
                            patterns+=("$i")
                        done
                        shift 2
                        ;;
                    --from-agent)
                        from_agent="$2"
                        shift 2
                        ;;
                    --description)
                        description="$2"
                        shift 2
                        ;;
                    --metadata)
                        metadata="$2"
                        shift 2
                        ;;
                    --json)
                        json_output=true
                        shift
                        ;;
                    *)
                        echo -e "${RED}Error: Unknown option '$1' for campaigns create.${NC}" >&2
                        echo "Usage: visited-tracker campaigns create --name <name> --pattern '<glob>'" >&2
                        return 1
                        ;;
                esac
            done

            if [ -z "$name" ]; then
                echo -e "${RED}Error: --name is required for campaigns create.${NC}" >&2
                return 1
            fi

            if [ ${#patterns[@]} -eq 0 ]; then
                echo -e "${RED}Error: At least one --pattern or --patterns value is required.${NC}" >&2
                return 1
            fi

            local patterns_json
            patterns_json=$(printf '%s\n' "${patterns[@]}" | jq -R . | jq -s .)

            local payload
            if [ -n "$description" ]; then
                payload=$(jq -n \
                    --arg name "$name" \
                    --arg from_agent "$from_agent" \
                    --arg description "$description" \
                    --argjson patterns "$patterns_json" \
                    --argjson metadata "$metadata" \
                    '{name: $name, from_agent: $from_agent, description: $description, patterns: $patterns, metadata: $metadata}')
            else
                payload=$(jq -n \
                    --arg name "$name" \
                    --arg from_agent "$from_agent" \
                    --argjson patterns "$patterns_json" \
                    --argjson metadata "$metadata" \
                    '{name: $name, from_agent: $from_agent, patterns: $patterns, metadata: $metadata}')
            fi

            local response
            response=$(api_request "POST" "/api/v1/campaigns" "$payload")
            local new_id
            new_id=$(echo "$response" | jq -r '.id // empty')
            if [ -n "$new_id" ]; then
                CAMPAIGN_ID="$new_id"
                export VISITED_TRACKER_CAMPAIGN_ID="$CAMPAIGN_ID"
            fi

            if [ "$json_output" = true ]; then
                echo "$response" | format_json
            else
                echo -e "${GREEN}‚úì Campaign created:${NC} $name"
                echo "ID: ${new_id}"
                echo "Patterns: ${patterns[*]}"
            fi
            ;;
        delete)
            local target_id=""
            local json_output=false

            if [[ $# -gt 0 ]]; then
                target_id="$1"
                shift
            fi

            while [[ $# -gt 0 ]]; do
                case $1 in
                    --json)
                        json_output=true
                        shift
                        ;;
                    *)
                        echo -e "${RED}Error: Unknown option '$1' for campaigns delete.${NC}" >&2
                        return 1
                        ;;
                esac
            done

            if [ -z "$target_id" ]; then
                echo -e "${RED}Error: campaigns delete requires a campaign ID.${NC}" >&2
                return 1
            fi

            local response
            response=$(api_request "DELETE" "/api/v1/campaigns/$target_id")

            if [ "$CAMPAIGN_ID" = "$target_id" ]; then
                CAMPAIGN_ID=""
                unset VISITED_TRACKER_CAMPAIGN_ID
            fi

            if [ "$json_output" = true ]; then
                echo "$response" | format_json
            else
                echo -e "${GREEN}‚úì Campaign deleted:${NC} $target_id"
            fi
            ;;
        *)
            echo -e "${RED}Error: Unknown campaigns subcommand '$subcommand'.${NC}" >&2
            echo "Available subcommands: list, create, delete, note, reset" >&2
            return 1
            ;;
    esac
}

show_status() {
    local api_url
    api_url=$(get_api_url)
    
    # Get health status
    local health_response
    if ! health_response=$(curl -sS "${api_url}/health" 2>/dev/null); then
        echo -e "${RED}Error: Unable to reach Visited Tracker API at ${api_url}/health.${NC}" >&2
        return 1
    fi
    
    echo -e "${CYAN}üîç Visited Tracker Status${NC}"
    echo "$health_response" | jq -r '"Service: \(.service)\nVersion: \(.version)\nStatus: \(.status)\nUptime: \(.metrics.uptime_seconds // 0 | floor)s"'
    
    # Get coverage stats (if endpoint exists)
    echo ""
    echo -e "${BLUE}Coverage Overview:${NC}"
    if ensure_campaign_id; then
        local coverage_response=""
        local coverage_status=0
        coverage_response=$(api_request "GET" "/api/v1/campaigns/${CAMPAIGN_ID}/coverage" "" true) || coverage_status=$?
        if [ $coverage_status -eq 0 ] && echo "$coverage_response" | jq empty 2>/dev/null; then
            echo "$coverage_response" | jq -r '"Total files: \(.total_files // 0)\nVisited: \(.visited_files // 0) (\(.coverage_percentage // 0 | round)%)\nUnvisited: \(.unvisited_files // 0)"'
        else
            echo "Coverage data not available (campaign request failed)"
        fi
    else
        echo "Coverage data not available (no campaigns found)"
    fi
}

import_data() {
    local file="$1"
    local format="json"
    local merge_strategy="combine"
    local json_output=false
    
    shift
    while [[ $# -gt 0 ]]; do
        case $1 in
            --format)
                format="$2"
                shift 2
                ;;
            --merge)
                merge_strategy="$2"
                shift 2
                ;;
            --json)
                json_output=true
                shift
                ;;
            *)
                shift
                ;;
        esac
    done
    
    if [[ ! -f "$file" ]]; then
        echo -e "${RED}Error: File not found: $file${NC}" >&2
        exit 1
    fi
    
    local message
    message=$(jq -n --arg msg "Import command placeholder ‚Äì API import endpoint not yet implemented" '{message: $msg}')

    if [[ "$json_output" == "true" ]]; then
        echo "$message" | format_json
    else
        echo -e "${YELLOW}‚ö† Import placeholder${NC}"
        echo "$message" | jq -r '.message'
    fi
}

export_data() {
    local file="$1"
    local format="json"
    local include_history=false
    local patterns=()
    local query_params=""
    
    shift
    while [[ $# -gt 0 ]]; do
        case $1 in
            --format)
                format="$2"
                shift 2
                ;;
            --include-history)
                include_history=true
                shift
                ;;
            --patterns)
                IFS=',' read -ra ADDR <<< "$2"
                for i in "${ADDR[@]}"; do
                    patterns+=("$i")
                done
                shift 2
                ;;
            *)
                shift
                ;;
        esac
    done
    
    # Build query parameters
    query_params="?format=$format"
    
    if [[ "$include_history" == "true" ]]; then
        query_params="${query_params}&include_history=true"
    fi
    
    if [[ ${#patterns[@]} -gt 0 ]]; then
        for pattern in "${patterns[@]}"; do
            query_params="${query_params}&patterns=$pattern"
        done
    fi
    
    local response
    response=$(api_request "GET" "$(campaign_endpoint "/export")${query_params}")
    
    # Save to file
    echo "$response" > "$file"
    
    echo -e "${GREEN}‚úì Export completed${NC}"
    echo "$response" | jq -r '"Exported \(.exported_count) files to: '"$file"'"'
}

################################################################################
# Main Command Router
################################################################################

while [[ $# -gt 0 ]]; do
    case $1 in
        --campaign|--campaign-id)
            if [[ $# -lt 2 ]]; then
                echo -e "${RED}Error: --campaign-id requires an argument.${NC}" >&2
                exit 1
            fi
            CAMPAIGN_ID="$2"
            export VISITED_TRACKER_CAMPAIGN_ID="$CAMPAIGN_ID"
            shift 2
            ;;
        --campaign=*|--campaign-id=*)
            CAMPAIGN_ID="${1#*=}"
            export VISITED_TRACKER_CAMPAIGN_ID="$CAMPAIGN_ID"
            shift
            ;;
        --)
            shift
            break
            ;;
        *)
            break
            ;;
    esac
done

COMMAND="${1:-help}"
if [[ $# -gt 0 ]]; then
    shift
fi

case "$COMMAND" in
    visit)
        record_visit "$@"
        ;;
    exclude)
        exclude_file "$@"
        ;;
    sync)
        sync_structure "$@"
        ;;
    least-visited)
        get_least_visited "$@"
        ;;
    most-stale)
        get_most_stale "$@"
        ;;
    coverage)
        get_coverage "$@"
        ;;
    campaigns|campaign)
        campaigns_command "$@"
        ;;
    import)
        import_data "$@"
        ;;
    export)
        export_data "$@"
        ;;
    status)
        show_status
        ;;
    version|--version|-v)
        show_version
        ;;
    help|--help|-h|"")
        show_help
        ;;
    *)
        echo -e "${RED}Error: Unknown command '$COMMAND'${NC}" >&2
        echo "Run 'visited-tracker help' for usage information" >&2
        exit 1
        ;;
esac
