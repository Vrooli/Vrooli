#\!/usr/bin/env bash
# App Monitor CLI - Lightweight wrapper for the Go API

set -euo pipefail

# Configuration
# API_PORT must be provided by environment
if [ -z "$API_PORT" ]; then
    echo "Error: API_PORT environment variable is required"
    exit 1
fi
API_BASE_URL="${APP_MONITOR_API_URL:-http://localhost:${API_PORT}}"
APP_ROOT="${APP_ROOT:-$(builtin cd "${BASH_SOURCE[0]%/*}/../../.." && builtin pwd)}"
SCRIPT_DIR="${APP_ROOT}/scenarios/app-monitor/cli"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Helper functions
log_info() {
    echo -e "${BLUE}ℹ${NC} $1"
}

log_success() {
    echo -e "${GREEN}✅${NC} $1"
}

log_warning() {
    echo -e "${YELLOW}⚠${NC} $1"
}

log_error() {
    echo -e "${RED}❌${NC} $1"
}

# API request helper
api_request() {
    local method="$1"
    local endpoint="$2"
    local data="${3:-}"
    
    local curl_args=("-X" "$method" "-H" "Content-Type: application/json" "-s")
    
    if [[ -n "$data" ]]; then
        curl_args+=("-d" "$data")
    fi
    
    curl "${curl_args[@]}" "$API_BASE_URL$endpoint"
}

# Check if API is available
check_api() {
    if \! curl -s "$API_BASE_URL/health" > /dev/null 2>&1; then
        log_error "App Monitor API is not available at $API_BASE_URL"
        log_info "Make sure the App Monitor service is running"
        return 1
    fi
}

# Commands
cmd_status() {
    log_info "Checking App Monitor status..."
    
    if \! check_api; then
        return 1
    fi
    
    local health_response
    health_response=$(api_request "GET" "/health")
    
    local status
    status=$(echo "$health_response" | jq -r '.status // "unknown"')
    
    if [[ "$status" == "healthy" ]]; then
        log_success "App Monitor is healthy"
        echo "$health_response" | jq .
    else
        log_warning "App Monitor status: $status"
        echo "$health_response" | jq .
    fi
}

cmd_list() {
    log_info "Listing managed apps..."
    
    if \! check_api; then
        return 1
    fi
    
    local apps_response
    apps_response=$(api_request "GET" "/api/v1/apps")
    
    if [[ "$apps_response" == "[]" ]]; then
        log_info "No apps currently registered"
        return 0
    fi
    
    echo "$apps_response" | jq -r '.[] | "\(.name) (\(.id[0:8])...): \(.status) - \(.scenario_name)"'
}

cmd_start() {
    local app_id="$1"
    
    log_info "Starting app: $app_id"
    
    if \! check_api; then
        return 1
    fi
    
    local response
    response=$(api_request "POST" "/api/v1/apps/$app_id/start")
    
    local message
    message=$(echo "$response" | jq -r '.message // .error // "Unknown response"')
    
    if echo "$response" | jq -e '.message' > /dev/null 2>&1; then
        log_success "$message"
    else
        log_error "$message"
        return 1
    fi
}

cmd_stop() {
    local app_id="$1"
    
    log_info "Stopping app: $app_id"
    
    if \! check_api; then
        return 1
    fi
    
    local response
    response=$(api_request "POST" "/api/v1/apps/$app_id/stop")
    
    local message
    message=$(echo "$response" | jq -r '.message // .error // "Unknown response"')
    
    if echo "$response" | jq -e '.message' > /dev/null 2>&1; then
        log_success "$message"
    else
        log_error "$message"
        return 1
    fi
}

cmd_logs() {
    local app_id="$1"
    local limit="${2:-50}"
    
    log_info "Fetching logs for app: $app_id"
    
    if \! check_api; then
        return 1
    fi
    
    local logs_response
    logs_response=$(api_request "GET" "/api/v1/apps/$app_id/logs?limit=$limit")
    
    if [[ "$logs_response" == "[]" ]]; then
        log_info "No logs found for app: $app_id"
        return 0
    fi
    
    echo "$logs_response" | jq -r '.[] | "\(.timestamp) [\(.level)] \(.message)"'
}

cmd_metrics() {
    local app_id="$1"
    local hours="${2:-24}"
    
    log_info "Fetching metrics for app: $app_id (last $hours hours)"
    
    if \! check_api; then
        return 1
    fi
    
    local metrics_response
    metrics_response=$(api_request "GET" "/api/v1/apps/$app_id/metrics?hours=$hours")
    
    if [[ "$metrics_response" == "[]" ]]; then
        log_info "No metrics found for app: $app_id"
        return 0
    fi
    
    echo "$metrics_response" | jq -r '.[] | "\(.timestamp) - CPU: \(.cpu_usage)% Memory: \(.memory_usage)% Status: \(.status)"'
}

cmd_docker() {
    log_info "Docker information..."
    
    if \! check_api; then
        return 1
    fi
    
    local docker_response
    docker_response=$(api_request "GET" "/api/v1/docker/info")
    
    echo "$docker_response" | jq '{
        "Containers": .Containers,
        "Images": .Images,
        "Server Version": .ServerVersion,
        "Operating System": .OperatingSystem,
        "Architecture": .Architecture
    }'
}

cmd_health() {
    local app_id="$1"
    
    log_info "Checking health for app: $app_id"
    
    if \! check_api; then
        return 1
    fi
    
    local response
    response=$(api_request "GET" "/api/v1/apps/$app_id")
    
    if [[ "$response" == "null" ]] || echo "$response" | jq -e '.error' > /dev/null 2>&1; then
        log_error "App not found: $app_id"
        return 1
    fi
    
    local status
    local uptime
    local memory
    local cpu
    status=$(echo "$response" | jq -r '.status // "unknown"')
    uptime=$(echo "$response" | jq -r '.uptime // "unknown"')
    memory=$(echo "$response" | jq -r '.memory_usage // "unknown"')
    cpu=$(echo "$response" | jq -r '.cpu_usage // "unknown"')
    
    case "$status" in
        "running")
            log_success "App $app_id is healthy"
            ;;
        "stopped")
            log_warning "App $app_id is stopped"
            ;;
        *)
            log_error "App $app_id status: $status"
            ;;
    esac
    
    echo "  Status: $status"
    echo "  Uptime: $uptime"
    echo "  Memory: $memory%"
    echo "  CPU: $cpu%"
}

cmd_restart() {
    local app_id="$1"
    
    log_info "Restarting app: $app_id"
    
    # First stop the app
    log_info "Stopping app..."
    if cmd_stop "$app_id"; then
        # Wait a moment for clean shutdown
        sleep 2
        
        # Then start the app
        log_info "Starting app..."
        cmd_start "$app_id"
    else
        log_error "Failed to stop app, restart aborted"
        return 1
    fi
}

cmd_help() {
    cat << 'HELP'
App Monitor CLI - Manage and monitor scenarios

Usage:
    app-monitor <command> [arguments]

Commands:
    status                  Check App Monitor service health
    list                    List all managed applications
    start <app_id>          Start an application
    stop <app_id>           Stop an application
    restart <app_id>        Restart an application (stop then start)
    health <app_id>         Check specific app health status
    logs <app_id> [limit]   Show application logs (default: 50)
    metrics <app_id> [hrs]  Show application metrics (default: 24h)
    docker                  Show Docker system information
    help                    Show this help message

Environment Variables:
    APP_MONITOR_API_URL     API base URL (default: http://localhost:\$API_PORT)
    API_PORT                API port (required)

Examples:
    app-monitor status
    app-monitor list
    app-monitor start abc123
    app-monitor stop abc123
    app-monitor restart abc123
    app-monitor health abc123
    app-monitor logs abc123 100
    app-monitor metrics abc123 12

HELP
}

# Main command dispatcher
main() {
    if [[ $# -eq 0 ]]; then
        cmd_help
        return 0
    fi
    
    local command="$1"
    shift
    
    # Check for required tools
    if \! command -v curl > /dev/null 2>&1; then
        log_error "curl is required but not installed"
        return 1
    fi
    
    if \! command -v jq > /dev/null 2>&1; then
        log_error "jq is required but not installed"
        return 1
    fi
    
    case "$command" in
        "status")
            cmd_status "$@"
            ;;
        "list")
            cmd_list "$@"
            ;;
        "start")
            if [[ $# -eq 0 ]]; then
                log_error "App ID required for start command"
                return 1
            fi
            cmd_start "$@"
            ;;
        "stop")
            if [[ $# -eq 0 ]]; then
                log_error "App ID required for stop command"
                return 1
            fi
            cmd_stop "$@"
            ;;
        "restart")
            if [[ $# -eq 0 ]]; then
                log_error "App ID required for restart command"
                return 1
            fi
            cmd_restart "$@"
            ;;
        "health")
            if [[ $# -eq 0 ]]; then
                log_error "App ID required for health command"
                return 1
            fi
            cmd_health "$@"
            ;;
        "logs")
            if [[ $# -eq 0 ]]; then
                log_error "App ID required for logs command"
                return 1
            fi
            cmd_logs "$@"
            ;;
        "metrics")
            if [[ $# -eq 0 ]]; then
                log_error "App ID required for metrics command"
                return 1
            fi
            cmd_metrics "$@"
            ;;
        "docker")
            cmd_docker "$@"
            ;;
        "help"|"-h"|"--help")
            cmd_help
            ;;
        *)
            log_error "Unknown command: $command"
            echo
            cmd_help
            return 1
            ;;
    esac
}

main "$@"
