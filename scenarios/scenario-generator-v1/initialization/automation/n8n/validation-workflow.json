{
  "name": "Validation Phase Workflow",
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "validation-workflow",
        "responseMode": "responseNode",
        "options": {}
      },
      "id": "webhook_validation",
      "name": "Validation Trigger",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 1.1,
      "position": [200, 300]
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// Prepare validation request and create temporary scenario files\nconst request = $json;\nconst generatedFiles = request.generated_files || request.files || {};\n\nif (Object.keys(generatedFiles).length === 0) {\n  throw new Error('No generated files available for validation');\n}\n\n// Create temporary directory for validation\nconst tempDir = `/tmp/scenario-validation-${request.generation_id || Date.now()}`;\n\nreturn {\n  ...request,\n  phase: 'validation',\n  temp_directory: tempDir,\n  validation_iteration: (request.current_iteration?.validation || 0) + 1,\n  max_validation_iterations: request.iteration_limits?.validation || 5,\n  files_to_validate: Object.keys(generatedFiles).length\n};"
      },
      "id": "prepare_validation",
      "name": "Prepare Validation",
      "type": "n8n-nodes-base.code", 
      "typeVersion": 1,
      "position": [400, 300]
    },
    {
      "parameters": {
        "command": "mkdir -p {{ $json.temp_directory }} && echo 'Temp directory created: {{ $json.temp_directory }}'",
        "options": {}
      },
      "id": "create_temp_directory",
      "name": "Create Temp Directory",
      "type": "n8n-nodes-base.executeCommand",
      "typeVersion": 1,
      "position": [600, 300]
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// Write generated files to temp directory for validation\nconst request = $json;\nconst generatedFiles = request.generated_files || request.files || {};\nconst tempDir = request.temp_directory;\n\n// Create file write commands\nconst fileCommands = [];\nconst filePaths = [];\n\nObject.entries(generatedFiles).forEach(([filename, content]) => {\n  const fullPath = `${tempDir}/${filename}`;\n  const dirPath = fullPath.substring(0, fullPath.lastIndexOf('/'));\n  \n  // Create directory command\n  fileCommands.push(`mkdir -p \"${dirPath}\"`);\n  \n  // Create file command with content\n  const escapedContent = content.replace(/'/g, \"'\\\\''\")\n                               .replace(/\"/g, '\\\\\"')\n                               .replace(/\\n/g, '\\\\n');\n  fileCommands.push(`echo '${escapedContent}' > \"${fullPath}\"`);\n  \n  filePaths.push(fullPath);\n});\n\nreturn {\n  ...request,\n  file_commands: fileCommands,\n  file_paths: filePaths,\n  command_script: fileCommands.join(' && ')\n};"
      },
      "id": "prepare_file_writes",
      "name": "Prepare File Writes",
      "type": "n8n-nodes-base.code",
      "typeVersion": 1,
      "position": [800, 300]
    },
    {
      "parameters": {
        "command": "{{ $json.command_script }}",
        "options": {}
      },
      "id": "write_scenario_files",
      "name": "Write Scenario Files",
      "type": "n8n-nodes-base.executeCommand",
      "typeVersion": 1,
      "position": [1000, 300]
    },
    {
      "parameters": {
        "command": "cd {{ $json.temp_directory }} && ${VROOLI_ROOT:-${HOME}/Vrooli}/scripts/scenarios/tools/scenario-to-app.sh $(basename {{ $json.temp_directory }}) --dry-run --verbose 2>&1",
        "options": {}
      },
      "id": "run_scenario_validation",
      "name": "Run Scenario Validation",
      "type": "n8n-nodes-base.executeCommand",
      "typeVersion": 1,
      "position": [1200, 300]
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// Analyze validation results\nconst request = $json;\nconst validationOutput = $json.stdout || $json.stderr || '';\n\n// Check for validation success\nconst validationPassed = validationOutput.includes('✅') && \n                        validationOutput.includes('completed') &&\n                        !validationOutput.includes('❌') &&\n                        !validationOutput.includes('ERROR');\n\n// Extract validation details\nconst validationDetails = {\n  schema_validation: validationOutput.includes('Schema validation passed'),\n  file_structure: validationOutput.includes('file paths are valid'),\n  resource_analysis: validationOutput.includes('Enabled resources'),\n  app_generation: validationOutput.includes('app generated successfully'),\n  validation_passed: validationPassed\n};\n\n// Extract any error messages\nconst errorPattern = /(ERROR|❌|FAILED)[^\\n]*\\n?[^\\n]*/gi;\nconst errors = validationOutput.match(errorPattern) || [];\n\n// Calculate validation score\nlet validationScore = 0;\nif (validationDetails.schema_validation) validationScore += 30;\nif (validationDetails.file_structure) validationScore += 25;\nif (validationDetails.resource_analysis) validationScore += 25;\nif (validationDetails.app_generation) validationScore += 20;\n\n// Determine if fixes are needed\nconst needsFixes = !validationPassed && \n                  request.validation_iteration < request.max_validation_iterations &&\n                  errors.length > 0;\n\nreturn {\n  ...request,\n  validation_output: validationOutput,\n  validation_details: validationDetails,\n  validation_score: validationScore,\n  validation_passed: validationPassed,\n  validation_errors: errors,\n  needs_fixes: needsFixes,\n  validation_quality: validationScore >= 90 ? 'excellent' :\n                     validationScore >= 70 ? 'good' : 'needs_improvement'\n};"
      },
      "id": "analyze_validation_results",
      "name": "Analyze Validation Results",
      "type": "n8n-nodes-base.code",
      "typeVersion": 1,
      "position": [1400, 300]
    },
    {
      "parameters": {},
      "id": "validation_decision",
      "name": "Validation Decision",
      "type": "n8n-nodes-base.if",
      "typeVersion": 1,
      "position": [1600, 300],
      "parameters": {
        "conditions": {
          "string": [
            {
              "value1": "={{ $json.needs_fixes }}",
              "operation": "equal",
              "value2": "true"
            }
          ]
        }
      }
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// Generate bug fixing prompt for Claude Code\nconst request = $json;\nconst errors = request.validation_errors || [];\n\nconst bugFixPrompt = `# Scenario Generation - Validation Bug Fixing (Iteration ${request.validation_iteration})\n\nThe generated scenario has validation issues that need to be fixed. Please analyze and fix the following problems:\n\n## Validation Results:\n- Schema Validation: ${request.validation_details.schema_validation ? '✓ Passed' : '✗ Failed'}\n- File Structure: ${request.validation_details.file_structure ? '✓ Valid' : '✗ Invalid'}\n- Resource Analysis: ${request.validation_details.resource_analysis ? '✓ Passed' : '✗ Failed'}\n- App Generation: ${request.validation_details.app_generation ? '✓ Success' : '✗ Failed'}\n- Overall Score: ${request.validation_score}/100\n\n## Validation Errors:\n${errors.map((error, index) => `${index + 1}. ${error}`).join('\\n')}\n\n## Full Validation Output:\n\\`\\`\\`\n${request.validation_output}\n\\`\\`\\`\n\n## Current Generated Files:\n${Object.keys(request.generated_files || {}).map(file => `- ${file}`).join('\\n')}\n\n## Fixing Requirements:\n\n1. **Analyze each error** and understand the root cause\n2. **Fix file structure issues** - ensure all required files exist\n3. **Correct JSON syntax** in service.json and other config files\n4. **Fix resource references** - ensure all resources are properly configured\n5. **Validate file paths** - ensure initialization files exist and are referenced correctly\n6. **Address schema violations** - ensure service.json follows the required schema\n\n## Output Format:\n\nProvide **ONLY** the corrected files that need to be updated. Use this exact format:\n\n\\`\\`\\`filename\n[corrected file content]\n\\`\\`\\`\n\n**Important**: \n- Only include files that need changes\n- Provide complete, corrected content for each file\n- Ensure all JSON is valid and properly formatted\n- Follow Vrooli scenario conventions exactly\n- Test that your fixes address the specific errors mentioned\n\nFocus on fixing the immediate validation issues to make the scenario deployable.`;\n\nreturn {\n  ...request,\n  prompt: bugFixPrompt,\n  validation_iteration: request.validation_iteration + 1\n};"
      },
      "id": "generate_bug_fix_prompt",
      "name": "Generate Bug Fix Prompt", 
      "type": "n8n-nodes-base.code",
      "typeVersion": 1,
      "position": [1400, 450]
    },
    {
      "parameters": {
        "command": "echo '{{ $json.prompt }}' | claude chat",
        "options": {}
      },
      "id": "claude_bug_fixing",
      "name": "Claude Bug Fixing",
      "type": "n8n-nodes-base.executeCommand",
      "typeVersion": 1,
      "position": [1200, 450]
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// Parse bug fixes and update generated files\nconst claudeOutput = $json.stdout || $json.output || '';\nconst request = $json;\n\nif (!claudeOutput.trim()) {\n  throw new Error('Claude Code returned empty bug fixes');\n}\n\n// Extract fixed file contents\nconst fileMatches = claudeOutput.match(/```([\\w\\/.\\-]+)\\n([\\s\\S]*?)\\n```/g) || [];\nconst fixedFiles = {};\n\nfileMatches.forEach(match => {\n  const fileMatch = match.match(/```([\\w\\/.\\-]+)\\n([\\s\\S]*?)\\n```/);\n  if (fileMatch) {\n    const filename = fileMatch[1];\n    const content = fileMatch[2];\n    fixedFiles[filename] = content;\n  }\n});\n\n// Merge fixes with existing files\nconst updatedFiles = {\n  ...request.generated_files,\n  ...fixedFiles\n};\n\nconsole.log(`Applied fixes to ${Object.keys(fixedFiles).length} files`);\n\nreturn {\n  ...request,\n  generated_files: updatedFiles,\n  bug_fixes_applied: Object.keys(fixedFiles),\n  fix_iteration: request.validation_iteration\n};"
      },
      "id": "apply_bug_fixes",
      "name": "Apply Bug Fixes",
      "type": "n8n-nodes-base.code",
      "typeVersion": 1,
      "position": [1000, 450]
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// Finalize validation with final results\nconst request = $json;\n\n// Clean up temp directory\nconst cleanupCommand = `rm -rf ${request.temp_directory}`;\n\n// Prepare final validation summary\nconst validationSummary = {\n  validation_passed: request.validation_passed,\n  validation_score: request.validation_score,\n  total_iterations: request.validation_iteration,\n  errors_fixed: request.bug_fixes_applied?.length || 0,\n  final_file_count: Object.keys(request.generated_files || {}).length,\n  deployment_ready: request.validation_passed && request.validation_score >= 70\n};\n\n// Determine next steps based on validation results\nconst nextSteps = [];\nif (validationSummary.deployment_ready) {\n  nextSteps.push(\n    'Scenario is ready for deployment',\n    'Run scenario-to-app.sh without --dry-run to deploy',\n    'Test all functionality after deployment',\n    'Monitor performance and usage metrics'\n  );\n} else {\n  nextSteps.push(\n    'Manual review recommended before deployment',\n    'Check validation errors and fix remaining issues',\n    'Consider simplifying complexity or reducing scope',\n    'Test individual components before full deployment'\n  );\n}\n\nreturn {\n  ...request,\n  status: 'validation_complete',\n  validation_summary: validationSummary,\n  deployment_ready: validationSummary.deployment_ready,\n  next_steps: nextSteps,\n  cleanup_command: cleanupCommand,\n  completed_at: new Date().toISOString()\n};"
      },
      "id": "finalize_validation",
      "name": "Finalize Validation",
      "type": "n8n-nodes-base.code",
      "typeVersion": 1,
      "position": [1800, 300]
    },
    {
      "parameters": {
        "command": "{{ $json.cleanup_command }}",
        "options": {}
      },
      "id": "cleanup_temp_files",
      "name": "Cleanup Temp Files",
      "type": "n8n-nodes-base.executeCommand",
      "typeVersion": 1,
      "position": [2000, 300]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ $json }}"
      },
      "id": "validation_response",
      "name": "Validation Response", 
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1,
      "position": [2200, 300]
    }
  ],
  "connections": {
    "webhook_validation": {
      "main": [
        [
          {
            "node": "prepare_validation",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "prepare_validation": {
      "main": [
        [
          {
            "node": "create_temp_directory",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "create_temp_directory": {
      "main": [
        [
          {
            "node": "prepare_file_writes",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "prepare_file_writes": {
      "main": [
        [
          {
            "node": "write_scenario_files",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "write_scenario_files": {
      "main": [
        [
          {
            "node": "run_scenario_validation",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "run_scenario_validation": {
      "main": [
        [
          {
            "node": "analyze_validation_results",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "analyze_validation_results": {
      "main": [
        [
          {
            "node": "validation_decision",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "validation_decision": {
      "main": [
        [
          {
            "node": "generate_bug_fix_prompt",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "finalize_validation",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "generate_bug_fix_prompt": {
      "main": [
        [
          {
            "node": "claude_bug_fixing",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "claude_bug_fixing": {
      "main": [
        [
          {
            "node": "apply_bug_fixes",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "apply_bug_fixes": {
      "main": [
        [
          {
            "node": "prepare_file_writes",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "finalize_validation": {
      "main": [
        [
          {
            "node": "cleanup_temp_files",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "cleanup_temp_files": {
      "main": [
        [
          {
            "node": "validation_response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "settings": {
    "executionOrder": "v1"
  },
  "staticData": null,
  "tags": [
    {
      "createdAt": "2024-08-28T12:00:00.000Z",
      "updatedAt": "2024-08-28T12:00:00.000Z",
      "id": "validation-phase",
      "name": "validation-phase"
    }
  ],
  "triggerCount": 1,
  "updatedAt": "2024-08-28T12:00:00.000Z",
  "versionId": "1"
}