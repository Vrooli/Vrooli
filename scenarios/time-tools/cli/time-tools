#!/bin/bash
################################################################################
# Time Tools CLI - Comprehensive temporal operations and scheduling platform
# 
# Timezone conversions, duration calculations, scheduling optimization, and more
# Port discovery uses vrooli scenario port command for dynamic allocation
################################################################################

set -e

# Configuration
SCENARIO_NAME="time-tools"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
PURPLE='\033[0;35m'
NC='\033[0m' # No Color

################################################################################
# Port Discovery - Dynamic port lookup
################################################################################
get_api_url() {
    # Use vrooli scenario port command for dynamic port lookup
    local api_port
    api_port=$(vrooli scenario port "${SCENARIO_NAME}" TIME_TOOLS_PORT 2>/dev/null)
    
    if [[ -z "$api_port" ]]; then
        echo -e "${RED}❌ Error: ${SCENARIO_NAME} is not running${NC}" >&2
        echo "   Start it with: vrooli scenario run ${SCENARIO_NAME}" >&2
        exit 1
    fi
    
    echo "http://localhost:${api_port}"
}

################################################################################
# Helper Functions
################################################################################
show_help() {
    echo -e "${CYAN}⏰ Time Tools CLI${NC}"
    echo "Comprehensive temporal operations and scheduling platform"
    echo ""
    echo "Usage: time-tools [command] [options]"
    echo ""
    echo "Commands:"
    echo -e "  ${GREEN}convert${NC} TIME FROM_TZ TO_TZ    Convert time between timezones"
    echo -e "  ${GREEN}duration${NC} START END            Calculate duration between two times"
    echo -e "  ${GREEN}format${NC} TIME FORMAT            Format time in various styles"
    echo -e "  ${GREEN}schedule${NC} [options]            Find optimal meeting times"
    echo -e "  ${GREEN}conflicts${NC} START END           Detect scheduling conflicts"
    echo -e "  ${GREEN}event${NC} create|list             Manage calendar events"
    echo -e "  ${GREEN}business-hours${NC} START END      Calculate business hours between times"
    echo -e "  ${GREEN}add-time${NC} TIME DURATION        Add duration to a time"
    echo -e "  ${GREEN}subtract-time${NC} TIME DURATION   Subtract duration from a time"
    echo -e "  ${GREEN}now${NC} [TIMEZONE]                Show current time in timezone"
    echo -e "  ${GREEN}status${NC}                        Show API status"
    echo -e "  ${GREEN}help${NC}                          Show this help message"
    echo -e "  ${GREEN}version${NC}                       Show version information"
    echo ""
    echo "Options:"
    echo "  --exclude-weekends             Exclude weekends from calculations"
    echo "  --exclude-holidays             Exclude holidays from calculations"
    echo "  --business-hours-only          Use only business hours"
    echo "  --timezone TZ                  Specify timezone"
    echo "  --format FORMAT                Output format (iso8601, unix, human, relative)"
    echo "  --participants P1,P2           Comma-separated list of participants"
    echo "  --duration MINUTES             Duration in minutes"
    echo "  --earliest DATE                Earliest date for scheduling"
    echo "  --latest DATE                  Latest date for scheduling"
    echo "  --json                         Output raw JSON"
    echo ""
    echo "Examples:"
    echo "  time-tools convert '2024-01-15T10:00:00Z' UTC 'America/New_York'"
    echo "  time-tools duration '2024-01-15T09:00:00Z' '2024-01-15T17:00:00Z' --business-hours-only"
    echo "  time-tools schedule --participants alice,bob --duration 60 --earliest 2024-01-15"
    echo "  time-tools conflicts '2024-01-15T14:00:00Z' '2024-01-15T15:00:00Z' --organizer alice"
    echo "  time-tools now 'Asia/Tokyo'"
    echo "  time-tools format '2024-01-15T10:00:00Z' human --timezone 'America/Los_Angeles'"
}

show_version() {
    local api_url
    api_url=$(get_api_url 2>/dev/null || echo "API not running")
    echo "time-tools CLI v1.0.0"
    echo "API: ${api_url}"
}

# Format JSON output if jq is available
format_json() {
    if command -v jq >/dev/null 2>&1; then
        jq .
    else
        cat
    fi
}

# Make API request
api_request() {
    local method="$1"
    local endpoint="$2"
    local data="${3:-}"
    local api_url
    api_url=$(get_api_url)
    
    local curl_opts=(-s -X "$method" -H "Content-Type: application/json")
    
    if [[ -n "$data" ]]; then
        curl_opts+=(-d "$data")
    fi
    
    response=$(curl "${curl_opts[@]}" "${api_url}${endpoint}" 2>/dev/null)
    
    if [[ $? -ne 0 ]]; then
        echo -e "${RED}❌ API request failed${NC}" >&2
        return 1
    fi
    
    echo "$response"
}

################################################################################
# Command Handlers
################################################################################

# Convert timezone
cmd_convert() {
    if [[ $# -lt 3 ]]; then
        echo -e "${RED}Usage: time-tools convert TIME FROM_TIMEZONE TO_TIMEZONE${NC}"
        echo "Example: time-tools convert '2024-01-15T10:00:00Z' UTC 'America/New_York'"
        exit 1
    fi
    
    local time="$1"
    local from_tz="$2"
    local to_tz="$3"
    
    local data=$(cat <<EOF
{
    "time": "$time",
    "from_timezone": "$from_tz",
    "to_timezone": "$to_tz"
}
EOF
    )
    
    local response
    response=$(api_request POST "/api/v1/time/convert" "$data")
    
    if [[ -n "$JSON_OUTPUT" ]]; then
        echo "$response" | format_json
    else
        local converted_time original_time offset_minutes is_dst
        converted_time=$(echo "$response" | jq -r '.converted_time')
        original_time=$(echo "$response" | jq -r '.original_time')
        offset_minutes=$(echo "$response" | jq -r '.offset_minutes')
        is_dst=$(echo "$response" | jq -r '.is_dst')
        
        echo -e "${GREEN}✓ Timezone Conversion${NC}"
        echo -e "  Original:  $original_time ($from_tz)"
        echo -e "  Converted: $converted_time ($to_tz)"
        echo -e "  Offset:    $offset_minutes minutes"
        if [[ "$is_dst" == "true" ]]; then
            echo -e "  DST:       ${YELLOW}Active${NC}"
        fi
    fi
}

# Calculate duration
cmd_duration() {
    if [[ $# -lt 2 ]]; then
        echo -e "${RED}Usage: time-tools duration START_TIME END_TIME [options]${NC}"
        echo "Example: time-tools duration '2024-01-15T09:00:00Z' '2024-01-15T17:00:00Z'"
        exit 1
    fi
    
    local start_time="$1"
    local end_time="$2"
    shift 2
    
    local exclude_weekends="false"
    local exclude_holidays="false"
    local business_hours_only="false"
    local timezone=""
    local entity_id=""
    
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --exclude-weekends)
                exclude_weekends="true"
                shift
                ;;
            --exclude-holidays)
                exclude_holidays="true"
                shift
                ;;
            --business-hours-only)
                business_hours_only="true"
                shift
                ;;
            --timezone)
                timezone="$2"
                shift 2
                ;;
            --entity)
                entity_id="$2"
                shift 2
                ;;
            *)
                shift
                ;;
        esac
    done
    
    local data=$(cat <<EOF
{
    "start_time": "$start_time",
    "end_time": "$end_time",
    "timezone": "$timezone",
    "exclude_weekends": $exclude_weekends,
    "exclude_holidays": $exclude_holidays,
    "business_hours_only": $business_hours_only,
    "entity_id": "$entity_id"
}
EOF
    )
    
    local response
    response=$(api_request POST "/api/v1/time/duration" "$data")
    
    if [[ -n "$JSON_OUTPUT" ]]; then
        echo "$response" | format_json
    else
        local total_hours total_days business_hours business_days
        total_hours=$(echo "$response" | jq -r '.total_hours')
        total_days=$(echo "$response" | jq -r '.total_days')
        business_hours=$(echo "$response" | jq -r '.business_hours // 0')
        business_days=$(echo "$response" | jq -r '.business_days // 0')
        
        echo -e "${GREEN}✓ Duration Calculation${NC}"
        echo -e "  Start:          $start_time"
        echo -e "  End:            $end_time"
        echo -e "  Total Hours:    $(printf "%.2f" $total_hours)"
        echo -e "  Total Days:     $(printf "%.2f" $total_days)"
        
        if [[ "$business_hours_only" == "true" ]] || [[ "$exclude_weekends" == "true" ]]; then
            echo -e "  Business Hours: $(printf "%.2f" $business_hours)"
            echo -e "  Business Days:  $business_days"
        fi
    fi
}

# Format time
cmd_format() {
    if [[ $# -lt 2 ]]; then
        echo -e "${RED}Usage: time-tools format TIME FORMAT [--timezone TZ]${NC}"
        echo "Formats: iso8601, unix, date, time, datetime, human, relative, or custom"
        echo "Example: time-tools format '2024-01-15T10:00:00Z' human --timezone 'America/Los_Angeles'"
        exit 1
    fi
    
    local time="$1"
    local format="$2"
    shift 2
    
    local timezone=""
    local locale="en"
    
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --timezone)
                timezone="$2"
                shift 2
                ;;
            --locale)
                locale="$2"
                shift 2
                ;;
            *)
                shift
                ;;
        esac
    done
    
    local data=$(cat <<EOF
{
    "time": "$time",
    "format": "$format",
    "timezone": "$timezone",
    "locale": "$locale"
}
EOF
    )
    
    local response
    response=$(api_request POST "/api/v1/time/format" "$data")
    
    if [[ -n "$JSON_OUTPUT" ]]; then
        echo "$response" | format_json
    else
        local formatted
        formatted=$(echo "$response" | jq -r '.formatted')
        
        echo -e "${GREEN}✓ Formatted Time${NC}"
        echo -e "  Original: $time"
        echo -e "  Format:   $format"
        if [[ -n "$timezone" ]]; then
            echo -e "  Timezone: $timezone"
        fi
        echo -e "  Result:   ${CYAN}$formatted${NC}"
    fi
}

# Find optimal schedule
cmd_schedule() {
    local participants=""
    local duration_minutes="60"
    local timezone="UTC"
    local earliest_date=$(date +%Y-%m-%d)
    local latest_date=$(date -d "+7 days" +%Y-%m-%d)
    local business_hours_only="false"
    
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --participants)
                participants="$2"
                shift 2
                ;;
            --duration)
                duration_minutes="$2"
                shift 2
                ;;
            --timezone)
                timezone="$2"
                shift 2
                ;;
            --earliest)
                earliest_date="$2"
                shift 2
                ;;
            --latest)
                latest_date="$2"
                shift 2
                ;;
            --business-hours-only)
                business_hours_only="true"
                shift
                ;;
            *)
                shift
                ;;
        esac
    done
    
    if [[ -z "$participants" ]]; then
        echo -e "${RED}Error: --participants required${NC}"
        echo "Usage: time-tools schedule --participants alice,bob --duration 60"
        exit 1
    fi
    
    # Convert comma-separated to JSON array
    local participants_json
    participants_json=$(echo "$participants" | awk -F, '{printf "["; for(i=1;i<=NF;i++) printf "\"%s\"%s", $i, (i<NF?",":""); printf "]"}')
    
    local data=$(cat <<EOF
{
    "participants": $participants_json,
    "duration_minutes": $duration_minutes,
    "timezone": "$timezone",
    "earliest_date": "$earliest_date",
    "latest_date": "$latest_date",
    "business_hours_only": $business_hours_only
}
EOF
    )
    
    local response
    response=$(api_request POST "/api/v1/schedule/optimal" "$data")
    
    if [[ -n "$JSON_OUTPUT" ]]; then
        echo "$response" | format_json
    else
        echo -e "${GREEN}✓ Optimal Meeting Times${NC}"
        echo -e "  Participants: $participants"
        echo -e "  Duration:     $duration_minutes minutes"
        echo -e "  Date Range:   $earliest_date to $latest_date"
        echo ""
        
        local slots
        slots=$(echo "$response" | jq -r '.optimal_slots[]')
        
        if [[ -z "$slots" ]]; then
            echo -e "  ${YELLOW}No optimal slots found${NC}"
        else
            echo "$response" | jq -r '.optimal_slots[] | 
                "  \(.start_time | split("T")[0]) at \(.start_time | split("T")[1] | split(":")[0:2] | join(":")) - Score: \(.score * 100 | floor)%"'
        fi
    fi
}

# Detect conflicts
cmd_conflicts() {
    if [[ $# -lt 2 ]]; then
        echo -e "${RED}Usage: time-tools conflicts START_TIME END_TIME [--organizer ID]${NC}"
        echo "Example: time-tools conflicts '2024-01-15T14:00:00Z' '2024-01-15T15:00:00Z' --organizer alice"
        exit 1
    fi
    
    local start_time="$1"
    local end_time="$2"
    shift 2
    
    local organizer_id="default"
    
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --organizer)
                organizer_id="$2"
                shift 2
                ;;
            *)
                shift
                ;;
        esac
    done
    
    local data=$(cat <<EOF
{
    "start_time": "$start_time",
    "end_time": "$end_time",
    "organizer_id": "$organizer_id"
}
EOF
    )
    
    local response
    response=$(api_request POST "/api/v1/schedule/conflicts" "$data")
    
    if [[ -n "$JSON_OUTPUT" ]]; then
        echo "$response" | format_json
    else
        local has_conflicts conflict_count
        has_conflicts=$(echo "$response" | jq -r '.has_conflicts')
        conflict_count=$(echo "$response" | jq -r '.conflict_count')
        
        if [[ "$has_conflicts" == "true" ]]; then
            echo -e "${YELLOW}⚠ Scheduling Conflicts Detected${NC}"
            echo -e "  Time Range: $start_time to $end_time"
            echo -e "  Conflicts:  $conflict_count"
            echo ""
            
            echo "$response" | jq -r '.conflicts[] | 
                "  • \(.event_title)\n    Overlap: \(.overlap_minutes) minutes\n    Severity: \(.severity)"'
        else
            echo -e "${GREEN}✓ No Conflicts${NC}"
            echo -e "  Time Range: $start_time to $end_time"
            echo -e "  Status:     Clear for scheduling"
        fi
    fi
}

# Show current time
cmd_now() {
    local timezone="${1:-UTC}"
    
    # Get current time in ISO format
    local current_time
    current_time=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
    
    local data=$(cat <<EOF
{
    "time": "$current_time",
    "from_timezone": "UTC",
    "to_timezone": "$timezone"
}
EOF
    )
    
    local response
    response=$(api_request POST "/api/v1/time/convert" "$data")
    
    if [[ -n "$JSON_OUTPUT" ]]; then
        echo "$response" | format_json
    else
        local converted_time
        converted_time=$(echo "$response" | jq -r '.converted_time')
        
        echo -e "${GREEN}✓ Current Time${NC}"
        echo -e "  Timezone: $timezone"
        echo -e "  Time:     ${CYAN}$(echo "$converted_time" | cut -d'T' -f2 | cut -d'+' -f1 | cut -d'-' -f1)${NC}"
        echo -e "  Date:     $(echo "$converted_time" | cut -d'T' -f1)"
    fi
}

# Event management
cmd_event() {
    local subcmd="${1:-list}"
    shift
    
    case "$subcmd" in
        create)
            echo -e "${YELLOW}Event creation via CLI coming soon${NC}"
            echo "Use the API directly for now: POST /api/v1/events"
            ;;
        list)
            local organizer_id=""
            local status=""
            
            while [[ $# -gt 0 ]]; do
                case "$1" in
                    --organizer)
                        organizer_id="$2"
                        shift 2
                        ;;
                    --status)
                        status="$2"
                        shift 2
                        ;;
                    *)
                        shift
                        ;;
                esac
            done
            
            local query_params=""
            [[ -n "$organizer_id" ]] && query_params="${query_params}&organizer_id=${organizer_id}"
            [[ -n "$status" ]] && query_params="${query_params}&status=${status}"
            
            local response
            response=$(api_request GET "/api/v1/events?${query_params#&}")
            
            if [[ -n "$JSON_OUTPUT" ]]; then
                echo "$response" | format_json
            else
                local count
                count=$(echo "$response" | jq -r '.count')
                
                echo -e "${GREEN}✓ Events ($count total)${NC}"
                echo ""
                
                echo "$response" | jq -r '.events[] | 
                    "  • \(.title)\n    \(.start_time | split("T")[0]) at \(.start_time | split("T")[1] | split(":")[0:2] | join(":"))\n    Status: \(.status)\n"'
            fi
            ;;
        *)
            echo -e "${RED}Unknown subcommand: $subcmd${NC}"
            echo "Usage: time-tools event create|list"
            exit 1
            ;;
    esac
}

# Show status
cmd_status() {
    local response
    response=$(api_request GET "/api/v1/health")
    
    if [[ -n "$JSON_OUTPUT" ]]; then
        echo "$response" | format_json
    else
        local status database version
        status=$(echo "$response" | jq -r '.status')
        database=$(echo "$response" | jq -r '.database')
        version=$(echo "$response" | jq -r '.version')
        
        if [[ "$status" == "healthy" ]]; then
            echo -e "${GREEN}✓ Time Tools API Status${NC}"
        else
            echo -e "${RED}✗ Time Tools API Status${NC}"
        fi
        echo -e "  Status:   $status"
        echo -e "  Database: $database"
        echo -e "  Version:  $version"
        echo -e "  API URL:  $(get_api_url)"
    fi
}

################################################################################
# Main Command Router
################################################################################

# Parse global options
JSON_OUTPUT=""
while [[ $# -gt 0 ]] && [[ "$1" == --* ]]; do
    case "$1" in
        --json)
            JSON_OUTPUT="1"
            shift
            ;;
        *)
            break
            ;;
    esac
done

# Route to command handler
case "${1:-help}" in
    convert)
        shift
        cmd_convert "$@"
        ;;
    duration)
        shift
        cmd_duration "$@"
        ;;
    format)
        shift
        cmd_format "$@"
        ;;
    schedule)
        shift
        cmd_schedule "$@"
        ;;
    conflicts)
        shift
        cmd_conflicts "$@"
        ;;
    event)
        shift
        cmd_event "$@"
        ;;
    now)
        shift
        cmd_now "$@"
        ;;
    status)
        cmd_status
        ;;
    help|--help|-h)
        show_help
        ;;
    version|--version|-v)
        show_version
        ;;
    *)
        echo -e "${RED}Unknown command: $1${NC}"
        echo "Run 'time-tools help' for usage information"
        exit 1
        ;;
esac