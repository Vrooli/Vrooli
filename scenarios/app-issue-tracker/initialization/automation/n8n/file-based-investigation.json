{
  "name": "File-Based Issue Investigation Workflow",
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "investigate-issue-file",
        "responseMode": "responseNode",
        "options": {}
      },
      "id": "webhook_trigger",
      "name": "Webhook Trigger",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 1,
      "position": [250, 300]
    },
    {
      "parameters": {
        "functionCode": "const issueId = items[0].json.issue_id;\nconst agentId = items[0].json.agent_id || 'deep-investigator';\nconst priority = items[0].json.priority || 'normal';\n\n// Find issue file in folders\nconst fs = require('fs');\nconst path = require('path');\nconst yaml = require('js-yaml');\n\nconst vrooliRoot = process.env.VROOLI_ROOT || (process.env.HOME + '/Vrooli');\nconst issuesDir = vrooliRoot + '/scenarios/app-issue-tracker/issues';\nconst folders = ['open', 'investigating', 'in-progress', 'fixed', 'closed', 'failed'];\n\nlet issueFile = null;\nlet issueData = null;\nlet currentFolder = null;\n\n// Search for issue file by ID\nfor (const folder of folders) {\n  const folderPath = path.join(issuesDir, folder);\n  if (!fs.existsSync(folderPath)) continue;\n  \n  const files = fs.readdirSync(folderPath).filter(f => f.endsWith('.yaml'));\n  \n  for (const file of files) {\n    const filePath = path.join(folderPath, file);\n    try {\n      const content = fs.readFileSync(filePath, 'utf8');\n      const data = yaml.load(content);\n      \n      if (data.id === issueId) {\n        issueFile = file;\n        issueData = data;\n        currentFolder = folder;\n        break;\n      }\n    } catch (e) {\n      console.log('Error reading file:', file, e.message);\n    }\n  }\n  \n  if (issueFile) break;\n}\n\nif (!issueData) {\n  throw new Error(`Issue not found: ${issueId}`);\n}\n\n// Move to investigating folder if not already there\nif (currentFolder !== 'investigating') {\n  const oldPath = path.join(issuesDir, currentFolder, issueFile);\n  const newPath = path.join(issuesDir, 'investigating', issueFile);\n  \n  // Update status in data\n  issueData.status = 'investigating';\n  issueData.investigation = issueData.investigation || {};\n  issueData.investigation.agent_id = agentId;\n  issueData.investigation.started_at = new Date().toISOString();\n  issueData.metadata.updated_at = new Date().toISOString();\n  \n  // Write updated data to new location\n  const updatedYaml = yaml.dump(issueData);\n  fs.writeFileSync(newPath, updatedYaml);\n  \n  // Remove from old location\n  fs.unlinkSync(oldPath);\n  \n  issueFile = issueFile; // filename stays the same\n}\n\nreturn [{\n  json: {\n    issue_id: issueId,\n    agent_id: agentId,\n    priority: priority,\n    title: issueData.title,\n    description: issueData.description,\n    type: issueData.type,\n    error_message: issueData.error_context?.error_message || '',\n    stack_trace: issueData.error_context?.stack_trace || '',\n    affected_files: issueData.error_context?.affected_files || [],\n    app_id: issueData.app_id,\n    filename: issueFile,\n    project_path: process.cwd() // Default to current working directory\n  }\n}];"
      },
      "id": "load_issue_file",
      "name": "Load Issue from File",
      "type": "n8n-nodes-base.code",
      "typeVersion": 1,
      "position": [450, 300]
    },
    {
      "parameters": {
        "functionCode": "const issue = items[0].json;\n\n// Build comprehensive context for Claude Code investigation\nconst investigationPrompt = `# Issue Investigation Request\n\nYou are investigating an issue reported in the app-issue-tracker system.\n\n## Issue Details\n- **ID:** ${issue.issue_id}\n- **Title:** ${issue.title}\n- **Type:** ${issue.type}\n- **Priority:** ${issue.priority}\n- **Application:** ${issue.app_id}\n\n## Description\n${issue.description}\n\n${issue.error_message ? `## Error Information\n**Error Message:** ${issue.error_message}\n\n` : ''}\n${issue.stack_trace ? `## Stack Trace\n\\`\\`\\`\n${issue.stack_trace}\n\\`\\`\\`\n\n` : ''}\n${issue.affected_files.length > 0 ? `## Affected Files\n${issue.affected_files.map(f => `- ${f}`).join('\\n')}\n\n` : ''}\n## Investigation Tasks\n\nPlease perform a thorough investigation:\n\n1. **Analyze the codebase** at the current working directory\n2. **Identify the root cause** of this ${issue.type}\n3. **Examine related files** and dependencies\n4. **Check for similar patterns** in the codebase\n5. **Provide actionable recommendations**\n\n## Expected Output Format\n\nStructure your response as follows:\n\n### Investigation Summary\nBrief overview of the issue and investigation approach.\n\n### Root Cause Analysis  \nDetailed explanation of what is causing the issue.\n\n### Affected Components\nList of files, functions, or systems impacted.\n\n### Recommended Solutions\nPrioritized list of potential fixes with implementation details.\n\n### Testing Strategy\nHow to verify the fix and prevent regression.\n\n### Related Issues\nAny similar issues or patterns to watch for.\n\n### Confidence Level\nRate your confidence in the analysis (1-10) and explain any uncertainties.\n\nPlease begin your investigation now.\n`;\n\nreturn [{\n  json: {\n    issue_id: issue.issue_id,\n    agent_id: issue.agent_id,\n    filename: issue.filename,\n    investigation_prompt: investigationPrompt,\n    project_path: issue.project_path || process.cwd()\n  }\n}];"
      },
      "id": "prepare_investigation",
      "name": "Prepare Investigation Prompt",
      "type": "n8n-nodes-base.code",
      "typeVersion": 1,
      "position": [650, 300]
    },
    {
      "parameters": {
        "command": "${VROOLI_ROOT:-${HOME}/Vrooli}/scenarios/app-issue-tracker/scripts/claude-investigator.sh investigate '{{ $json.issue_id }}' '{{ $json.agent_id }}' '{{ $json.project_path }}' '{{ $json.investigation_prompt }}'",
        "options": {
          "timeout": 300
        }
      },
      "id": "claude_investigation",
      "name": "Claude Code Investigation",
      "type": "n8n-nodes-base.executeCommand",
      "typeVersion": 1,
      "position": [850, 300]
    },
    {
      "parameters": {
        "functionCode": "// Parse Claude Code investigation output\nconst commandOutput = items[0].json.stdout || items[0].json.output || '';\nconst issueId = items[0].json.issue_id || 'unknown';\nconst filename = items[0].json.filename || '';\n\nlet investigationData;\ntry {\n  investigationData = JSON.parse(commandOutput);\n} catch (e) {\n  console.log('Failed to parse JSON output, treating as text:', e);\n  investigationData = {\n    issue_id: issueId,\n    investigation_report: commandOutput,\n    root_cause: 'Parse error - see investigation report',\n    suggested_fix: 'Manual review required',\n    confidence_score: 3,\n    affected_files: [],\n    status: 'completed'\n  };\n}\n\n// Prepare file update data\nconst result = {\n  issue_id: investigationData.issue_id || issueId,\n  filename: filename,\n  investigation_report: investigationData.investigation_report || 'No report generated',\n  root_cause: investigationData.root_cause || 'Unable to determine root cause',\n  suggested_fix: investigationData.suggested_fix || 'No specific fix identified',\n  confidence_score: investigationData.confidence_score || 5,\n  affected_files: investigationData.affected_files || [],\n  timestamp: new Date().toISOString(),\n  status: investigationData.status || 'completed'\n};\n\nreturn [{json: result}];"
      },
      "id": "parse_investigation",
      "name": "Parse Investigation Results",
      "type": "n8n-nodes-base.code",
      "typeVersion": 1,
      "position": [1050, 300]
    },
    {
      "parameters": {
        "functionCode": "const fs = require('fs');\nconst path = require('path');\nconst yaml = require('js-yaml');\n\nconst result = items[0].json;\nconst vrooliRoot = process.env.VROOLI_ROOT || (process.env.HOME + '/Vrooli');\nconst issuesDir = vrooliRoot + '/scenarios/app-issue-tracker/issues';\n\n// Find and update the issue file\nlet updated = false;\nconst folders = ['investigating', 'in-progress', 'open']; // Try investigating first\n\nfor (const folder of folders) {\n  const filePath = path.join(issuesDir, folder, result.filename);\n  \n  if (fs.existsSync(filePath)) {\n    try {\n      // Load current issue data\n      const content = fs.readFileSync(filePath, 'utf8');\n      const issueData = yaml.load(content);\n      \n      // Update investigation section\n      issueData.investigation = issueData.investigation || {};\n      issueData.investigation.completed_at = result.timestamp;\n      issueData.investigation.report = result.investigation_report;\n      issueData.investigation.root_cause = result.root_cause;\n      issueData.investigation.suggested_fix = result.suggested_fix;\n      issueData.investigation.confidence_score = result.confidence_score;\n      \n      // Update affected files if provided\n      if (result.affected_files && result.affected_files.length > 0) {\n        issueData.error_context = issueData.error_context || {};\n        issueData.error_context.affected_files = result.affected_files;\n      }\n      \n      // Update metadata\n      issueData.metadata.updated_at = result.timestamp;\n      issueData.status = 'investigating'; // Keep in investigating status\n      \n      // Write updated YAML back\n      const updatedYaml = yaml.dump(issueData, {\n        lineWidth: -1,\n        noRefs: true,\n        quotingType: '\"'\n      });\n      \n      fs.writeFileSync(filePath, updatedYaml);\n      \n      console.log(`Updated issue file: ${filePath}`);\n      updated = true;\n      break;\n      \n    } catch (e) {\n      console.log(`Error updating file ${filePath}:`, e.message);\n    }\n  }\n}\n\nif (!updated) {\n  throw new Error(`Could not find or update issue file: ${result.filename}`);\n}\n\nreturn [{\n  json: {\n    success: true,\n    issue_id: result.issue_id,\n    filename: result.filename,\n    investigation_completed: true,\n    timestamp: result.timestamp\n  }\n}];"
      },
      "id": "update_issue_file",
      "name": "Update Issue File",
      "type": "n8n-nodes-base.code",
      "typeVersion": 1,
      "position": [1250, 300]
    },
    {
      "parameters": {
        "functionCode": "const result = items[0].json;\n\n// Generate embedding for Qdrant (optional)\n// For now, just return success\nconst vectorUpdate = {\n  issue_id: result.issue_id,\n  embedding_updated: false, // Set to true when real embeddings are implemented\n  vector_db_status: 'skipped',\n  message: 'Vector DB update skipped in file-based mode'\n};\n\nreturn [{\n  json: {\n    ...result,\n    vector_update: vectorUpdate\n  }\n}];"
      },
      "id": "optional_vector_update",
      "name": "Optional Vector DB Update",
      "type": "n8n-nodes-base.code",
      "typeVersion": 1,
      "position": [1450, 300]
    },
    {
      "parameters": {
        "values": {
          "string": [
            {
              "name": "status",
              "value": "success"
            },
            {
              "name": "issue_id", 
              "value": "={{ $json.issue_id }}"
            },
            {
              "name": "investigation_complete",
              "value": "true"
            },
            {
              "name": "filename",
              "value": "={{ $json.filename }}"
            },
            {
              "name": "timestamp",
              "value": "={{ $json.timestamp }}"
            }
          ]
        }
      },
      "id": "webhook_response",
      "name": "Webhook Response",
      "type": "n8n-nodes-base.set",
      "typeVersion": 2,
      "position": [1650, 300]
    }
  ],
  "connections": {
    "webhook_trigger": {
      "main": [[{"node": "load_issue_file", "type": "main", "index": 0}]]
    },
    "load_issue_file": {
      "main": [[{"node": "prepare_investigation", "type": "main", "index": 0}]]
    },
    "prepare_investigation": {
      "main": [[{"node": "claude_investigation", "type": "main", "index": 0}]]
    },
    "claude_investigation": {
      "main": [[{"node": "parse_investigation", "type": "main", "index": 0}]]
    },
    "parse_investigation": {
      "main": [[{"node": "update_issue_file", "type": "main", "index": 0}]]
    },
    "update_issue_file": {
      "main": [[{"node": "optional_vector_update", "type": "main", "index": 0}]]
    },
    "optional_vector_update": {
      "main": [[{"node": "webhook_response", "type": "main", "index": 0}]]
    }
  },
  "settings": {
    "executionOrder": "v1",
    "saveManualExecutions": true,
    "callerPolicy": "workflowsFromSameOwner",
    "errorWorkflow": ""
  },
  "staticData": null,
  "pinData": {},
  "versionId": "v2.0.0-file-based",
  "triggerCount": 1
}