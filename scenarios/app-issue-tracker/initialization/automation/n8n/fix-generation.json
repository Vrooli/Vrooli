{
  "name": "Fix Generation Workflow",
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "generate-fix",
        "responseMode": "responseNode",
        "options": {}
      },
      "id": "webhook_trigger",
      "name": "Fix Generation Webhook",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 1,
      "position": [250, 300]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "SELECT i.*, a.name as app_name, a.deployment_path as project_path FROM issues i LEFT JOIN apps a ON i.app_id = a.id WHERE i.id = '{{ $json.issue_id }}'"
      },
      "id": "get_issue_details",
      "name": "Get Issue Details",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2,
      "position": [450, 300]
    },
    {
      "parameters": {
        "functionCode": "const issue = items[0].json;\n\n// Validate that issue has investigation report\nif (!issue.investigation_report || issue.investigation_report.trim() === '') {\n  throw new Error('Issue must be investigated before fix generation');\n}\n\n// Check if issue is in appropriate status\nconst validStatuses = ['investigating', 'analyzed', 'ready_for_fix'];\nif (!validStatuses.includes(issue.status)) {\n  console.log(`Warning: Issue status is '${issue.status}', expected one of: ${validStatuses.join(', ')}`);\n}\n\n// Prepare fix generation context\nconst context = {\n  issue_id: issue.id,\n  issue_title: issue.title,\n  issue_description: issue.description,\n  investigation_report: issue.investigation_report,\n  error_message: issue.error_message || '',\n  stack_trace: issue.stack_trace || '',\n  project_path: issue.project_path || '',\n  auto_apply: $json.auto_apply || false,\n  backup_enabled: $json.backup_enabled !== false, // default to true\n  priority: issue.priority,\n  type: issue.type\n};\n\nreturn [{json: context}];"
      },
      "id": "prepare_fix_generation",
      "name": "Prepare Fix Generation",
      "type": "n8n-nodes-base.code",
      "typeVersion": 1,
      "position": [650, 300]
    },
    {
      "parameters": {
        "command": "/home/matthalloran8/Vrooli/scenarios/app-issue-tracker/scripts/claude-fix-generator.sh generate '{{ $json.issue_id }}' '{{ $json.project_path }}' '{{ $json.auto_apply }}' '{{ $json.backup_enabled }}'",
        "options": {
          "timeout": 600
        }
      },
      "id": "generate_fix",
      "name": "Generate Fix with Claude Code",
      "type": "n8n-nodes-base.executeCommand",
      "typeVersion": 1,
      "position": [850, 300]
    },
    {
      "parameters": {
        "functionCode": "// Parse output from claude-fix-generator.sh script\nconst commandOutput = items[0].json.stdout || items[0].json.output || '';\n\nlet fixData;\ntry {\n  // The script outputs JSON, so parse it directly\n  fixData = JSON.parse(commandOutput);\n} catch (e) {\n  // Fallback: treat as plain text if JSON parsing fails\n  console.log('Failed to parse JSON output from fix generator:', e);\n  fixData = {\n    issue_id: 'unknown',\n    fix_generation_status: 'failed',\n    fix_report: commandOutput,\n    fix_summary: 'Parse error - see fix report',\n    risk_level: 'high',\n    has_code_changes: false,\n    auto_apply_result: 'failed'\n  };\n}\n\n// Ensure all required fields are present\nconst result = {\n  issue_id: fixData.issue_id || 'unknown',\n  fix_generation_status: fixData.fix_generation_status || 'unknown',\n  fix_report: fixData.fix_report || 'No fix report generated',\n  fix_summary: fixData.fix_summary || 'No summary available',\n  implementation_steps: fixData.implementation_steps || 'No implementation steps provided',\n  rollback_plan: fixData.rollback_plan || 'No rollback plan provided',\n  risk_level: fixData.risk_level || 'medium',\n  has_code_changes: fixData.has_code_changes || false,\n  auto_apply_enabled: fixData.auto_apply_enabled || false,\n  auto_apply_result: fixData.auto_apply_result || 'not_attempted',\n  backup_path: fixData.backup_path || '',\n  workspace_path: fixData.workspace_path || '',\n  fix_generated_at: fixData.fix_generated_at || new Date().toISOString(),\n  project_path: fixData.project_path || ''\n};\n\nreturn [{json: result}];"
      },
      "id": "parse_fix_response",
      "name": "Parse Fix Response",
      "type": "n8n-nodes-base.code",
      "typeVersion": 1,
      "position": [1050, 300]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "UPDATE issues SET status = CASE WHEN '{{ $json.auto_apply_result }}' = 'success' THEN 'fix_applied' ELSE 'fix_generated' END, suggested_fix = $1, fix_summary = $2, rollback_plan = $3, risk_level = $4, updated_at = CURRENT_TIMESTAMP WHERE id = '{{ $json.issue_id }}' RETURNING *",
        "additionalFields": {
          "values": "={{ $json.fix_report }},={{ $json.fix_summary }},={{ $json.rollback_plan }},={{ $json.risk_level }}"
        }
      },
      "id": "update_issue_with_fix",
      "name": "Update Issue with Fix",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2,
      "position": [1250, 300]
    },
    {
      "parameters": {
        "url": "{{ $env.QDRANT_URL || 'http://localhost:6333' }}/collections/issue_embeddings/points",
        "authentication": "genericCredentialType",
        "genericAuthType": "httpBasicAuth",
        "httpMethod": "PUT",
        "body": "{\n  \"points\": [\n    {\n      \"id\": \"{{ $json.issue_id }}\",\n      \"vector\": {{ $json.embedding || '[]' }},\n      \"payload\": {\n        \"title\": \"{{ $json.title }}\",\n        \"description\": \"{{ $json.description }}\",\n        \"fix_summary\": \"{{ $json.fix_summary }}\",\n        \"risk_level\": \"{{ $json.risk_level }}\",\n        \"status\": \"{{ $json.status }}\",\n        \"has_fix\": true,\n        \"auto_applied\": {{ $json.auto_apply_result === 'success' }}\n      }\n    }\n  ]\n}"
      },
      "id": "update_vector_db_with_fix",
      "name": "Update Vector DB with Fix",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 3,
      "position": [1450, 300]
    },
    {
      "parameters": {
        "functionCode": "// Conditional execution based on auto-apply result\nconst autoApplyResult = items[0].json.auto_apply_result;\nconst riskLevel = items[0].json.risk_level;\n\nif (autoApplyResult === 'success') {\n  // Fix was automatically applied, run tests\n  return [{json: {...items[0].json, should_test: true}}];\n} else {\n  // Skip testing, move to notification\n  return [{json: {...items[0].json, should_test: false, test_result: 'skipped'}}];\n}"
      },
      "id": "check_auto_apply_result",
      "name": "Check Auto-Apply Result",
      "type": "n8n-nodes-base.code",
      "typeVersion": 1,
      "position": [1650, 300]
    },
    {
      "parameters": {
        "conditions": {
          "boolean": [
            {
              "value1": "={{ $json.should_test }}",
              "operation": "equal",
              "value2": true
            }
          ]
        }
      },
      "id": "test_condition",
      "name": "Should Test?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 1,
      "position": [1850, 300]
    },
    {
      "parameters": {
        "command": "/home/matthalloran8/Vrooli/scenarios/app-issue-tracker/scripts/claude-fix-generator.sh test '{{ $json.issue_id }}' '{{ $json.project_path }}'",
        "options": {
          "timeout": 300
        }
      },
      "id": "run_tests",
      "name": "Run Tests",
      "type": "n8n-nodes-base.executeCommand",
      "typeVersion": 1,
      "position": [2050, 250]
    },
    {
      "parameters": {
        "functionCode": "// Process test results\nconst testOutput = items[0].json.stdout || items[0].json.output || '';\nconst exitCode = items[0].json.exitCode || 0;\n\nconst testResult = {\n  test_executed: true,\n  test_passed: exitCode === 0,\n  test_output: testOutput,\n  test_timestamp: new Date().toISOString()\n};\n\n// If tests failed, update issue status\nif (!testResult.test_passed) {\n  testResult.recommended_action = 'rollback';\n  testResult.issue_status = 'fix_failed';\n} else {\n  testResult.recommended_action = 'monitor';\n  testResult.issue_status = 'fix_verified';\n}\n\nreturn [{json: {...items[0].json, ...testResult}}];"
      },
      "id": "process_test_results",
      "name": "Process Test Results",
      "type": "n8n-nodes-base.code",
      "typeVersion": 1,
      "position": [2250, 250]
    },
    {
      "parameters": {
        "functionCode": "// Merge test results (for skipped tests, just pass through)\nconst result = {\n  ...items[0].json,\n  test_executed: items[0].json.test_executed || false,\n  test_passed: items[0].json.test_passed !== false, // default to true if not executed\n  test_output: items[0].json.test_output || 'Tests skipped',\n  recommended_action: items[0].json.recommended_action || 'manual_review',\n  final_status: items[0].json.issue_status || 'fix_generated'\n};\n\nreturn [{json: result}];"
      },
      "id": "merge_results",
      "name": "Merge Results",
      "type": "n8n-nodes-base.code",
      "typeVersion": 1,
      "position": [2050, 350]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "UPDATE issues SET status = '{{ $json.final_status }}', test_results = $1, updated_at = CURRENT_TIMESTAMP WHERE id = '{{ $json.issue_id }}'",
        "additionalFields": {
          "values": "={{ JSON.stringify({test_executed: $json.test_executed, test_passed: $json.test_passed, test_output: $json.test_output, test_timestamp: $json.test_timestamp}) }}"
        }
      },
      "id": "update_final_status",
      "name": "Update Final Status",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2,
      "position": [2250, 350]
    },
    {
      "parameters": {
        "values": {
          "string": [
            {
              "name": "status",
              "value": "success"
            },
            {
              "name": "issue_id",
              "value": "={{ $json.issue_id }}"
            },
            {
              "name": "fix_generated",
              "value": "true"
            },
            {
              "name": "auto_applied",
              "value": "={{ $json.auto_apply_result === 'success' ? 'true' : 'false' }}"
            },
            {
              "name": "test_passed",
              "value": "={{ $json.test_passed ? 'true' : 'false' }}"
            },
            {
              "name": "risk_level",
              "value": "={{ $json.risk_level }}"
            },
            {
              "name": "recommended_action",
              "value": "={{ $json.recommended_action }}"
            },
            {
              "name": "workspace_path",
              "value": "={{ $json.workspace_path }}"
            },
            {
              "name": "backup_path",
              "value": "={{ $json.backup_path }}"
            }
          ]
        }
      },
      "id": "webhook_response",
      "name": "Webhook Response",
      "type": "n8n-nodes-base.set",
      "typeVersion": 2,
      "position": [2450, 350]
    }
  ],
  "connections": {
    "webhook_trigger": {
      "main": [[{"node": "get_issue_details", "type": "main", "index": 0}]]
    },
    "get_issue_details": {
      "main": [[{"node": "prepare_fix_generation", "type": "main", "index": 0}]]
    },
    "prepare_fix_generation": {
      "main": [[{"node": "generate_fix", "type": "main", "index": 0}]]
    },
    "generate_fix": {
      "main": [[{"node": "parse_fix_response", "type": "main", "index": 0}]]
    },
    "parse_fix_response": {
      "main": [[{"node": "update_issue_with_fix", "type": "main", "index": 0}]]
    },
    "update_issue_with_fix": {
      "main": [[{"node": "update_vector_db_with_fix", "type": "main", "index": 0}]]
    },
    "update_vector_db_with_fix": {
      "main": [[{"node": "check_auto_apply_result", "type": "main", "index": 0}]]
    },
    "check_auto_apply_result": {
      "main": [[{"node": "test_condition", "type": "main", "index": 0}]]
    },
    "test_condition": {
      "main": [
        [{"node": "run_tests", "type": "main", "index": 0}],
        [{"node": "merge_results", "type": "main", "index": 0}]
      ]
    },
    "run_tests": {
      "main": [[{"node": "process_test_results", "type": "main", "index": 0}]]
    },
    "process_test_results": {
      "main": [[{"node": "update_final_status", "type": "main", "index": 0}]]
    },
    "merge_results": {
      "main": [[{"node": "update_final_status", "type": "main", "index": 0}]]
    },
    "update_final_status": {
      "main": [[{"node": "webhook_response", "type": "main", "index": 0}]]
    }
  },
  "settings": {
    "executionOrder": "v1",
    "saveManualExecutions": true,
    "callerPolicy": "workflowsFromSameOwner",
    "errorWorkflow": ""
  },
  "staticData": null,
  "pinData": {},
  "versionId": "v1.0.0",
  "triggerCount": 1
}