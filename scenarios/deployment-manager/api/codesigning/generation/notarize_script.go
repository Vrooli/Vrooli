package generation

import (
	"bytes"
	"text/template"

	"deployment-manager/codesigning"
)

// notarizeScriptTemplateAPIKey is the template for notarization using API Key (preferred method).
const notarizeScriptTemplateAPIKey = `// Auto-generated notarization script for electron-builder
// This script runs after signing to notarize the macOS app with Apple.
//
// Required environment variables:
//   - APPLE_API_KEY_ID: The API Key ID from App Store Connect
//   - APPLE_API_KEY_PATH: Path to the .p8 API key file
//   - APPLE_API_ISSUER: The Issuer ID from App Store Connect
//
// Generated by deployment-manager code signing system.

const { notarize } = require('@electron/notarize');
const path = require('path');

exports.default = async function notarizing(context) {
    const { electronPlatformName, appOutDir } = context;

    // Only notarize macOS builds
    if (electronPlatformName !== 'darwin') {
        console.log('Skipping notarization: not macOS');
        return;
    }

    const appName = context.packager.appInfo.productFilename;
    const appPath = path.join(appOutDir, ` + "`${appName}.app`" + `);

    console.log(` + "`Notarizing ${appPath}...`" + `);

    const startTime = Date.now();

    try {
        await notarize({
            tool: 'notarytool',
            appPath: appPath,
            appleApiKey: process.env.{{.APIKeyIDEnv}} || '{{.APIKeyID}}',
            appleApiKeyId: process.env.{{.APIKeyIDEnv}} || '{{.APIKeyID}}',
            appleApiIssuer: process.env.{{.APIIssuerEnv}} || '{{.APIIssuer}}',
            teamId: '{{.TeamID}}'
        });

        const duration = ((Date.now() - startTime) / 1000).toFixed(1);
        console.log(` + "`Notarization complete in ${duration}s`" + `);
    } catch (error) {
        console.error('Notarization failed:', error.message);
        throw error;
    }
};
`

// notarizeScriptTemplateAppPassword is the template for notarization using App-Specific Password.
const notarizeScriptTemplateAppPassword = `// Auto-generated notarization script for electron-builder
// This script runs after signing to notarize the macOS app with Apple.
//
// Required environment variables:
//   - {{.AppleIDEnv}}: Your Apple ID email
//   - {{.AppleIDPasswordEnv}}: Your app-specific password
//
// Generated by deployment-manager code signing system.

const { notarize } = require('@electron/notarize');
const path = require('path');

exports.default = async function notarizing(context) {
    const { electronPlatformName, appOutDir } = context;

    // Only notarize macOS builds
    if (electronPlatformName !== 'darwin') {
        console.log('Skipping notarization: not macOS');
        return;
    }

    const appName = context.packager.appInfo.productFilename;
    const appPath = path.join(appOutDir, ` + "`${appName}.app`" + `);

    console.log(` + "`Notarizing ${appPath}...`" + `);

    const startTime = Date.now();

    try {
        await notarize({
            tool: 'notarytool',
            appPath: appPath,
            appleId: process.env.{{.AppleIDEnv}},
            appleIdPassword: process.env.{{.AppleIDPasswordEnv}},
            teamId: '{{.TeamID}}'
        });

        const duration = ((Date.now() - startTime) / 1000).toFixed(1);
        console.log(` + "`Notarization complete in ${duration}s`" + `);
    } catch (error) {
        console.error('Notarization failed:', error.message);
        throw error;
    }
};
`

// generateNotarizeJS generates the afterSign notarization script for electron-builder.
func generateNotarizeJS(config *codesigning.MacOSSigningConfig) ([]byte, error) {
	if config == nil || !config.Notarize {
		return nil, nil
	}

	var tmplStr string
	var data map[string]string

	// Choose template based on credential method
	if config.AppleAPIKeyID != "" {
		// API Key method (preferred)
		tmplStr = notarizeScriptTemplateAPIKey

		apiKeyIDEnv := "APPLE_API_KEY_ID"
		apiIssuerEnv := "APPLE_API_ISSUER"

		data = map[string]string{
			"APIKeyID":      config.AppleAPIKeyID,
			"APIKeyIDEnv":   apiKeyIDEnv,
			"APIIssuer":     config.AppleAPIIssuerID,
			"APIIssuerEnv":  apiIssuerEnv,
			"TeamID":        config.TeamID,
		}
	} else {
		// App-Specific Password method
		tmplStr = notarizeScriptTemplateAppPassword

		appleIDEnv := config.AppleIDEnv
		if appleIDEnv == "" {
			appleIDEnv = "APPLE_ID"
		}

		appleIDPasswordEnv := config.AppleIDPasswordEnv
		if appleIDPasswordEnv == "" {
			appleIDPasswordEnv = "APPLE_ID_PASSWORD"
		}

		data = map[string]string{
			"AppleIDEnv":         appleIDEnv,
			"AppleIDPasswordEnv": appleIDPasswordEnv,
			"TeamID":             config.TeamID,
		}
	}

	tmpl, err := template.New("notarize").Parse(tmplStr)
	if err != nil {
		return nil, err
	}

	var buf bytes.Buffer
	if err := tmpl.Execute(&buf, data); err != nil {
		return nil, err
	}

	return buf.Bytes(), nil
}

// NotarizeCredentialMethod returns which credential method is configured.
// Returns "api_key", "app_password", or "" if notarization is not configured.
func NotarizeCredentialMethod(config *codesigning.MacOSSigningConfig) string {
	if config == nil || !config.Notarize {
		return ""
	}

	if config.AppleAPIKeyID != "" {
		return "api_key"
	}

	if config.AppleIDEnv != "" || config.AppleIDPasswordEnv != "" {
		return "app_password"
	}

	return ""
}
