# Auto-Update Channel Design

This guide documents the auto-update system for desktop applications built with `scenario-to-desktop`. It covers the channel model, provider configuration, and operational workflows.

## Overview

Desktop applications generated by `scenario-to-desktop` use `electron-updater` for automatic updates. Updates are organized into **channels** (dev, beta, stable) and can be served from **GitHub Releases** or a **self-hosted update server**.

### Design Principles

1. **Off by default** - Auto-updates are disabled unless explicitly configured with a provider
2. **Channel separation** - Dev/beta channels use prereleases; stable uses production releases
3. **User control** - Manual update checks available via Help menu regardless of auto-check setting
4. **Telemetry integration** - Update events are recorded in `deployment-telemetry.jsonl`
5. **Graceful fallback** - Missing/misconfigured updates don't break the app

## Update Channels

Three channels are supported:

| Channel | Purpose | GitHub Release Type | Typical Users |
|---------|---------|---------------------|---------------|
| `dev` | Internal testing, frequent updates | Prerelease | Developers |
| `beta` | Pre-release testing, near-stable | Prerelease | Beta testers |
| `stable` | Production releases | Release | End users |

### Channel Selection

The channel is set at generation time via the `update_config.channel` option:

```json
{
  "update_config": {
    "channel": "stable",
    "provider": "github",
    "github": {
      "owner": "your-org",
      "repo": "your-app-desktop"
    }
  }
}
```

The channel affects:
- **GitHub provider**: Whether to allow prereleases (`dev`/`beta`) or only releases (`stable`)
- **Generic provider**: The URL path used to fetch update metadata (e.g., `/stable/latest.yml`)
- **Telemetry**: All update events include the channel for analytics

## Update Providers

### GitHub Releases

The recommended provider for public applications. Uses GitHub's release infrastructure.

**Configuration:**

```json
{
  "update_config": {
    "channel": "stable",
    "provider": "github",
    "github": {
      "owner": "your-organization",
      "repo": "your-app-desktop",
      "private": false
    },
    "auto_check": true
  }
}
```

**Publishing workflow:**

1. Build installers: `npm run dist:all`
2. Create GitHub release with version tag (e.g., `v1.2.0`)
3. Upload platform artifacts:
   - Windows: `your-app-1.2.0.msi`, `latest.yml`
   - macOS: `your-app-1.2.0.pkg`, `latest-mac.yml`
   - Linux: `your-app-1.2.0.AppImage`, `latest-linux.yml`
4. For prereleases (dev/beta): Mark the release as "Pre-release"

**Required release assets:**

```
your-app-1.2.0.msi
your-app-1.2.0-mac.pkg
your-app-1.2.0.AppImage
latest.yml           # Windows update manifest
latest-mac.yml       # macOS update manifest
latest-linux.yml     # Linux update manifest
```

**Private repositories:**

For private repos, set `"private": true` and ensure `GH_TOKEN` environment variable is set at runtime with a token that has `repo` scope.

### Generic (Self-Hosted) Server

For organizations requiring full control over update distribution.

**Configuration:**

```json
{
  "update_config": {
    "channel": "stable",
    "provider": "generic",
    "generic": {
      "url": "https://updates.yourcompany.com/app-name",
      "channel_path": "/{channel}"
    },
    "auto_check": true
  }
}
```

**Server structure:**

```
https://updates.yourcompany.com/app-name/
├── dev/
│   ├── latest.yml
│   ├── latest-mac.yml
│   ├── latest-linux.yml
│   └── [artifacts]
├── beta/
│   ├── latest.yml
│   ├── latest-mac.yml
│   ├── latest-linux.yml
│   └── [artifacts]
└── stable/
    ├── latest.yml
    ├── latest-mac.yml
    ├── latest-linux.yml
    └── [artifacts]
```

**Update manifest format (`latest.yml`):**

```yaml
version: 1.2.0
files:
  - url: your-app-1.2.0.msi
    sha512: <base64-encoded-sha512>
    size: 52428800
path: your-app-1.2.0.msi
sha512: <base64-encoded-sha512>
releaseDate: '2025-01-15T12:00:00.000Z'
```

**Server requirements:**

- HTTPS required (HTTP only works for localhost testing)
- CORS headers if served from different domain than app
- Static file hosting (S3, CloudFront, nginx, etc.)

### Disabled (No Updates)

For applications that don't need auto-updates:

```json
{
  "update_config": {
    "provider": "none"
  }
}
```

Or simply omit the `update_config` entirely.

## Configuration Reference

### DesktopConfig.update_config

| Property | Type | Default | Description |
|----------|------|---------|-------------|
| `channel` | `"dev" \| "beta" \| "stable"` | `"stable"` | Update channel |
| `provider` | `"github" \| "generic" \| "none"` | `"none"` | Update provider type |
| `auto_check` | `boolean` | `false` | Auto-check on app start |
| `github.owner` | `string` | - | GitHub org/user |
| `github.repo` | `string` | - | GitHub repository name |
| `github.private` | `boolean` | `false` | Private repo (requires GH_TOKEN) |
| `generic.url` | `string` | - | Base URL for update server |
| `generic.channel_path` | `string` | `"/{channel}"` | Path pattern for channels |

### Generated Files

The template generator creates these update-related configurations:

**`package.json` (build.publish section):**

```json
{
  "build": {
    "publish": {
      "provider": "github",
      "owner": "your-org",
      "repo": "your-app-desktop",
      "releaseType": "release"
    }
  }
}
```

**`src/main.ts` (UPDATE_CONFIG constant):**

```typescript
const UPDATE_CONFIG = {
    CHANNEL: "stable",
    PROVIDER: "github",
    AUTO_CHECK: true,
    SERVER_URL: "https://github.com/your-org/your-app-desktop/releases",
};
```

## Runtime Behavior

### Startup Flow

1. App launches and initializes
2. If `ENABLE_AUTO_UPDATER` and packaged and `PROVIDER !== "none"`:
   - Configure `autoUpdater` with channel settings
   - Set up event handlers
   - If `AUTO_CHECK` is true, check for updates after 3-second delay
3. User can always trigger manual check via Help → Check for Updates

### Update Flow

1. **Check**: Query update server for latest version
2. **Compare**: If newer version available, trigger download
3. **Download**: Download update in background, report progress
4. **Notify**: Show dialog with "Restart Now" / "Later" options
5. **Install**: On restart or quit, apply update

### Telemetry Events

All update-related events are recorded to `deployment-telemetry.jsonl`:

| Event | Description |
|-------|-------------|
| `update_check_started` | Update check initiated |
| `update_available` | Newer version found |
| `update_downloaded` | Update package downloaded |
| `update_error` | Update check/download failed |

Example:
```json
{"ts": "2025-01-15T12:00:00Z", "event": "update_available", "details": {"version": "1.2.0", "channel": "stable"}}
```

## Installer Formats

The desktop build system produces platform-specific installers:

| Platform | Primary Format | File Extension | Notes |
|----------|---------------|----------------|-------|
| Windows | MSI | `.msi` | Enterprise-friendly, silent install support |
| macOS | PKG | `.pkg` | Installer package, supports signed distribution |
| Linux | AppImage | `.AppImage` | Portable, self-contained |
| Linux | DEB | `.deb` | Debian/Ubuntu package manager |

### Build Commands

```bash
# Build for specific platform
npm run dist:win    # Windows MSI
npm run dist:mac    # macOS PKG
npm run dist:linux  # Linux AppImage + DEB

# Build for all platforms
npm run dist:all
```

### Output Location

Built artifacts are placed in `dist-electron/`:

```
dist-electron/
├── your-app-1.0.0.msi
├── your-app-1.0.0-mac.pkg
├── your-app-1.0.0.AppImage
├── your-app-1.0.0_amd64.deb
├── latest.yml
├── latest-mac.yml
└── latest-linux.yml
```

## Code Signing

### Current State

Code signing is disabled by default (`signAndEditExecutable: false`, `hardenedRuntime: false`). This allows unsigned development builds but triggers OS security warnings for end users.

### Production Requirements

For production distribution:

**Windows:**
- Obtain Authenticode code signing certificate (~$200-400/year)
- Configure in `package.json`:
  ```json
  {
    "build": {
      "win": {
        "certificateFile": "./cert.pfx",
        "certificatePassword": "${WIN_CSC_KEY_PASSWORD}",
        "signAndEditExecutable": true
      }
    }
  }
  ```

**macOS:**
- Obtain Apple Developer certificate ($99/year)
- Enable hardened runtime and notarization:
  ```json
  {
    "build": {
      "mac": {
        "hardenedRuntime": true,
        "gatekeeperAssess": true,
        "entitlements": "build/entitlements.mac.plist"
      },
      "afterSign": "scripts/notarize.js"
    }
  }
  ```

**Linux:**
- GPG signing optional but recommended for package managers

## Operational Workflows

### Setting Up GitHub Releases

1. **Generate with updates enabled:**
   ```bash
   POST /api/v1/desktop/generate/quick
   {
     "scenario_name": "picker-wheel",
     "update_config": {
       "channel": "stable",
       "provider": "github",
       "github": {"owner": "vrooli", "repo": "picker-wheel-desktop"},
       "auto_check": true
     }
   }
   ```

2. **Build release:**
   ```bash
   cd scenarios/picker-wheel/platforms/electron
   npm run dist:all
   ```

3. **Create GitHub release:**
   - Tag: `v1.0.0`
   - Upload all `.msi`, `.pkg`, `.AppImage`, `latest*.yml` files

4. **Users receive updates automatically**

### Setting Up Self-Hosted Updates

1. **Configure generic provider:**
   ```json
   {
     "update_config": {
       "channel": "stable",
       "provider": "generic",
       "generic": {
         "url": "https://updates.example.com/picker-wheel"
       }
     }
   }
   ```

2. **Set up update server:**
   - Create directory structure: `/stable/`, `/beta/`, `/dev/`
   - Configure HTTPS and static file serving

3. **Publish updates:**
   - Build: `npm run dist:all`
   - Upload artifacts and `latest*.yml` to appropriate channel directory
   - Users on that channel receive updates

### Rolling Out Updates Gradually

1. **Push to dev channel** - Internal testing
2. **Promote to beta** - Copy artifacts to `/beta/`, update `latest*.yml`
3. **Promote to stable** - Copy artifacts to `/stable/`, update `latest*.yml`

Each channel is independent; users only receive updates from their configured channel.

## Troubleshooting

### Updates Not Working

1. **Check provider configuration:**
   - Verify `UPDATE_CONFIG.PROVIDER` is not `"none"`
   - Check console logs for "Auto-updater configured" message

2. **Verify release assets:**
   - Ensure `latest.yml` exists alongside installer
   - Check version in `latest.yml` is newer than installed

3. **Network issues:**
   - For GitHub: Check rate limits, repo accessibility
   - For generic: Verify HTTPS, CORS headers, URL accessibility

### "Update Check Failed" Error

- **GitHub private repo**: Set `GH_TOKEN` environment variable
- **Self-hosted**: Verify SSL certificate, check server logs
- **Firewall**: Ensure update server is reachable

### Update Downloads But Doesn't Install

- **Windows**: May need admin privileges for MSI
- **macOS**: Verify app isn't open in multiple locations
- **Linux**: AppImage needs execute permissions after update

## See Also

- [Tier 2 Desktop Documentation](../tiers/tier-2-desktop.md)
- [Packaging Matrix](./packaging-matrix.md)
- [Secrets Management](./secrets-management.md) (for handling update server credentials)
- [electron-updater Documentation](https://www.electron.build/auto-update)
