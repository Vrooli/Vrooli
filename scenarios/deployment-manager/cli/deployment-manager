#!/bin/bash
# deployment-manager - Command-line interface for Deployment Manager

set -euo pipefail

readonly CLI_NAME="deployment-manager"
readonly CLI_VERSION="1.0.0"
readonly CONFIG_DIR="$HOME/.${CLI_NAME}"
readonly CONFIG_FILE="$CONFIG_DIR/config.json"
readonly SCENARIO_ID="deployment-manager"
readonly DEFAULT_TOKEN=""
CONFIG_API_BASE=""
API_BASE=""
OUTPUT_FORMAT="text"

readonly RED='\033[0;31m'
readonly GREEN='\033[0;32m'
readonly YELLOW='\033[1;33m'
readonly BLUE='\033[0;34m'
readonly NC='\033[0m'

init_config() {
    if [[ ! -d "$CONFIG_DIR" ]]; then
        mkdir -p "$CONFIG_DIR"
    fi
    
    if [[ ! -f "$CONFIG_FILE" ]]; then
        cat > "$CONFIG_FILE" <<JSON
{
  "api_base": "",
  "api_token": "$DEFAULT_TOKEN",
  "output_format": "json",
  "created_at": "$(date -u +"%Y-%m-%dT%H:%M:%SZ")"
}
JSON
        echo -e "${GREEN}✓${NC} Configuration created at $CONFIG_FILE"
    fi
}

load_config() {
    if [[ -f "$CONFIG_FILE" ]]; then
        CONFIG_API_BASE=$(jq -r '.api_base // ""' "$CONFIG_FILE" 2>/dev/null || echo "")
        API_TOKEN=$(jq -r '.api_token // ""' "$CONFIG_FILE" 2>/dev/null || echo "")
    else
        CONFIG_API_BASE=""
        API_TOKEN=""
    fi
}

detect_api_port() {
    if command -v vrooli >/dev/null 2>&1; then
        vrooli scenario port "$SCENARIO_ID" API_PORT 2>/dev/null || true
    fi
}

detect_api_base() {
    if [[ -n "${API_BASE_URL:-}" ]]; then
        echo "${API_BASE_URL%/}"
        return 0
    fi

    # Prefer detected port (from vrooli scenario port) over env var
    # because env var might be from a different scenario
    local detected_port
    detected_port="$(detect_api_port)"
    if [[ -n "$detected_port" ]]; then
        echo "http://localhost:${detected_port}"
        return 0
    fi

    # Fall back to API_PORT env var if detection fails
    if [[ -n "${API_PORT:-}" ]]; then
        echo "http://${API_HOST:-localhost}:${API_PORT}"
        return 0
    fi

    return 1
}

normalize_api_base() {
    local value="$1"
    if [[ -z "$value" || "$value" == "null" ]]; then
        return 1
    fi
    echo "${value%/}"
}

resolve_api_base() {
    local candidate

    if candidate=$(normalize_api_base "$1" 2>/dev/null); then
        echo "$candidate"
        return 0
    fi

    local detected
    if detected=$(detect_api_base); then
        echo "$detected"
        return 0
    fi

    return 1
}

api_request() {
    local method="$1"
    local endpoint="$2"
    local url="${API_BASE}${endpoint}"

    if [[ -z "$API_BASE" ]]; then
        echo -e "${RED}✗${NC} API base URL is not configured. Start the scenario via 'vrooli scenario run deployment-manager' or run '$CLI_NAME configure api_base <url>'." >&2
        return 1
    fi

    local headers=(-H 'Content-Type: application/json')
    if [[ -n "${API_TOKEN:-}" ]]; then
        headers+=(-H "Authorization: Bearer $API_TOKEN")
    fi

    curl -s -X "$method" "${headers[@]}" "$url"
}

log_info() {
    if [[ "$OUTPUT_FORMAT" == "json" ]]; then
        return 0
    fi
    echo -e "${BLUE}${1}${NC}"
}

log_success() {
    if [[ "$OUTPUT_FORMAT" == "json" ]]; then
        return 0
    fi
    echo -e "${GREEN}✓${NC} ${1}"
}

log_error() {
    if [[ "$OUTPUT_FORMAT" == "json" ]]; then
        echo "$1" >&2
    else
        echo -e "${RED}✗${NC} ${1}" >&2
    fi
}

tier_to_number() {
    local tier="$1"
    case "$tier" in
        local|1) echo "1" ;;
        desktop|2) echo "2" ;;
        mobile|ios|android|3) echo "3" ;;
        saas|cloud|web|4) echo "4" ;;
        enterprise|on-prem|5) echo "5" ;;
        *)
            # If it's already a number 1-5, return it
            if [[ "$tier" =~ ^[1-5]$ ]]; then
                echo "$tier"
            else
                # Default to mobile tier for unrecognized platform-specific names
                echo "3"
            fi
            ;;
    esac
}

cmd_status() {
    echo -e "${BLUE}Checking system health...${NC}"
    response=$(api_request GET "/health" || true)
    if [[ -z "$response" ]]; then
        echo -e "${RED}✗${NC} API is not reachable"
        return 1
    fi

    status=$(echo "$response" | jq -r '.status // "unknown"' 2>/dev/null || echo "unknown")
    if [[ "$status" == "healthy" ]]; then
        echo -e "${GREEN}✓${NC} Service is healthy"
    else
        echo -e "${YELLOW}⚠${NC} Service status: $status"
    fi

    echo "$response" | jq -r '
        "  Service: \(.service // "unknown")",
        "  Version: \(.version // "unknown")",
        "  Database: \(.dependencies.database // "unknown")"
    ' 2>/dev/null || true
}

cmd_configure() {
    local key="${1:-}"
    local value="${2:-}"

    if [[ -z "$key" ]]; then
        cat "$CONFIG_FILE" | jq '.' 2>/dev/null || cat "$CONFIG_FILE"
        return 0
    fi

    case "$key" in
        api|api_base)
            jq --arg v "$value" '.api_base = $v' "$CONFIG_FILE" > "${CONFIG_FILE}.tmp" && mv "${CONFIG_FILE}.tmp" "$CONFIG_FILE"
            echo -e "${GREEN}✓${NC} API base set to: $value"
            CONFIG_API_BASE="$value"
            ;;
        token|api_token)
            jq --arg v "$value" '.api_token = $v' "$CONFIG_FILE" > "${CONFIG_FILE}.tmp" && mv "${CONFIG_FILE}.tmp" "$CONFIG_FILE"
            echo -e "${GREEN}✓${NC} API token updated"
            API_TOKEN="$value"
            ;;
        *)
            echo -e "${RED}✗${NC} Unknown configuration key: $key"
            echo "Valid keys: api_base, api_token"
            return 1
            ;;
    esac
}

cmd_version() {
    echo "$CLI_NAME version $CLI_VERSION"
    if [[ -n "$API_BASE" ]]; then
        echo "API endpoint: $API_BASE"
    else
        echo "API endpoint: (auto-detect when scenario is running)"
    fi
}

cmd_analyze() {
    local scenario=""

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --format)
                OUTPUT_FORMAT="$2"
                shift 2
                ;;
            *)
                if [[ -z "$scenario" ]]; then
                    scenario="$1"
                fi
                shift
                ;;
        esac
    done

    if [[ -z "$scenario" ]]; then
        log_error "Scenario name is required"
        echo "Usage: $CLI_NAME analyze <scenario> [--format json]"
        return 1
    fi

    log_info "Analyzing dependencies for '$scenario'..."
    response=$(api_request GET "/api/v1/dependencies/analyze/$scenario" || true)
    if [[ -z "$response" ]]; then
        log_error "Failed to analyze dependencies"
        return 1
    fi

    # Check if response contains an error
    if echo "$response" | jq -e '.error' >/dev/null 2>&1; then
        echo "$response" | jq '.' 2>/dev/null || echo "$response"
        return 1
    fi

    echo "$response" | jq '.' 2>/dev/null || echo "$response"
}

cmd_fitness() {
    local scenario=""
    local tier="2"

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --tier)
                tier="$2"
                shift 2
                ;;
            --format)
                OUTPUT_FORMAT="$2"
                shift 2
                ;;
            *)
                if [[ -z "$scenario" ]]; then
                    scenario="$1"
                fi
                shift
                ;;
        esac
    done

    if [[ -z "$scenario" ]]; then
        log_error "Scenario name is required"
        echo "Usage: $CLI_NAME fitness <scenario> [--tier <tier>] [--format json]"
        return 1
    fi

    log_info "Calculating fitness scores for '$scenario' (tier $tier)..."
    local payload=$(jq -n --arg s "$scenario" --argjson t "[$tier]" '{scenario: $s, tiers: $t}')
    response=$(curl -s -X POST -H 'Content-Type: application/json' -d "$payload" "${API_BASE}/api/v1/fitness/score" || true)

    if [[ -z "$response" ]]; then
        log_error "Failed to calculate fitness scores"
        return 1
    fi

    echo "$response" | jq '.' 2>/dev/null || echo "$response"
}

cmd_profiles() {
    local subcmd="${1:-list}"
    shift || true

    case "$subcmd" in
        list)
            echo -e "${BLUE}Listing deployment profiles...${NC}"
            response=$(api_request GET "/api/v1/profiles" || true)
            if [[ -z "$response" ]]; then
                echo -e "${RED}✗${NC} Failed to list profiles"
                return 1
            fi
            echo "$response" | jq '.' 2>/dev/null || echo "$response"
            ;;
        *)
            echo -e "${RED}✗${NC} Unknown profiles subcommand: $subcmd"
            echo "Valid subcommands: list"
            return 1
            ;;
    esac
}

cmd_profile() {
    local subcmd="${1:-}"
    shift || true

    case "$subcmd" in
        create)
            local name="${1:-}"
            local scenario=""
            local tier="2"

            if [[ -z "$name" ]]; then
                log_error "Profile name is required"
                echo "Usage: $CLI_NAME profile create <name> [<scenario>] [--scenario <scenario>] [--tier <tier>] [--format json]"
                return 1
            fi
            shift

            # Check if next arg is a scenario name (not a flag)
            if [[ $# -gt 0 && "$1" != --* ]]; then
                scenario="$1"
                shift
            fi

            # Parse flags
            while [[ $# -gt 0 ]]; do
                case "$1" in
                    --scenario)
                        scenario="$2"
                        shift 2
                        ;;
                    --tier)
                        tier="$2"
                        shift 2
                        ;;
                    --format)
                        OUTPUT_FORMAT="$2"
                        shift 2
                        ;;
                    *)
                        log_error "Unknown flag: $1"
                        return 1
                        ;;
                esac
            done

            if [[ -z "$scenario" ]]; then
                log_error "Scenario is required (either as positional arg or --scenario flag)"
                return 1
            fi

            # Convert tier name to number
            local tier_num=$(tier_to_number "$tier")

            log_info "Creating profile '$name' for scenario '$scenario' (tier $tier)..."
            local payload=$(jq -n --arg n "$name" --arg s "$scenario" --argjson t "[$tier_num]" \
                '{name: $n, scenario: $s, tiers: $t, swaps: {}, secrets: {}, settings: {}}')
            response=$(curl -s -X POST -H 'Content-Type: application/json' -d "$payload" "${API_BASE}/api/v1/profiles" || true)

            if [[ -z "$response" ]]; then
                log_error "Failed to create profile"
                return 1
            fi
            echo "$response" | jq '.' 2>/dev/null || echo "$response"
            ;;
        list)
            shift || true
            while [[ $# -gt 0 ]]; do
                case "$1" in
                    --format)
                        OUTPUT_FORMAT="$2"
                        shift 2
                        ;;
                    *)
                        shift
                        ;;
                esac
            done
            log_info "Listing deployment profiles..."
            response=$(api_request GET "/api/v1/profiles" || true)
            if [[ -z "$response" ]]; then
                log_error "Failed to list profiles"
                return 1
            fi
            echo "$response" | jq '.' 2>/dev/null || echo "$response"
            ;;
        show)
            local profile_id="${1:-}"
            shift || true

            while [[ $# -gt 0 ]]; do
                case "$1" in
                    --format)
                        OUTPUT_FORMAT="$2"
                        shift 2
                        ;;
                    *)
                        shift
                        ;;
                esac
            done

            if [[ -z "$profile_id" ]]; then
                log_error "Profile ID is required"
                echo "Usage: $CLI_NAME profile show <profile_id> [--format json]"
                return 1
            fi
            log_info "Fetching profile '$profile_id'..."
            response=$(api_request GET "/api/v1/profiles/$profile_id" || true)
            if [[ -z "$response" ]]; then
                log_error "Failed to fetch profile"
                return 1
            fi
            # Check if response contains an error or is not implemented
            if echo "$response" | jq -e '.error' >/dev/null 2>&1 || echo "$response" | jq -e '.message | contains("not yet implemented")' >/dev/null 2>&1; then
                echo "$response" | jq '.' 2>/dev/null || echo "$response"
                return 1
            fi
            echo "$response" | jq '.' 2>/dev/null || echo "$response"
            ;;
        delete)
            local profile_id="${1:-}"
            shift || true

            while [[ $# -gt 0 ]]; do
                case "$1" in
                    --format)
                        OUTPUT_FORMAT="$2"
                        shift 2
                        ;;
                    *)
                        shift
                        ;;
                esac
            done

            if [[ -z "$profile_id" ]]; then
                log_error "Profile ID is required"
                echo "Usage: $CLI_NAME profile delete <profile_id> [--format json]"
                return 1
            fi
            log_info "Deleting profile '$profile_id'..."
            response=$(curl -s -X DELETE -H 'Content-Type: application/json' "${API_BASE}/api/v1/profiles/$profile_id" || true)
            if [[ -z "$response" ]]; then
                log_error "Failed to delete profile"
                return 1
            fi
            echo "$response" | jq '.' 2>/dev/null || echo "$response"
            ;;
        swap)
            local profile_id="${1:-}"
            local action="${2:-}"
            local from="${3:-}"
            local to="${4:-}"
            shift 4 || true

            while [[ $# -gt 0 ]]; do
                case "$1" in
                    --format)
                        OUTPUT_FORMAT="$2"
                        shift 2
                        ;;
                    *)
                        shift
                        ;;
                esac
            done

            if [[ -z "$profile_id" ]] || [[ -z "$action" ]] || [[ -z "$from" ]] || [[ -z "$to" ]]; then
                log_error "Profile ID, action, from, and to are required"
                echo "Usage: $CLI_NAME profile swap <profile_id> <add|remove> <from> <to> [--format json]"
                return 1
            fi

            log_info "Updating swap for profile '$profile_id': $from -> $to..."

            # Get current profile
            current_profile=$(api_request GET "/api/v1/profiles/$profile_id" || true)
            if [[ -z "$current_profile" ]]; then
                log_error "Failed to fetch current profile"
                return 1
            fi

            # Update swaps field
            local swaps=$(echo "$current_profile" | jq --arg from "$from" --arg to "$to" '.swaps[$from] = $to')
            local payload=$(echo "$current_profile" | jq --arg from "$from" --arg to "$to" '.swaps[$from] = $to | {swaps: .swaps}')

            response=$(curl -s -X PUT -H 'Content-Type: application/json' -d "$payload" "${API_BASE}/api/v1/profiles/$profile_id" || true)
            if [[ -z "$response" ]]; then
                log_error "Failed to update profile swap"
                return 1
            fi
            echo "$response" | jq '.' 2>/dev/null || echo "$response"
            ;;
        set)
            local profile_id="${1:-}"
            local key="${2:-}"
            local value="${3:-}"
            shift 3 || true

            while [[ $# -gt 0 ]]; do
                case "$1" in
                    --format)
                        OUTPUT_FORMAT="$2"
                        shift 2
                        ;;
                    *)
                        shift
                        ;;
                esac
            done

            if [[ -z "$profile_id" ]] || [[ -z "$key" ]]; then
                log_error "Profile ID and key are required"
                echo "Usage: $CLI_NAME profile set <profile_id> <key> <value> [--format json]"
                return 1
            fi

            log_info "Setting $key for profile '$profile_id'..."

            # Get current profile
            current_profile=$(api_request GET "/api/v1/profiles/$profile_id" || true)
            if [[ -z "$current_profile" ]]; then
                log_error "Failed to fetch current profile"
                return 1
            fi

            # Build update payload based on key type
            local payload
            case "$key" in
                tier)
                    local tier_num=$(tier_to_number "$value")
                    payload=$(echo "$current_profile" | jq --argjson tier "[$tier_num]" '{tiers: $tier}')
                    ;;
                env)
                    local env_key="${3:-}"
                    local env_value="${4:-}"
                    if [[ -z "$env_key" ]]; then
                        log_error "Environment variable key is required"
                        echo "Usage: $CLI_NAME profile set <profile_id> env <key> <value>"
                        return 1
                    fi
                    payload=$(echo "$current_profile" | jq --arg k "$env_key" --arg v "$env_value" '.settings.env[$k] = $v | {settings: .settings}')
                    ;;
                *)
                    payload=$(echo "$current_profile" | jq --arg k "$key" --arg v "$value" '.settings[$k] = $v | {settings: .settings}')
                    ;;
            esac

            response=$(curl -s -X PUT -H 'Content-Type: application/json' -d "$payload" "${API_BASE}/api/v1/profiles/$profile_id" || true)
            if [[ -z "$response" ]]; then
                log_error "Failed to update profile"
                return 1
            fi
            echo "$response" | jq '.' 2>/dev/null || echo "$response"
            ;;
        analyze)
            local profile_id="${1:-}"
            shift || true

            while [[ $# -gt 0 ]]; do
                case "$1" in
                    --format)
                        OUTPUT_FORMAT="$2"
                        shift 2
                        ;;
                    *)
                        shift
                        ;;
                esac
            done

            if [[ -z "$profile_id" ]]; then
                log_error "Profile ID is required"
                echo "Usage: $CLI_NAME profile analyze <profile_id> [--format json]"
                return 1
            fi

            log_info "Analyzing profile '$profile_id'..."
            response=$(api_request GET "/api/v1/profiles/$profile_id" || true)
            if [[ -z "$response" ]]; then
                log_error "Failed to fetch profile"
                return 1
            fi
            echo "$response" | jq '.' 2>/dev/null || echo "$response"
            ;;
        export)
            local profile_id="${1:-}"
            shift || true
            local output_file=""

            while [[ $# -gt 0 ]]; do
                case "$1" in
                    --output)
                        output_file="$2"
                        shift 2
                        ;;
                    --format)
                        OUTPUT_FORMAT="$2"
                        shift 2
                        ;;
                    *)
                        shift
                        ;;
                esac
            done

            if [[ -z "$profile_id" ]]; then
                log_error "Profile ID is required"
                echo "Usage: $CLI_NAME profile export <profile_id> [--output <file>] [--format json]"
                return 1
            fi

            log_info "Exporting profile '$profile_id'..."
            response=$(api_request GET "/api/v1/profiles/$profile_id" || true)
            if [[ -z "$response" ]]; then
                log_error "Failed to export profile"
                return 1
            fi

            if [[ -n "$output_file" ]]; then
                echo "$response" | jq '.' > "$output_file" 2>/dev/null || echo "$response" > "$output_file"
                echo "Profile exported to $output_file"
            else
                echo "$response" | jq '.' 2>/dev/null || echo "$response"
            fi
            ;;
        versions)
            local profile_id="${1:-}"
            shift || true

            while [[ $# -gt 0 ]]; do
                case "$1" in
                    --format)
                        OUTPUT_FORMAT="$2"
                        shift 2
                        ;;
                    *)
                        shift
                        ;;
                esac
            done

            if [[ -z "$profile_id" ]]; then
                log_error "Profile ID is required"
                echo "Usage: $CLI_NAME profile versions <profile_id> [--format json]"
                return 1
            fi

            log_info "Fetching version history for '$profile_id'..."
            response=$(api_request GET "/api/v1/profiles/$profile_id/versions" || true)
            if [[ -z "$response" ]]; then
                log_error "Failed to fetch version history"
                return 1
            fi
            echo "$response" | jq '.' 2>/dev/null || echo "$response"
            ;;
        update)
            local profile_id="${1:-}"
            shift || true

            if [[ -z "$profile_id" ]]; then
                log_error "Profile ID is required"
                echo "Usage: $CLI_NAME profile update <profile_id> [--tier <tier>] [--format json]"
                return 1
            fi

            local tier=""
            while [[ $# -gt 0 ]]; do
                case "$1" in
                    --tier)
                        tier="$2"
                        shift 2
                        ;;
                    --format)
                        OUTPUT_FORMAT="$2"
                        shift 2
                        ;;
                    *)
                        shift
                        ;;
                esac
            done

            # Get current profile
            local current_profile=$(api_request GET "/api/v1/profiles/$profile_id" || true)
            if [[ -z "$current_profile" ]]; then
                log_error "Failed to fetch profile"
                return 1
            fi

            # Build payload
            local payload="$current_profile"
            if [[ -n "$tier" ]]; then
                local tier_num=$(tier_to_number "$tier")
                payload=$(echo "$payload" | jq --argjson tier "[$tier_num]" '.tiers = $tier')
            fi

            log_info "Updating profile '$profile_id'..."
            response=$(curl -s -X PUT -H 'Content-Type: application/json' -d "$payload" "${API_BASE}/api/v1/profiles/$profile_id" || true)
            if [[ -z "$response" ]]; then
                log_error "Failed to update profile"
                return 1
            fi

            echo "$response" | jq -r '.message // "Profile updated successfully"' 2>/dev/null || echo "Profile updated successfully"
            ;;
        save)
            local profile_id="${1:-}"
            shift || true

            if [[ -z "$profile_id" ]]; then
                log_error "Profile ID is required"
                echo "Usage: $CLI_NAME profile save <profile_id> [--format json]"
                return 1
            fi

            while [[ $# -gt 0 ]]; do
                case "$1" in
                    --format)
                        OUTPUT_FORMAT="$2"
                        shift 2
                        ;;
                    *)
                        shift
                        ;;
                esac
            done

            # Get current profile and save it (no-op for now, as saves are automatic)
            log_info "Saving profile '$profile_id'..."
            response=$(api_request GET "/api/v1/profiles/$profile_id" || true)
            if [[ -z "$response" ]]; then
                log_error "Failed to save profile"
                return 1
            fi

            echo "Profile saved successfully"
            ;;
        import)
            local file_path="${1:-}"
            shift || true
            local name=""

            if [[ -z "$file_path" ]]; then
                log_error "File path is required"
                echo "Usage: $CLI_NAME profile import <file> [--name <name>] [--format json]"
                return 1
            fi

            while [[ $# -gt 0 ]]; do
                case "$1" in
                    --name)
                        name="$2"
                        shift 2
                        ;;
                    --format)
                        OUTPUT_FORMAT="$2"
                        shift 2
                        ;;
                    *)
                        shift
                        ;;
                esac
            done

            if [[ ! -f "$file_path" ]]; then
                log_error "File not found: $file_path"
                return 1
            fi

            local profile_data=$(cat "$file_path")

            # Update name if provided
            if [[ -n "$name" ]]; then
                profile_data=$(echo "$profile_data" | jq --arg n "$name" '.name = $n')
            fi

            log_info "Importing profile from '$file_path'..."
            response=$(curl -s -X POST -H 'Content-Type: application/json' -d "$profile_data" "${API_BASE}/api/v1/profiles" || true)
            if [[ -z "$response" ]]; then
                log_error "Failed to import profile"
                return 1
            fi

            echo "$response" | jq -r '.message // "Profile imported successfully"' 2>/dev/null || echo "Profile imported successfully"
            ;;
        *)
            log_error "Unknown profile subcommand: $subcmd"
            echo "Valid subcommands: create, list, show, delete, swap, set, analyze, export, versions, update, save, import"
            return 1
            ;;
    esac
}

cmd_deploy() {
    local profile_id="${1:-}"
    local dry_run=false
    local async=false
    local validate_only=false
    shift || true

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --dry-run)
                dry_run=true
                shift
                ;;
            --async)
                async=true
                shift
                ;;
            --validate-only)
                validate_only=true
                shift
                ;;
            --stream-logs)
                shift
                ;;
            *)
                shift
                ;;
        esac
    done

    if [[ -z "$profile_id" ]]; then
        echo -e "${RED}✗${NC} Profile ID is required"
        echo "Usage: $CLI_NAME deploy <profile_id> [--dry-run] [--async] [--validate-only]"
        return 1
    fi

    # Validate profile exists first
    log_info "Validating profile '$profile_id'..."
    validation=$(api_request GET "/api/v1/profiles/$profile_id" 2>&1 || true)
    if [[ -z "$validation" ]] || echo "$validation" | jq -e '.error' >/dev/null 2>&1; then
        log_error "Profile '$profile_id' not found or invalid"
        return 1
    fi

    # [REQ:DM-P0-034] Check for required packagers
    if [[ "$validate_only" == "true" ]]; then
        local tiers=$(echo "$validation" | jq -r '.tiers[]' 2>/dev/null || echo "")
        local warnings=()

        for tier in $tiers; do
            local tier_name=""
            case "$tier" in
                1) tier_name="local" ;;
                2) tier_name="desktop" ;;
                3) tier_name="mobile" ;;
                4) tier_name="saas" ;;
                5) tier_name="enterprise" ;;
            esac

            # Check if packager exists
            local packager_check=$(vrooli scenario status "scenario-to-$tier_name" 2>&1 || echo "not found")
            if [[ "$packager_check" =~ "not found" ]] || [[ "$packager_check" =~ "No scenario" ]]; then
                warnings+=("⚠️  Missing packager: scenario-to-$tier_name (required for tier $tier)")
            fi
        done

        if [[ ${#warnings[@]} -gt 0 ]]; then
            echo -e "${YELLOW}Validation warnings:${NC}"
            for warning in "${warnings[@]}"; do
                echo "  $warning"
            done
            return 0
        else
            echo -e "${GREEN}✓${NC} All required packagers are available"
            return 0
        fi
    fi

    echo -e "${BLUE}Deploying profile '$profile_id'...${NC}"
    response=$(curl -s -X POST -H 'Content-Type: application/json' "${API_BASE}/api/v1/deploy/$profile_id" || true)
    if [[ -z "$response" ]]; then
        echo -e "${RED}✗${NC} Failed to deploy profile"
        return 1
    fi

    echo "$response" | jq '.' 2>/dev/null || echo "$response"
}

cmd_logs() {
    local profile_id="${1:-}"
    shift || true

    local level=""
    local search=""

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --level)
                level="$2"
                shift 2
                ;;
            --search)
                search="$2"
                shift 2
                ;;
            --format)
                OUTPUT_FORMAT="$2"
                shift 2
                ;;
            *)
                shift
                ;;
        esac
    done

    if [[ -z "$profile_id" ]]; then
        log_error "Profile ID is required"
        echo "Usage: $CLI_NAME logs <profile_id> [--level <level>] [--search <term>]"
        return 1
    fi

    log_info "Fetching logs for profile '$profile_id'..."
    local endpoint="/api/v1/logs/$profile_id"
    if [[ -n "$level" ]]; then
        endpoint="${endpoint}?level=${level}"
    fi
    response=$(api_request GET "$endpoint" || true)
    if [[ -z "$response" ]]; then
        log_error "Failed to fetch logs"
        return 1
    fi
    echo "$response" | jq '.' 2>/dev/null || echo "$response"
}

cmd_deployment() {
    local subcmd="${1:-status}"
    shift || true

    case "$subcmd" in
        status)
            local deployment_id="${1:-}"
            shift || true

            while [[ $# -gt 0 ]]; do
                case "$1" in
                    --format)
                        OUTPUT_FORMAT="$2"
                        shift 2
                        ;;
                    *)
                        shift
                        ;;
                esac
            done

            if [[ -z "$deployment_id" ]]; then
                log_error "Deployment ID is required"
                echo "Usage: $CLI_NAME deployment status <deployment_id> [--format json]"
                return 1
            fi

            log_info "Checking deployment status for '$deployment_id'..."
            response=$(api_request GET "/api/v1/deployments/$deployment_id" || true)
            if [[ -z "$response" ]]; then
                log_error "Failed to get deployment status"
                return 1
            fi
            echo "$response" | jq '.' 2>/dev/null || echo "$response"
            ;;
        *)
            log_error "Unknown deployment subcommand: $subcmd"
            echo "Valid subcommands: status"
            return 1
            ;;
    esac
}

cmd_swaps() {
    local subcmd="${1:-list}"
    shift || true

    case "$subcmd" in
        list)
            local scenario="${1:-}"
            shift || true

            while [[ $# -gt 0 ]]; do
                case "$1" in
                    --format)
                        OUTPUT_FORMAT="$2"
                        shift 2
                        ;;
                    *)
                        shift
                        ;;
                esac
            done

            if [[ -z "$scenario" ]]; then
                log_error "Scenario name is required"
                echo "Usage: $CLI_NAME swaps list <scenario> [--format json]"
                return 1
            fi
            log_info "Fetching swap suggestions for '$scenario'..."
            response=$(api_request GET "/api/v1/swaps/suggest/$scenario" || true)
            if [[ -z "$response" ]]; then
                log_error "Failed to fetch swap suggestions"
                return 1
            fi
            echo "$response" | jq '.' 2>/dev/null || echo "$response"
            ;;
        analyze)
            local from="${1:-}"
            local to="${2:-}"
            shift 2 || true

            while [[ $# -gt 0 ]]; do
                case "$1" in
                    --format)
                        OUTPUT_FORMAT="$2"
                        shift 2
                        ;;
                    *)
                        shift
                        ;;
                esac
            done

            if [[ -z "$from" ]] || [[ -z "$to" ]]; then
                log_error "Both 'from' and 'to' dependencies are required"
                echo "Usage: $CLI_NAME swaps analyze <from> <to> [--format json]"
                return 1
            fi
            log_info "Analyzing swap impact: $from -> $to..."
            response=$(api_request GET "/api/v1/swaps/analyze/$from/$to" || true)
            if [[ -z "$response" ]]; then
                log_error "Failed to analyze swap impact"
                return 1
            fi
            echo "$response" | jq '.' 2>/dev/null || echo "$response"
            ;;
        cascade)
            local from="${1:-}"
            local to="${2:-}"
            shift 2 || true

            while [[ $# -gt 0 ]]; do
                case "$1" in
                    --format)
                        OUTPUT_FORMAT="$2"
                        shift 2
                        ;;
                    *)
                        shift
                        ;;
                esac
            done

            if [[ -z "$from" ]] || [[ -z "$to" ]]; then
                log_error "Both 'from' and 'to' dependencies are required"
                echo "Usage: $CLI_NAME swaps cascade <from> <to> [--format json]"
                return 1
            fi
            log_info "Checking cascade impact: $from -> $to..."
            response=$(api_request GET "/api/v1/swaps/cascade/$from/$to" || true)
            if [[ -z "$response" ]]; then
                log_error "Failed to check cascade impact"
                return 1
            fi
            echo "$response" | jq '.' 2>/dev/null || echo "$response"
            ;;
        info)
            local swap_id="${1:-}"
            shift || true

            while [[ $# -gt 0 ]]; do
                case "$1" in
                    --format)
                        OUTPUT_FORMAT="$2"
                        shift 2
                        ;;
                    *)
                        shift
                        ;;
                esac
            done

            if [[ -z "$swap_id" ]]; then
                log_error "Swap ID is required"
                echo "Usage: $CLI_NAME swaps info <swap_id> [--format json]"
                return 1
            fi
            log_info "Fetching swap details for '$swap_id'..."
            response=$(api_request GET "/api/v1/swaps/$swap_id" || true)
            if [[ -z "$response" ]]; then
                log_error "Failed to fetch swap details"
                return 1
            fi
            echo "$response" | jq '.' 2>/dev/null || echo "$response"
            ;;
        apply)
            local profile_id="${1:-}"
            local from="${2:-}"
            local to="${3:-}"
            shift 3 || true
            local show_fitness=false

            while [[ $# -gt 0 ]]; do
                case "$1" in
                    --show-fitness)
                        show_fitness=true
                        shift
                        ;;
                    --format)
                        OUTPUT_FORMAT="$2"
                        shift 2
                        ;;
                    *)
                        shift
                        ;;
                esac
            done

            if [[ -z "$profile_id" ]] || [[ -z "$from" ]] || [[ -z "$to" ]]; then
                log_error "Profile ID, from, and to dependencies are required"
                echo "Usage: $CLI_NAME swaps apply <profile_id> <from> <to> [--show-fitness] [--format json]"
                return 1
            fi

            # Add swap to profile using profile swap add command
            log_info "Applying swap: $from -> $to to profile '$profile_id'..."
            swap_response=$(curl -s -X POST -H 'Content-Type: application/json' \
                -d "{\"from\": \"$from\", \"to\": \"$to\"}" \
                "${API_BASE}/api/v1/profiles/$profile_id/swaps" || true)

            if [[ -z "$swap_response" ]]; then
                log_error "Failed to apply swap"
                return 1
            fi

            if [[ "$show_fitness" == "true" ]]; then
                # Get updated profile with fitness scores
                profile_response=$(api_request GET "/api/v1/profiles/$profile_id" || true)
                if [[ -n "$profile_response" ]]; then
                    echo "$profile_response" | jq '{message: "Swap applied successfully", fitness: .fitness, updated: true}' 2>/dev/null || echo "Swap applied, fitness scores updated"
                else
                    echo "Swap applied successfully"
                fi
            else
                echo "$swap_response" | jq '.' 2>/dev/null || echo "Swap applied successfully"
            fi
            ;;
        --help|-h)
            cat <<'EOF'
Swap Commands:
    swaps list <scenario>           List swap suggestions for scenario
    swaps analyze <from> <to>       Analyze swap impact (fitness delta)
    swaps cascade <from> <to>       Check cascade impact of swap
    swaps info <swap_id>            Get detailed swap information
    swaps apply <profile> <from> <to> [--show-fitness]  Apply swap to profile
EOF
            ;;
        *)
            log_error "Unknown swaps subcommand: $subcmd"
            echo "Valid subcommands: list, analyze, cascade, info, apply"
            return 1
            ;;
    esac
}

cmd_packagers() {
    local subcmd="${1:-list}"
    shift || true

    case "$subcmd" in
        list)
            while [[ $# -gt 0 ]]; do
                case "$1" in
                    --format)
                        OUTPUT_FORMAT="$2"
                        shift 2
                        ;;
                    *)
                        shift
                        ;;
                esac
            done

            log_info "Listing available packagers..."
            response=$(api_request GET "/api/v1/packagers" || true)
            if [[ -z "$response" ]]; then
                log_error "Failed to list packagers"
                return 1
            fi
            echo "$response" | jq '.' 2>/dev/null || echo "$response"
            ;;
        discover)
            while [[ $# -gt 0 ]]; do
                case "$1" in
                    --format)
                        OUTPUT_FORMAT="$2"
                        shift 2
                        ;;
                    *)
                        shift
                        ;;
                esac
            done

            log_info "Discovering packagers..."
            response=$(curl -s -X POST -H 'Content-Type: application/json' "${API_BASE}/api/v1/packagers/discover" || true)
            if [[ -z "$response" ]]; then
                log_error "Failed to discover packagers"
                return 1
            fi
            echo "$response" | jq '.' 2>/dev/null || echo "$response"
            ;;
        --help|-h)
            cat <<'EOF'
Packager Commands:
    packagers list       List available packagers (scenario-to-*)
    packagers discover   Discover installed packagers
EOF
            ;;
        *)
            log_error "Unknown packagers subcommand: $subcmd"
            echo "Valid subcommands: list, discover"
            return 1
            ;;
    esac
}

cmd_package() {
    local profile_id="${1:-}"
    shift || true

    local packager=""
    local dry_run=false

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --packager)
                packager="$2"
                shift 2
                ;;
            --dry-run)
                dry_run=true
                shift
                ;;
            --format)
                OUTPUT_FORMAT="$2"
                shift 2
                ;;
            *)
                shift
                ;;
        esac
    done

    if [[ -z "$profile_id" ]]; then
        log_error "Profile ID is required"
        echo "Usage: $CLI_NAME package <profile_id> --packager <name> [--dry-run] [--format json]"
        return 1
    fi

    if [[ -z "$packager" ]]; then
        log_error "--packager is required"
        return 1
    fi

    log_info "Packaging profile '$profile_id' with '$packager'..."
    local payload=$(jq -n --arg p "$packager" --argjson d "$dry_run" '{packager: $p, dry_run: $d}')
    response=$(curl -s -X POST -H 'Content-Type: application/json' -d "$payload" "${API_BASE}/api/v1/package/$profile_id" || true)

    if [[ -z "$response" ]]; then
        log_error "Failed to package profile"
        return 1
    fi
    echo "$response" | jq '.' 2>/dev/null || echo "$response"
}

cmd_validate() {
    local profile_id="${1:-}"
    shift || true

    local format="text"
    local verbose=false
    local color=false

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --format)
                format="$2"
                shift 2
                ;;
            --verbose)
                verbose=true
                shift
                ;;
            --color)
                color=true
                shift
                ;;
            *)
                shift
                ;;
        esac
    done

    if [[ -z "$profile_id" ]]; then
        log_error "Profile ID is required"
        echo "Usage: $CLI_NAME validate <profile_id> [--format json|text] [--verbose] [--color]"
        return 1
    fi

    log_info "Validating deployment profile '$profile_id'..."

    # Call validation API endpoint
    local endpoint="/api/v1/profiles/$profile_id/validate"
    if [[ "$verbose" == true ]]; then
        endpoint="${endpoint}?verbose=true"
    fi

    response=$(api_request GET "$endpoint" || true)

    # Check if profile not found (empty response or error in JSON)
    if [[ -z "$response" ]] || echo "$response" | jq -e '.error' >/dev/null 2>&1; then
        # Profile not found - provide remediation
        log_error "Profile '$profile_id' not found"
        if [[ "$format" == "json" ]]; then
            echo '{"error": "profile not found", "remediation": {"steps": ["Create profile with: deployment-manager profile create <name> <scenario> --tier <tier>", "Verify profile exists with: deployment-manager profiles list"]}}'
        else
            echo ""
            echo "Remediation steps:"
            echo "  1. Create profile with: deployment-manager profile create <name> <scenario> --tier <tier>"
            echo "  2. Verify profile exists with: deployment-manager profiles list"
        fi
        return 1
    fi

    # Output based on format
    if [[ "$format" == "json" ]]; then
        echo "$response" | jq '.' 2>/dev/null || echo "$response"
    else
        # Parse and display human-readable output
        local status=$(echo "$response" | jq -r '.status // "unknown"' 2>/dev/null || echo "unknown")
        local checks=$(echo "$response" | jq -r '.checks // []' 2>/dev/null || echo "[]")

        echo ""
        echo "Validation Results:"
        echo "==================="

        # Display each check with status
        echo "$response" | jq -r '.checks[]? | "  [\(.status | ascii_upcase)] \(.name): \(.message // "OK")"' 2>/dev/null || echo "  No checks available"

        if [[ "$verbose" == true ]]; then
            echo ""
            echo "Remediation Steps:"
            echo "$response" | jq -r '.checks[]? | select(.status == "fail") | "  \(.name):\n    - \(.remediation.steps[]?)"' 2>/dev/null || echo "  No failed checks"
        fi

        echo ""
        echo "Overall Status: $status"
    fi
}

cmd_estimate_cost() {
    local profile_id="${1:-}"
    shift || true

    local verbose=false

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --format)
                OUTPUT_FORMAT="$2"
                shift 2
                ;;
            --verbose)
                verbose=true
                shift
                ;;
            --help)
                echo "Cost Estimation: Estimates monthly costs for SaaS/Enterprise tiers"
                echo "Accuracy: ±20% based on industry averages"
                echo ""
                echo "Usage: $CLI_NAME estimate-cost <profile_id> [--verbose] [--format json]"
                return 0
                ;;
            *)
                shift
                ;;
        esac
    done

    if [[ -z "$profile_id" ]]; then
        log_error "Profile ID is required"
        echo "Usage: $CLI_NAME estimate-cost <profile_id> [--verbose] [--format json]"
        return 1
    fi

    log_info "Estimating costs for profile '$profile_id'..."

    local endpoint="/api/v1/profiles/$profile_id/cost-estimate"
    if [[ "$verbose" == true ]]; then
        endpoint="${endpoint}?verbose=true"
    fi

    response=$(api_request GET "$endpoint" || true)

    if [[ -z "$response" ]]; then
        log_error "Failed to estimate costs"
        return 1
    fi

    echo "$response" | jq '.' 2>/dev/null || echo "$response"
}

cmd_secrets() {
    local subcmd="${1:-help}"
    shift || true

    case "$subcmd" in
        identify)
            local profile_id="${1:-}"
            shift || true

            local format="text"

            while [[ $# -gt 0 ]]; do
                case "$1" in
                    --format)
                        format="$2"
                        shift 2
                        ;;
                    *)
                        shift
                        ;;
                esac
            done

            if [[ -z "$profile_id" ]]; then
                log_error "Profile ID is required"
                echo "Usage: $CLI_NAME secrets identify <profile_id> [--format json]"
                return 1
            fi

            log_info "Identifying secrets for profile '$profile_id'..."
            response=$(api_request GET "/api/v1/profiles/$profile_id/secrets" || true)

            if [[ -z "$response" ]]; then
                log_error "Failed to identify secrets"
                return 1
            fi

            echo "$response" | jq '.' 2>/dev/null || echo "$response"
            ;;
        template)
            local profile_id="${1:-}"
            shift || true

            local format="env"

            while [[ $# -gt 0 ]]; do
                case "$1" in
                    --format)
                        format="$2"
                        shift 2
                        ;;
                    *)
                        shift
                        ;;
                esac
            done

            if [[ -z "$profile_id" ]]; then
                log_error "Profile ID is required"
                echo "Usage: $CLI_NAME secrets template <profile_id> [--format env|vault|aws]"
                return 1
            fi

            log_info "Generating secret template for profile '$profile_id' (format: $format)..."
            response=$(api_request GET "/api/v1/profiles/$profile_id/secrets/template?format=$format" || true)

            if [[ -z "$response" ]]; then
                log_error "Failed to generate template"
                return 1
            fi

            # If format is env, display raw template; otherwise show JSON
            if [[ "$format" == "env" ]]; then
                echo "$response" | jq -r '.template // .content // .' 2>/dev/null || echo "$response"
            else
                echo "$response" | jq '.' 2>/dev/null || echo "$response"
            fi
            ;;
        validate)
            local profile_id="${1:-}"
            shift || true

            while [[ $# -gt 0 ]]; do
                case "$1" in
                    --format)
                        OUTPUT_FORMAT="$2"
                        shift 2
                        ;;
                    *)
                        shift
                        ;;
                esac
            done

            if [[ -z "$profile_id" ]]; then
                log_error "Profile ID is required"
                echo "Usage: $CLI_NAME secrets validate <profile_id> [--format json]"
                return 1
            fi

            log_info "Validating secrets for profile '$profile_id'..."
            response=$(api_request POST "/api/v1/profiles/$profile_id/secrets/validate" || true)

            if [[ -z "$response" ]]; then
                log_error "Failed to validate secrets"
                return 1
            fi

            echo "$response" | jq '.' 2>/dev/null || echo "$response"
            ;;
        --help|-h|help)
            cat <<'EOF'
Secret Management Commands:
    secrets identify <profile_id>              Identify all required secrets
    secrets template <profile_id>              Generate secret template (.env/vault/aws)
                     [--format env|vault|aws]
    secrets validate <profile_id>              Test secret connectivity

Examples:
    deployment-manager secrets identify my-profile --format json
    deployment-manager secrets template my-profile --format env
    deployment-manager secrets template my-profile --format vault
EOF
            ;;
        *)
            log_error "Unknown secrets subcommand: $subcmd"
            echo "Valid subcommands: identify, template, validate"
            echo "Run '$CLI_NAME secrets --help' for more information"
            return 1
            ;;
    esac
}

cmd_help() {
    cat <<'EOF'
deployment-manager - Command-line interface for Deployment Manager

Usage: deployment-manager <command> [args]

Commands:
    status                                    Check API and dependency health
    analyze <scenario> [--format json]        Analyze scenario dependencies
    fitness <scenario> [--tier <n>]           Calculate platform fitness scores

    profiles list [--format json]             List all deployment profiles
    profile create <name> --scenario <s> ...  Create new deployment profile
    profile show <id> [--format json]         Show profile details
    profile delete <id> [--format json]       Delete a profile
    profile list [--format json]              List all profiles
    profile update <id> [--tier <tier>]       Update profile settings
    profile save <id>                         Save profile changes
    profile swap <id> add <from> <to>         Add dependency swap to profile
    profile set <id> <key> <value>            Update profile setting
    profile export <id> [--format json]       Export profile to JSON
    profile import <file> [--name <name>]     Import profile from JSON
    profile versions <id> [--format json]     Show version history

    swaps list <scenario> [--format json]     List swap suggestions
    swaps analyze <from> <to>                 Analyze swap impact
    swaps cascade <from> <to>                 Check cascade effects
    swaps info <swap_id>                      Get swap details
    swaps apply <profile> <from> <to> [--show-fitness]  Apply swap to profile

    validate <profile_id> [--format json]     Validate deployment profile
    estimate-cost <profile_id> [--verbose]    Estimate monthly costs for profile

    secrets identify <profile_id>             Identify required secrets
    secrets template <profile_id>             Generate secret template
    secrets validate <profile_id>             Test secret connectivity

    packagers list [--format json]            List available packagers
    packagers discover [--format json]        Discover packagers
    package <profile_id> --packager <name>    Package a profile

    deploy <profile_id>                       Deploy a profile
    deployment status <id> [--format json]    Check deployment status

    configure [key] [value]                   View or update CLI configuration
    version                                   Show CLI version
    help                                      Show this help message

Note: Add --format json to any command for machine-readable output
EOF
}

main() {
    init_config
    load_config

    local command="${1:-help}"
    shift || true

    local env_prefix="$(echo "$CLI_NAME" | tr '[:lower:]' '[:upper:]' | tr -c 'A-Z0-9' '_')"
    local env_api_base_var="${env_prefix}_API_BASE"
    local env_api_token_var="${env_prefix}_API_TOKEN"

    local env_api_base="${!env_api_base_var:-}"
    local env_api_token="${!env_api_token_var:-}"

    if [[ -n "$env_api_token" ]]; then
        API_TOKEN="$env_api_token"
    fi

    if [[ -n "$env_api_base" ]]; then
        API_BASE="${env_api_base%/}"
    fi

    # Commands that require API_BASE (all except configure, version, help)
    case "$command" in
        configure|config|version|--version|-v|help|--help|-h)
            # These commands don't need API_BASE
            ;;
        *)
            # All other commands require API_BASE
            if [[ -z "$API_BASE" ]]; then
                if ! API_BASE=$(resolve_api_base "$CONFIG_API_BASE"); then
                    echo -e "${RED}✗${NC} Unable to determine API base URL. Ensure the scenario is running via 'vrooli scenario run $SCENARIO_ID' or configure it with '$CLI_NAME configure api_base <url>'."
                    exit 1
                fi
            fi
            ;;
    esac

    case "$command" in
        status)
            cmd_status
            ;;
        analyze)
            cmd_analyze "$@"
            ;;
        fitness)
            cmd_fitness "$@"
            ;;
        profiles)
            cmd_profiles "$@"
            ;;
        profile)
            cmd_profile "$@"
            ;;
        swaps)
            cmd_swaps "$@"
            ;;
        packagers)
            cmd_packagers "$@"
            ;;
        package)
            cmd_package "$@"
            ;;
        deploy)
            cmd_deploy "$@"
            ;;
        logs)
            cmd_logs "$@"
            ;;
        deployment)
            cmd_deployment "$@"
            ;;
        validate)
            cmd_validate "$@"
            ;;
        estimate-cost)
            cmd_estimate_cost "$@"
            ;;
        secrets)
            cmd_secrets "$@"
            ;;
        configure|config)
            cmd_configure "$@"
            ;;
        version|--version|-v)
            cmd_version
            ;;
        help|--help|-h)
            cmd_help
            ;;
        *)
            log_error "Unknown command: $command"
            echo "Run '$CLI_NAME help' for usage information"
            exit 1
            ;;
    esac
}

main "$@"
