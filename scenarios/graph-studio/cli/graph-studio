#!/bin/bash
################################################################################
# Graph Studio CLI - Thin Wrapper Version
# 
# A lightweight CLI that delegates all logic to the scenario's API.
# Port discovery uses ultra-fast file-based lookup.
################################################################################

set -e

# Configuration
SCENARIO_NAME="graph-studio"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
PURPLE='\033[0;35m'
NC='\033[0m' # No Color

################################################################################
# Port Discovery - Ultra-fast file-based lookup
################################################################################
get_api_url() {
    # Use the new ultra-fast port command
    local api_port
    api_port=$(vrooli scenario port "${SCENARIO_NAME}" API_PORT 2>/dev/null)
    
    if [[ -z "$api_port" ]]; then
        echo -e "${RED}‚ùå Error: ${SCENARIO_NAME} is not running${NC}" >&2
        echo "   Start it with: vrooli scenario run ${SCENARIO_NAME}" >&2
        exit 1
    fi
    
    echo "http://localhost:${api_port}"
}

################################################################################
# Helper Functions
################################################################################
usage() {
    echo -e "${CYAN}Graph Studio CLI v2.0.0${NC}"
    echo "Unified interface for graph operations and visualization"
    echo ""
    echo "Usage: graph-studio [COMMAND] [OPTIONS]"
    echo ""
    echo "Commands:"
    echo -e "  ${GREEN}list${NC}         List graphs or plugins"
    echo -e "  ${GREEN}create${NC}       Create new graph"
    echo -e "  ${GREEN}get${NC}          Get specific graph details"
    echo -e "  ${GREEN}update${NC}       Update existing graph"
    echo -e "  ${GREEN}delete${NC}       Delete graph"
    echo -e "  ${GREEN}validate${NC}     Validate graph structure"
    echo -e "  ${GREEN}convert${NC}      Convert graph to another format"
    echo -e "  ${GREEN}render${NC}       Render graph as image (SVG/PNG/HTML)"
    echo -e "  ${GREEN}plugins${NC}      List available plugins"
    echo -e "  ${GREEN}status${NC}       Show operational status"
    echo -e "  ${GREEN}health${NC}       Check service health"
    echo ""
    echo "Graph Types:"
    echo "  mind-maps        Hierarchical thought organization and brainstorming"
    echo "  network-graphs   Relationship and connection modeling"
    echo "  bpmn            Business Process Model and Notation"
    echo "  mermaid         Text-based diagramming and charting"
    echo ""
    echo "Examples:"
    echo "  graph-studio list                      # List all graphs"
    echo "  graph-studio list mind-maps            # List mind map graphs"
    echo "  graph-studio create \"Project\" bpmn     # Create BPMN diagram"
    echo "  graph-studio validate abc-123          # Validate graph"
    echo "  graph-studio convert abc-123 mermaid   # Convert to Mermaid"
    echo "  graph-studio render abc-123 svg        # Render as SVG"
    echo ""
    echo "Options:"
    echo "  --help, -h       Show help for any command"
    echo "  --json           Output in JSON format (most commands)"
    echo "  --verbose        Show detailed output"
    echo ""
    echo "For more information: graph-studio <command> --help"
}

# Format JSON output if jq is available
format_json() {
    if command -v jq >/dev/null 2>&1; then
        jq .
    else
        cat
    fi
}

# Make API request
api_request() {
    local method="$1"
    local endpoint="$2"
    local data="${3:-}"
    local expected_status="${4:-200}"
    local api_url
    
    # Get the current API URL
    api_url=$(get_api_url)
    
    local curl_args=(-s -w "%{http_code}")
    
    if [[ "$method" != "GET" ]]; then
        curl_args+=(-X "$method")
    fi
    
    if [[ -n "$data" ]]; then
        curl_args+=(-H "Content-Type: application/json" -d "$data")
    fi
    
    local response
    response=$(curl "${curl_args[@]}" "${api_url}${endpoint}")
    
    local http_code="${response: -3}"
    local body="${response%???}"
    
    if [[ "$http_code" != "$expected_status" ]]; then
        echo -e "${RED}‚ùå API call failed: HTTP $http_code${NC}" >&2
        if command -v jq >/dev/null 2>&1 && echo "$body" | jq . >/dev/null 2>&1; then
            echo "$body" | jq . >&2
        else
            echo "$body" >&2
        fi
        return 1
    fi
    
    echo "$body"
}

################################################################################
# Command Implementations - All delegated to API
################################################################################

# List graphs command
cmd_list() {
    local graph_type=""
    local json_output=false
    local limit="50"
    local offset="0"
    
    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case $1 in
            --type)
                graph_type="$2"
                shift 2
                ;;
            --limit)
                limit="$2"
                shift 2
                ;;
            --offset)
                offset="$2"
                shift 2
                ;;
            --json)
                json_output=true
                shift
                ;;
            --help|-h)
                echo "Usage: graph-studio list [OPTIONS]"
                echo ""
                echo "List graphs with optional filtering"
                echo ""
                echo "Options:"
                echo "  --type <type>    Filter by graph type"
                echo "  --limit <num>    Maximum results to return (default: 50)"
                echo "  --offset <num>   Offset for pagination (default: 0)"
                echo "  --json           Output in JSON format"
                echo ""
                echo "Graph Types:"
                echo "  mind-maps, network-graphs, bpmn, mermaid"
                echo ""
                echo "Examples:"
                echo "  graph-studio list"
                echo "  graph-studio list --type mind-maps"
                echo "  graph-studio list --limit 10 --offset 20"
                return 0
                ;;
            -*)
                echo -e "${RED}‚ùå Unknown option: $1${NC}" >&2
                return 1
                ;;
            *)
                if [[ -z "$graph_type" ]]; then
                    graph_type="$1"
                fi
                shift
                ;;
        esac
    done
    
    echo -e "${BLUE}üìã Fetching graphs...${NC}"
    
    # Build query parameters
    local query_params=""
    [[ -n "$graph_type" ]] && query_params="${query_params:+$query_params&}type=$graph_type"
    [[ "$limit" != "50" ]] && query_params="${query_params:+$query_params&}limit=$limit"
    [[ "$offset" != "0" ]] && query_params="${query_params:+$query_params&}offset=$offset"
    
    local endpoint="/api/v1/graphs"
    [[ -n "$query_params" ]] && endpoint="${endpoint}?${query_params}"
    
    local response
    response=$(api_request "GET" "$endpoint" "" "200")
    
    if [[ $? -ne 0 ]]; then
        return 1
    fi
    
    if [[ $json_output == true ]]; then
        echo "$response" | format_json
    else
        if command -v jq >/dev/null 2>&1; then
            local total
            total=$(echo "$response" | jq -r '.total // 0')
            
            echo -e "${GREEN}‚úÖ Found $total graphs${NC}"
            [[ -n "$graph_type" ]] && echo "   Filtered by type: $graph_type"
            
            if [[ $total -gt 0 ]]; then
                echo ""
                printf "%-36s %-20s %-12s %-20s\n" "ID" "NAME" "TYPE" "UPDATED"
                printf "%-36s %-20s %-12s %-20s\n" "----" "----" "----" "-------"
                echo "$response" | jq -r '.graphs[] | "\(.id) \(.name) \(.type) \(.updated_at)"' | 
                while read -r id name type updated; do
                    # Truncate long names
                    if [[ ${#name} -gt 20 ]]; then
                        name="${name:0:17}..."
                    fi
                    printf "%-36s %-20s %-12s %-20s\n" "$id" "$name" "$type" "${updated:0:19}"
                done
            fi
        else
            echo "$response" | format_json
        fi
    fi
}

# Create graph command
cmd_create() {
    local name=""
    local graph_type=""
    local description=""
    local json_output=false
    
    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case $1 in
            --description)
                description="$2"
                shift 2
                ;;
            --json)
                json_output=true
                shift
                ;;
            --help|-h)
                echo "Usage: graph-studio create <name> <type> [OPTIONS]"
                echo ""
                echo "Create new graph"
                echo ""
                echo "Options:"
                echo "  --description <desc>  Graph description"
                echo "  --json                Output in JSON format"
                echo ""
                echo "Graph Types:"
                echo "  mind-maps        Hierarchical thought organization"
                echo "  network-graphs   Relationship and connection modeling"
                echo "  bpmn            Business Process Model and Notation"
                echo "  mermaid         Text-based diagramming"
                echo ""
                echo "Examples:"
                echo "  graph-studio create \"Project Plan\" bpmn"
                echo "  graph-studio create \"Ideas\" mind-maps --description \"Project brainstorming\""
                return 0
                ;;
            -*)
                echo -e "${RED}‚ùå Unknown option: $1${NC}" >&2
                return 1
                ;;
            *)
                if [[ -z "$name" ]]; then
                    name="$1"
                elif [[ -z "$graph_type" ]]; then
                    graph_type="$1"
                fi
                shift
                ;;
        esac
    done
    
    if [[ -z "$name" || -z "$graph_type" ]]; then
        echo -e "${RED}‚ùå Error: Graph name and type required${NC}" >&2
        echo "   Usage: graph-studio create <name> <type> [options]" >&2
        return 1
    fi
    
    # Validate graph type
    case $graph_type in
        mind-maps|network-graphs|bpmn|mermaid)
            ;;
        *)
            echo -e "${RED}‚ùå Error: Invalid graph type: $graph_type${NC}" >&2
            echo "   Valid types: mind-maps, network-graphs, bpmn, mermaid" >&2
            return 1
            ;;
    esac
    
    echo -e "${BLUE}üìù Creating graph: $name${NC}"
    
    # Build request JSON
    local request_body=$(cat <<EOF
{
    "name": "$name",
    "type": "$graph_type",
    "description": "$description"
}
EOF
)
    
    local response
    response=$(api_request "POST" "/api/v1/graphs" "$request_body" "201")
    
    if [[ $? -ne 0 ]]; then
        return 1
    fi
    
    if [[ $json_output == true ]]; then
        echo "$response" | format_json
    else
        if command -v jq >/dev/null 2>&1; then
            local graph_id
            graph_id=$(echo "$response" | jq -r '.id')
            
            echo -e "${GREEN}‚úÖ Graph created successfully!${NC}"
            echo "  Name: $name"
            echo "  Type: $graph_type"
            echo "  ID: $graph_id"
            [[ -n "$description" ]] && echo "  Description: $description"
            echo ""
            echo -e "${CYAN}üí° Next steps:${NC}"
            echo "  ‚Ä¢ View: graph-studio get $graph_id"
            echo "  ‚Ä¢ Edit: Use the web interface or API"
            echo "  ‚Ä¢ Render: graph-studio render $graph_id svg"
        else
            echo -e "${GREEN}‚úÖ Graph created successfully!${NC}"
            echo "$response" | format_json
        fi
    fi
}

# Get graph command
cmd_get() {
    local graph_id=""
    local json_output=false
    
    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case $1 in
            --json)
                json_output=true
                shift
                ;;
            --help|-h)
                echo "Usage: graph-studio get <graph_id> [OPTIONS]"
                echo ""
                echo "Get specific graph details"
                echo ""
                echo "Options:"
                echo "  --json    Output in JSON format"
                echo ""
                echo "Examples:"
                echo "  graph-studio get abc-123"
                return 0
                ;;
            -*)
                echo -e "${RED}‚ùå Unknown option: $1${NC}" >&2
                return 1
                ;;
            *)
                if [[ -z "$graph_id" ]]; then
                    graph_id="$1"
                fi
                shift
                ;;
        esac
    done
    
    if [[ -z "$graph_id" ]]; then
        echo -e "${RED}‚ùå Error: Graph ID required${NC}" >&2
        echo "   Usage: graph-studio get <graph_id>" >&2
        return 1
    fi
    
    echo -e "${BLUE}üìÑ Fetching graph: $graph_id${NC}"
    
    local response
    response=$(api_request "GET" "/api/v1/graphs/$graph_id" "" "200")
    
    if [[ $? -ne 0 ]]; then
        return 1
    fi
    
    if [[ $json_output == true ]]; then
        echo "$response" | format_json
    else
        if command -v jq >/dev/null 2>&1; then
            echo -e "${GREEN}‚úÖ Graph Details:${NC}"
            echo ""
            echo "$response" | jq -r '
                "Name: \(.name)",
                "Type: \(.type)",
                "Description: \(.description // "No description")",
                "Version: \(.version)",
                "Created by: \(.created_by)",
                "Created: \(.created_at)",
                "Updated: \(.updated_at)",
                "Tags: \(if .tags and (.tags | length) > 0 then (.tags | join(", ")) else "None" end)"
            ' 2>/dev/null
        else
            echo "$response" | format_json
        fi
    fi
}

# Update graph command
cmd_update() {
    local graph_id=""
    local name=""
    local description=""
    local json_output=false
    local has_updates=false
    
    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case $1 in
            --name)
                name="$2"
                has_updates=true
                shift 2
                ;;
            --description)
                description="$2"
                has_updates=true
                shift 2
                ;;
            --json)
                json_output=true
                shift
                ;;
            --help|-h)
                echo "Usage: graph-studio update <graph_id> [OPTIONS]"
                echo ""
                echo "Update existing graph"
                echo ""
                echo "Options:"
                echo "  --name <name>         Update graph name"
                echo "  --description <desc>  Update description"
                echo "  --json                Output in JSON format"
                echo ""
                echo "Examples:"
                echo "  graph-studio update abc-123 --name \"New Name\""
                echo "  graph-studio update abc-123 --description \"Updated description\""
                return 0
                ;;
            -*)
                echo -e "${RED}‚ùå Unknown option: $1${NC}" >&2
                return 1
                ;;
            *)
                if [[ -z "$graph_id" ]]; then
                    graph_id="$1"
                fi
                shift
                ;;
        esac
    done
    
    if [[ -z "$graph_id" ]]; then
        echo -e "${RED}‚ùå Error: Graph ID required${NC}" >&2
        echo "   Usage: graph-studio update <graph_id> [options]" >&2
        return 1
    fi
    
    if [[ "$has_updates" == false ]]; then
        echo -e "${RED}‚ùå Error: No updates specified${NC}" >&2
        echo "   Use --name or --description to update graph" >&2
        return 1
    fi
    
    echo -e "${BLUE}üìù Updating graph: $graph_id${NC}"
    
    # Build update JSON
    local updates="{}"
    
    if [[ -n "$name" ]]; then
        updates=$(echo "$updates" | jq --arg val "$name" '. + {name: $val}')
    fi
    
    if [[ -n "$description" ]]; then
        updates=$(echo "$updates" | jq --arg val "$description" '. + {description: $val}')
    fi
    
    local response
    response=$(api_request "PUT" "/api/v1/graphs/$graph_id" "$updates" "200")
    
    if [[ $? -ne 0 ]]; then
        return 1
    fi
    
    if [[ $json_output == true ]]; then
        echo "$response" | format_json
    else
        echo -e "${GREEN}‚úÖ Graph updated successfully!${NC}"
        [[ -n "$name" ]] && echo "   Name: $name"
        [[ -n "$description" ]] && echo "   Description: $description"
    fi
}

# Delete graph command
cmd_delete() {
    local graph_id=""
    local json_output=false
    
    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case $1 in
            --json)
                json_output=true
                shift
                ;;
            --help|-h)
                echo "Usage: graph-studio delete <graph_id> [OPTIONS]"
                echo ""
                echo "Delete graph (with confirmation)"
                echo ""
                echo "Options:"
                echo "  --json    Output in JSON format"
                echo ""
                echo "Examples:"
                echo "  graph-studio delete abc-123"
                return 0
                ;;
            -*)
                echo -e "${RED}‚ùå Unknown option: $1${NC}" >&2
                return 1
                ;;
            *)
                if [[ -z "$graph_id" ]]; then
                    graph_id="$1"
                fi
                shift
                ;;
        esac
    done
    
    if [[ -z "$graph_id" ]]; then
        echo -e "${RED}‚ùå Error: Graph ID required${NC}" >&2
        echo "   Usage: graph-studio delete <graph_id>" >&2
        return 1
    fi
    
    echo -e "${YELLOW}‚ö†Ô∏è  Are you sure you want to delete graph '$graph_id'? [y/N]${NC}"
    read -r confirm
    if [[ ! "$confirm" =~ ^[Yy]$ ]]; then
        echo "Delete cancelled."
        return 0
    fi
    
    echo -e "${BLUE}üóëÔ∏è  Deleting graph: $graph_id${NC}"
    
    local response
    response=$(api_request "DELETE" "/api/v1/graphs/$graph_id" "" "200")
    
    if [[ $? -ne 0 ]]; then
        return 1
    fi
    
    if [[ $json_output == true ]]; then
        echo "$response" | format_json
    else
        echo -e "${GREEN}‚úÖ Graph deleted successfully!${NC}"
    fi
}

# Validate graph command
cmd_validate() {
    local graph_id=""
    local json_output=false
    
    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case $1 in
            --json)
                json_output=true
                shift
                ;;
            --help|-h)
                echo "Usage: graph-studio validate <graph_id> [OPTIONS]"
                echo ""
                echo "Validate graph structure and content"
                echo ""
                echo "Options:"
                echo "  --json    Output in JSON format"
                echo ""
                echo "Examples:"
                echo "  graph-studio validate abc-123"
                return 0
                ;;
            -*)
                echo -e "${RED}‚ùå Unknown option: $1${NC}" >&2
                return 1
                ;;
            *)
                if [[ -z "$graph_id" ]]; then
                    graph_id="$1"
                fi
                shift
                ;;
        esac
    done
    
    if [[ -z "$graph_id" ]]; then
        echo -e "${RED}‚ùå Error: Graph ID required${NC}" >&2
        echo "   Usage: graph-studio validate <graph_id>" >&2
        return 1
    fi
    
    echo -e "${BLUE}üîç Validating graph: $graph_id${NC}"
    
    local response
    response=$(api_request "POST" "/api/v1/graphs/$graph_id/validate" "" "200")
    
    if [[ $? -ne 0 ]]; then
        return 1
    fi
    
    if [[ $json_output == true ]]; then
        echo "$response" | format_json
    else
        if command -v jq >/dev/null 2>&1; then
            local valid
            valid=$(echo "$response" | jq -r '.valid')
            
            if [[ "$valid" == "true" ]]; then
                echo -e "${GREEN}‚úÖ Graph is valid${NC}"
            else
                echo -e "${YELLOW}‚ö†Ô∏è  Graph validation failed${NC}"
            fi
            
            # Show errors if any
            local errors
            errors=$(echo "$response" | jq -r '.errors[]?' 2>/dev/null)
            if [[ -n "$errors" ]]; then
                echo ""
                echo -e "${RED}Errors:${NC}"
                echo "$errors" | while IFS= read -r line; do
                    echo "  ‚Ä¢ $line"
                done
            fi
            
            # Show warnings if any
            local warnings
            warnings=$(echo "$response" | jq -r '.warnings[]?' 2>/dev/null)
            if [[ -n "$warnings" ]]; then
                echo ""
                echo -e "${YELLOW}Warnings:${NC}"
                echo "$warnings" | while IFS= read -r line; do
                    echo "  ‚Ä¢ $line"
                done
            fi
        else
            echo "$response" | format_json
        fi
    fi
}

# Convert graph command
cmd_convert() {
    local graph_id=""
    local target_format=""
    local json_output=false
    
    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case $1 in
            --json)
                json_output=true
                shift
                ;;
            --help|-h)
                echo "Usage: graph-studio convert <graph_id> <target_format> [OPTIONS]"
                echo ""
                echo "Convert graph to another format"
                echo ""
                echo "Options:"
                echo "  --json    Output in JSON format"
                echo ""
                echo "Supported Conversions:"
                echo "  mind-maps -> mermaid"
                echo "  bpmn -> mermaid"
                echo ""
                echo "Examples:"
                echo "  graph-studio convert abc-123 mermaid"
                return 0
                ;;
            -*)
                echo -e "${RED}‚ùå Unknown option: $1${NC}" >&2
                return 1
                ;;
            *)
                if [[ -z "$graph_id" ]]; then
                    graph_id="$1"
                elif [[ -z "$target_format" ]]; then
                    target_format="$1"
                fi
                shift
                ;;
        esac
    done
    
    if [[ -z "$graph_id" || -z "$target_format" ]]; then
        echo -e "${RED}‚ùå Error: Graph ID and target format required${NC}" >&2
        echo "   Usage: graph-studio convert <graph_id> <target_format>" >&2
        return 1
    fi
    
    echo -e "${BLUE}üîÑ Converting graph: $graph_id${NC}"
    echo "   Target format: $target_format"
    
    # Build request JSON
    local request_body=$(cat <<EOF
{
    "target_format": "$target_format"
}
EOF
)
    
    local response
    response=$(api_request "POST" "/api/v1/graphs/$graph_id/convert" "$request_body" "200")
    
    if [[ $? -ne 0 ]]; then
        return 1
    fi
    
    if [[ $json_output == true ]]; then
        echo "$response" | format_json
    else
        if command -v jq >/dev/null 2>&1; then
            local new_id
            new_id=$(echo "$response" | jq -r '.converted_graph_id')
            
            echo -e "${GREEN}‚úÖ Graph converted successfully!${NC}"
            echo "  Original: $graph_id"
            echo "  New graph ID: $new_id"
            echo "  Format: $target_format"
            echo ""
            echo -e "${CYAN}üí° Next steps:${NC}"
            echo "  ‚Ä¢ View: graph-studio get $new_id"
            echo "  ‚Ä¢ Render: graph-studio render $new_id svg"
        else
            echo -e "${GREEN}‚úÖ Graph converted successfully!${NC}"
            echo "$response" | format_json
        fi
    fi
}

# Render graph command
cmd_render() {
    local graph_id=""
    local format="svg"
    local output_file=""
    
    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case $1 in
            --format)
                format="$2"
                shift 2
                ;;
            --output|-o)
                output_file="$2"
                shift 2
                ;;
            --help|-h)
                echo "Usage: graph-studio render <graph_id> [format] [OPTIONS]"
                echo ""
                echo "Render graph as image or HTML"
                echo ""
                echo "Options:"
                echo "  --format <fmt>     Output format (svg, html, png)"
                echo "  --output <file>    Save output to file"
                echo ""
                echo "Formats:"
                echo "  svg     Scalable Vector Graphics (default)"
                echo "  html    HTML with embedded SVG"
                echo "  png     Portable Network Graphics (saved to file)"
                echo ""
                echo "Examples:"
                echo "  graph-studio render abc-123"
                echo "  graph-studio render abc-123 html"
                echo "  graph-studio render abc-123 --format png --output graph.png"
                return 0
                ;;
            -*)
                echo -e "${RED}‚ùå Unknown option: $1${NC}" >&2
                return 1
                ;;
            *)
                if [[ -z "$graph_id" ]]; then
                    graph_id="$1"
                elif [[ -z "$format" || "$format" == "svg" ]]; then
                    format="$1"
                fi
                shift
                ;;
        esac
    done
    
    if [[ -z "$graph_id" ]]; then
        echo -e "${RED}‚ùå Error: Graph ID required${NC}" >&2
        echo "   Usage: graph-studio render <graph_id> [format]" >&2
        return 1
    fi
    
    # Validate format
    case $format in
        svg|html|png)
            ;;
        *)
            echo -e "${RED}‚ùå Error: Invalid format: $format${NC}" >&2
            echo "   Valid formats: svg, html, png" >&2
            return 1
            ;;
    esac
    
    echo -e "${BLUE}üé® Rendering graph: $graph_id${NC}"
    echo "   Format: $format"
    
    # Build request JSON
    local request_body=$(cat <<EOF
{
    "format": "$format"
}
EOF
)
    
    # Get API URL for direct request
    local api_url
    api_url=$(get_api_url)
    
    if [[ "$format" == "svg" || "$format" == "html" ]]; then
        # For text formats, output directly or save to file
        if [[ -n "$output_file" ]]; then
            curl -s -X POST \
                -H "Content-Type: application/json" \
                -d "$request_body" \
                -o "$output_file" \
                "${api_url}/api/v1/graphs/${graph_id}/render"
            
            if [[ -f "$output_file" ]]; then
                echo -e "${GREEN}‚úÖ Graph rendered and saved to: $output_file${NC}"
            else
                echo -e "${RED}‚ùå Failed to render graph${NC}"
                return 1
            fi
        else
            # Output to stdout
            curl -s -X POST \
                -H "Content-Type: application/json" \
                -d "$request_body" \
                "${api_url}/api/v1/graphs/${graph_id}/render"
        fi
    else
        # For binary formats, always save to file
        local default_output="graph_${graph_id}.${format}"
        local actual_output="${output_file:-$default_output}"
        
        curl -s -X POST \
            -H "Content-Type: application/json" \
            -d "$request_body" \
            -o "$actual_output" \
            "${api_url}/api/v1/graphs/${graph_id}/render"
        
        if [[ -f "$actual_output" ]]; then
            echo -e "${GREEN}‚úÖ Graph rendered and saved to: $actual_output${NC}"
        else
            echo -e "${RED}‚ùå Failed to render graph${NC}"
            return 1
        fi
    fi
}

# List plugins command
cmd_plugins() {
    local category=""
    local json_output=false
    
    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case $1 in
            --category)
                category="$2"
                shift 2
                ;;
            --json)
                json_output=true
                shift
                ;;
            --help|-h)
                echo "Usage: graph-studio plugins [OPTIONS]"
                echo ""
                echo "List available plugins"
                echo ""
                echo "Options:"
                echo "  --category <cat>  Filter by category"
                echo "  --json            Output in JSON format"
                echo ""
                echo "Categories:"
                echo "  visualization, process"
                echo ""
                echo "Examples:"
                echo "  graph-studio plugins"
                echo "  graph-studio plugins --category visualization"
                return 0
                ;;
            -*)
                echo -e "${RED}‚ùå Unknown option: $1${NC}" >&2
                return 1
                ;;
            *)
                if [[ -z "$category" ]]; then
                    category="$1"
                fi
                shift
                ;;
        esac
    done
    
    echo -e "${BLUE}üîå Fetching available plugins...${NC}"
    
    local endpoint="/api/v1/plugins"
    [[ -n "$category" ]] && endpoint="${endpoint}?category=${category}"
    
    local response
    response=$(api_request "GET" "$endpoint" "" "200")
    
    if [[ $? -ne 0 ]]; then
        return 1
    fi
    
    if [[ $json_output == true ]]; then
        echo "$response" | format_json
    else
        if command -v jq >/dev/null 2>&1; then
            local total
            total=$(echo "$response" | jq -r '.total // 0')
            
            echo -e "${GREEN}‚úÖ Found $total plugins${NC}"
            [[ -n "$category" ]] && echo "   Filtered by category: $category"
            
            if [[ $total -gt 0 ]]; then
                echo ""
                echo -e "${CYAN}Available Plugins:${NC}"
                echo "$response" | jq -r '.plugins[] | "  \(.id) - \(.name) (\(.category))\n    \(.description)\n    Formats: \(.formats | join(", "))\n"' 2>/dev/null
            fi
        else
            echo "$response" | format_json
        fi
    fi
}

# Status command
cmd_status() {
    local json_output=false
    
    while [[ $# -gt 0 ]]; do
        case $1 in
            --json)
                json_output=true
                shift
                ;;
            --help|-h)
                echo "Usage: graph-studio status [OPTIONS]"
                echo ""
                echo "Show operational status and loaded plugins"
                echo ""
                echo "Options:"
                echo "  --json    Output in JSON format"
                return 0
                ;;
            *)
                shift
                ;;
        esac
    done
    
    echo -e "${CYAN}üìä Graph Studio Status${NC}"
    echo ""
    
    local api_url
    if api_url=$(get_api_url 2>/dev/null); then
        echo -e "${GREEN}‚úÖ Service: Running${NC}"
        echo "   API: $api_url"
        
        # Get health for more details
        local health_response
        health_response=$(curl -s "${api_url}/health" 2>/dev/null)
        
        if [[ -n "$health_response" ]]; then
            if [[ $json_output == true ]]; then
                echo "$health_response" | format_json
            else
                echo ""
                echo -e "${CYAN}Service Details:${NC}"
                if command -v jq >/dev/null 2>&1; then
                    echo "$health_response" | jq -r '
                        "  Status: \(.status)",
                        "  Version: \(.version)",
                        "  Plugins Loaded: \(.plugins_loaded)",
                        "  Plugins Active: \(.plugins_active)"
                    ' 2>/dev/null || echo "  Status information unavailable"
                fi
            fi
        fi
    else
        echo -e "${RED}‚ùå Service: Not Running${NC}"
        echo "   Start with: vrooli scenario run graph-studio"
    fi
}

# Health check command
cmd_health() {
    local detailed=false
    local json_output=false
    
    while [[ $# -gt 0 ]]; do
        case $1 in
            --detailed)
                detailed=true
                shift
                ;;
            --json)
                json_output=true
                shift
                ;;
            --help|-h)
                echo "Usage: graph-studio health [OPTIONS]"
                echo ""
                echo "Check service health"
                echo ""
                echo "Options:"
                echo "  --detailed    Show detailed health information"
                echo "  --json        Output in JSON format"
                return 0
                ;;
            *)
                shift
                ;;
        esac
    done
    
    echo -e "${BLUE}üè• Checking health...${NC}"
    
    local api_url
    api_url=$(get_api_url)
    
    local health_response
    health_response=$(curl -s "${api_url}/health")
    
    if [[ $json_output == true ]]; then
        echo "$health_response" | format_json
    else
        if echo "$health_response" | grep -q "healthy"; then
            echo -e "${GREEN}‚úÖ Graph Studio is healthy${NC}"
            echo "   API: ${api_url}"
            
            if [[ "$detailed" == true ]]; then
                echo ""
                echo -e "${CYAN}üìã Health Details:${NC}"
                if command -v jq >/dev/null 2>&1; then
                    echo "$health_response" | jq -r '
                        "  Status: \(.status)",
                        "  Version: \(.version)",
                        "  Plugins Loaded: \(.plugins_loaded)",
                        "  Plugins Active: \(.plugins_active)",
                        "  Timestamp: \(.timestamp)"
                    ' 2>/dev/null
                fi
            fi
        else
            echo -e "${RED}‚ùå Health check failed${NC}"
            echo "   Response: $health_response"
            return 1
        fi
    fi
}

################################################################################
# Main Command Router
################################################################################
main() {
    local command="${1:-}"
    
    if [[ -z "$command" ]]; then
        usage
        exit 0
    fi
    
    shift
    
    case "$command" in
        list)
            cmd_list "$@"
            ;;
        create)
            cmd_create "$@"
            ;;
        get)
            cmd_get "$@"
            ;;
        update)
            cmd_update "$@"
            ;;
        delete)
            cmd_delete "$@"
            ;;
        validate)
            cmd_validate "$@"
            ;;
        convert)
            cmd_convert "$@"
            ;;
        render)
            cmd_render "$@"
            ;;
        plugins)
            cmd_plugins "$@"
            ;;
        status)
            cmd_status "$@"
            ;;
        health)
            cmd_health "$@"
            ;;
        --help|-h|help)
            usage
            ;;
        --version|-v|version)
            echo "Graph Studio CLI v2.0.0 (thin wrapper)"
            ;;
        *)
            echo -e "${RED}‚ùå Unknown command: $command${NC}" >&2
            usage
            exit 1
            ;;
    esac
}

# Run main function
main "$@"