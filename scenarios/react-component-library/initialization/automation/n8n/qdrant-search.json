{
  "name": "Component Search via Qdrant",
  "nodes": [
    {
      "parameters": {},
      "id": "webhook-trigger", 
      "name": "Search Webhook",
      "type": "n8n-nodes-base.webhook",
      "position": [240, 300],
      "webhookId": "component-search-webhook"
    },
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "component-search",
        "options": {}
      },
      "id": "webhook-response",
      "name": "Search Response",
      "type": "n8n-nodes-base.webhookResponse",
      "position": [1200, 300]
    },
    {
      "parameters": {
        "functionCode": "// Extract search parameters from webhook payload\nconst query = items[0].json.query;\nconst category = items[0].json.category || '';\nconst limit = items[0].json.limit || 20;\nconst minAccessibilityScore = items[0].json.min_accessibility_score || 0;\n\n// Validate inputs\nif (!query) {\n  throw new Error('Search query is required');\n}\n\n// Prepare search configuration\nconst searchConfig = {\n  query,\n  category,\n  limit: Math.min(limit, 100), // Cap at 100 results\n  minAccessibilityScore,\n  timestamp: new Date().toISOString()\n};\n\n// Clean query for embedding\nconst cleanQuery = query.trim().toLowerCase();\n\nreturn [{\n  ...searchConfig,\n  cleanQuery\n}];"
      },
      "id": "prepare-search-params",
      "name": "Prepare Search Parameters",
      "type": "n8n-nodes-base.code",
      "position": [400, 300]
    },
    {
      "parameters": {
        "command": "resource-qdrant",
        "arguments": "search --collection react_components --query \"{{ $json.cleanQuery }}\" --limit {{ $json.limit }} --format json"
      },
      "id": "qdrant-semantic-search",
      "name": "Qdrant Semantic Search",
      "type": "n8n-nodes-base.executeCommand",
      "position": [560, 300]
    },
    {
      "parameters": {
        "functionCode": "// Process Qdrant search results\nconst searchParams = items[0].json;\nconst qdrantResults = items[1].json; // Results from Qdrant command\n\n// Parse Qdrant response (handle both string and object responses)\nlet searchResults = [];\nif (typeof qdrantResults === 'string') {\n  try {\n    searchResults = JSON.parse(qdrantResults);\n  } catch (e) {\n    console.log('Failed to parse Qdrant results:', e);\n    searchResults = [];\n  }\n} else if (Array.isArray(qdrantResults)) {\n  searchResults = qdrantResults;\n} else if (qdrantResults && qdrantResults.results) {\n  searchResults = qdrantResults.results;\n}\n\n// Filter and transform results\nconst filteredComponents = [];\n\nsearchResults.forEach(result => {\n  const payload = result.payload || {};\n  const score = result.score || 0;\n  \n  // Apply category filter\n  if (searchParams.category && payload.category !== searchParams.category) {\n    return;\n  }\n  \n  // Apply accessibility score filter\n  if (searchParams.minAccessibilityScore > 0) {\n    const accessibilityScore = payload.accessibility_score || 0;\n    if (accessibilityScore < searchParams.minAccessibilityScore) {\n      return;\n    }\n  }\n  \n  // Transform to component format\n  const component = {\n    id: payload.component_id,\n    name: payload.name || 'Unknown Component',\n    category: payload.category || 'uncategorized',\n    description: payload.description || '',\n    tags: payload.tags || [],\n    author: payload.author || 'anonymous',\n    usage_count: payload.usage_count || 0,\n    accessibility_score: payload.accessibility_score,\n    created_at: payload.created_at,\n    search_score: Math.round(score * 100) / 100,\n    relevance: score > 0.8 ? 'high' : score > 0.6 ? 'medium' : 'low'\n  };\n  \n  filteredComponents.push(component);\n});\n\n// Sort by search score (relevance)\nfilteredComponents.sort((a, b) => b.search_score - a.search_score);\n\n// Prepare final response\nconst response = {\n  query: searchParams.query,\n  components: filteredComponents,\n  total: filteredComponents.length,\n  search_time_ms: Date.now() - new Date(searchParams.timestamp).getTime(),\n  filters_applied: {\n    category: searchParams.category,\n    min_accessibility_score: searchParams.minAccessibilityScore\n  },\n  timestamp: new Date().toISOString()\n};\n\nreturn [response];"
      },
      "id": "process-search-results", 
      "name": "Process Search Results",
      "type": "n8n-nodes-base.code",
      "position": [720, 300]
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "id": "has-results",
              "leftValue": "={{ $json.total }}",
              "rightValue": 0,
              "operator": {
                "type": "number",
                "operation": "gt"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "check-has-results",
      "name": "Check Has Results",
      "type": "n8n-nodes-base.if",
      "position": [880, 300]
    },
    {
      "parameters": {
        "functionCode": "// Enhance results with additional metadata and suggestions\nconst searchResponse = items[0].json;\n\n// Add search suggestions for empty results\nif (searchResponse.total === 0) {\n  searchResponse.suggestions = [\n    'Try using more general terms (e.g., \"button\" instead of \"custom styled button\")',\n    'Check spelling and try different keywords',\n    'Browse components by category instead',\n    'Consider generating a new component with AI'\n  ];\n  \n  // Suggest similar queries\n  const query = searchResponse.query.toLowerCase();\n  const commonSuggestions = [];\n  \n  if (query.includes('button')) {\n    commonSuggestions.push('form components', 'interactive elements');\n  }\n  if (query.includes('modal') || query.includes('dialog')) {\n    commonSuggestions.push('overlay components', 'popup elements');\n  }\n  if (query.includes('table') || query.includes('data')) {\n    commonSuggestions.push('data display', 'list components');\n  }\n  \n  if (commonSuggestions.length > 0) {\n    searchResponse.related_searches = commonSuggestions;\n  }\n} else {\n  // Add category distribution for successful searches\n  const categoryCount = {};\n  searchResponse.components.forEach(comp => {\n    categoryCount[comp.category] = (categoryCount[comp.category] || 0) + 1;\n  });\n  \n  searchResponse.category_distribution = categoryCount;\n  \n  // Add quality insights\n  const highQualityComponents = searchResponse.components.filter(c => \n    c.accessibility_score && c.accessibility_score >= 90\n  ).length;\n  \n  searchResponse.insights = {\n    high_quality_components: highQualityComponents,\n    avg_accessibility_score: searchResponse.components\n      .filter(c => c.accessibility_score)\n      .reduce((sum, c) => sum + c.accessibility_score, 0) / \n      searchResponse.components.filter(c => c.accessibility_score).length || 0\n  };\n}\n\nreturn [searchResponse];"
      },
      "id": "enhance-successful-results",
      "name": "Enhance Successful Results", 
      "type": "n8n-nodes-base.code",
      "position": [1040, 200]
    },
    {
      "parameters": {
        "functionCode": "// Handle empty search results with helpful suggestions\nconst searchResponse = items[0].json;\n\n// Add fallback search using broader terms\nconst query = searchResponse.query.toLowerCase();\nconst fallbackQueries = [];\n\n// Extract key terms for fallback searches\nconst keywords = query.split(' ').filter(word => \n  word.length > 3 && \n  !['the', 'and', 'with', 'for', 'that', 'this', 'from'].includes(word)\n);\n\nif (keywords.length > 1) {\n  fallbackQueries.push(keywords[0]); // Try just the first keyword\n  fallbackQueries.push(keywords.join(' ')); // Try all keywords\n}\n\nsearchResponse.empty_result_handling = {\n  original_query: searchResponse.query,\n  suggested_fallback_queries: fallbackQueries,\n  help_message: 'No components found matching your search. Try the suggestions above or create a new component.',\n  actions: [\n    {\n      label: 'Browse All Components',\n      url: '/library'\n    },\n    {\n      label: 'Generate with AI',\n      url: `/generate?description=${encodeURIComponent(searchResponse.query)}`\n    },\n    {\n      label: 'Create Manually',\n      url: '/create'\n    }\n  ]\n};\n\nreturn [searchResponse];"
      },
      "id": "handle-empty-results",
      "name": "Handle Empty Results",
      "type": "n8n-nodes-base.code",
      "position": [1040, 400]
    },
    {
      "parameters": {
        "mode": "combine",
        "combineBy": "combineAll",
        "options": {}
      },
      "id": "merge-responses",
      "name": "Merge Responses",
      "type": "n8n-nodes-base.merge",
      "position": [1200, 300]
    }
  ],
  "connections": {
    "webhook-trigger": {
      "main": [
        [
          {
            "node": "prepare-search-params",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "prepare-search-params": {
      "main": [
        [
          {
            "node": "qdrant-semantic-search",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "qdrant-semantic-search": {
      "main": [
        [
          {
            "node": "process-search-results",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "process-search-results": {
      "main": [
        [
          {
            "node": "check-has-results", 
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "check-has-results": {
      "main": [
        [
          {
            "node": "enhance-successful-results",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "handle-empty-results",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "enhance-successful-results": {
      "main": [
        [
          {
            "node": "merge-responses",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "handle-empty-results": {
      "main": [
        [
          {
            "node": "merge-responses",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "merge-responses": {
      "main": [
        [
          {
            "node": "webhook-response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "settings": {
    "executionOrder": "v1"
  },
  "staticData": null,
  "tags": [
    {
      "createdAt": "2025-01-28T00:00:00.000Z",
      "updatedAt": "2025-01-28T00:00:00.000Z", 
      "id": "component-search",
      "name": "component-search"
    }
  ],
  "triggerCount": 1,
  "updatedAt": "2025-01-28T00:00:00.000Z",
  "versionId": "1"
}