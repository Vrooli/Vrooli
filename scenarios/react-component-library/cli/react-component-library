#!/usr/bin/env bash

# React Component Library CLI
# Version: 1.0.0

set -e

# Configuration
API_BASE_URL="${API_BASE_URL:-http://localhost:15092}"
UI_BASE_URL="${UI_BASE_URL:-http://localhost:36092}"
CLI_NAME="react-component-library"
CLI_VERSION="1.0.0"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
PURPLE='\033[0;35m'
CYAN='\033[0;36m'
NC='\033[0m' # No Color

# Logging functions
log_info() {
    echo -e "${BLUE}‚Ñπ${NC} $1"
}

log_success() {
    echo -e "${GREEN}‚úÖ${NC} $1"
}

log_warn() {
    echo -e "${YELLOW}‚ö†Ô∏è${NC} $1"
}

log_error() {
    echo -e "${RED}‚ùå${NC} $1"
}

log_step() {
    echo -e "${PURPLE}üîß${NC} $1"
}

# Help function
show_help() {
    cat << EOF
${CYAN}React Component Library CLI${NC} - ${CLI_VERSION}

AI-powered React component library with accessibility testing and performance benchmarking

${YELLOW}USAGE:${NC}
    ${CLI_NAME} <command> [options]

${YELLOW}COMMANDS:${NC}
    ${GREEN}create${NC}      Create a new React component
    ${GREEN}test${NC}        Run tests on component(s)
    ${GREEN}search${NC}      Search components by description or requirements
    ${GREEN}export${NC}      Export component for use in other projects
    ${GREEN}generate${NC}    AI-generate component from natural language description
    ${GREEN}improve${NC}     AI-powered component improvement suggestions
    ${GREEN}status${NC}      Show operational status and resource health
    ${GREEN}version${NC}     Show CLI and API version information
    ${GREEN}help${NC}        Show this help message

${YELLOW}GLOBAL OPTIONS:${NC}
    --json          Output results as JSON
    --verbose       Show detailed output
    --api-url URL   Override default API URL

${YELLOW}EXAMPLES:${NC}
    # Create a new button component
    ${CLI_NAME} create Button form --template button

    # Search for modal components
    ${CLI_NAME} search "modal dialog component"

    # Run accessibility tests
    ${CLI_NAME} test MyComponent --accessibility

    # Generate component with AI
    ${CLI_NAME} generate "responsive navigation menu with dropdown"

    # Export component as npm package
    ${CLI_NAME} export Button --format npm-package

${YELLOW}DOCUMENTATION:${NC}
    For more information, visit: ${UI_BASE_URL}

EOF
}

# Version function
show_version() {
    if [[ "${1:-}" == "--json" ]]; then
        echo '{"cli_version": "'${CLI_VERSION}'", "api_version": "1.0.0"}'
    else
        echo "${CLI_NAME} ${CLI_VERSION}"
        echo "API Version: 1.0.0"
    fi
}

# Status function
show_status() {
    local json_output=false
    local verbose=false
    
    while [[ $# -gt 0 ]]; do
        case $1 in
            --json)
                json_output=true
                shift
                ;;
            --verbose)
                verbose=true
                shift
                ;;
            --help)
                cat << EOF
${CYAN}Status${NC}

Display service health for the React Component Library

${YELLOW}USAGE:${NC}
    ${CLI_NAME} status [--json] [--verbose]

${YELLOW}OPTIONS:${NC}
    --json       Output raw JSON response
    --verbose    Show detailed JSON alongside summary status

EOF
                return 0
                ;;
            -* )
                log_error "Unknown option for status: $1"
                log_info "Usage: ${CLI_NAME} status [--json] [--verbose]"
                return 1
                ;;
            * )
                log_error "Unexpected argument for status command: $1"
                log_info "Usage: ${CLI_NAME} status [--json] [--verbose]"
                return 1
                ;;
        esac
    done

    log_step "Checking React Component Library status..."
    
    # Check API health
    if curl -s "${API_BASE_URL}/health" > /dev/null 2>&1; then
        local health_response=$(curl -s "${API_BASE_URL}/health")
        local api_status=$(echo "$health_response" | jq -r '.status // "unknown"' 2>/dev/null || echo "unknown")
        
        if [[ "$json_output" == "true" ]]; then
            echo "$health_response"
        else
            if [[ "$api_status" == "healthy" ]]; then
                log_success "API is healthy"
            elif [[ "$api_status" == "degraded" ]]; then
                log_warn "API is degraded"
            else
                log_error "API is unhealthy"
            fi
            
            if [[ "$verbose" == "true" ]]; then
                echo "$health_response" | jq '.' 2>/dev/null || echo "$health_response"
            fi
        fi
    else
        if [[ "$json_output" == "true" ]]; then
            echo '{"status": "offline", "error": "API not accessible"}'
        else
            log_error "API is not accessible at ${API_BASE_URL}"
        fi
        exit 1
    fi
}

# Create component function
create_component() {
    local name=""
    local category=""
    local template=""
    local interactive=false
    local ai_generate=false
    
    while [[ $# -gt 0 ]]; do
        case $1 in
            --template) template="$2"; shift 2 ;;
            --interactive) interactive=true; shift ;;
            --ai-generate) ai_generate=true; shift ;;
            --help) 
                cat << EOF
${CYAN}Create Component${NC}

Create a new React component

${YELLOW}USAGE:${NC}
    ${CLI_NAME} create <name> <category> [options]

${YELLOW}ARGUMENTS:${NC}
    name        Component name in PascalCase
    category    Component category (form, layout, display, etc.)

${YELLOW}OPTIONS:${NC}
    --template <name>    Use predefined template (button, modal, form, etc.)
    --interactive        Launch interactive component builder
    --ai-generate        Generate component using AI based on description

${YELLOW}EXAMPLES:${NC}
    ${CLI_NAME} create Button form --template button
    ${CLI_NAME} create Modal feedback --interactive
    ${CLI_NAME} create Card layout --ai-generate

EOF
                return 0
                ;;
            -*) log_error "Unknown option: $1"; return 1 ;;
            *)
                if [[ -z "$name" ]]; then
                    name="$1"
                elif [[ -z "$category" ]]; then
                    category="$1"
                fi
                shift
                ;;
        esac
    done
    
    if [[ -z "$name" || -z "$category" ]]; then
        log_error "Component name and category are required"
        log_info "Usage: ${CLI_NAME} create <name> <category> [options]"
        return 1
    fi
    
    log_step "Creating component: $name (category: $category)"
    
    # Prepare request data
    local request_data='{
        "name": "'$name'",
        "category": "'$category'",
        "description": "Generated component: '$name'",
        "code": "const '$name' = () => <div>Hello from '$name'</div>; export default '$name';",
        "tags": ["'$category'", "generated"]
    }'
    
    # Make API request
    local response
    if response=$(curl -s -X POST \
        -H "Content-Type: application/json" \
        -d "$request_data" \
        "${API_BASE_URL}/api/v1/components"); then
        
        local component_id=$(echo "$response" | jq -r '.id // "unknown"' 2>/dev/null)
        
        if [[ "$component_id" != "unknown" && "$component_id" != "null" ]]; then
            log_success "Component '$name' created successfully!"
            log_info "Component ID: $component_id"
            log_info "View at: ${UI_BASE_URL}/component/$component_id"
        else
            log_error "Failed to create component"
            echo "$response" | jq '.' 2>/dev/null || echo "$response"
            return 1
        fi
    else
        log_error "Failed to connect to API"
        return 1
    fi
}

# Test component function
test_component() {
    local component=""
    local accessibility=false
    local performance=false
    local visual=false
    local fix=false
    local json_output=false
    
    while [[ $# -gt 0 ]]; do
        case $1 in
            --all)
                accessibility=true
                performance=true
                visual=true
                shift
                ;;
            --accessibility) accessibility=true; shift ;;
            --performance) performance=true; shift ;;
            --visual) visual=true; shift ;;
            --fix) fix=true; shift ;;
            --json) json_output=true; shift ;;
            --help)
                cat << EOF
${CYAN}Test Component${NC}

Run tests on component(s)

${YELLOW}USAGE:${NC}
    ${CLI_NAME} test [component] [options]

${YELLOW}ARGUMENTS:${NC}
    component    Component name or ID (tests all if omitted)

${YELLOW}OPTIONS:${NC}
    --accessibility    Run accessibility tests only
    --performance      Run performance benchmarks only
    --visual           Run visual regression tests
    --fix              Apply AI-generated fixes for failing tests
    --json             Output results as JSON

${YELLOW}EXAMPLES:${NC}
    ${CLI_NAME} test Button --accessibility
    ${CLI_NAME} test --performance
    ${CLI_NAME} test Modal --fix

EOF
                return 0
                ;;
            -*) log_error "Unknown option: $1"; return 1 ;;
            *) component="$1"; shift ;;
        esac
    done
    
    # Default to all tests if none specified
    if [[ "$accessibility" == "false" && "$performance" == "false" && "$visual" == "false" ]]; then
        accessibility=true
        performance=true
        visual=true
    fi
    
    # Build test types array
    local test_types=()
    [[ "$accessibility" == "true" ]] && test_types+=("accessibility")
    [[ "$performance" == "true" ]] && test_types+=("performance") 
    [[ "$visual" == "true" ]] && test_types+=("visual")
    
    local test_types_json
    test_types_json=$(printf '%s\n' "${test_types[@]}" | jq -R . | jq -s .)
    
    log_step "Running tests..."
    
    if [[ -n "$component" ]]; then
        # Test specific component - need to get component ID first
        log_info "Testing component: $component"
        # This would require a search/lookup first in a real implementation
        log_warn "Specific component testing not fully implemented in CLI yet"
        log_info "Please use the web interface at ${UI_BASE_URL}"
    else
        # Test all components
        log_info "Running tests on all components"
        log_warn "Bulk testing not implemented in CLI yet"
        log_info "Please use the web interface at ${UI_BASE_URL}"
    fi
}

# Search components function
search_components() {
    local query=""
    local category=""
    local min_score=""
    local json_output=false
    
    while [[ $# -gt 0 ]]; do
        case $1 in
            --category) category="$2"; shift 2 ;;
            --min-score) min_score="$2"; shift 2 ;;
            --json) json_output=true; shift ;;
            --help)
                cat << EOF
${CYAN}Search Components${NC}

Search components by description or requirements

${YELLOW}USAGE:${NC}
    ${CLI_NAME} search <query> [options]

${YELLOW}ARGUMENTS:${NC}
    query    Natural language description of desired component

${YELLOW}OPTIONS:${NC}
    --category <category>    Filter by component category
    --min-score <score>      Minimum accessibility score
    --json                   Output results as JSON

${YELLOW}EXAMPLES:${NC}
    ${CLI_NAME} search "button component"
    ${CLI_NAME} search "modal dialog" --category feedback
    ${CLI_NAME} search "form input" --min-score 90

EOF
                return 0
                ;;
            -*) log_error "Unknown option: $1"; return 1 ;;
            *) query="$1"; shift ;;
        esac
    done
    
    if [[ -z "$query" ]]; then
        log_error "Search query is required"
        log_info "Usage: ${CLI_NAME} search <query> [options]"
        return 1
    fi
    
    log_step "Searching components: $query"
    
    # Build query parameters
    local url="${API_BASE_URL}/api/v1/components/search?query=$(printf '%s' "$query" | jq -sRr @uri)"
    [[ -n "$category" ]] && url+="&category=$category"
    [[ -n "$min_score" ]] && url+="&min_accessibility_score=$min_score"
    
    local response
    if response=$(curl -s "$url"); then
        if [[ "$json_output" == "true" ]]; then
            echo "$response"
        else
            local total=$(echo "$response" | jq -r '.total // 0' 2>/dev/null)
            log_success "Found $total components"
            
            echo "$response" | jq -r '.components[] | "‚Ä¢ \(.name) (\(.category)) - \(.description[:60])..."' 2>/dev/null || {
                log_warn "Could not parse search results"
                echo "$response"
            }
        fi
    else
        log_error "Search failed"
        return 1
    fi
}

# Generate component function
generate_component() {
    local description=""
    local style=""
    local accessibility=""
    local interactive=false
    
    while [[ $# -gt 0 ]]; do
        case $1 in
            --style) style="$2"; shift 2 ;;
            --accessibility) accessibility="$2"; shift 2 ;;
            --interactive) interactive=true; shift ;;
            --help)
                cat << EOF
${CYAN}Generate Component${NC}

AI-generate component from natural language description

${YELLOW}USAGE:${NC}
    ${CLI_NAME} generate <description> [options]

${YELLOW}ARGUMENTS:${NC}
    description    Natural language description of desired component

${YELLOW}OPTIONS:${NC}
    --style <style>           Style preference (minimal, material, bootstrap, custom)
    --accessibility <level>   Accessibility level (A, AA, AAA)
    --interactive             Iterative refinement mode

${YELLOW}EXAMPLES:${NC}
    ${CLI_NAME} generate "responsive navigation menu with dropdown"
    ${CLI_NAME} generate "data table with sorting" --style material --accessibility AA
    ${CLI_NAME} generate "modal dialog" --interactive

EOF
                return 0
                ;;
            -*) log_error "Unknown option: $1"; return 1 ;;
            *) description="$1"; shift ;;
        esac
    done
    
    if [[ -z "$description" ]]; then
        log_error "Component description is required"
        log_info "Usage: ${CLI_NAME} generate <description> [options]"
        return 1
    fi
    
    log_step "Generating component with AI: $description"
    
    # Prepare request data
    local request_data
    request_data=$(jq -n \
        --arg desc "$description" \
        --arg style "${style:-minimal}" \
        --arg accessibility "${accessibility:-AA}" \
        '{
            "description": $desc,
            "style_preferences": {"style": $style},
            "accessibility_level": $accessibility
        }')
    
    local response
    if response=$(curl -s -X POST \
        -H "Content-Type: application/json" \
        -d "$request_data" \
        "${API_BASE_URL}/api/v1/components/generate"); then
        
        local component_name=$(echo "$response" | jq -r '.component_name // "GeneratedComponent"' 2>/dev/null)
        local explanation=$(echo "$response" | jq -r '.explanation // ""' 2>/dev/null)
        
        log_success "Component generated: $component_name"
        [[ -n "$explanation" ]] && log_info "Explanation: $explanation"
        
        # Show generated code
        echo
        echo "${YELLOW}Generated Code:${NC}"
        echo "$response" | jq -r '.generated_code // "No code generated"' 2>/dev/null
        
        # Show usage example
        echo
        echo "${YELLOW}Usage Example:${NC}"
        echo "$response" | jq -r '.example_usage // "No example provided"' 2>/dev/null
        
    else
        log_error "AI generation failed"
        return 1
    fi
}

# Main command dispatcher
main() {
    if [[ $# -eq 0 ]]; then
        show_help
        return 0
    fi
    
    case "$1" in
        "help"|"-h"|"--help") show_help ;;
        "version"|"-v"|"--version") shift; show_version "$@" ;;
        "status") shift; show_status "$@" ;;
        "create") shift; create_component "$@" ;;
        "test") shift; test_component "$@" ;;
        "search") shift; search_components "$@" ;;
        "generate") shift; generate_component "$@" ;;
        "export"|"improve")
            log_warn "Command '$1' is not yet implemented in CLI"
            log_info "Please use the web interface at ${UI_BASE_URL}"
            ;;
        *)
            log_error "Unknown command: $1"
            log_info "Run '${CLI_NAME} help' for usage information"
            exit 1
            ;;
    esac
}

# Run main function with all arguments
main "$@"
