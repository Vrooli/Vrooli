{
  "name": "Sprint Planner",
  "nodes": [
    {
      "parameters": {
        "path": "sprint-planner",
        "options": {}
      },
      "id": "webhook-trigger",
      "name": "Webhook",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2,
      "position": [250, 300]
    },
    {
      "parameters": {},
      "id": "manual-trigger",
      "name": "Manual Trigger",
      "type": "n8n-nodes-base.manualTrigger",
      "typeVersion": 1,
      "position": [250, 500]
    },
    {
      "parameters": {
        "values": {
          "string": [
            {
              "name": "backlog",
              "value": "={{ $json.backlog || '[]' }}"
            },
            {
              "name": "sprint_duration",
              "value": "={{ $json.sprint_duration || '2_weeks' }}"
            },
            {
              "name": "team_members",
              "value": "={{ $json.team_members || '[]' }}"
            },
            {
              "name": "velocity",
              "value": "={{ $json.velocity || '40' }}"
            },
            {
              "name": "sprint_goals",
              "value": "={{ $json.sprint_goals || 'Deliver value to users' }}"
            },
            {
              "name": "dependencies",
              "value": "={{ $json.dependencies || '[]' }}"
            }
          ]
        },
        "options": {}
      },
      "id": "defaults-node",
      "name": "Set Defaults",
      "type": "n8n-nodes-base.set",
      "typeVersion": 3,
      "position": [450, 500]
    },
    {
      "parameters": {
        "mode": "combine",
        "combinationMode": "multiplex",
        "options": {}
      },
      "id": "merge-inputs",
      "name": "Merge",
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3,
      "position": [650, 400]
    },
    {
      "parameters": {
        "jsCode": "// Parse sprint parameters and calculate capacity\nconst backlog = typeof $json.backlog === 'string' ? JSON.parse($json.backlog) : $json.backlog;\nconst teamMembers = typeof $json.team_members === 'string' ? JSON.parse($json.team_members) : $json.team_members;\nconst sprintDuration = $json.sprint_duration || '2_weeks';\nconst velocity = parseInt($json.velocity) || 40;\nconst sprintGoals = $json.sprint_goals;\nconst dependencies = typeof $json.dependencies === 'string' ? JSON.parse($json.dependencies) : $json.dependencies;\n\n// Calculate sprint capacity\nlet durationDays = 10; // default 2 weeks\nif (sprintDuration.includes('week')) {\n  const weeks = parseInt(sprintDuration) || 2;\n  durationDays = weeks * 5; // 5 working days per week\n} else if (sprintDuration.includes('day')) {\n  durationDays = parseInt(sprintDuration) || 10;\n}\n\n// Calculate team capacity\nlet teamCapacity = velocity; // Use historical velocity if available\nif (teamMembers.length > 0) {\n  // Calculate capacity based on team members\n  teamCapacity = teamMembers.reduce((total, member) => {\n    const availability = member.availability || 1.0; // Full time by default\n    const focusFactor = member.focus_factor || 0.7; // 70% productive time\n    const dailyPoints = member.daily_points || 4; // Story points per day\n    return total + (dailyPoints * durationDays * availability * focusFactor);\n  }, 0);\n}\n\n// Sort backlog by priority (if not already sorted)\nconst sortedBacklog = [...backlog].sort((a, b) => {\n  // First by priority level\n  const priorityOrder = { 'CRITICAL': 0, 'HIGH': 1, 'MEDIUM': 2, 'LOW': 3 };\n  const aPriority = priorityOrder[a.priority] || 4;\n  const bPriority = priorityOrder[b.priority] || 4;\n  if (aPriority !== bPriority) return aPriority - bPriority;\n  \n  // Then by business value\n  return (b.business_value || 0) - (a.business_value || 0);\n});\n\n// Plan sprint items\nconst sprintItems = [];\nconst deferredItems = [];\nlet currentCapacity = 0;\nlet blockedByDependencies = [];\n\n// Check dependencies\nconst hasDependencyIssue = (item) => {\n  if (!item.dependencies || item.dependencies.length === 0) return false;\n  return item.dependencies.some(dep => {\n    // Check if dependency is in sprint or completed\n    const depInSprint = sprintItems.some(si => si.id === dep);\n    const depCompleted = dependencies.some(d => d.id === dep && d.status === 'completed');\n    return !depInSprint && !depCompleted;\n  });\n};\n\n// Allocate items to sprint\nfor (const item of sortedBacklog) {\n  const itemEffort = item.story_points || item.effort || 5;\n  \n  // Check if item fits in capacity\n  if (currentCapacity + itemEffort <= teamCapacity) {\n    // Check dependencies\n    if (!hasDependencyIssue(item)) {\n      sprintItems.push({\n        ...item,\n        allocated_points: itemEffort,\n        sprint_status: 'committed'\n      });\n      currentCapacity += itemEffort;\n    } else {\n      blockedByDependencies.push({\n        ...item,\n        reason: 'blocked_by_dependencies'\n      });\n    }\n  } else {\n    deferredItems.push({\n      ...item,\n      reason: 'capacity_exceeded',\n      would_need: itemEffort\n    });\n  }\n}\n\n// Calculate sprint metrics\nconst metrics = {\n  planned_points: currentCapacity,\n  capacity: teamCapacity,\n  utilization: Math.round((currentCapacity / teamCapacity) * 100),\n  items_count: sprintItems.length,\n  deferred_count: deferredItems.length,\n  blocked_count: blockedByDependencies.length\n};\n\n// Generate daily standup schedule\nconst dailyPlan = [];\nlet dayNumber = 1;\nlet remainingItems = [...sprintItems];\n\nwhile (dayNumber <= durationDays && remainingItems.length > 0) {\n  const dailyCapacity = teamCapacity / durationDays;\n  const dayItems = [];\n  let dayPoints = 0;\n  \n  while (remainingItems.length > 0 && dayPoints < dailyCapacity) {\n    const item = remainingItems.shift();\n    if (item.allocated_points + dayPoints <= dailyCapacity * 1.2) {\n      dayItems.push(item);\n      dayPoints += item.allocated_points;\n    } else {\n      remainingItems.unshift(item);\n      break;\n    }\n  }\n  \n  dailyPlan.push({\n    day: dayNumber,\n    date: new Date(Date.now() + (dayNumber - 1) * 24 * 60 * 60 * 1000).toISOString(),\n    items: dayItems.map(i => ({ id: i.id, name: i.name, points: i.allocated_points })),\n    total_points: dayPoints,\n    focus_areas: dayItems.length > 0 ? [...new Set(dayItems.map(i => i.category || 'general'))] : []\n  });\n  \n  dayNumber++;\n}\n\nreturn {\n  sprint_duration: sprintDuration,\n  duration_days: durationDays,\n  team_capacity: teamCapacity,\n  sprint_goals: sprintGoals,\n  sprint_items: sprintItems,\n  deferred_items: deferredItems,\n  blocked_items: blockedByDependencies,\n  metrics: metrics,\n  daily_plan: dailyPlan,\n  team_allocation: teamMembers.map(member => ({\n    name: member.name,\n    capacity: Math.round(member.daily_points * durationDays * (member.availability || 1) * (member.focus_factor || 0.7)),\n    assigned_items: sprintItems.filter(item => \n      item.assignee === member.name || \n      (item.required_skills && member.skills && \n       item.required_skills.some(skill => member.skills.includes(skill)))\n    ).map(i => i.name)\n  }))\n};"
      },
      "id": "calculate-sprint",
      "name": "Calculate Sprint Plan",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [850, 400]
    },
    {
      "parameters": {
        "url": "={{ $env.service.n8n.url }}/webhook/ollama",
        "sendBody": true,
        "bodyParameters": {
          "parameters": [
            {
              "name": "prompt",
              "value": "=Analyze this sprint plan and provide recommendations:\n\nSprint Plan:\n{{ JSON.stringify($json) }}\n\nProvide:\n1. Risk assessment for the sprint\n2. Recommendations for team pairing and collaboration\n3. Suggested daily focus areas\n4. Potential bottlenecks and mitigation strategies\n5. Success criteria and definition of done\n\nConsider the team capacity, dependencies, and sprint goals.\n\nFormat response as JSON."
            },
            {
              "name": "model",
              "value": "llama3.2:latest"
            },
            {
              "name": "temperature",
              "value": "0.6"
            },
            {
              "name": "format",
              "value": "json"
            }
          ]
        },
        "options": {
          "timeout": 60000
        }
      },
      "id": "analyze-sprint",
      "name": "AI Sprint Analysis",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4,
      "position": [1050, 400]
    },
    {
      "parameters": {
        "jsCode": "// Combine sprint plan with AI analysis\nconst sprintPlan = $input.all()[0].json;\nconst aiAnalysis = $input.all()[1].json;\n\n// Generate sprint ceremonies schedule\nconst ceremonies = [];\nconst sprintStart = new Date();\nconst sprintEnd = new Date(Date.now() + sprintPlan.duration_days * 24 * 60 * 60 * 1000);\n\n// Sprint planning (day 1)\nceremonies.push({\n  type: 'sprint_planning',\n  date: sprintStart.toISOString(),\n  duration: '2_hours',\n  agenda: [\n    'Review sprint goals',\n    'Estimate and commit to backlog items',\n    'Identify dependencies and risks',\n    'Create sprint plan'\n  ],\n  required_attendees: 'all_team'\n});\n\n// Daily standups\nfor (let day = 1; day <= sprintPlan.duration_days; day++) {\n  const date = new Date(sprintStart.getTime() + (day - 1) * 24 * 60 * 60 * 1000);\n  if (date.getDay() !== 0 && date.getDay() !== 6) { // Skip weekends\n    ceremonies.push({\n      type: 'daily_standup',\n      date: date.toISOString(),\n      duration: '15_minutes',\n      agenda: [\n        'What was completed yesterday',\n        'What will be worked on today',\n        'Any blockers or impediments'\n      ],\n      required_attendees: 'all_team'\n    });\n  }\n}\n\n// Sprint review (last day)\nceremonies.push({\n  type: 'sprint_review',\n  date: new Date(sprintEnd.getTime() - 2 * 60 * 60 * 1000).toISOString(), // 2 hours before end\n  duration: '1_hour',\n  agenda: [\n    'Demo completed work',\n    'Review sprint goals achievement',\n    'Gather stakeholder feedback',\n    'Update product backlog'\n  ],\n  required_attendees: 'team_and_stakeholders'\n});\n\n// Sprint retrospective (last day)\nceremonies.push({\n  type: 'sprint_retrospective',\n  date: sprintEnd.toISOString(),\n  duration: '1.5_hours',\n  agenda: [\n    'What went well',\n    'What could be improved',\n    'Action items for next sprint'\n  ],\n  required_attendees: 'all_team'\n});\n\n// Create burndown chart data\nconst burndownData = [];\nlet remainingPoints = sprintPlan.metrics.planned_points;\nconst idealBurnRate = remainingPoints / sprintPlan.duration_days;\n\nfor (let day = 0; day <= sprintPlan.duration_days; day++) {\n  burndownData.push({\n    day: day,\n    date: new Date(sprintStart.getTime() + day * 24 * 60 * 60 * 1000).toISOString(),\n    ideal_remaining: Math.max(0, remainingPoints - (idealBurnRate * day)),\n    actual_remaining: null, // Will be filled during sprint execution\n    completed_today: null\n  });\n}\n\n// Generate sprint board columns\nconst boardColumns = [\n  {\n    name: 'Backlog',\n    items: sprintPlan.deferred_items.map(i => ({ id: i.id, name: i.name })),\n    wip_limit: null\n  },\n  {\n    name: 'Ready',\n    items: sprintPlan.sprint_items.filter(i => !i.in_progress).map(i => ({ id: i.id, name: i.name })),\n    wip_limit: null\n  },\n  {\n    name: 'In Progress',\n    items: [],\n    wip_limit: sprintPlan.team_allocation.length * 2 // 2 items per person\n  },\n  {\n    name: 'Review',\n    items: [],\n    wip_limit: 3\n  },\n  {\n    name: 'Done',\n    items: [],\n    wip_limit: null\n  }\n];\n\n// Final output\nreturn {\n  sprint_id: `sprint-${Date.now()}`,\n  created_at: new Date().toISOString(),\n  sprint_plan: sprintPlan,\n  ai_analysis: aiAnalysis,\n  ceremonies: ceremonies,\n  burndown_chart: {\n    data: burndownData,\n    ideal_velocity: idealBurnRate,\n    total_points: sprintPlan.metrics.planned_points\n  },\n  kanban_board: {\n    columns: boardColumns,\n    total_items: sprintPlan.sprint_items.length,\n    blocked_items: sprintPlan.blocked_items.length\n  },\n  summary: {\n    sprint_name: `Sprint ${new Date().toISOString().split('T')[0]}`,\n    duration: `${sprintPlan.duration_days} days`,\n    start_date: sprintStart.toISOString(),\n    end_date: sprintEnd.toISOString(),\n    team_size: sprintPlan.team_allocation.length,\n    total_capacity: sprintPlan.team_capacity,\n    committed_points: sprintPlan.metrics.planned_points,\n    utilization: `${sprintPlan.metrics.utilization}%`,\n    items_committed: sprintPlan.sprint_items.length,\n    items_deferred: sprintPlan.deferred_items.length,\n    risks_identified: aiAnalysis.risks ? aiAnalysis.risks.length : 0\n  }\n};"
      },
      "id": "format-output",
      "name": "Format Sprint Output",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1250, 400]
    },
    {
      "parameters": {
        "values": {
          "string": [
            {
              "name": "status",
              "value": "success"
            },
            {
              "name": "message",
              "value": "Sprint planned successfully"
            }
          ]
        },
        "options": {}
      },
      "id": "success-response",
      "name": "Success Response",
      "type": "n8n-nodes-base.set",
      "typeVersion": 3,
      "position": [1450, 300]
    },
    {
      "parameters": {
        "values": {
          "string": [
            {
              "name": "status",
              "value": "error"
            },
            {
              "name": "message",
              "value": "={{ $json.error.message || 'Failed to plan sprint' }}"
            }
          ]
        },
        "options": {}
      },
      "id": "error-response",
      "name": "Error Response",
      "type": "n8n-nodes-base.set",
      "typeVersion": 3,
      "position": [1450, 500],
      "continueOnFail": true
    },
    {
      "parameters": {
        "options": {}
      },
      "id": "respond-webhook",
      "name": "Respond to Webhook",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1,
      "position": [1650, 400]
    }
  ],
  "connections": {
    "webhook-trigger": {
      "main": [
        [
          {
            "node": "merge-inputs",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "manual-trigger": {
      "main": [
        [
          {
            "node": "defaults-node",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "defaults-node": {
      "main": [
        [
          {
            "node": "merge-inputs",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "merge-inputs": {
      "main": [
        [
          {
            "node": "calculate-sprint",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "calculate-sprint": {
      "main": [
        [
          {
            "node": "analyze-sprint",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "analyze-sprint": {
      "main": [
        [
          {
            "node": "format-output",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "format-output": {
      "main": [
        [
          {
            "node": "success-response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "success-response": {
      "main": [
        [
          {
            "node": "respond-webhook",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "error-response": {
      "main": [
        [
          {
            "node": "respond-webhook",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": false,
  "settings": {
    "executionOrder": "v1"
  },
  "versionId": "sprint-planner-v1",
  "meta": {
    "templateCredsSetupCompleted": true,
    "instanceId": "product-manager-sprint"
  },
  "id": "sprint-planner",
  "tags": []
}