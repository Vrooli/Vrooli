#!/usr/bin/env bash

# Device Sync Hub CLI
# Cross-device file and clipboard synchronization CLI tool

set -euo pipefail

# Configuration
CLI_NAME="device-sync-hub"
CLI_VERSION="1.0.0"
API_URL="${API_URL:-http://localhost:3300}"
AUTH_URL="${AUTH_URL:-http://localhost:3250}"
CONFIG_DIR="$HOME/.vrooli/$CLI_NAME"
CONFIG_FILE="$CONFIG_DIR/config.json"
AUTH_TOKEN=""

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
BOLD='\033[1m'
NC='\033[0m' # No Color

# Ensure config directory exists
mkdir -p "$CONFIG_DIR"

# Helper functions
log_info() {
    echo -e "${BLUE}[INFO]${NC} $1"
}

log_success() {
    echo -e "${GREEN}[SUCCESS]${NC} $1"
}

log_warning() {
    echo -e "${YELLOW}[WARNING]${NC} $1"
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $1" >&2
}

log_bold() {
    echo -e "${BOLD}$1${NC}"
}

# Load configuration
load_config() {
    if [[ -f "$CONFIG_FILE" ]]; then
        AUTH_TOKEN=$(jq -r '.auth_token // ""' "$CONFIG_FILE" 2>/dev/null || echo "")
    fi
}

# Save configuration
save_config() {
    local config="{\"auth_token\": \"$AUTH_TOKEN\"}"
    echo "$config" > "$CONFIG_FILE"
    chmod 600 "$CONFIG_FILE"
}

# API request wrapper
api_request() {
    local method="$1"
    local endpoint="$2"
    local data="${3:-}"
    local content_type="${4:-application/json}"
    
    local curl_args=(-s -X "$method")
    
    if [[ -n "$AUTH_TOKEN" ]]; then
        curl_args+=(-H "Authorization: Bearer $AUTH_TOKEN")
    fi
    
    if [[ -n "$data" ]]; then
        if [[ "$content_type" == "multipart/form-data" ]]; then
            curl_args+=("$data")
        else
            curl_args+=(-H "Content-Type: $content_type" -d "$data")
        fi
    fi
    
    curl_args+=("$API_URL$endpoint")
    
    curl "${curl_args[@]}"
}

# Authentication
authenticate() {
    if [[ -z "$AUTH_TOKEN" ]]; then
        log_error "No authentication token found. Please login first."
        log_info "Run: $CLI_NAME login"
        exit 1
    fi
    
    # Validate token
    local response
    response=$(curl -s -H "Authorization: Bearer $AUTH_TOKEN" "$AUTH_URL/api/v1/auth/validate" || echo "")
    
    if [[ -z "$response" ]] || ! echo "$response" | jq -e '.valid' >/dev/null 2>&1; then
        log_error "Authentication token is invalid or expired."
        log_info "Run: $CLI_NAME login"
        exit 1
    fi
}

# Commands

cmd_help() {
    cat << 'EOF'
Device Sync Hub CLI - Cross-device file and clipboard synchronization

USAGE:
    device-sync-hub <COMMAND> [OPTIONS]

COMMANDS:
    login                      Authenticate with the service
    logout                     Remove authentication token
    status [--json] [--verbose] Show service status and connection info
    version [--json]           Show CLI and API version information
    
    upload <file>              Upload a file for cross-device sharing
        [--expires <hours>]        Set expiration time (default: 24h)
        
    upload-text <text>         Upload text content for sharing  
        [--expires <hours>]        Set expiration time (default: 24h)
        [--clipboard]              Mark as clipboard content
        
    list [--json] [--filter <type>]  List all active sync items
                                     Filter: all, file, text, clipboard
                                     
    download <item_id> [path]  Download a sync item by ID
                              If path not specified, uses original filename
                              
    delete <item_id>           Delete a sync item immediately
    
    settings                   Show current settings
    settings set <key> <value> Update a setting
    
    cleanup                    Manually trigger cleanup of expired items

EXAMPLES:
    # Login to the service
    device-sync-hub login

    # Upload a file
    device-sync-hub upload photo.jpg --expires 48
    
    # Share some text
    device-sync-hub upload-text "Remember to buy groceries" 
    
    # Share clipboard content
    device-sync-hub upload-text "$(pbpaste)" --clipboard
    
    # List all items
    device-sync-hub list
    
    # List only files with JSON output
    device-sync-hub list --filter file --json
    
    # Download an item
    device-sync-hub download a1b2c3d4-e5f6-7890-abcd-ef1234567890
    
    # Delete an item
    device-sync-hub delete a1b2c3d4-e5f6-7890-abcd-ef1234567890
    
    # Check status
    device-sync-hub status --verbose

CONFIGURATION:
    Config directory: ~/.vrooli/device-sync-hub/
    Config file:     ~/.vrooli/device-sync-hub/config.json
    
    Environment variables:
    - API_URL:  API server URL (default: http://localhost:3300)
    - AUTH_URL: Auth server URL (default: http://localhost:3250)

AUTHENTICATION:
    This CLI integrates with scenario-authenticator for secure access.
    You need valid credentials to use the sync functionality.

EOF
}

cmd_version() {
    local json_output=false
    
    while [[ $# -gt 0 ]]; do
        case $1 in
            --json)
                json_output=true
                shift
                ;;
            *)
                log_error "Unknown option: $1"
                exit 1
                ;;
        esac
    done
    
    if [[ "$json_output" == "true" ]]; then
        echo "{\"cli_version\": \"$CLI_VERSION\", \"api_url\": \"$API_URL\"}"
    else
        echo "Device Sync Hub CLI v$CLI_VERSION"
        echo "API URL: $API_URL"
    fi
}

cmd_login() {
    echo -n "Email: "
    read -r email
    echo -n "Password: "
    read -rs password
    echo
    
    log_info "Authenticating..."
    
    local response
    response=$(curl -s -X POST \
        -H "Content-Type: application/json" \
        -d "{\"email\": \"$email\", \"password\": \"$password\"}" \
        "$AUTH_URL/api/v1/auth/login" || echo "")
    
    if [[ -z "$response" ]]; then
        log_error "Failed to connect to authentication service"
        exit 1
    fi
    
    if echo "$response" | jq -e '.token' >/dev/null 2>&1; then
        AUTH_TOKEN=$(echo "$response" | jq -r '.token')
        save_config
        log_success "Logged in successfully"
        
        # Show user info if available
        local user_email
        user_email=$(echo "$response" | jq -r '.email // ""')
        if [[ -n "$user_email" ]]; then
            log_info "Logged in as: $user_email"
        fi
    else
        local error_msg
        error_msg=$(echo "$response" | jq -r '.error // "Login failed"')
        log_error "$error_msg"
        exit 1
    fi
}

cmd_logout() {
    if [[ -f "$CONFIG_FILE" ]]; then
        rm "$CONFIG_FILE"
        log_success "Logged out successfully"
    else
        log_info "Already logged out"
    fi
}

cmd_status() {
    local json_output=false
    local verbose=false
    
    while [[ $# -gt 0 ]]; do
        case $1 in
            --json)
                json_output=true
                shift
                ;;
            --verbose)
                verbose=true
                shift
                ;;
            *)
                log_error "Unknown option: $1"
                exit 1
                ;;
        esac
    done
    
    # Check API health
    local api_status="offline"
    local api_response
    api_response=$(curl -s "$API_URL/health" || echo "")
    
    if [[ -n "$api_response" ]] && echo "$api_response" | jq -e '.healthy' >/dev/null 2>&1; then
        api_status="online"
    fi
    
    # Check auth status
    local auth_status="not_authenticated"
    local user_info=""
    
    if [[ -n "$AUTH_TOKEN" ]]; then
        local auth_response
        auth_response=$(curl -s -H "Authorization: Bearer $AUTH_TOKEN" \
            "$AUTH_URL/api/v1/auth/validate" || echo "")
        
        if [[ -n "$auth_response" ]] && echo "$auth_response" | jq -e '.valid' >/dev/null 2>&1; then
            auth_status="authenticated"
            user_info=$(echo "$auth_response" | jq -r '.email // ""')
        else
            auth_status="token_invalid"
        fi
    fi
    
    # Get sync items count if authenticated
    local items_count=0
    if [[ "$auth_status" == "authenticated" ]]; then
        local items_response
        items_response=$(api_request "GET" "/api/v1/sync/items" || echo "")
        if [[ -n "$items_response" ]]; then
            items_count=$(echo "$items_response" | jq -r '.items | length' 2>/dev/null || echo "0")
        fi
    fi
    
    if [[ "$json_output" == "true" ]]; then
        cat << EOF
{
  "service": "device-sync-hub",
  "version": "$CLI_VERSION",
  "api_status": "$api_status",
  "api_url": "$API_URL",
  "auth_status": "$auth_status",
  "user": "$user_info",
  "active_items": $items_count,
  "healthy": $(if [[ "$api_status" == "online" && "$auth_status" == "authenticated" ]]; then echo "true"; else echo "false"; fi)
}
EOF
    else
        log_bold "Device Sync Hub Status"
        echo "API Status: $api_status"
        echo "Auth Status: $auth_status"
        if [[ -n "$user_info" ]]; then
            echo "User: $user_info"
        fi
        echo "Active Items: $items_count"
        
        if [[ "$verbose" == "true" ]]; then
            echo ""
            echo "Configuration:"
            echo "  API URL: $API_URL"
            echo "  Auth URL: $AUTH_URL"
            echo "  Config Dir: $CONFIG_DIR"
            echo "  CLI Version: $CLI_VERSION"
        fi
        
        if [[ "$api_status" == "online" && "$auth_status" == "authenticated" ]]; then
            log_success "Service is healthy and ready"
        else
            log_warning "Service may not be fully operational"
        fi
    fi
}

cmd_upload() {
    if [[ $# -lt 1 ]]; then
        log_error "Usage: $CLI_NAME upload <file> [--expires <hours>]"
        exit 1
    fi
    
    authenticate
    
    local file_path="$1"
    local expires_hours="24"
    
    shift
    
    while [[ $# -gt 0 ]]; do
        case $1 in
            --expires)
                expires_hours="$2"
                shift 2
                ;;
            *)
                log_error "Unknown option: $1"
                exit 1
                ;;
        esac
    done
    
    if [[ ! -f "$file_path" ]]; then
        log_error "File not found: $file_path"
        exit 1
    fi
    
    local filename
    filename=$(basename "$file_path")
    
    log_info "Uploading: $filename"
    
    local response
    response=$(api_request "POST" "/api/v1/sync/upload" \
        "-F file=@$file_path -F content_type=file -F expires_in=$expires_hours" \
        "multipart/form-data" || echo "")
    
    if [[ -n "$response" ]] && echo "$response" | jq -e '.success' >/dev/null 2>&1; then
        local item_id expires_at
        item_id=$(echo "$response" | jq -r '.item_id')
        expires_at=$(echo "$response" | jq -r '.expires_at')
        
        log_success "File uploaded successfully"
        echo "Item ID: $item_id"
        echo "Expires: $expires_at"
    else
        local error_msg
        error_msg=$(echo "$response" | jq -r '.error // "Upload failed"' 2>/dev/null || echo "Upload failed")
        log_error "$error_msg"
        exit 1
    fi
}

cmd_upload_text() {
    if [[ $# -lt 1 ]]; then
        log_error "Usage: $CLI_NAME upload-text <text> [--expires <hours>] [--clipboard]"
        exit 1
    fi
    
    authenticate
    
    local text="$1"
    local expires_hours="24"
    local content_type="text"
    
    shift
    
    while [[ $# -gt 0 ]]; do
        case $1 in
            --expires)
                expires_hours="$2"
                shift 2
                ;;
            --clipboard)
                content_type="clipboard"
                shift
                ;;
            *)
                log_error "Unknown option: $1"
                exit 1
                ;;
        esac
    done
    
    log_info "Uploading text content..."
    
    local json_data
    json_data=$(jq -n \
        --arg text "$text" \
        --arg content_type "$content_type" \
        --argjson expires_in "$expires_hours" \
        '{text: $text, content_type: $content_type, expires_in: $expires_in}')
    
    local response
    response=$(api_request "POST" "/api/v1/sync/upload" "$json_data" || echo "")
    
    if [[ -n "$response" ]] && echo "$response" | jq -e '.success' >/dev/null 2>&1; then
        local item_id expires_at
        item_id=$(echo "$response" | jq -r '.item_id')
        expires_at=$(echo "$response" | jq -r '.expires_at')
        
        log_success "Text uploaded successfully"
        echo "Item ID: $item_id"
        echo "Content Type: $content_type"
        echo "Expires: $expires_at"
    else
        local error_msg
        error_msg=$(echo "$response" | jq -r '.error // "Upload failed"' 2>/dev/null || echo "Upload failed")
        log_error "$error_msg"
        exit 1
    fi
}

cmd_list() {
    authenticate
    
    local json_output=false
    local filter_type="all"
    
    while [[ $# -gt 0 ]]; do
        case $1 in
            --json)
                json_output=true
                shift
                ;;
            --filter)
                filter_type="$2"
                shift 2
                ;;
            *)
                log_error "Unknown option: $1"
                exit 1
                ;;
        esac
    done
    
    local response
    response=$(api_request "GET" "/api/v1/sync/items" || echo "")
    
    if [[ -z "$response" ]]; then
        log_error "Failed to fetch items"
        exit 1
    fi
    
    if [[ "$json_output" == "true" ]]; then
        if [[ "$filter_type" == "all" ]]; then
            echo "$response"
        else
            echo "$response" | jq --arg filter "$filter_type" '.items |= map(select(.content_type == $filter))'
        fi
    else
        local items
        if [[ "$filter_type" == "all" ]]; then
            items=$(echo "$response" | jq -r '.items')
        else
            items=$(echo "$response" | jq -r --arg filter "$filter_type" '.items | map(select(.content_type == $filter))')
        fi
        
        local item_count
        item_count=$(echo "$items" | jq -r 'length')
        
        if [[ "$item_count" -eq 0 ]]; then
            log_info "No items found"
            return
        fi
        
        log_bold "Sync Items ($item_count total, filter: $filter_type)"
        printf "%-36s %-20s %-10s %-15s %s\n" "ID" "FILENAME" "TYPE" "SIZE" "EXPIRES"
        echo "--------------------------------------------------------------------------------"
        
        echo "$items" | jq -r '.[] | [.id, .filename, .content_type, (.file_size // 0), .expires_at] | @tsv' | \
        while IFS=$'\t' read -r id filename content_type size expires_at; do
            local formatted_size
            if [[ "$size" -gt 0 ]]; then
                formatted_size=$(numfmt --to=iec-i --suffix=B "$size" 2>/dev/null || echo "${size}B")
            else
                formatted_size="-"
            fi
            
            local formatted_expires
            formatted_expires=$(date -d "$expires_at" "+%m/%d %H:%M" 2>/dev/null || echo "Unknown")
            
            printf "%-36s %-20s %-10s %-15s %s\n" \
                "${id:0:36}" \
                "${filename:0:20}" \
                "$content_type" \
                "$formatted_size" \
                "$formatted_expires"
        done
    fi
}

cmd_download() {
    if [[ $# -lt 1 ]]; then
        log_error "Usage: $CLI_NAME download <item_id> [output_path]"
        exit 1
    fi
    
    authenticate
    
    local item_id="$1"
    local output_path="${2:-}"
    
    # Get item info first to get the original filename
    local item_response
    item_response=$(api_request "GET" "/api/v1/sync/items" || echo "")
    
    if [[ -z "$item_response" ]]; then
        log_error "Failed to fetch item information"
        exit 1
    fi
    
    local item_info
    item_info=$(echo "$item_response" | jq -r --arg id "$item_id" '.items[] | select(.id == $id)')
    
    if [[ -z "$item_info" ]]; then
        log_error "Item not found: $item_id"
        exit 1
    fi
    
    local filename
    filename=$(echo "$item_info" | jq -r '.filename')
    
    if [[ -z "$output_path" ]]; then
        output_path="$filename"
    fi
    
    log_info "Downloading: $filename"
    
    # Download the file
    local http_code
    http_code=$(curl -s -w "%{http_code}" -o "$output_path" \
        -H "Authorization: Bearer $AUTH_TOKEN" \
        "$API_URL/api/v1/sync/items/$item_id/download")
    
    if [[ "$http_code" -eq 200 ]]; then
        log_success "Downloaded: $output_path"
    else
        rm -f "$output_path" # Clean up failed download
        log_error "Download failed (HTTP $http_code)"
        exit 1
    fi
}

cmd_delete() {
    if [[ $# -lt 1 ]]; then
        log_error "Usage: $CLI_NAME delete <item_id>"
        exit 1
    fi
    
    authenticate
    
    local item_id="$1"
    
    local response
    response=$(api_request "DELETE" "/api/v1/sync/items/$item_id" || echo "")
    
    if [[ -n "$response" ]] && echo "$response" | jq -e '.success' >/dev/null 2>&1; then
        log_success "Item deleted successfully"
    else
        local error_msg
        error_msg=$(echo "$response" | jq -r '.error // "Delete failed"' 2>/dev/null || echo "Delete failed")
        log_error "$error_msg"
        exit 1
    fi
}

cmd_settings() {
    if [[ $# -eq 0 ]]; then
        authenticate
        
        local response
        response=$(api_request "GET" "/api/v1/sync/settings" || echo "")
        
        if [[ -n "$response" ]]; then
            log_bold "Device Sync Hub Settings"
            echo "Max File Size: $(echo "$response" | jq -r '.max_file_size' | numfmt --to=iec-i --suffix=B)"
            echo "Default Expiry: $(echo "$response" | jq -r '.default_expiry_hours')h"
            echo "Thumbnail Size: $(echo "$response" | jq -r '.thumbnail_size // 200')px"
        else
            log_error "Failed to fetch settings"
            exit 1
        fi
    elif [[ "$1" == "set" ]]; then
        log_warning "Settings modification not implemented yet"
        log_info "Settings are configured on the server side"
        exit 1
    else
        log_error "Usage: $CLI_NAME settings [set <key> <value>]"
        exit 1
    fi
}

cmd_cleanup() {
    authenticate
    
    log_info "Triggering cleanup of expired items..."
    
    # This would typically be a server-side operation
    # For now, we'll just show the current items
    log_warning "Cleanup is handled automatically by the server"
    log_info "Expired items are cleaned up every hour automatically"
}

# Main command dispatcher
main() {
    load_config
    
    if [[ $# -eq 0 ]]; then
        cmd_help
        exit 0
    fi
    
    local command="$1"
    shift
    
    case "$command" in
        help|--help|-h)
            cmd_help
            ;;
        version|--version|-v)
            cmd_version "$@"
            ;;
        login)
            cmd_login "$@"
            ;;
        logout)
            cmd_logout "$@"
            ;;
        status)
            cmd_status "$@"
            ;;
        upload)
            cmd_upload "$@"
            ;;
        upload-text)
            cmd_upload_text "$@"
            ;;
        list)
            cmd_list "$@"
            ;;
        download)
            cmd_download "$@"
            ;;
        delete)
            cmd_delete "$@"
            ;;
        settings)
            cmd_settings "$@"
            ;;
        cleanup)
            cmd_cleanup "$@"
            ;;
        *)
            log_error "Unknown command: $command"
            log_info "Run '$CLI_NAME help' for usage information"
            exit 1
            ;;
    esac
}

# Check dependencies
if ! command -v curl >/dev/null 2>&1; then
    log_error "curl is required but not installed"
    exit 1
fi

if ! command -v jq >/dev/null 2>&1; then
    log_error "jq is required but not installed"
    exit 1
fi

# Run main function with all arguments
main "$@"