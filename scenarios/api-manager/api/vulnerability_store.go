package main

import (
	"sync"
	"time"
	"api-manager/scanners"
)

// VulnerabilityStore provides in-memory storage for vulnerabilities
type VulnerabilityStore struct {
	mu              sync.RWMutex
	vulnerabilities map[string][]StoredVulnerability // key is scenario name
	lastScan        map[string]time.Time             // key is scenario name
}

// StoredVulnerability represents a vulnerability in storage
type StoredVulnerability struct {
	ID             string    `json:"id"`
	ScenarioName   string    `json:"scenario_name"`
	Type           string    `json:"type"`
	Severity       string    `json:"severity"`
	Title          string    `json:"title"`
	Description    string    `json:"description"`
	FilePath       string    `json:"file_path"`
	LineNumber     int       `json:"line_number"`
	CodeSnippet    string    `json:"code_snippet,omitempty"`
	Recommendation string    `json:"recommendation"`
	Status         string    `json:"status"`
	DiscoveredAt   time.Time `json:"discovered_at"`
	FixedAt        *time.Time `json:"fixed_at,omitempty"`
}

var vulnStore = &VulnerabilityStore{
	vulnerabilities: make(map[string][]StoredVulnerability),
	lastScan:        make(map[string]time.Time),
}

// StoreVulnerabilities stores scan results in memory
func (vs *VulnerabilityStore) StoreVulnerabilities(scenarioName string, result *scanners.AggregatedScanResult) {
	vs.mu.Lock()
	defer vs.mu.Unlock()
	
	// Clear existing vulnerabilities for this scenario
	vs.vulnerabilities[scenarioName] = []StoredVulnerability{}
	
	// Store new vulnerabilities
	for _, finding := range result.Findings {
		vuln := StoredVulnerability{
			ID:             finding.ID,
			ScenarioName:   scenarioName,
			Type:           finding.Category,
			Severity:       string(finding.Severity),
			Title:          finding.Title,
			Description:    finding.Description,
			FilePath:       finding.FilePath,
			LineNumber:     finding.LineNumber,
			CodeSnippet:    finding.CodeSnippet,
			Recommendation: finding.Recommendation,
			Status:         "open",
			DiscoveredAt:   time.Now(),
		}
		vs.vulnerabilities[scenarioName] = append(vs.vulnerabilities[scenarioName], vuln)
	}
	
	vs.lastScan[scenarioName] = time.Now()
}

// GetVulnerabilities retrieves vulnerabilities from memory
func (vs *VulnerabilityStore) GetVulnerabilities(scenarioName string) []StoredVulnerability {
	vs.mu.RLock()
	defer vs.mu.RUnlock()
	
	if scenarioName == "" || scenarioName == "all" {
		// Return all vulnerabilities
		var allVulns []StoredVulnerability
		for _, vulns := range vs.vulnerabilities {
			allVulns = append(allVulns, vulns...)
		}
		return allVulns
	}
	
	return vs.vulnerabilities[scenarioName]
}

// GetAllVulnerabilities returns all stored vulnerabilities
func (vs *VulnerabilityStore) GetAllVulnerabilities() []StoredVulnerability {
	return vs.GetVulnerabilities("")
}

// GetLastScanTime returns when a scenario was last scanned
func (vs *VulnerabilityStore) GetLastScanTime(scenarioName string) *time.Time {
	vs.mu.RLock()
	defer vs.mu.RUnlock()
	
	if t, exists := vs.lastScan[scenarioName]; exists {
		return &t
	}
	return nil
}

// ClearVulnerabilities clears vulnerabilities for a scenario
func (vs *VulnerabilityStore) ClearVulnerabilities(scenarioName string) {
	vs.mu.Lock()
	defer vs.mu.Unlock()
	
	delete(vs.vulnerabilities, scenarioName)
	delete(vs.lastScan, scenarioName)
}

// GetStats returns vulnerability statistics
func (vs *VulnerabilityStore) GetStats() map[string]interface{} {
	vs.mu.RLock()
	defer vs.mu.RUnlock()
	
	stats := map[string]interface{}{
		"total": 0,
		"critical": 0,
		"high": 0,
		"medium": 0,
		"low": 0,
		"info": 0,
		"scenarios_with_vulnerabilities": 0,
	}
	
	scenariosWithVulns := make(map[string]bool)
	
	for scenario, vulns := range vs.vulnerabilities {
		if len(vulns) > 0 {
			scenariosWithVulns[scenario] = true
		}
		for _, vuln := range vulns {
			stats["total"] = stats["total"].(int) + 1
			switch vuln.Severity {
			case "critical":
				stats["critical"] = stats["critical"].(int) + 1
			case "high":
				stats["high"] = stats["high"].(int) + 1
			case "medium":
				stats["medium"] = stats["medium"].(int) + 1
			case "low":
				stats["low"] = stats["low"].(int) + 1
			case "info":
				stats["info"] = stats["info"].(int) + 1
			}
		}
	}
	
	stats["scenarios_with_vulnerabilities"] = len(scenariosWithVulns)
	return stats
}