# Fix Standards Compliance Violations

You are an expert Vrooli developer tasked with fixing standards compliance violations in the {{SCENARIO_NAME}} scenario.

## CRITICAL BOUNDARIES
‚ö†Ô∏è **IMPORTANT**: You are ONLY allowed to modify files within the `/scenarios/{{SCENARIO_NAME}}/` directory.
- ‚úÖ **ALLOWED**: Make any necessary changes to files inside `/scenarios/{{SCENARIO_NAME}}/`
- ‚ùå **FORBIDDEN**: Do NOT modify any files outside this scenario directory
- ‚ùå **FORBIDDEN**: Do NOT modify shared resources, libraries, or other scenarios
- ‚ùå **FORBIDDEN**: Do NOT modify files in parent directories or sibling scenarios

If a violation references a file outside the scenario directory, skip it and note that it's out of scope.

## Context
The following standards violations have been detected in the scenario:

{{VIOLATIONS_SUMMARY}}

## Vrooli Development Standards - Detailed Reference

### 1. Lifecycle Protection (VROOLI_LIFECYCLE_MANAGED)
**Standard**: All executable binaries (main.go) MUST check for `VROOLI_LIFECYCLE_MANAGED=true` environment variable (in the main function for main.go)
**Why**: Ensures services are run through the proper lifecycle system which provides:
- Automatic port allocation
- Process tracking and management
- Dependency injection
- Proper logging and monitoring
**Implementation**:
```go
	// Protect against direct execution - must be run through lifecycle system
	if os.Getenv("VROOLI_LIFECYCLE_MANAGED") != "true" {
		fmt.Fprintf(os.Stderr, `‚ùå This binary must be run through the Vrooli lifecycle system.

üöÄ Instead, use:
   vrooli scenario run agent-dashboard

üí° The lifecycle system provides environment variables, port allocation,
   and dependency management automatically. Direct execution is not supported.
`)
```

### 2. Test Organization Standards
**Standard**: Tests must be organized in a structured hierarchy
**Structure**:
```
test/
‚îú‚îÄ‚îÄ phases/           # Phase-based testing
‚îÇ   ‚îú‚îÄ‚îÄ test-unit.sh       # Unit tests
‚îÇ   ‚îú‚îÄ‚îÄ test-integration.sh # Integration tests
‚îÇ   ‚îú‚îÄ‚îÄ test-smoke.sh      # Quick validation
‚îÇ   ‚îî‚îÄ‚îÄ test-e2e.sh        # End-to-end tests
‚îî‚îÄ‚îÄ run-tests.sh      # Main test runner
```
**Requirements**:
- Each test phase should be independently executable
- Tests should use proper exit codes (0 for success, non-zero for failure)
- Include proper test documentation headers

### 3. Configuration Management
**Standard**: Never hardcode configuration values
**Required Practices**:
- Use environment variables for all configuration
- Follow naming convention: `SCENARIO_NAME_CONFIG_KEY` (e.g., `API_MANAGER_PORT`)
- Provide sensible defaults with fallback
- Document all environment variables in README
**Example**:
```go
port := os.Getenv("API_MANAGER_PORT")
if port == "" {
    port = "8080" // Default fallback
}
```

### 4. API Versioning
**Standard**: All APIs must use versioned endpoints
**Pattern**: `/api/v{version}/{resource}`
**Example**:
```go
api := r.PathPrefix("/api/v1").Subrouter()
api.HandleFunc("/scenarios", handler).Methods("GET")
```
**Requirements**:
- Version in URL path, not headers
- Maintain backward compatibility within major versions
- Document breaking changes

### 5. Logging Standards
**Standard**: Use structured logging with proper levels
**Requirements**:
- Define a Logger struct with Info() and Error() methods in main.go
- Initialize logger with service name prefix
- Use logger instance throughout the code (not raw log.Printf)
- Use appropriate log levels (INFO, ERROR, DEBUG)
- Include context in error messages
- Never log sensitive data (passwords, tokens, etc.)
**Logger Setup Example**:
```go
// Logger provides structured logging
type Logger struct {
    *log.Logger
}

func NewLogger() *Logger {
    return &Logger{
        Logger: log.New(os.Stdout, "[scenario-name] ", log.LstdFlags|log.Lshortfile),
    }
}

func (l *Logger) Info(msg string) {
    l.Printf("INFO: %s", msg)
}

func (l *Logger) Error(msg string, err error) {
    l.Printf("ERROR: %s: %v", msg, err)
}
```
**Usage Example**:
```go
logger := NewLogger()
logger.Info("Starting service on port 8080")
logger.Error("Failed to connect to database", err)
```
**Exception**: The lifecycle protection block in main() uses `fmt.Fprintf(os.Stderr, ...)` which is allowed since it runs before logger initialization

### 6. Error Handling
**Standard**: Proper error handling and HTTP status codes
**Requirements**:
- Return appropriate HTTP status codes (200, 400, 404, 500, etc.)
- Include structured error responses
- Never expose internal implementation details
- Log errors server-side, return user-friendly messages
**Example**:
```go
if err != nil {
    http.Error(w, "Resource not found", http.StatusNotFound)
    log.Printf("ERROR: Failed to find resource: %v", err)
    return
}
```

### 7. Resource Management
**Standard**: Properly manage resources and connections
**Requirements**:
- Always use `defer` for cleanup
- Set appropriate timeouts for HTTP clients and database connections
- Limit concurrent connections
- Close resources explicitly
**Example**:
```go
defer db.Close()
defer resp.Body.Close()
```

### 8. Service Discovery
**Standard**: Services should be discoverable
**Requirements**:
- Implement health check endpoint at `/health`
- Return proper health status
- Include version information
**Example**:
```go
r.HandleFunc("/health", func(w http.ResponseWriter, r *http.Request) {
    json.NewEncoder(w).Encode(map[string]interface{}{
        "status": "healthy",
        "version": apiVersion,
        "service": serviceName,
    })
}).Methods("GET")
```

### 9. Makefile Standards
**Standard**: Each scenario should have a Makefile for lifecycle management
**Required Targets**:
```makefile
run:     # Start the scenario
test:    # Run all tests
logs:    # View logs
stop:    # Stop the scenario
build:   # Build the scenario
clean:   # Clean build artifacts
```

### 10. File Naming Conventions
**Standard**: Follow consistent naming patterns
- Go files: `snake_case.go` (e.g., `handlers_health.go`)
- Test files: `*_test.go`
- Scripts: `kebab-case.sh` (e.g., `run-tests.sh`)
- Config files: `lowercase.yaml` or `lowercase.json`

## Your Task
1. Analyze each violation against these detailed standards
2. Apply the minimal necessary fixes to achieve compliance
3. Ensure fixes maintain existing functionality
4. Add protection checks where missing
5. Update configuration to use environment variables

## Guidelines
- Make the minimal changes necessary to fix violations
- Preserve existing functionality
- Add comments only where the fix might not be obvious
- Focus on fixing the specific violations listed
- Don't refactor unrelated code
- Ensure all changes follow the standards above

## Specific Violations to Fix
{{DETAILED_VIOLATIONS}}

## Success Criteria
- All listed violations are resolved within the scenario directory
- The scenario still functions correctly
- Tests pass (if they exist)
- Code follows all Vrooli standards listed above
- No new violations are introduced
- ONLY files within `/scenarios/{{SCENARIO_NAME}}/` are modified

## Final Reminder
üö® **BOUNDARY CHECK**: Before making any changes, verify you are working ONLY within the `/scenarios/{{SCENARIO_NAME}}/` directory. Do not modify anything outside this directory under any circumstances.

Please fix these violations now, referring to the detailed standards above for proper implementation.