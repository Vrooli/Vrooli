import { useEffect } from "react";
import {
  Key,
  Lock,
  RefreshCw,
  AlertCircle,
  CheckCircle2,
  Loader2,
  Shield,
  Download,
  Settings,
} from "lucide-react";
import { Button } from "../ui/button";
import { Alert } from "../ui/alert";
import { Card, CardContent, CardHeader, CardTitle } from "../ui/card";
import { Input } from "../ui/input";
import type { useDeployment } from "../../hooks/useDeployment";
import type { BundleSecretPlan, SecretsSummary } from "../../types/secrets";

interface StepSecretsProps {
  deployment: ReturnType<typeof useDeployment>;
}

export function StepSecrets({ deployment }: StepSecretsProps) {
  const {
    parsedManifest,
    secretsManifest,
    secretsError,
    isFetchingSecrets,
    secretsFetched,
    fetchSecrets,
    providedSecrets,
    setProvidedSecrets,
  } = deployment;

  // Fetch secrets when step loads (only once per session)
  useEffect(() => {
    if (parsedManifest.ok && !secretsFetched && !isFetchingSecrets) {
      fetchSecrets();
    }
  }, [parsedManifest, secretsFetched, isFetchingSecrets, fetchSecrets]);

  // Loading state
  if (isFetchingSecrets) {
    return (
      <div className="flex flex-col items-center justify-center py-12 gap-4">
        <Loader2 className="h-8 w-8 text-blue-400 animate-spin" />
        <p className="text-slate-400">Loading secrets requirements...</p>
      </div>
    );
  }

  // Error state
  if (secretsError) {
    return (
      <div className="space-y-4">
        <Alert variant="error" title="Failed to fetch secrets">
          {secretsError}
        </Alert>
        <Button onClick={fetchSecrets} className="w-full">
          <RefreshCw className="h-4 w-4 mr-2" />
          Retry
        </Button>
      </div>
    );
  }

  // Fetched but no secrets manifest (null = no secrets required)
  if (secretsFetched && !secretsManifest) {
    return <NoSecretsCard />;
  }

  // Not fetched yet
  if (!secretsManifest) {
    return (
      <div className="flex flex-col items-center justify-center py-12 gap-4">
        <Shield className="h-12 w-12 text-slate-500" />
        <p className="text-slate-400">Click to load secrets requirements</p>
        <Button onClick={fetchSecrets}>
          <Download className="h-4 w-4 mr-2" />
          Fetch Secrets
        </Button>
      </div>
    );
  }

  const { bundle_secrets, summary } = secretsManifest;
  const autoGenerated = bundle_secrets.filter((s) => s.class === "per_install_generated");
  const userPrompt = bundle_secrets.filter((s) => s.class === "user_prompt");
  const remoteFetch = bundle_secrets.filter((s) => s.class === "remote_fetch");
  const infrastructure = bundle_secrets.filter((s) => s.class === "infrastructure");

  return (
    <div className="space-y-6">
      {/* Summary */}
      <SummaryCard summary={summary} />

      {/* No secrets needed */}
      {bundle_secrets.length === 0 && <NoSecretsCard />}

      {/* Infrastructure secrets */}
      {infrastructure.length > 0 && (
        <SecretsSection
          title="Infrastructure"
          icon={<Settings className="h-4 w-4 text-slate-400" />}
          description="These configuration values are set by the deployment system"
          secrets={infrastructure}
        />
      )}

      {/* Auto-generated secrets */}
      {autoGenerated.length > 0 && (
        <SecretsSection
          title="Auto-Generated"
          icon={<Lock className="h-4 w-4 text-emerald-400" />}
          description="These will be generated automatically during deployment"
          secrets={autoGenerated}
        />
      )}

      {/* User-provided secrets */}
      {userPrompt.length > 0 && (
        <UserPromptSection
          secrets={userPrompt}
          providedSecrets={providedSecrets}
          onSecretChange={setProvidedSecrets}
        />
      )}

      {/* Remote-fetch secrets */}
      {remoteFetch.length > 0 && (
        <SecretsSection
          title="Remote Fetch"
          icon={<RefreshCw className="h-4 w-4 text-blue-400" />}
          description="These will be fetched from external sources during deployment"
          secrets={remoteFetch}
        />
      )}
    </div>
  );
}

function SummaryCard({ summary }: { summary: SecretsSummary }) {
  return (
    <Card>
      <CardContent className="py-4">
        <div className="grid grid-cols-5 gap-4 text-center">
          <SummaryStat
            label="Total"
            value={summary.total_secrets}
            icon={<Shield className="h-4 w-4 text-slate-400" />}
          />
          <SummaryStat
            label="Config"
            value={summary.infrastructure}
            icon={<Settings className="h-4 w-4 text-slate-400" />}
          />
          <SummaryStat
            label="Auto"
            value={summary.per_install_generated}
            icon={<Lock className="h-4 w-4 text-emerald-400" />}
          />
          <SummaryStat
            label="Required"
            value={summary.user_prompt}
            icon={<Key className="h-4 w-4 text-amber-400" />}
          />
          <SummaryStat
            label="Fetch"
            value={summary.remote_fetch}
            icon={<RefreshCw className="h-4 w-4 text-blue-400" />}
          />
        </div>
      </CardContent>
    </Card>
  );
}

function SummaryStat({
  label,
  value,
  icon,
}: {
  label: string;
  value: number;
  icon: React.ReactNode;
}) {
  return (
    <div className="flex flex-col items-center gap-1">
      {icon}
      <span className="text-lg font-semibold text-slate-200">{value}</span>
      <span className="text-xs text-slate-500">{label}</span>
    </div>
  );
}

function NoSecretsCard() {
  return (
    <Card>
      <CardContent className="py-8">
        <div className="flex flex-col items-center gap-3 text-center">
          <CheckCircle2 className="h-12 w-12 text-emerald-400" />
          <h3 className="font-medium text-slate-200">No Secrets Required</h3>
          <p className="text-sm text-slate-400">
            This deployment doesn't require any secrets. You can proceed to the
            next step.
          </p>
        </div>
      </CardContent>
    </Card>
  );
}

function SecretsSection({
  title,
  icon,
  description,
  secrets,
}: {
  title: string;
  icon: React.ReactNode;
  description: string;
  secrets: BundleSecretPlan[];
}) {
  return (
    <Card>
      <CardHeader className="pb-2">
        <CardTitle className="flex items-center gap-2 text-base">
          {icon}
          {title}
        </CardTitle>
        <p className="text-sm text-slate-400">{description}</p>
      </CardHeader>
      <CardContent>
        <ul className="space-y-2">
          {secrets.map((secret) => (
            <li
              key={secret.id}
              className="flex items-start gap-3 text-sm py-2 border-b border-slate-800 last:border-0"
            >
              <Lock className="h-4 w-4 text-slate-500 mt-0.5 flex-shrink-0" />
              <div>
                <span className="font-mono text-slate-300">
                  {secret.target.name || secret.id}
                </span>
                {secret.description && (
                  <p className="text-xs text-slate-500 mt-0.5">
                    {secret.description}
                  </p>
                )}
              </div>
            </li>
          ))}
        </ul>
      </CardContent>
    </Card>
  );
}

function UserPromptSection({
  secrets,
  providedSecrets,
  onSecretChange,
}: {
  secrets: BundleSecretPlan[];
  providedSecrets: Record<string, string>;
  onSecretChange: (key: string, value: string) => void;
}) {
  return (
    <Card>
      <CardHeader className="pb-2">
        <CardTitle className="flex items-center gap-2 text-base">
          <Key className="h-4 w-4 text-amber-400" />
          Required Credentials
        </CardTitle>
        <p className="text-sm text-slate-400">
          Please provide values for these secrets
        </p>
      </CardHeader>
      <CardContent>
        <div className="space-y-4">
          {secrets.map((secret) => {
            const key = secret.target.name || secret.id;
            const value = providedSecrets[key] || "";
            const label = secret.prompt?.label || key;
            const hasValue = value.trim().length > 0;

            return (
              <div key={secret.id} className="space-y-1.5">
                <div className="flex items-center gap-2">
                  <label
                    htmlFor={`secret-${secret.id}`}
                    className="text-sm font-medium text-slate-300"
                  >
                    {label}
                  </label>
                  {secret.required && (
                    <span className="text-xs px-1.5 py-0.5 rounded bg-red-500/20 text-red-400">
                      Required
                    </span>
                  )}
                  {hasValue && (
                    <CheckCircle2 className="h-3.5 w-3.5 text-emerald-400" />
                  )}
                </div>
                {secret.prompt?.description && (
                  <p className="text-xs text-slate-500">
                    {secret.prompt.description}
                  </p>
                )}
                <Input
                  id={`secret-${secret.id}`}
                  type="password"
                  value={value}
                  onChange={(e) => onSecretChange(key, e.target.value)}
                  placeholder={`Enter ${label}...`}
                  className="font-mono"
                />
              </div>
            );
          })}
        </div>

        {/* Validation hint */}
        {secrets.some((s) => s.required) && (
          <div className="mt-4 flex items-start gap-2 text-xs text-slate-500">
            <AlertCircle className="h-3.5 w-3.5 mt-0.5 flex-shrink-0" />
            <span>
              All required secrets must be provided before proceeding. Values
              are sent securely during deployment.
            </span>
          </div>
        )}
      </CardContent>
    </Card>
  );
}
