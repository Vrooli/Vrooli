#\!/bin/bash
# Smart File Photo Manager CLI
# Lightweight wrapper for the Smart File Photo Manager API

set -euo pipefail

# Configuration
API_BASE_URL="${SMART_FILE_MANAGER_API_URL:-http://localhost:8090}"
VERSION="1.0.0"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Helper functions
log_info() {
    echo -e "${BLUE}[INFO]${NC} $1"
}

log_success() {
    echo -e "${GREEN}[SUCCESS]${NC} $1"
}

log_warning() {
    echo -e "${YELLOW}[WARNING]${NC} $1"
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

# Check if API is available
check_api() {
    if \! curl -sf "${API_BASE_URL}/health" > /dev/null 2>&1; then
        log_error "Smart File Photo Manager API is not available at ${API_BASE_URL}"
        log_info "Make sure the API server is running"
        exit 1
    fi
}

# Show usage information
show_help() {
    cat << EOF
Smart File Photo Manager CLI v${VERSION}

USAGE:
    smart-file-photo-manager [COMMAND] [OPTIONS]

COMMANDS:
    files           List and manage files
    search          Search files by content or metadata
    upload          Upload new files
    organize        Organize files automatically
    suggestions     Manage AI suggestions
    folders         Manage folders
    stats           Show system statistics
    health          Check API health
    help            Show this help message

FILE COMMANDS:
    files list [--folder PATH] [--type TYPE] [--status STATUS] [--limit N]
    files get <file-id>
    files delete <file-id>
    files download <file-id> [--output PATH]

SEARCH COMMANDS:
    search text <query> [--limit N]
    search semantic <query> [--limit N]
    search visual <query> [--limit N]

UPLOAD COMMANDS:
    upload file <path> [--folder FOLDER] [--tags TAG1,TAG2]
    upload batch <directory> [--folder FOLDER] [--recursive]

ORGANIZE COMMANDS:
    organize auto [--folder PATH] [--dry-run]
    organize suggestions [--auto-apply]
    organize duplicates [--action merge|delete|flag]

SUGGESTION COMMANDS:
    suggestions list [--type TYPE] [--status STATUS]
    suggestions accept <suggestion-id>
    suggestions reject <suggestion-id>
    suggestions apply <suggestion-id>

FOLDER COMMANDS:
    folders list [--path PATH]
    folders create <path> [--smart] [--query QUERY]
    folders delete <path>

STATS COMMANDS:
    stats overview
    stats files [--type TYPE]
    stats processing

OPTIONS:
    --api-url URL   Override API base URL (default: ${API_BASE_URL})
    --json          Output in JSON format
    --verbose       Enable verbose output
    --help          Show help for specific command

EXAMPLES:
    smart-file-photo-manager files list --folder /photos --type image
    smart-file-photo-manager search text "vacation photos"
    smart-file-photo-manager upload file photo.jpg --folder /photos/2024
    smart-file-photo-manager organize auto --dry-run
    smart-file-photo-manager suggestions list --status pending

ENVIRONMENT VARIABLES:
    SMART_FILE_MANAGER_API_URL    API base URL (default: http://localhost:8090)

EOF
}

# Make API request
api_request() {
    local method="$1"
    local endpoint="$2"
    local data="${3:-}"
    
    local curl_opts=(-s -X "$method" -H "Content-Type: application/json")
    
    if [ -n "$data" ]; then
        curl_opts+=(-d "$data")
    fi
    
    curl "${curl_opts[@]}" "${API_BASE_URL}${endpoint}"
}

# Files commands
cmd_files() {
    local subcmd="${1:-list}"
    shift || true
    
    case "$subcmd" in
        list)
            local folder="/"
            local file_type=""
            local status=""
            local limit="50"
            
            while [[ $# -gt 0 ]]; do
                case $1 in
                    --folder)
                        folder="$2"
                        shift 2
                        ;;
                    --type)
                        file_type="$2"
                        shift 2
                        ;;
                    --status)
                        status="$2"
                        shift 2
                        ;;
                    --limit)
                        limit="$2"
                        shift 2
                        ;;
                    *)
                        log_error "Unknown option: $1"
                        exit 1
                        ;;
                esac
            done
            
            local query="?folder=${folder}&limit=${limit}"
            [ -n "$file_type" ] && query="${query}&type=${file_type}"
            [ -n "$status" ] && query="${query}&status=${status}"
            
            api_request "GET" "/api/files${query}"
            ;;
        get)
            local file_id="$1"
            [ -z "$file_id" ] && { log_error "File ID required"; exit 1; }
            
            api_request "GET" "/api/files/${file_id}"
            ;;
        delete)
            local file_id="$1"
            [ -z "$file_id" ] && { log_error "File ID required"; exit 1; }
            
            api_request "DELETE" "/api/files/${file_id}"
            ;;
        download)
            local file_id="$1"
            [ -z "$file_id" ] && { log_error "File ID required"; exit 1; }
            
            log_info "Downloading file ${file_id}..."
            curl -sf "${API_BASE_URL}/api/files/${file_id}/download"
            ;;
        *)
            log_error "Unknown files command: $subcmd"
            exit 1
            ;;
    esac
}

# Search commands
cmd_search() {
    local search_type="${1:-text}"
    local query="$2"
    shift 2 || true
    
    [ -z "$query" ] && { log_error "Search query required"; exit 1; }
    
    local limit="20"
    
    while [[ $# -gt 0 ]]; do
        case $1 in
            --limit)
                limit="$2"
                shift 2
                ;;
            *)
                log_error "Unknown option: $1"
                exit 1
                ;;
        esac
    done
    
    local search_data=$(cat << EOF
{
    "query": "$query",
    "type": "$search_type",
    "limit": $limit
}
EOF
    )
    
    api_request "POST" "/api/search" "$search_data"
}

# Upload commands
cmd_upload() {
    local subcmd="${1:-file}"
    shift || true
    
    case "$subcmd" in
        file)
            local file_path="$1"
            [ -z "$file_path" ] && { log_error "File path required"; exit 1; }
            [ \! -f "$file_path" ] && { log_error "File not found: $file_path"; exit 1; }
            
            shift
            local folder="/"
            local tags=""
            
            while [[ $# -gt 0 ]]; do
                case $1 in
                    --folder)
                        folder="$2"
                        shift 2
                        ;;
                    --tags)
                        tags="$2"
                        shift 2
                        ;;
                    *)
                        log_error "Unknown option: $1"
                        exit 1
                        ;;
                esac
            done
            
            log_info "Uploading file: $file_path"
            log_warning "File upload implementation requires integration with MinIO storage"
            log_info "This would typically involve:"
            log_info "1. Computing file hash"
            log_info "2. Uploading to MinIO storage"
            log_info "3. Registering with API"
            ;;
        batch)
            log_info "Batch upload implementation pending"
            ;;
        *)
            log_error "Unknown upload command: $subcmd"
            exit 1
            ;;
    esac
}

# Organize commands
cmd_organize() {
    local subcmd="${1:-auto}"
    shift || true
    
    case "$subcmd" in
        auto)
            local folder=""
            local dry_run=false
            
            while [[ $# -gt 0 ]]; do
                case $1 in
                    --folder)
                        folder="$2"
                        shift 2
                        ;;
                    --dry-run)
                        dry_run=true
                        shift
                        ;;
                    *)
                        log_error "Unknown option: $1"
                        exit 1
                        ;;
                esac
            done
            
            local organize_data=$(cat << EOF
{
    "operation": "auto_organize",
    "folder_path": "$folder",
    "dry_run": $dry_run
}
EOF
            )
            
            api_request "POST" "/api/organize" "$organize_data"
            ;;
        suggestions)
            api_request "POST" "/api/organize" '{"operation": "apply_suggestions"}'
            ;;
        duplicates)
            api_request "POST" "/api/find-duplicates" '{}'
            ;;
        *)
            log_error "Unknown organize command: $subcmd"
            exit 1
            ;;
    esac
}

# Suggestions commands
cmd_suggestions() {
    local subcmd="${1:-list}"
    shift || true
    
    case "$subcmd" in
        list)
            local suggestion_type=""
            local status=""
            
            while [[ $# -gt 0 ]]; do
                case $1 in
                    --type)
                        suggestion_type="$2"
                        shift 2
                        ;;
                    --status)
                        status="$2"
                        shift 2
                        ;;
                    *)
                        log_error "Unknown option: $1"
                        exit 1
                        ;;
                esac
            done
            
            local query="?"
            [ -n "$suggestion_type" ] && query="${query}type=${suggestion_type}&"
            [ -n "$status" ] && query="${query}status=${status}"
            
            api_request "GET" "/api/suggestions${query}"
            ;;
        accept|reject|apply)
            local suggestion_id="$1"
            [ -z "$suggestion_id" ] && { log_error "Suggestion ID required"; exit 1; }
            
            if [ "$subcmd" = "apply" ]; then
                api_request "POST" "/api/suggestions/${suggestion_id}/apply"
            else
                local update_data='{"status": "'$subcmd'ed"}'
                api_request "PUT" "/api/suggestions/${suggestion_id}" "$update_data"
            fi
            ;;
        *)
            log_error "Unknown suggestions command: $subcmd"
            exit 1
            ;;
    esac
}

# Folders commands
cmd_folders() {
    local subcmd="${1:-list}"
    shift || true
    
    case "$subcmd" in
        list)
            api_request "GET" "/api/folders"
            ;;
        create)
            local path="$1"
            [ -z "$path" ] && { log_error "Folder path required"; exit 1; }
            shift
            
            local is_smart=false
            local query=""
            
            while [[ $# -gt 0 ]]; do
                case $1 in
                    --smart)
                        is_smart=true
                        shift
                        ;;
                    --query)
                        query="$2"
                        shift 2
                        ;;
                    *)
                        log_error "Unknown option: $1"
                        exit 1
                        ;;
                esac
            done
            
            local folder_data=$(cat << EOF
{
    "path": "$path",
    "is_smart": $is_smart,
    "smart_query": "$query"
}
EOF
            )
            
            api_request "POST" "/api/folders" "$folder_data"
            ;;
        delete)
            local path="$1"
            [ -z "$path" ] && { log_error "Folder path required"; exit 1; }
            
            api_request "DELETE" "/api/folders/${path}"
            ;;
        *)
            log_error "Unknown folders command: $subcmd"
            exit 1
            ;;
    esac
}

# Stats commands
cmd_stats() {
    local subcmd="${1:-overview}"
    shift || true
    
    case "$subcmd" in
        overview)
            api_request "GET" "/api/stats"
            ;;
        files)
            api_request "GET" "/api/stats/files"
            ;;
        processing)
            api_request "GET" "/api/stats/processing"
            ;;
        *)
            log_error "Unknown stats command: $subcmd"
            exit 1
            ;;
    esac
}

# Health command
cmd_health() {
    if api_request "GET" "/health" | jq -e '.status == "ok"' > /dev/null 2>&1; then
        log_success "Smart File Photo Manager API is healthy"
    else
        log_error "Smart File Photo Manager API health check failed"
        exit 1
    fi
}

# Main command dispatcher
main() {
    # Parse global options
    while [[ $# -gt 0 ]]; do
        case $1 in
            --api-url)
                API_BASE_URL="$2"
                shift 2
                ;;
            --help)
                show_help
                exit 0
                ;;
            --version)
                echo "Smart File Photo Manager CLI v${VERSION}"
                exit 0
                ;;
            -*)
                log_error "Unknown global option: $1"
                exit 1
                ;;
            *)
                break
                ;;
        esac
    done
    
    # Get command
    local command="${1:-help}"
    shift || true
    
    # Check API availability for most commands
    case "$command" in
        help|--help)
            show_help
            exit 0
            ;;
        *)
            check_api
            ;;
    esac
    
    # Dispatch to command handlers
    case "$command" in
        files)
            cmd_files "$@"
            ;;
        search)
            cmd_search "$@"
            ;;
        upload)
            cmd_upload "$@"
            ;;
        organize)
            cmd_organize "$@"
            ;;
        suggestions)
            cmd_suggestions "$@"
            ;;
        folders)
            cmd_folders "$@"
            ;;
        stats)
            cmd_stats "$@"
            ;;
        health)
            cmd_health
            ;;
        *)
            log_error "Unknown command: $command"
            log_info "Run 'smart-file-photo-manager help' for usage information"
            exit 1
            ;;
    esac
}

# Execute main function if script is run directly
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    main "$@"
fi
