{
  "name": "Text Processing Pipeline",
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "text-process",
        "responseMode": "responseNode",
        "options": {}
      },
      "id": "webhook_trigger",
      "name": "Webhook Trigger",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 1.1,
      "position": [200, 300]
    },
    {
      "parameters": {},
      "id": "manual_trigger",
      "name": "Manual Trigger",
      "type": "n8n-nodes-base.manualTrigger",
      "typeVersion": 1,
      "position": [200, 500]
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// Test defaults for manual execution\nreturn {\n  text: 'Sample text for processing. This is a test document with multiple lines.\\nIt contains various elements for testing.',\n  operations: ['stats', 'language'],\n  format: 'plain'\n};"
      },
      "id": "set_test_defaults",
      "name": "Set Test Defaults",
      "type": "n8n-nodes-base.code",
      "typeVersion": 1,
      "position": [400, 500]
    },
    {
      "parameters": {},
      "id": "merge_triggers",
      "name": "Merge Triggers",
      "type": "n8n-nodes-base.merge",
      "typeVersion": 2.1,
      "position": [600, 400]
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// Validate and prepare text processing request\nconst input = $input.item.json;\n\n// Validate required fields\nif (!input.text || typeof input.text !== 'string') {\n  throw new Error('Missing required parameter: text');\n}\n\nif (input.text.length > 1000000) {\n  throw new Error('Text too large (max 1MB)');\n}\n\n// Get operations to perform\nconst operations = Array.isArray(input.operations) ? input.operations : ['stats'];\nconst format = input.format || 'plain';\n\n// Build commands for each operation\nconst commands = [];\nconst timestamp = Date.now();\nconst tempFile = `/tmp/text_${timestamp}.txt`;\n\n// Save text to temp file\nconst saveCmd = `echo '${input.text.replace(/'/g, \"'\\\"'\\\"'\")}' > ${tempFile}`;\ncommands.push(saveCmd);\n\n// Add operation commands\nif (operations.includes('stats')) {\n  commands.push(`wc -l ${tempFile} | awk '{print \"lines: \"$1}'`);\n  commands.push(`wc -w ${tempFile} | awk '{print \"words: \"$1}'`);\n  commands.push(`wc -c ${tempFile} | awk '{print \"chars: \"$1}'`);\n}\n\nif (operations.includes('language')) {\n  // Use text-tools CLI for language detection\n  commands.push(`text-tools analyze --language ${tempFile} 2>/dev/null || echo \"language: unknown\"`);\n}\n\nif (operations.includes('entities')) {\n  commands.push(`text-tools analyze --entities ${tempFile} 2>/dev/null || echo \"entities: []\"`);\n}\n\nif (operations.includes('keywords')) {\n  commands.push(`text-tools analyze --keywords ${tempFile} 2>/dev/null || echo \"keywords: []\"`);\n}\n\n// Cleanup\ncommands.push(`rm -f ${tempFile}`);\n\n// Join all commands\nconst command = commands.join('; ');\n\nreturn {\n  command: command,\n  operations: operations,\n  format: format,\n  temp_file: tempFile,\n  text_length: input.text.length,\n  timestamp: new Date().toISOString()\n};"
      },
      "id": "prepare_commands",
      "name": "Prepare Commands",
      "type": "n8n-nodes-base.code",
      "typeVersion": 1,
      "position": [800, 400]
    },
    {
      "parameters": {
        "command": "={{ $json.command }}",
        "options": {
          "timeout": 30000
        }
      },
      "id": "execute_processing",
      "name": "Execute Processing",
      "type": "n8n-nodes-base.executeCommand",
      "typeVersion": 1,
      "position": [1000, 400]
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// Format the processing results\nconst commandResult = $input.item.json;\nconst metadata = $('Prepare Commands').item.json;\n\nconst success = commandResult.exitCode === 0;\nconst output = commandResult.stdout || '';\n\n// Parse output into structured data\nconst results = {};\nconst lines = output.split('\\n').filter(line => line.trim());\n\nfor (const line of lines) {\n  const [key, value] = line.split(':').map(s => s.trim());\n  if (key && value) {\n    // Try to parse JSON values\n    if (value.startsWith('[') || value.startsWith('{')) {\n      try {\n        results[key] = JSON.parse(value);\n      } catch {\n        results[key] = value;\n      }\n    } else if (!isNaN(value)) {\n      results[key] = parseInt(value);\n    } else {\n      results[key] = value;\n    }\n  }\n}\n\nreturn {\n  success: success,\n  results: results,\n  operations_performed: metadata.operations,\n  format: metadata.format,\n  text_length: metadata.text_length,\n  processing_time_ms: Date.now() - new Date(metadata.timestamp).getTime(),\n  timestamp: metadata.timestamp,\n  error: success ? null : commandResult.stderr\n};"
      },
      "id": "format_results",
      "name": "Format Results",
      "type": "n8n-nodes-base.code",
      "typeVersion": 1,
      "position": [1200, 400]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ JSON.stringify($json, null, 2) }}",
        "responseHeaders": {
          "entries": [
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        }
      },
      "id": "webhook_response",
      "name": "Webhook Response",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1,
      "position": [1400, 400]
    }
  ],
  "connections": {
    "webhook_trigger": {
      "main": [[{"node": "merge_triggers", "type": "main", "index": 0}]]
    },
    "manual_trigger": {
      "main": [[{"node": "set_test_defaults", "type": "main", "index": 0}]]
    },
    "set_test_defaults": {
      "main": [[{"node": "merge_triggers", "type": "main", "index": 1}]]
    },
    "merge_triggers": {
      "main": [[{"node": "prepare_commands", "type": "main", "index": 0}]]
    },
    "prepare_commands": {
      "main": [[{"node": "execute_processing", "type": "main", "index": 0}]]
    },
    "execute_processing": {
      "main": [[{"node": "format_results", "type": "main", "index": 0}]]
    },
    "format_results": {
      "main": [[{"node": "webhook_response", "type": "main", "index": 0}]]
    }
  },
  "active": false,
  "settings": {
    "executionOrder": "v1"
  },
  "versionId": "text-tools-v1",
  "id": "text-processing-pipeline",
  "meta": {
    "instanceId": "text-tools"
  },
  "tags": []
}