#!/bin/bash

# Data Structurer CLI
# Command-line interface for the data-structurer scenario

set -euo pipefail

# Configuration
# Try to get port from multiple sources in order of preference:
# 1. DATA_STRUCTURER_API_PORT (scenario-specific)
# 2. DATA_STRUCTURER_API_URL (full URL override)
# 3. API_PORT (generic, may be wrong if multiple scenarios running)
# 4. Default 15774 (data-structurer's typical port)
SCENARIO_PORT="${DATA_STRUCTURER_API_PORT:-${API_PORT:-15774}}"
API_BASE_URL="${DATA_STRUCTURER_API_URL:-http://localhost:${SCENARIO_PORT}}"
CONFIG_DIR="$HOME/.vrooli/data-structurer"
CONFIG_FILE="$CONFIG_DIR/config.yaml"

# Ensure config directory exists
mkdir -p "$CONFIG_DIR"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Logging functions
log_info() {
    echo -e "${BLUE}[INFO]${NC} $1"
}

log_success() {
    echo -e "${GREEN}[SUCCESS]${NC} $1"
}

log_warning() {
    echo -e "${YELLOW}[WARN]${NC} $1"
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $1" >&2
}

# HTTP helper functions
api_get() {
    local endpoint="$1"
    local output_file="${2:-}"
    
    if [[ -n "$output_file" ]]; then
        curl -s -f "$API_BASE_URL/api/v1$endpoint" -o "$output_file" || {
            log_error "Failed to GET $endpoint"
            return 1
        }
    else
        curl -s -f "$API_BASE_URL/api/v1$endpoint" || {
            log_error "Failed to GET $endpoint"
            return 1
        }
    fi
}

api_post() {
    local endpoint="$1"
    local data="$2"
    
    curl -s -f -X POST "$API_BASE_URL/api/v1$endpoint" \
        -H "Content-Type: application/json" \
        -d "$data" || {
        log_error "Failed to POST to $endpoint"
        return 1
    }
}

api_put() {
    local endpoint="$1"
    local data="$2"
    
    curl -s -f -X PUT "$API_BASE_URL/api/v1$endpoint" \
        -H "Content-Type: application/json" \
        -d "$data" || {
        log_error "Failed to PUT to $endpoint"
        return 1
    }
}

api_delete() {
    local endpoint="$1"
    
    curl -s -f -X DELETE "$API_BASE_URL/api/v1$endpoint" || {
        log_error "Failed to DELETE $endpoint"
        return 1
    }
}

# Check if jq is available
check_jq() {
    if ! command -v jq &> /dev/null; then
        log_error "jq is required but not installed. Please install jq to continue."
        exit 1
    fi
}

# Format JSON output based on flags
format_output() {
    local json_data="$1"
    local format="${2:-human}"
    
    if [[ "$format" == "json" ]]; then
        echo "$json_data" | jq .
    else
        # Human readable format (implement based on data structure)
        echo "$json_data"
    fi
}

# Show usage information
show_usage() {
    cat << EOF
Data Structurer CLI - Transform unstructured data into structured formats

USAGE:
    data-structurer <COMMAND> [OPTIONS]

COMMANDS:
    status                          Show operational status and resource health
    help                           Display this help message
    version                        Show version information

    create-schema <name> <schema>  Create a new data schema
    list-schemas                   List all available schemas  
    get-schema <id>                Get schema details
    update-schema <id> [options]   Update an existing schema
    delete-schema <id>             Delete a schema

    list-templates                 List available schema templates
    get-template <id>              Get template details
    create-from-template <id>      Create schema from template

    process <schema-id> <input>    Process unstructured data
    get-result <processing-id>     Get processing result
    get-data <schema-id>           Get all processed data for schema

    list-jobs                      List processing jobs
    get-job <id>                   Get job details

FLAGS:
    --json                         Output in JSON format
    --verbose                      Enable verbose output
    --help                         Show help for specific command

EXAMPLES:
    # Create a schema
    data-structurer create-schema "contacts" ./contact-schema.json

    # Process a document
    data-structurer process abc-123-def ./document.pdf

    # List all schemas
    data-structurer list-schemas --json

    # Get processing results
    data-structurer get-data abc-123-def --format csv

For more information on a specific command:
    data-structurer <command> --help

EOF
}

# Show version information
show_version() {
    local format="${1:-human}"
    
    local version_info='{
        "version": "1.0.0",
        "api_version": "v1",
        "cli_version": "1.0.0",
        "api_url": "'$API_BASE_URL'"
    }'
    
    if [[ "$format" == "json" ]]; then
        echo "$version_info" | jq .
    else
        echo "Data Structurer CLI v1.0.0"
        echo "API Version: v1"
        echo "API URL: $API_BASE_URL"
    fi
}

# Show system status
show_status() {
    local format="${1:-human}"
    local verbose="${2:-false}"
    
    log_info "Checking Data Structurer status..."
    
    # Check API health
    local health_data
    health_data=$(curl -s -f "$API_BASE_URL/health" 2>/dev/null) || {
        local error_data='{
            "status": "unhealthy",
            "error": "API unreachable",
            "api_url": "'$API_BASE_URL'"
        }'
        format_output "$error_data" "$format"
        return 1
    }
    
    if [[ "$format" == "json" ]]; then
        echo "$health_data" | jq .
    else
        local status=$(echo "$health_data" | jq -r '.status')
        local service=$(echo "$health_data" | jq -r '.service')
        local timestamp=$(echo "$health_data" | jq -r '.timestamp')
        local database=$(echo "$health_data" | jq -r '.database // "unknown"')
        
        echo "Service: $service"
        echo "Status: $status"
        echo "Database: $database"
        echo "API URL: $API_BASE_URL"
        echo "Timestamp: $(date -d @$timestamp 2>/dev/null || echo $timestamp)"
        
        if [[ "$verbose" == "true" ]]; then
            echo
            echo "Additional Details:"
            echo "$health_data" | jq .
        fi
    fi
}

# Schema management commands
cmd_create_schema() {
    local name="$1"
    local schema_file="$2"
    local description="${3:-}"
    
    if [[ ! -f "$schema_file" ]]; then
        log_error "Schema file not found: $schema_file"
        return 1
    fi
    
    # Read and validate schema file
    local schema_def
    schema_def=$(cat "$schema_file") || {
        log_error "Failed to read schema file"
        return 1
    }
    
    # Validate JSON
    echo "$schema_def" | jq . > /dev/null || {
        log_error "Invalid JSON in schema file"
        return 1
    }
    
    # Prepare request data
    local request_data
    request_data=$(jq -n \
        --arg name "$name" \
        --arg description "$description" \
        --argjson schema_definition "$schema_def" \
        '{
            name: $name,
            description: $description,
            schema_definition: $schema_definition
        }')
    
    log_info "Creating schema: $name"
    local result
    result=$(api_post "/schemas" "$request_data") || return 1
    
    local schema_id=$(echo "$result" | jq -r '.id')
    log_success "Schema created successfully: $schema_id"
    echo "$result" | jq .
}

cmd_list_schemas() {
    local format="${1:-human}"
    
    log_info "Fetching schemas..."
    local result
    result=$(api_get "/schemas") || return 1
    
    if [[ "$format" == "json" ]]; then
        echo "$result" | jq .
    else
        local count=$(echo "$result" | jq -r '.count')
        echo "Found $count schemas:"
        echo
        
        echo "$result" | jq -r '.schemas[] | [.id, .name, .version, .usage_count] | @tsv' | \
        while IFS=$'\t' read -r id name version usage; do
            printf "%-36s %-30s v%-3s (%d uses)\n" "$id" "$name" "$version" "$usage"
        done
    fi
}

cmd_get_schema() {
    local schema_id="$1"
    local format="${2:-human}"
    
    log_info "Fetching schema: $schema_id"
    local result
    result=$(api_get "/schemas/$schema_id") || return 1
    
    if [[ "$format" == "json" ]]; then
        echo "$result" | jq .
    else
        local name=$(echo "$result" | jq -r '.name')
        local description=$(echo "$result" | jq -r '.description // "No description"')
        local version=$(echo "$result" | jq -r '.version')
        local usage_count=$(echo "$result" | jq -r '.usage_count')
        local avg_confidence=$(echo "$result" | jq -r '.avg_confidence')
        
        echo "Schema: $name"
        echo "ID: $schema_id"
        echo "Description: $description"
        echo "Version: $version"
        echo "Usage Count: $usage_count"
        echo "Avg Confidence: $avg_confidence"
        echo
        echo "Schema Definition:"
        echo "$result" | jq '.schema_definition'
        
        if echo "$result" | jq -e '.example_data' > /dev/null 2>&1; then
            echo
            echo "Example Data:"
            echo "$result" | jq '.example_data'
        fi
    fi
}

cmd_delete_schema() {
    local schema_id="$1"
    
    log_info "Deleting schema: $schema_id"
    local result
    result=$(api_delete "/schemas/$schema_id") || return 1
    
    log_success "Schema deleted successfully"
    echo "$result" | jq .
}

# Schema template commands
cmd_list_templates() {
    local category="${1:-}"
    local format="${2:-human}"
    
    local endpoint="/schema-templates"
    if [[ -n "$category" ]]; then
        endpoint="$endpoint?category=$category"
    fi
    
    log_info "Fetching schema templates..."
    local result
    result=$(api_get "$endpoint") || return 1
    
    if [[ "$format" == "json" ]]; then
        echo "$result" | jq .
    else
        local count=$(echo "$result" | jq -r '.count')
        echo "Found $count templates:"
        echo
        
        echo "$result" | jq -r '.templates[] | [.name, .category, .description, .usage_count] | @tsv' | \
        while IFS=$'\t' read -r name category description usage; do
            printf "%-25s %-15s %-50s (%d uses)\n" "$name" "$category" "$description" "$usage"
        done
    fi
}

cmd_create_from_template() {
    local template_id="$1"
    local name="$2"
    local description="${3:-}"
    
    # Prepare request data
    local request_data
    request_data=$(jq -n \
        --arg name "$name" \
        --arg description "$description" \
        '{
            name: $name,
            description: $description
        }')
    
    log_info "Creating schema from template: $template_id"
    local result
    result=$(api_post "/schemas/from-template/$template_id" "$request_data") || return 1
    
    local schema_id=$(echo "$result" | jq -r '.id')
    log_success "Schema created from template: $schema_id"
    echo "$result" | jq .
}

# Data processing commands
cmd_process() {
    local schema_id="$1"
    local input="$2"
    local input_type="${3:-auto}"
    local batch_mode="${4:-false}"
    
    # Auto-detect input type if not specified
    if [[ "$input_type" == "auto" ]]; then
        if [[ -f "$input" ]]; then
            input_type="file"
        elif [[ "$input" =~ ^https?:// ]]; then
            input_type="url"
        else
            input_type="text"
        fi
    fi
    
    # Prepare input data based on type
    local input_data
    if [[ "$input_type" == "file" ]]; then
        if [[ ! -f "$input" ]]; then
            log_error "File not found: $input"
            return 1
        fi
        input_data="$input"  # For file type, pass the path
    else
        input_data="$input"
    fi
    
    # Prepare request data
    local request_data
    request_data=$(jq -n \
        --arg schema_id "$schema_id" \
        --arg input_type "$input_type" \
        --arg input_data "$input_data" \
        --argjson batch_mode "$batch_mode" \
        '{
            schema_id: $schema_id,
            input_type: $input_type,
            input_data: $input_data,
            batch_mode: $batch_mode
        }')
    
    log_info "Processing data with schema: $schema_id"
    log_info "Input type: $input_type"
    
    local result
    result=$(api_post "/process" "$request_data") || return 1
    
    local processing_id=$(echo "$result" | jq -r '.processing_id')
    local status=$(echo "$result" | jq -r '.status')
    
    if [[ "$status" == "completed" ]]; then
        log_success "Processing completed: $processing_id"
        echo
        echo "Structured Data:"
        echo "$result" | jq '.structured_data'
        
        local confidence=$(echo "$result" | jq -r '.confidence_score // "N/A"')
        echo
        echo "Confidence Score: $confidence"
    elif [[ "$status" == "failed" ]]; then
        log_error "Processing failed: $processing_id"
        echo "$result" | jq '.errors[]?' 2>/dev/null || echo "No error details available"
    else
        log_info "Processing started: $processing_id"
        echo "Status: $status"
        echo "Use 'data-structurer get-result $processing_id' to check progress"
    fi
    
    echo
    echo "Processing ID: $processing_id"
}

cmd_get_result() {
    local processing_id="$1"
    local format="${2:-human}"
    
    log_info "Fetching processing result: $processing_id"
    local result
    result=$(api_get "/process/$processing_id") || return 1
    
    if [[ "$format" == "json" ]]; then
        echo "$result" | jq .
    else
        local status=$(echo "$result" | jq -r '.processing_status')
        local confidence=$(echo "$result" | jq -r '.confidence_score // "N/A"')
        local processing_time=$(echo "$result" | jq -r '.processing_time_ms // "N/A"')
        local created_at=$(echo "$result" | jq -r '.created_at')
        
        echo "Processing ID: $processing_id"
        echo "Status: $status"
        echo "Confidence: $confidence"
        echo "Processing Time: ${processing_time}ms"
        echo "Created: $created_at"
        
        if [[ "$status" == "completed" ]]; then
            echo
            echo "Structured Data:"
            echo "$result" | jq '.structured_data'
        elif [[ "$status" == "failed" ]]; then
            local error_msg=$(echo "$result" | jq -r '.error_message // "Unknown error"')
            echo
            echo "Error: $error_msg"
        fi
    fi
}

cmd_get_data() {
    local schema_id="$1"
    local format="${2:-human}"
    local limit="${3:-10}"
    local offset="${4:-0}"
    
    local endpoint="/data/$schema_id?limit=$limit&offset=$offset"
    
    log_info "Fetching processed data for schema: $schema_id"
    local result
    result=$(api_get "$endpoint") || return 1
    
    if [[ "$format" == "json" ]]; then
        echo "$result" | jq .
    elif [[ "$format" == "csv" ]]; then
        # Extract CSV data (simplified)
        echo "$result" | jq -r '.data[].structured_data | keys_unsorted' | head -1 | tr '\n' ',' | sed 's/,$/\n/'
        echo "$result" | jq -r '.data[].structured_data | [.[]] | @csv'
    else
        local schema_name=$(echo "$result" | jq -r '.schema.name')
        local total_count=$(echo "$result" | jq -r '.pagination.total_count')
        local data_count=$(echo "$result" | jq -r '.data | length')
        
        echo "Schema: $schema_name ($schema_id)"
        echo "Total Records: $total_count"
        echo "Showing: $data_count records (offset: $offset)"
        echo
        
        echo "$result" | jq -r '.data[] | [.id, .processing_status, .confidence_score, .created_at] | @tsv' | \
        while IFS=$'\t' read -r id status confidence created; do
            printf "%-36s %-12s %-8s %s\n" "$id" "$status" "$confidence" "$created"
        done
    fi
}

# Job management commands
cmd_list_jobs() {
    local format="${1:-human}"
    
    log_info "Fetching processing jobs..."
    local result
    result=$(api_get "/jobs") || return 1
    
    if [[ "$format" == "json" ]]; then
        echo "$result" | jq .
    else
        local count=$(echo "$result" | jq -r '.count')
        echo "Found $count jobs:"
        echo
        
        printf "%-36s %-12s %-8s %-8s %s\n" "ID" "STATUS" "PRIORITY" "PROGRESS" "CREATED"
        echo "$result" | jq -r '.jobs[] | [.id, .status, .priority, (.processed_items // 0), .created_at] | @tsv' | \
        while IFS=$'\t' read -r id status priority progress created; do
            printf "%-36s %-12s %-8s %-8s %s\n" "$id" "$status" "$priority" "$progress" "$created"
        done
    fi
}

# Main command dispatch
main() {
    check_jq
    
    local command="${1:-help}"
    shift || true
    
    # Parse global flags
    local format="human"
    local verbose="false"
    
    while [[ $# -gt 0 ]]; do
        case $1 in
            --json)
                format="json"
                shift
                ;;
            --verbose)
                verbose="true"
                shift
                ;;
            --help)
                if [[ -n "${command:-}" ]] && [[ "$command" != "help" ]]; then
                    show_command_help "$command"
                else
                    show_usage
                fi
                exit 0
                ;;
            -*)
                log_error "Unknown flag: $1"
                exit 1
                ;;
            *)
                break
                ;;
        esac
    done
    
    # Command dispatch
    case "$command" in
        status)
            show_status "$format" "$verbose"
            ;;
        help|--help)
            show_usage
            ;;
        version)
            show_version "$format"
            ;;
        create-schema)
            if [[ $# -lt 2 ]]; then
                log_error "Usage: create-schema <name> <schema-file> [description]"
                exit 1
            fi
            cmd_create_schema "$1" "$2" "${3:-}"
            ;;
        list-schemas)
            cmd_list_schemas "$format"
            ;;
        get-schema)
            if [[ $# -lt 1 ]]; then
                log_error "Usage: get-schema <schema-id>"
                exit 1
            fi
            cmd_get_schema "$1" "$format"
            ;;
        delete-schema)
            if [[ $# -lt 1 ]]; then
                log_error "Usage: delete-schema <schema-id>"
                exit 1
            fi
            cmd_delete_schema "$1"
            ;;
        list-templates)
            cmd_list_templates "${1:-}" "$format"
            ;;
        create-from-template)
            if [[ $# -lt 2 ]]; then
                log_error "Usage: create-from-template <template-id> <name> [description]"
                exit 1
            fi
            cmd_create_from_template "$1" "$2" "${3:-}"
            ;;
        process)
            if [[ $# -lt 2 ]]; then
                log_error "Usage: process <schema-id> <input> [input-type] [batch-mode]"
                exit 1
            fi
            cmd_process "$1" "$2" "${3:-auto}" "${4:-false}"
            ;;
        get-result)
            if [[ $# -lt 1 ]]; then
                log_error "Usage: get-result <processing-id>"
                exit 1
            fi
            cmd_get_result "$1" "$format"
            ;;
        get-data)
            if [[ $# -lt 1 ]]; then
                log_error "Usage: get-data <schema-id> [format] [limit] [offset]"
                exit 1
            fi
            cmd_get_data "$1" "${2:-$format}" "${3:-10}" "${4:-0}"
            ;;
        list-jobs)
            cmd_list_jobs "$format"
            ;;
        get-job)
            if [[ $# -lt 1 ]]; then
                log_error "Usage: get-job <job-id>"
                exit 1
            fi
            # Implement get-job if needed
            log_error "get-job command not yet implemented"
            exit 1
            ;;
        *)
            log_error "Unknown command: $command"
            echo
            show_usage
            exit 1
            ;;
    esac
}

# Run main function with all arguments
main "$@"