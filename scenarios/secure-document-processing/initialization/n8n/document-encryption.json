{
  "name": "Document Encryption Pipeline",
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "encrypt-document",
        "responseMode": "responseNode",
        "options": {
          "responseHeaders": {
            "entries": [
              {
                "name": "Access-Control-Allow-Origin",
                "value": "*"
              }
            ]
          }
        }
      },
      "id": "webhook_trigger",
      "name": "Webhook",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 1.1,
      "position": [200, 300],
      "webhookId": "encrypt-document"
    },
    {
      "parameters": {},
      "id": "manual_trigger",
      "name": "Manual Trigger",
      "type": "n8n-nodes-base.manualTrigger",
      "typeVersion": 1,
      "position": [200, 100]
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// Provide default values for manual testing\nconst isManual = $execution.mode === 'manual';\n\nif (isManual) {\n  return {\n    document: {\n      content: \"This is a test document for encryption\",\n      filename: \"test-document.txt\",\n      type: \"text\"\n    },\n    encryption: {\n      algorithm: \"aes256\",\n      compliance: \"hipaa\",\n      enableAudit: true,\n      enableVersioning: true,\n      autoRedact: false\n    },\n    user: {\n      id: \"test-user\",\n      role: \"admin\"\n    }\n  };\n}\n\n// Pass through webhook data\nreturn $input.item.json;"
      },
      "id": "default_provider",
      "name": "Default Provider",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [400, 100]
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// Validate and prepare encryption request\nconst input = $input.item.json;\nconst timestamp = new Date().toISOString();\nconst jobId = `enc_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n\n// Validate required fields\nif (!input.document || !input.document.content) {\n  throw new Error('Document content is required');\n}\n\n// Encryption algorithms and their configurations\nconst encryptionConfigs = {\n  'aes256': {\n    algorithm: 'aes-256-gcm',\n    keyLength: 32,\n    ivLength: 16,\n    tagLength: 16,\n    strength: 'high'\n  },\n  'aes128': {\n    algorithm: 'aes-128-gcm',\n    keyLength: 16,\n    ivLength: 16,\n    tagLength: 16,\n    strength: 'medium'\n  },\n  'rsa4096': {\n    algorithm: 'rsa-oaep',\n    keySize: 4096,\n    padding: 'OAEP',\n    strength: 'very-high'\n  },\n  'quantum': {\n    algorithm: 'kyber1024',\n    securityLevel: 5,\n    strength: 'quantum-resistant'\n  }\n};\n\n// Compliance requirements\nconst complianceRequirements = {\n  'hipaa': {\n    minKeyLength: 256,\n    requiresAudit: true,\n    requiresVersioning: true,\n    dataRetention: 365 * 7, // 7 years\n    encryptionAlgorithms: ['aes256', 'rsa4096']\n  },\n  'gdpr': {\n    minKeyLength: 256,\n    requiresAudit: true,\n    requiresVersioning: false,\n    dataRetention: 365 * 3, // 3 years\n    encryptionAlgorithms: ['aes256', 'aes128']\n  },\n  'sox': {\n    minKeyLength: 256,\n    requiresAudit: true,\n    requiresVersioning: true,\n    dataRetention: 365 * 7,\n    encryptionAlgorithms: ['aes256', 'rsa4096']\n  },\n  'pci': {\n    minKeyLength: 256,\n    requiresAudit: true,\n    requiresVersioning: false,\n    dataRetention: 365 * 2,\n    encryptionAlgorithms: ['aes256']\n  },\n  'fedramp': {\n    minKeyLength: 256,\n    requiresAudit: true,\n    requiresVersioning: true,\n    dataRetention: 365 * 10,\n    encryptionAlgorithms: ['aes256', 'rsa4096', 'quantum']\n  }\n};\n\n// Get encryption settings\nconst algorithm = input.encryption?.algorithm || 'aes256';\nconst compliance = input.encryption?.compliance || 'hipaa';\nconst encConfig = encryptionConfigs[algorithm];\nconst compReq = complianceRequirements[compliance];\n\n// Validate compliance\nif (!compReq.encryptionAlgorithms.includes(algorithm)) {\n  throw new Error(`Algorithm ${algorithm} is not compliant with ${compliance}`);\n}\n\n// Prepare encryption job\nreturn {\n  jobId: jobId,\n  timestamp: timestamp,\n  document: {\n    content: input.document.content,\n    filename: input.document.filename || 'document.txt',\n    type: input.document.type || 'text',\n    size: Buffer.from(input.document.content).length\n  },\n  encryption: {\n    algorithm: algorithm,\n    config: encConfig,\n    compliance: compliance,\n    requirements: compReq\n  },\n  security: {\n    enableAudit: input.encryption?.enableAudit ?? compReq.requiresAudit,\n    enableVersioning: input.encryption?.enableVersioning ?? compReq.requiresVersioning,\n    autoRedact: input.encryption?.autoRedact || false,\n    dataRetentionDays: compReq.dataRetention\n  },\n  user: {\n    id: input.user?.id || 'anonymous',\n    role: input.user?.role || 'user',\n    ip: input.user?.ip || 'unknown'\n  },\n  status: 'initialized'\n};"
      },
      "id": "prepare_encryption",
      "name": "Prepare Encryption",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [600, 300]
    },
    {
      "parameters": {
        "conditions": {
          "boolean": [
            {
              "value1": "={{ $json.security.autoRedact }}",
              "value2": true
            }
          ]
        }
      },
      "id": "check_redaction",
      "name": "Check Redaction",
      "type": "n8n-nodes-base.if",
      "typeVersion": 1,
      "position": [800, 300]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "http://localhost:5678/webhook/ollama",
        "sendBody": true,
        "bodyParameters": {
          "parameters": [
            {
              "name": "prompt",
              "value": "=You are a document redaction specialist. Identify and redact sensitive information in the following document. Replace sensitive data with [REDACTED-TYPE] where TYPE describes what was redacted (e.g., SSN, PHONE, EMAIL, NAME, ADDRESS, MEDICAL, FINANCIAL).\n\nDocument:\n{{ $json.document.content }}\n\nReturn ONLY the redacted document text with no additional explanation."
            },
            {
              "name": "model",
              "value": "llama3.2"
            },
            {
              "name": "temperature",
              "value": "0.1"
            },
            {
              "name": "max_tokens",
              "value": "4096"
            }
          ]
        },
        "options": {}
      },
      "id": "redact_sensitive",
      "name": "Redact Sensitive Data",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [1000, 400]
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// Merge redacted content if applicable\nconst original = $input.all()[0].json;\nconst redacted = $input.all()[1]?.json;\n\nif (redacted && redacted.response) {\n  // Update document with redacted content\n  original.document.content = redacted.response;\n  original.document.redacted = true;\n  original.audit = original.audit || [];\n  original.audit.push({\n    timestamp: new Date().toISOString(),\n    action: 'content_redacted',\n    details: 'Sensitive data automatically redacted'\n  });\n}\n\nreturn original;"
      },
      "id": "merge_redacted",
      "name": "Merge Redacted",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1200, 300]
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// Perform encryption simulation\n// In production, this would integrate with actual encryption libraries\nconst data = $input.item.json;\nconst crypto = require('crypto');\n\n// Generate encryption key and IV\nconst key = crypto.randomBytes(32); // 256 bits\nconst iv = crypto.randomBytes(16); // 128 bits\n\n// Simulate encryption (in production, use actual encryption)\nconst cipher = crypto.createCipheriv('aes-256-gcm', key, iv);\nlet encrypted = cipher.update(data.document.content, 'utf8', 'base64');\nencrypted += cipher.final('base64');\nconst authTag = cipher.getAuthTag();\n\n// Generate document hash for integrity\nconst hash = crypto.createHash('sha256');\nhash.update(data.document.content);\nconst documentHash = hash.digest('hex');\n\n// Create encrypted document record\nconst encryptedDocument = {\n  jobId: data.jobId,\n  timestamp: data.timestamp,\n  document: {\n    filename: data.document.filename,\n    type: data.document.type,\n    originalSize: data.document.size,\n    encryptedSize: Buffer.from(encrypted, 'base64').length,\n    hash: documentHash,\n    redacted: data.document.redacted || false\n  },\n  encryption: {\n    algorithm: data.encryption.algorithm,\n    keyId: `key_${Date.now()}`, // In production, store in key management system\n    iv: iv.toString('base64'),\n    authTag: authTag.toString('base64'),\n    encryptedAt: new Date().toISOString()\n  },\n  compliance: {\n    framework: data.encryption.compliance,\n    requirements: data.encryption.requirements,\n    validated: true\n  },\n  security: data.security,\n  user: data.user,\n  status: 'encrypted',\n  encryptedContent: encrypted,\n  audit: [\n    {\n      timestamp: new Date().toISOString(),\n      action: 'document_encrypted',\n      user: data.user.id,\n      details: `Document encrypted using ${data.encryption.algorithm}`\n    },\n    ...(data.audit || [])\n  ]\n};\n\nreturn encryptedDocument;"
      },
      "id": "encrypt_document",
      "name": "Encrypt Document",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1400, 300]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "=http://localhost:5432/api/documents/encrypted",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ JSON.stringify($json) }}",
        "options": {
          "batching": {
            "batch": {
              "batchSize": 1
            }
          }
        }
      },
      "id": "store_encrypted",
      "name": "Store Encrypted",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [1600, 300],
      "continueOnFail": true
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ JSON.stringify({\n  success: true,\n  jobId: $json.jobId,\n  document: {\n    filename: $json.document.filename,\n    size: $json.document.encryptedSize,\n    hash: $json.document.hash,\n    redacted: $json.document.redacted\n  },\n  encryption: {\n    algorithm: $json.encryption.algorithm,\n    encryptedAt: $json.encryption.encryptedAt\n  },\n  compliance: {\n    framework: $json.compliance.framework,\n    validated: $json.compliance.validated\n  },\n  status: $json.status,\n  message: 'Document successfully encrypted and stored securely'\n}) }}",
        "options": {}
      },
      "id": "respond",
      "name": "Respond",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1,
      "position": [1800, 300]
    }
  ],
  "connections": {
    "webhook_trigger": {
      "main": [
        [
          {
            "node": "prepare_encryption",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "manual_trigger": {
      "main": [
        [
          {
            "node": "default_provider",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "default_provider": {
      "main": [
        [
          {
            "node": "prepare_encryption",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "prepare_encryption": {
      "main": [
        [
          {
            "node": "check_redaction",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "check_redaction": {
      "main": [
        [
          {
            "node": "redact_sensitive",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "merge_redacted",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "redact_sensitive": {
      "main": [
        [
          {
            "node": "merge_redacted",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "merge_redacted": {
      "main": [
        [
          {
            "node": "encrypt_document",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "encrypt_document": {
      "main": [
        [
          {
            "node": "store_encrypted",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "store_encrypted": {
      "main": [
        [
          {
            "node": "respond",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": true,
  "settings": {
    "saveManualExecutions": true,
    "callerPolicy": "workflowsFromSameOwner",
    "errorWorkflow": "",
    "saveExecutionProgress": true,
    "saveDataSuccessExecution": "all"
  },
  "tags": [],
  "pinData": {},
  "versionId": "1.0.0",
  "triggerCount": 1
}