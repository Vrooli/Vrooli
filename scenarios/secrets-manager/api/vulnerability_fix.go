package main

import (
	"context"
	"encoding/json"
	"fmt"
	"net/http"
	"os"
	"os/exec"
	"path/filepath"
	"strconv"
	"strings"
	"time"

	"github.com/google/uuid"
)

// Fix vulnerabilities handler - spawns claude-code agent
func (s *APIServer) fixVulnerabilitiesHandler(w http.ResponseWriter, r *http.Request) {
	if r.Method != http.MethodPost {
		http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
		return
	}

	var req struct {
		Vulnerabilities []SecurityVulnerability `json:"vulnerabilities"`
	}

	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		http.Error(w, "Invalid JSON", http.StatusBadRequest)
		return
	}

	if len(req.Vulnerabilities) == 0 {
		http.Error(w, "No vulnerabilities provided", http.StatusBadRequest)
		return
	}

	fixRequestID := uuid.New().String()
	logger.Info("Starting vulnerability fix request %s for %d vulnerabilities", fixRequestID, len(req.Vulnerabilities))

	// Spawn claude-code agent to fix vulnerabilities
	go func() {
		err := spawnVulnerabilityFixerAgent(fixRequestID, req.Vulnerabilities)
		if err != nil {
			logger.Info("Failed to spawn vulnerability fixer agent: %v", err)
		}
	}()

	response := map[string]interface{}{
		"status":          "accepted",
		"fix_request_id":  fixRequestID,
		"vulnerabilities": len(req.Vulnerabilities),
		"message":         "Claude Code vulnerability fixer agent has been spawned",
		"timestamp":       time.Now().Format(time.RFC3339),
	}

	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(response)
}

// fixProgressHandler handles progress updates from the claude-code agent
func (s *APIServer) fixProgressHandler(w http.ResponseWriter, r *http.Request) {
	if r.Method != http.MethodPost {
		http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
		return
	}

	var req struct {
		FixRequestID    string   `json:"fix_request_id"`
		VulnerabilityID string   `json:"vulnerability_id"`
		Status          string   `json:"status"` // completed, failed, skipped
		Message         string   `json:"message"`
		FilesModified   []string `json:"files_modified,omitempty"`
		VaultPath       string   `json:"vault_path,omitempty"`
	}

	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		http.Error(w, "Invalid JSON", http.StatusBadRequest)
		return
	}

	if req.FixRequestID == "" || req.VulnerabilityID == "" || req.Status == "" {
		http.Error(w, "Missing required fields: fix_request_id, vulnerability_id, status", http.StatusBadRequest)
		return
	}

	// Log the progress update
	logger.Info("Fix progress [%s]: %s - %s (%s)", req.FixRequestID, req.VulnerabilityID, req.Status, req.Message)

	if len(req.FilesModified) > 0 {
		logger.Info("  Files modified: %v", req.FilesModified)
	}

	if req.VaultPath != "" {
		logger.Info("  Vault path: %s", req.VaultPath)
	}

	response := map[string]interface{}{
		"status":    "acknowledged",
		"timestamp": time.Now().Format(time.RFC3339),
		"message":   "Progress update received",
	}

	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(response)
}

// fileContentHandler provides secure access to file content for vulnerability analysis
func (s *APIServer) fileContentHandler(w http.ResponseWriter, r *http.Request) {
	if r.Method != http.MethodGet {
		http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
		return
	}

	filePath := r.URL.Query().Get("path")
	if filePath == "" {
		http.Error(w, "Missing required parameter: path", http.StatusBadRequest)
		return
	}

	// Security: Resolve to absolute path and ensure it's within allowed directories
	vrooliRoot := os.Getenv("VROOLI_ROOT")
	if vrooliRoot == "" {
		homeDir, err := os.UserHomeDir()
		if err != nil {
			http.Error(w, "Cannot determine home directory", http.StatusInternalServerError)
			return
		}
		vrooliRoot = filepath.Join(homeDir, "Vrooli")
	}

	// Clean and resolve the file path
	cleanPath := filepath.Clean(filePath)
	var fullPath string

	// Handle both absolute and relative paths
	if filepath.IsAbs(cleanPath) {
		fullPath = cleanPath
	} else {
		fullPath = filepath.Join(vrooliRoot, cleanPath)
	}

	// Security check: ensure the resolved path is within the Vrooli directory
	resolvedPath, err := filepath.Abs(fullPath)
	if err != nil {
		http.Error(w, "Invalid file path", http.StatusBadRequest)
		return
	}

	allowedRoot, err := filepath.Abs(vrooliRoot)
	if err != nil {
		http.Error(w, "Cannot resolve Vrooli root path", http.StatusInternalServerError)
		return
	}

	if !strings.HasPrefix(resolvedPath, allowedRoot) {
		http.Error(w, "Access denied: path outside allowed directory", http.StatusForbidden)
		return
	}

	// Read the file content
	content, err := os.ReadFile(resolvedPath)
	if err != nil {
		if os.IsNotExist(err) {
			http.Error(w, "File not found", http.StatusNotFound)
		} else {
			http.Error(w, "Error reading file", http.StatusInternalServerError)
		}
		return
	}

	// Determine language based on file extension
	language := getLanguageFromPath(resolvedPath)

	// Create response
	response := map[string]interface{}{
		"path":     filePath,
		"content":  string(content),
		"language": language,
		"size":     len(content),
	}

	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(response)
}

// getLanguageFromPath determines the programming language based on file extension
func getLanguageFromPath(filePath string) string {
	ext := strings.ToLower(filepath.Ext(filePath))

	// Map extensions to Prism.js language identifiers
	languageMap := map[string]string{
		".js":         "javascript",
		".ts":         "typescript",
		".go":         "go",
		".py":         "python",
		".sh":         "bash",
		".bash":       "bash",
		".zsh":        "bash",
		".fish":       "bash",
		".json":       "json",
		".yaml":       "yaml",
		".yml":        "yaml",
		".toml":       "toml",
		".sql":        "sql",
		".md":         "markdown",
		".html":       "html",
		".css":        "css",
		".scss":       "scss",
		".sass":       "sass",
		".java":       "java",
		".cpp":        "cpp",
		".c":          "c",
		".rs":         "rust",
		".php":        "php",
		".rb":         "ruby",
		".swift":      "swift",
		".kt":         "kotlin",
		".dart":       "dart",
		".r":          "r",
		".dockerfile": "dockerfile",
		".xml":        "xml",
		".ini":        "ini",
		".cfg":        "ini",
		".conf":       "nginx", // Common for config files
	}

	if lang, exists := languageMap[ext]; exists {
		return lang
	}

	// Check for files without extensions but with known names
	filename := strings.ToLower(filepath.Base(filePath))
	if strings.Contains(filename, "dockerfile") {
		return "dockerfile"
	}
	if strings.Contains(filename, "makefile") {
		return "makefile"
	}

	return "text" // Default to plain text
}

// validateEnvironmentForFixes checks that the environment is ready for vulnerability fixing
func validateEnvironmentForFixes() error {
	// Check if vault is accessible
	cmd := exec.Command("resource-vault", "status")
	if err := cmd.Run(); err != nil {
		logger.Warning("Vault status check failed: %v", err)
		logger.Info("    The agent will attempt to work without vault access")
		// Don't fail completely - agent can still do code cleanup without vault
	}

	// Check if resource-claude-code is available
	cmd = exec.Command("resource-claude-code", "--help")
	if err := cmd.Run(); err != nil {
		return fmt.Errorf("resource-claude-code not available: %w", err)
	}

	logger.Info("‚úÖ Environment validation passed - ready to spawn vulnerability fixer agent")
	return nil
}

// spawnVulnerabilityFixerAgent spawns a claude-code agent to fix vulnerabilities
func spawnVulnerabilityFixerAgent(fixRequestID string, vulnerabilities []SecurityVulnerability) error {
	// Get VROOLI_ROOT
	vrooliRoot := os.Getenv("VROOLI_ROOT")
	if vrooliRoot == "" {
		home, err := os.UserHomeDir()
		if err != nil {
			return fmt.Errorf("failed to get user home directory: %w", err)
		}
		vrooliRoot = filepath.Join(home, "Vrooli")
	}

	// Validate environment before proceeding
	if err := validateEnvironmentForFixes(); err != nil {
		return fmt.Errorf("environment validation failed: %w", err)
	}

	// Load prompt template
	promptPath := filepath.Join(vrooliRoot, "scenarios", "secrets-manager", "initialization", "claude-code", "vulnerability-fixer.md")
	promptTemplate, err := os.ReadFile(promptPath)
	if err != nil {
		return fmt.Errorf("failed to read prompt template: %w", err)
	}

	// Build vulnerabilities JSON
	vulnJSON, err := json.MarshalIndent(vulnerabilities, "", "  ")
	if err != nil {
		return fmt.Errorf("failed to marshal vulnerabilities: %w", err)
	}

	// Replace template variables
	prompt := string(promptTemplate)
	prompt = strings.ReplaceAll(prompt, "{{FIX_REQUEST_ID}}", fixRequestID)
	prompt = strings.ReplaceAll(prompt, "{{TIMESTAMP}}", time.Now().Format(time.RFC3339))
	prompt = strings.ReplaceAll(prompt, "{{VULNERABILITIES_COUNT}}", strconv.Itoa(len(vulnerabilities)))
	prompt = strings.ReplaceAll(prompt, "{{SELECTED_VULNERABILITIES}}", string(vulnJSON))

	// Create context with timeout
	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Minute)
	defer cancel()

	// Use resource-claude-code directly (following system-monitor pattern)
	cmd := exec.CommandContext(ctx, "resource-claude-code", "run", "-")
	cmd.Dir = vrooliRoot

	// Apply Claude execution settings and context via environment variables
	cmd.Env = append(os.Environ(),
		"MAX_TURNS=75",
		"ANTHROPIC_BETA=computer-use-2024-10-22",
		fmt.Sprintf("SCENARIO_CONTEXT=%s", "secrets-manager"),
		fmt.Sprintf("WORKING_DIR=%s", vrooliRoot),
		fmt.Sprintf("FIX_REQUEST_ID=%s", fixRequestID),
	)

	// Set up stdin with the prompt
	stdin, err := cmd.StdinPipe()
	if err != nil {
		return fmt.Errorf("failed to create stdin pipe: %w", err)
	}

	// Log the agent startup details
	logger.Info("ü§ñ Spawning vulnerability fixer agent:")
	logger.Info("   üìÅ Working directory: %s", vrooliRoot)
	logger.Info("   üéØ Vulnerabilities to fix: %d", len(vulnerabilities))
	logger.Info("   ‚è±Ô∏è  Timeout: 10 minutes")
	logger.Info("   üìÑ Prompt template: %s", promptPath)

	// Start the command
	err = cmd.Start()
	if err != nil {
		return fmt.Errorf("failed to start claude-code command: %w", err)
	}

	logger.Info("‚úÖ Claude Code agent started successfully (PID: %d)", cmd.Process.Pid)

	// Write prompt to stdin and close
	go func() {
		defer stdin.Close()
		stdin.Write([]byte(prompt))
	}()

	// Wait for completion (non-blocking)
	go func() {
		err := cmd.Wait()
		if err != nil {
			logger.Info("Claude Code vulnerability fixer completed with error: %v", err)
		} else {
			logger.Info("Claude Code vulnerability fixer completed successfully for request %s", fixRequestID)
		}
	}()

	logger.Info("Successfully spawned vulnerability fixer agent for request %s", fixRequestID)
	return nil
}
