{
  "name": "Secret Validator - Environment Validation Pipeline",
  "nodes": [
    {
      "parameters": {
        "path": "secret-validate",
        "httpMethod": "POST",
        "responseMode": "onReceived",
        "options": {}
      },
      "id": "webhook-trigger",
      "name": "Secret Validation Webhook",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2,
      "position": [240, 300],
      "webhookId": "secret-validate"
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// Process secret validation request\nconst body = $input.item.json.body || {};\n\n// Set up validation request\nconst request = {\n  validation_id: crypto.randomUUID(),\n  resource_filter: body.resource || null,\n  validation_methods: ['env', 'vault', 'file'],\n  timestamp: new Date().toISOString(),\n  processing_start: Date.now()\n};\n\nreturn request;"
      },
      "id": "process-validation-request",
      "name": "Process Validation Request",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [460, 300]
    },
    {
      "parameters": {
        "operation": "select",
        "schema": "public",
        "table": "resource_secrets",
        "limit": 1000,
        "where": {
          "conditions": [
            {
              "leftValue": "resource_name",
              "operation": "equal",
              "rightValue": "={{ $('Process Validation Request').item.json.resource_filter || '' }}"
            }
          ]
        },
        "options": {
          "whereFixedCollection": {
            "conditions": [
              {
                "leftValue": "1",
                "operation": "equal", 
                "rightValue": "1"
              }
            ]
          }
        }
      },
      "id": "fetch-secrets",
      "name": "Fetch Resource Secrets",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2,
      "position": [680, 300],
      "credentials": {
        "postgres": {
          "id": "postgres-secrets",
          "name": "Secrets Manager DB"
        }
      }
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// Validate secrets against environment and vault\nconst validationRequest = $('Process Validation Request').item.json;\nconst secrets = $input.all().map(item => item.json);\n\nconst validationResults = [];\nconst summary = {\n  total_secrets: secrets.length,\n  valid_secrets: 0,\n  missing_secrets: [],\n  invalid_secrets: [],\n  validation_timestamp: new Date().toISOString()\n};\n\n// Process each secret\nsecrets.forEach(secret => {\n  const validation = {\n    id: crypto.randomUUID(),\n    resource_secret_id: secret.id,\n    validation_status: 'missing',\n    validation_method: 'env',\n    validation_timestamp: new Date().toISOString(),\n    error_message: null\n  };\n  \n  try {\n    // Check environment variable\n    const envValue = process.env[secret.secret_key];\n    \n    if (envValue && envValue.trim()) {\n      validation.validation_method = 'env';\n      \n      // Validate against pattern if provided\n      if (secret.validation_pattern) {\n        const regex = new RegExp(secret.validation_pattern);\n        if (regex.test(envValue)) {\n          validation.validation_status = 'valid';\n          summary.valid_secrets++;\n        } else {\n          validation.validation_status = 'invalid';\n          validation.error_message = 'Value does not match required pattern';\n          summary.invalid_secrets.push(validation);\n        }\n      } else {\n        validation.validation_status = 'valid';\n        summary.valid_secrets++;\n      }\n    } else {\n      // Check if we can access vault (simplified check)\n      const vaultAddr = process.env.VAULT_ADDR;\n      const vaultToken = process.env.VAULT_TOKEN || process.env.VAULT_DEV_ROOT_TOKEN_ID;\n      \n      if (vaultAddr && vaultToken) {\n        // TODO: Implement actual vault lookup via resource-vault CLI\n        // For now, mark as missing from env but potentially in vault\n        validation.validation_status = 'missing';\n        validation.validation_method = 'env';\n        validation.error_message = 'Environment variable not set (vault check not implemented)';\n      } else {\n        validation.validation_status = 'missing';\n        validation.validation_method = 'env';\n        validation.error_message = 'Environment variable not set and vault not accessible';\n      }\n      \n      if (secret.required) {\n        summary.missing_secrets.push(validation);\n      }\n    }\n  } catch (error) {\n    validation.validation_status = 'invalid';\n    validation.error_message = `Validation error: ${error.message}`;\n    summary.invalid_secrets.push(validation);\n  }\n  \n  validationResults.push(validation);\n});\n\n// Create health summary by resource\nconst healthSummary = {};\nsecrets.forEach(secret => {\n  if (!healthSummary[secret.resource_name]) {\n    healthSummary[secret.resource_name] = {\n      resource_name: secret.resource_name,\n      total_secrets: 0,\n      required_secrets: 0,\n      valid_secrets: 0,\n      missing_required_secrets: 0,\n      invalid_secrets: 0\n    };\n  }\n  \n  const health = healthSummary[secret.resource_name];\n  health.total_secrets++;\n  \n  if (secret.required) {\n    health.required_secrets++;\n  }\n  \n  const validation = validationResults.find(v => v.resource_secret_id === secret.id);\n  if (validation) {\n    switch (validation.validation_status) {\n      case 'valid':\n        health.valid_secrets++;\n        break;\n      case 'missing':\n        if (secret.required) {\n          health.missing_required_secrets++;\n        }\n        break;\n      case 'invalid':\n        health.invalid_secrets++;\n        break;\n    }\n  }\n});\n\nreturn {\n  validation_id: validationRequest.validation_id,\n  validation_results: validationResults,\n  summary: summary,\n  health_summary: Object.values(healthSummary),\n  processing_duration_ms: Date.now() - validationRequest.processing_start\n};"
      },
      "id": "validate-secrets",
      "name": "Validate Secrets",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [900, 300]
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// Prepare validation results for database storage\nconst results = $input.item.json;\n\n// Return individual validation records for database insertion\nreturn results.validation_results.map(validation => ({\n  id: validation.id,\n  resource_secret_id: validation.resource_secret_id,\n  validation_status: validation.validation_status,\n  validation_method: validation.validation_method,\n  validation_timestamp: validation.validation_timestamp,\n  error_message: validation.error_message\n}));"
      },
      "id": "prepare-validation-records",
      "name": "Prepare Validation Records",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1120, 200]
    },
    {
      "parameters": {
        "operation": "insert",
        "schema": "public",
        "table": "secret_validations",
        "columns": "id, resource_secret_id, validation_status, validation_method, validation_timestamp, error_message",
        "additionalFields": {
          "mode": "independently"
        }
      },
      "id": "store-validation-results",
      "name": "Store Validation Results",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2,
      "position": [1340, 200],
      "credentials": {
        "postgres": {
          "id": "postgres-secrets",
          "name": "Secrets Manager DB"
        }
      }
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// Check for critical security alerts\nconst results = $('Validate Secrets').item.json;\nconst alerts = [];\n\n// Generate security alerts based on validation results\nif (results.summary.missing_secrets.length > 0) {\n  const criticalMissing = results.summary.missing_secrets.filter(v => {\n    // Find the corresponding secret to check if it's required\n    const secrets = $('Fetch Resource Secrets').all().map(item => item.json);\n    const secret = secrets.find(s => s.id === v.resource_secret_id);\n    return secret && secret.required;\n  });\n  \n  if (criticalMissing.length > 0) {\n    alerts.push({\n      severity: 'critical',\n      type: 'missing_required_secrets',\n      count: criticalMissing.length,\n      message: `${criticalMissing.length} required secrets are missing from environment`,\n      timestamp: new Date().toISOString()\n    });\n  }\n}\n\nif (results.summary.invalid_secrets.length > 0) {\n  alerts.push({\n    severity: 'warning',\n    type: 'invalid_secret_format',\n    count: results.summary.invalid_secrets.length,\n    message: `${results.summary.invalid_secrets.length} secrets have invalid format or values`,\n    timestamp: new Date().toISOString()\n  });\n}\n\n// Check for vault connectivity issues\nconst vaultAddr = process.env.VAULT_ADDR;\nconst vaultToken = process.env.VAULT_TOKEN || process.env.VAULT_DEV_ROOT_TOKEN_ID;\n\nif (!vaultAddr || !vaultToken) {\n  alerts.push({\n    severity: 'warning',\n    type: 'vault_not_configured',\n    count: 1,\n    message: 'Vault is not properly configured - secrets cannot be stored securely',\n    timestamp: new Date().toISOString()\n  });\n}\n\nreturn {\n  validation_id: results.validation_id,\n  alerts: alerts,\n  alert_count: alerts.length\n};"
      },
      "id": "generate-security-alerts",
      "name": "Generate Security Alerts",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1120, 400]
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// Format final validation response\nconst validationResults = $('Validate Secrets').item.json;\nconst securityAlerts = $('Generate Security Alerts').item.json;\n\nreturn {\n  success: true,\n  validation_id: validationResults.validation_id,\n  total_secrets: validationResults.summary.total_secrets,\n  valid_secrets: validationResults.summary.valid_secrets,\n  missing_secrets: validationResults.summary.missing_secrets,\n  invalid_secrets: validationResults.summary.invalid_secrets,\n  health_summary: validationResults.health_summary,\n  security_alerts: securityAlerts.alerts,\n  processing_duration_ms: validationResults.processing_duration_ms,\n  message: `Validation completed: ${validationResults.summary.valid_secrets}/${validationResults.summary.total_secrets} secrets valid`,\n  timestamp: validationResults.summary.validation_timestamp\n};"
      },
      "id": "format-validation-response",
      "name": "Format Validation Response", 
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1340, 300]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ $json }}"
      },
      "id": "send-response",
      "name": "Send Response",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1,
      "position": [1560, 300]
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// Send critical alerts to external monitoring (optional)\nconst alerts = $input.item.json.alerts || [];\nconst criticalAlerts = alerts.filter(alert => alert.severity === 'critical');\n\nif (criticalAlerts.length > 0) {\n  // TODO: Integrate with external monitoring system\n  console.log('CRITICAL SECURITY ALERTS:', criticalAlerts);\n  \n  // For now, just log to workflow execution\n  return {\n    alert_sent: true,\n    critical_count: criticalAlerts.length,\n    timestamp: new Date().toISOString()\n  };\n}\n\nreturn { alert_sent: false, critical_count: 0 };"
      },
      "id": "send-alerts",
      "name": "Send Critical Alerts",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1120, 600]
    }
  ],
  "connections": {
    "webhook-trigger": {
      "main": [
        [
          {
            "node": "process-validation-request",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "process-validation-request": {
      "main": [
        [
          {
            "node": "fetch-secrets",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "fetch-secrets": {
      "main": [
        [
          {
            "node": "validate-secrets",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "validate-secrets": {
      "main": [
        [
          {
            "node": "prepare-validation-records",
            "type": "main",
            "index": 0
          },
          {
            "node": "generate-security-alerts",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "prepare-validation-records": {
      "main": [
        [
          {
            "node": "store-validation-results",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "generate-security-alerts": {
      "main": [
        [
          {
            "node": "format-validation-response",
            "type": "main",
            "index": 0
          },
          {
            "node": "send-alerts",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "format-validation-response": {
      "main": [
        [
          {
            "node": "send-response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": true,
  "settings": {
    "saveManualExecutions": true,
    "saveExecutionProgress": true,
    "saveDataSuccessExecution": "all",
    "saveDataErrorExecution": "all"
  },
  "staticData": {},
  "tags": ["secrets-manager", "validation", "security"],
  "meta": {
    "description": "Validates discovered secrets against environment variables and secure storage systems, generating security alerts for missing or invalid credentials",
    "version": "1.0.0"
  }
}