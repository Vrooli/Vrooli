{
  "name": "Professional Chart Generator",
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "chart-generator",
        "responseMode": "responseNode",
        "options": {}
      },
      "id": "webhook_trigger",
      "name": "Webhook Trigger",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 1.1,
      "position": [200, 300]
    },
    {
      "parameters": {},
      "id": "manual_trigger",
      "name": "Manual Trigger",
      "type": "n8n-nodes-base.manualTrigger",
      "typeVersion": 1,
      "position": [200, 500]
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// Return test defaults for manual trigger\nreturn {\n  chart_type: 'bar',\n  data: [\n    { x: 'Q1', y: 15000 },\n    { x: 'Q2', y: 22000 },\n    { x: 'Q3', y: 28000 },\n    { x: 'Q4', y: 25000 }\n  ],\n  style: 'professional',\n  export_formats: ['png', 'svg'],\n  title: 'Quarterly Sales Performance',\n  width: 800,\n  height: 600\n};"
      },
      "id": "set_test_defaults",
      "name": "Set Test Defaults",
      "type": "n8n-nodes-base.code",
      "typeVersion": 1,
      "position": [400, 500]
    },
    {
      "parameters": {},
      "id": "merge_triggers",
      "name": "Merge Triggers",
      "type": "n8n-nodes-base.merge",
      "typeVersion": 2.1,
      "position": [600, 400]
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// Comprehensive input validation for chart generation\nconst rawInput = $input.item.json;\nconsole.log('Chart generation request:', JSON.stringify(rawInput));\n\n// Handle different input structures\nlet input = rawInput;\nif (rawInput.json) {\n  input = rawInput.json;\n} else if (rawInput.data && typeof rawInput.data === 'object') {\n  input = rawInput.data;\n} else if (rawInput.body && typeof rawInput.body === 'object') {\n  input = rawInput.body;\n}\n\n// Validate chart_type\nconst validChartTypes = ['bar', 'line', 'pie', 'scatter', 'area', 'gantt', 'heatmap', 'treemap'];\nconst chartType = input.chart_type || 'bar';\nif (!validChartTypes.includes(chartType)) {\n  throw new Error('Invalid chart_type: ' + chartType + '. Supported types: ' + validChartTypes.join(', '));\n}\n\n// Validate data\nif (!input.data || !Array.isArray(input.data)) {\n  throw new Error('Missing or invalid data parameter. Must be an array of data points.');\n}\n\nif (input.data.length === 0) {\n  throw new Error('Data array cannot be empty. Please provide at least one data point.');\n}\n\n// Validate data structure\nconst sampleDataPoint = input.data[0];\nif (typeof sampleDataPoint !== 'object') {\n  throw new Error('Data points must be objects with x and y properties.');\n}\n\n// Check data point requirements based on chart type\nfor (let i = 0; i < Math.min(input.data.length, 5); i++) {\n  const point = input.data[i];\n  if (chartType === 'pie') {\n    if ((!point.x && !point.label) || (!point.y && !point.value)) {\n      throw new Error('Pie chart data points must have label/x and value/y properties. Point ' + i + ' is invalid.');\n    }\n  } else {\n    if (point.x === undefined || point.y === undefined) {\n      throw new Error('Data points must have x and y properties. Point ' + i + ' is missing required fields.');\n    }\n  }\n}\n\n// Validate style\nconst validStyles = ['professional', 'minimal', 'vibrant', 'dark', 'corporate'];\nconst style = input.style || 'professional';\nif (!validStyles.includes(style)) {\n  console.warn('Unknown style: ' + style + ', falling back to professional');\n}\n\n// Validate export formats\nconst validFormats = ['png', 'svg', 'pdf', 'jpg'];\nlet exportFormats = input.export_formats || ['png'];\nif (!Array.isArray(exportFormats)) {\n  exportFormats = [exportFormats];\n}\nexportFormats = exportFormats.filter(format => validFormats.includes(format));\nif (exportFormats.length === 0) {\n  exportFormats = ['png']; // default fallback\n}\n\n// Validate dimensions\nconst width = Math.max(200, Math.min(2000, parseInt(input.width) || 800));\nconst height = Math.max(200, Math.min(1500, parseInt(input.height) || 600));\n\n// Generate unique chart ID\nconst timestamp = Date.now();\nconst randomId = Math.random().toString(36).substring(2, 8);\nconst chartId = 'chart_' + timestamp + '_' + randomId;\n\n// Prepare validated data\nconst validatedData = {\n  chart_id: chartId,\n  chart_type: chartType,\n  data: input.data,\n  style: style,\n  export_formats: exportFormats,\n  dimensions: {\n    width: width,\n    height: height\n  },\n  config: {\n    title: input.title || '',\n    x_axis_label: input.x_axis_label || '',\n    y_axis_label: input.y_axis_label || '',\n    show_legend: input.show_legend !== false,\n    show_grid: input.show_grid !== false,\n    animation: input.animation !== false\n  },\n  metadata: {\n    data_points: input.data.length,\n    timestamp: new Date().toISOString(),\n    processing_id: chartId\n  }\n};\n\nconsole.log('Validated chart generation request:', JSON.stringify(validatedData));\nreturn validatedData;"
      },
      "id": "validate_input",
      "name": "Validate Input",
      "type": "n8n-nodes-base.code",
      "typeVersion": 1,
      "position": [800, 400]
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// Store chart data in PostgreSQL\nconst chartData = $input.item.json;\n\n// Prepare SQL to insert chart instance\nconst insertSql = `\nINSERT INTO chart_instances (\n  id, chart_type, data_source, config_overrides, \n  generation_metadata, created_at, expires_at\n) VALUES (\n  '${chartData.chart_id}',\n  '${chartData.chart_type}',\n  '${JSON.stringify(chartData.data).replace(/'/g, \"''\")}'::jsonb,\n  '${JSON.stringify(chartData.config).replace(/'/g, \"''\")}'::jsonb,\n  '${JSON.stringify(chartData.metadata).replace(/'/g, \"''\")}'::jsonb,\n  NOW(),\n  NOW() + INTERVAL '7 days'\n)`;\n\n// Build the resource command\nconst command = `resource-postgres execute \"${insertSql}\"`;\n\nreturn {\n  command: command,\n  chart_data: chartData,\n  sql_query: insertSql\n};"
      },
      "id": "store_chart_data",
      "name": "Store Chart Data",
      "type": "n8n-nodes-base.code",
      "typeVersion": 1,
      "position": [1000, 400]
    },
    {
      "parameters": {
        "command": "={{ $json.command }}",
        "options": {
          "timeout": 10000
        }
      },
      "id": "execute_database_insert",
      "name": "Execute Database Insert",
      "type": "n8n-nodes-base.executeCommand",
      "typeVersion": 1,
      "position": [1200, 400]
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// Generate chart using the chart-generator CLI\nconst chartData = $('Store Chart Data').item.json.chart_data;\nconst dbResult = $input.item.json;\n\n// Check if database insert succeeded\nif (dbResult.exitCode !== 0) {\n  throw new Error('Failed to store chart data in database: ' + dbResult.stderr);\n}\n\n// Create temporary data file\nconst dataFile = `/tmp/${chartData.chart_id}_data.json`;\nconst outputDir = `/tmp/${chartData.chart_id}_output`;\n\n// Escape data for shell\nconst escapedData = JSON.stringify(chartData.data).replace(/'/g, \"'\\\"'\\\"'\");\n\n// Build chart generation command\nconst commands = [\n  `mkdir -p \"${outputDir}\"`,\n  `echo '${escapedData}' > \"${dataFile}\"`,\n  `chart-generator generate ${chartData.chart_type} --data \"${dataFile}\" --style ${chartData.style} --output \"${outputDir}\" --format ${chartData.export_formats.join(',')} --width ${chartData.dimensions.width} --height ${chartData.dimensions.height}`,\n  `ls -la \"${outputDir}\" | grep -E '\\.(png|svg|pdf|jpg)$' || echo \"No files generated\"`,\n  `rm -f \"${dataFile}\"`\n].join(' && ');\n\nreturn {\n  command: commands,\n  chart_data: chartData,\n  output_dir: outputDir,\n  temp_data_file: dataFile\n};"
      },
      "id": "prepare_chart_generation",
      "name": "Prepare Chart Generation",
      "type": "n8n-nodes-base.code",
      "typeVersion": 1,
      "position": [1400, 400]
    },
    {
      "parameters": {
        "command": "={{ $json.command }}",
        "options": {
          "timeout": 30000
        }
      },
      "id": "execute_chart_generation",
      "name": "Execute Chart Generation",
      "type": "n8n-nodes-base.executeCommand",
      "typeVersion": 1,
      "position": [1600, 400]
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// Process chart generation results\nconst generationResult = $input.item.json;\nconst chartData = $('Prepare Chart Generation').item.json.chart_data;\nconst outputDir = $('Prepare Chart Generation').item.json.output_dir;\n\n// Check if chart generation succeeded\nconst success = generationResult.exitCode === 0;\n\nif (!success) {\n  throw new Error('Chart generation failed: ' + generationResult.stderr);\n}\n\n// Parse the file listing from stdout\nconst stdout = generationResult.stdout || '';\nconst generatedFiles = [];\n\n// Extract file paths from the ls output\nconst lines = stdout.split('\\n');\nfor (const line of lines) {\n  if (line.includes('.png') || line.includes('.svg') || line.includes('.pdf') || line.includes('.jpg')) {\n    const parts = line.trim().split(/\\s+/);\n    const filename = parts[parts.length - 1];\n    if (filename && (filename.endsWith('.png') || filename.endsWith('.svg') || filename.endsWith('.pdf') || filename.endsWith('.jpg'))) {\n      const format = filename.split('.').pop();\n      generatedFiles.push({\n        format: format,\n        filename: filename,\n        filepath: `${outputDir}/${filename}`,\n        size_bytes: 0 // Would need additional command to get actual size\n      });\n    }\n  }\n}\n\n// Update database with generated files\nconst updateSql = `\nUPDATE chart_instances \nSET generated_files = '${JSON.stringify(generatedFiles).replace(/'/g, \"''\")}'::jsonb\nWHERE id = '${chartData.chart_id}'`;\n\nconst updateCommand = `resource-postgres execute \"${updateSql}\"`;\n\n// Calculate total execution time\nconst endTime = new Date().toISOString();\nconst startTime = chartData.metadata.timestamp;\nconst executionTimeMs = new Date(endTime).getTime() - new Date(startTime).getTime();\n\n// Build comprehensive response\nconst response = {\n  success: true,\n  chart_id: chartData.chart_id,\n  chart_type: chartData.chart_type,\n  files: generatedFiles.reduce((acc, file) => {\n    acc[file.format] = file.filepath;\n    return acc;\n  }, {}),\n  metadata: {\n    generation_time_ms: executionTimeMs,\n    data_point_count: chartData.data.length,\n    style_applied: chartData.style,\n    dimensions: chartData.dimensions,\n    formats_generated: generatedFiles.map(f => f.format),\n    created_at: startTime,\n    completed_at: endTime\n  },\n  config: chartData.config,\n  cleanup_command: `rm -rf \"${outputDir}\"` // For cleanup after response\n};\n\nreturn {\n  response: response,\n  update_command: updateCommand,\n  chart_id: chartData.chart_id\n};"
      },
      "id": "process_results",
      "name": "Process Results",
      "type": "n8n-nodes-base.code",
      "typeVersion": 1,
      "position": [1800, 400]
    },
    {
      "parameters": {
        "command": "={{ $json.update_command }}",
        "options": {
          "timeout": 5000
        }
      },
      "id": "update_database",
      "name": "Update Database",
      "type": "n8n-nodes-base.executeCommand",
      "typeVersion": 1,
      "position": [2000, 400]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ JSON.stringify($('Process Results').item.json.response, null, 2) }}"
      },
      "id": "success_response",
      "name": "Success Response",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1,
      "position": [2200, 300]
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// Handle chart generation errors\nconst error = $input.item.json;\nconst chartData = $('Validate Input').item?.json || {};\n\nconst errorResponse = {\n  success: false,\n  error: {\n    message: error.message || 'Chart generation failed',\n    type: 'chart_generation_error',\n    timestamp: new Date().toISOString()\n  },\n  request: {\n    chart_type: chartData.chart_type || 'unknown',\n    data_points: chartData.data ? chartData.data.length : 0,\n    style: chartData.style || 'unknown'\n  },\n  debug: {\n    execution_step: $node.name,\n    raw_error: JSON.stringify(error)\n  }\n};\n\nreturn errorResponse;"
      },
      "id": "format_error",
      "name": "Format Error",
      "type": "n8n-nodes-base.code",
      "typeVersion": 1,
      "position": [1800, 600]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseCode": 400,
        "responseBody": "={{ JSON.stringify($json, null, 2) }}"
      },
      "id": "error_response",
      "name": "Error Response",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1,
      "position": [2000, 600]
    },
    {
      "parameters": {
        "command": "={{ $('Process Results').item.json.response.cleanup_command }}",
        "options": {
          "timeout": 5000
        }
      },
      "id": "cleanup_temp_files",
      "name": "Cleanup Temp Files",
      "type": "n8n-nodes-base.executeCommand",
      "typeVersion": 1,
      "position": [2200, 500]
    }
  ],
  "connections": {
    "Webhook Trigger": {
      "main": [
        [
          {
            "node": "Merge Triggers",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Manual Trigger": {
      "main": [
        [
          {
            "node": "Set Test Defaults",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Set Test Defaults": {
      "main": [
        [
          {
            "node": "Merge Triggers",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Merge Triggers": {
      "main": [
        [
          {
            "node": "Validate Input",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Validate Input": {
      "main": [
        [
          {
            "node": "Store Chart Data",
            "type": "main",
            "index": 0
          }
        ]
      ],
      "error": [
        [
          {
            "node": "Format Error",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Store Chart Data": {
      "main": [
        [
          {
            "node": "Execute Database Insert",
            "type": "main",
            "index": 0
          }
        ]
      ],
      "error": [
        [
          {
            "node": "Format Error",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Execute Database Insert": {
      "main": [
        [
          {
            "node": "Prepare Chart Generation",
            "type": "main",
            "index": 0
          }
        ]
      ],
      "error": [
        [
          {
            "node": "Format Error",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Chart Generation": {
      "main": [
        [
          {
            "node": "Execute Chart Generation",
            "type": "main",
            "index": 0
          }
        ]
      ],
      "error": [
        [
          {
            "node": "Format Error",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Execute Chart Generation": {
      "main": [
        [
          {
            "node": "Process Results",
            "type": "main",
            "index": 0
          }
        ]
      ],
      "error": [
        [
          {
            "node": "Format Error",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Process Results": {
      "main": [
        [
          {
            "node": "Update Database",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Update Database": {
      "main": [
        [
          {
            "node": "Success Response",
            "type": "main",
            "index": 0
          },
          {
            "node": "Cleanup Temp Files",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Format Error": {
      "main": [
        [
          {
            "node": "Error Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": true,
  "settings": {
    "executionOrder": "v1",
    "executionTimeout": 120
  },
  "staticData": null,
  "versionId": "chart-generator-v1.0.0",
  "meta": {
    "templateCredsSetupCompleted": true
  },
  "id": "chart-generator",
  "tags": [
    {
      "createdAt": "2025-09-05T00:00:00.000Z",
      "updatedAt": "2025-09-05T00:00:00.000Z",
      "id": "chart-generation",
      "name": "chart-generation"
    },
    {
      "createdAt": "2025-09-05T00:00:00.000Z",
      "updatedAt": "2025-09-05T00:00:00.000Z",
      "id": "data-visualization",
      "name": "data-visualization"
    },
    {
      "createdAt": "2025-09-05T00:00:00.000Z",
      "updatedAt": "2025-09-05T00:00:00.000Z",
      "id": "business-intelligence",
      "name": "business-intelligence"
    },
    {
      "createdAt": "2025-09-05T00:00:00.000Z",
      "updatedAt": "2025-09-05T00:00:00.000Z",
      "id": "professional-charts",
      "name": "professional-charts"
    }
  ]
}