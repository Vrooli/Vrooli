#!/bin/bash

# scenario-to-extension CLI - Browser Extension Generator for Vrooli
# Generated by scenario-to-extension for Vrooli platform

set -e

# Configuration
SCENARIO_NAME="scenario-to-extension"
VERSION="1.0.0"
# Construct API_ENDPOINT from API_PORT if available, otherwise use default
if [[ -n "${API_PORT}" ]]; then
    API_ENDPOINT="${API_ENDPOINT:-http://localhost:${API_PORT}}"
else
    API_ENDPOINT="${API_ENDPOINT:-http://localhost:3201}"
fi
DEBUG="${DEBUG:-false}"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
PURPLE='\033[0;35m'
CYAN='\033[0;36m'
BOLD='\033[1m'
NC='\033[0m' # No Color

# Helper functions
log() {
    echo -e "${GREEN}[$(date +'%H:%M:%S')]${NC} $1" >&2
}

warn() {
    echo -e "${YELLOW}[WARNING]${NC} $1" >&2
}

error() {
    echo -e "${RED}[ERROR]${NC} $1" >&2
    exit 1
}

debug() {
    if [[ "$DEBUG" == "true" ]]; then
        echo -e "${CYAN}[DEBUG]${NC} $1" >&2
    fi
}

# API helper functions
api_request() {
    local method="$1"
    local endpoint="$2" 
    local data="$3"
    
    local url="${API_ENDPOINT}${endpoint}"
    
    debug "Making $method request to $url"
    
    if [[ -n "$data" ]]; then
        curl -s -X "$method" \
             -H "Content-Type: application/json" \
             -d "$data" \
             "$url"
    else
        curl -s -X "$method" \
             -H "Content-Type: application/json" \
             "$url"
    fi
}

check_api_health() {
    local health_response
    health_response=$(api_request "GET" "/api/v1/health" 2>/dev/null || echo "")
    
    if [[ -z "$health_response" ]]; then
        warn "API endpoint not reachable at $API_ENDPOINT"
        return 1
    fi
    
    local status
    status=$(echo "$health_response" | jq -r '.status // empty' 2>/dev/null || echo "")
    
    if [[ "$status" != "healthy" ]]; then
        warn "API endpoint unhealthy: $status"
        return 1
    fi
    
    debug "API health check passed"
    return 0
}

# Command implementations
cmd_help() {
    cat << EOF
${BOLD}scenario-to-extension${NC} - Browser Extension Generator for Vrooli

${BOLD}USAGE:${NC}
    scenario-to-extension <command> [options]

${BOLD}COMMANDS:${NC}
    ${BLUE}generate${NC} <scenario>     Generate browser extension for a scenario
    ${BLUE}build${NC} <path>           Build an existing extension project
    ${BLUE}test${NC} <path>            Test extension functionality
    ${BLUE}status${NC}                Show system status
    ${BLUE}templates${NC}             List available templates
    ${BLUE}builds${NC}                List recent builds
    ${BLUE}help${NC}                  Show this help message
    ${BLUE}version${NC}               Show version information

${BOLD}GENERATE OPTIONS:${NC}
    --template <type>      Extension template type (full, content-script-only, background-only, popup-only)
    --permissions <perms>  Comma-separated browser permissions (storage,activeTab)
    --host-permissions <hosts>  Comma-separated host permission patterns
    --output <dir>         Output directory for generated extension
    --api-endpoint <url>   API endpoint for the scenario
    --debug               Enable debug mode in generated extension

${BOLD}BUILD OPTIONS:${NC}
    --watch               Watch for changes and rebuild automatically
    --minify              Minify output for production

${BOLD}TEST OPTIONS:${NC}
    --sites <urls>        Comma-separated list of test sites
    --headless            Run tests in headless mode
    --screenshot          Take screenshots during testing (default: true)
    --browser <type>      Browser to test with (chrome, firefox, edge)

${BOLD}STATUS OPTIONS:${NC}
    --json                Output status in JSON format
    --verbose             Show detailed status information

${BOLD}EXAMPLES:${NC}
    # Generate a full extension for web-scraper scenario
    scenario-to-extension generate web-scraper --template full --permissions storage,activeTab,scripting

    # Generate popup-only extension
    scenario-to-extension generate my-scenario --template popup-only --output ./extensions/my-extension

    # Build extension with watch mode
    scenario-to-extension build ./platforms/extension --watch

    # Test extension on specific sites
    scenario-to-extension test ./platforms/extension --sites https://example.com,https://google.com

    # Check system status
    scenario-to-extension status --verbose

${BOLD}ENVIRONMENT VARIABLES:${NC}
    API_ENDPOINT          API endpoint (default: http://localhost:3201)
    DEBUG                 Enable debug output (true/false)
    BROWSERLESS_URL       Browserless service URL for testing

For more information, visit: https://github.com/vrooli/vrooli
EOF
}

cmd_version() {
    cat << EOF
${BOLD}scenario-to-extension${NC} version ${VERSION}

Part of the Vrooli AI intelligence platform
Generated extensions bridge scenarios with web browsers

API Endpoint: ${API_ENDPOINT}
Debug Mode: ${DEBUG}

Report issues: https://github.com/vrooli/vrooli/issues
EOF
}

cmd_status() {
    local json_output=false
    local verbose=false
    
    # Parse flags
    while [[ $# -gt 0 ]]; do
        case $1 in
            --json)
                json_output=true
                shift
                ;;
            --verbose)
                verbose=true
                shift
                ;;
            *)
                error "Unknown status option: $1"
                ;;
        esac
    done
    
    log "Checking scenario-to-extension status..."
    
    local health_response
    health_response=$(api_request "GET" "/api/v1/health" 2>/dev/null || echo "")
    
    if [[ -z "$health_response" ]]; then
        if [[ "$json_output" == "true" ]]; then
            echo '{"status":"api_unreachable","api_endpoint":"'$API_ENDPOINT'","timestamp":"'$(date -Iseconds)'"}'
        else
            error "API endpoint unreachable at $API_ENDPOINT"
        fi
        exit 1
    fi
    
    if [[ "$json_output" == "true" ]]; then
        echo "$health_response" | jq '.'
    else
        local status scenario version timestamp
        status=$(echo "$health_response" | jq -r '.status // "unknown"')
        scenario=$(echo "$health_response" | jq -r '.scenario // "unknown"')  
        version=$(echo "$health_response" | jq -r '.version // "unknown"')
        timestamp=$(echo "$health_response" | jq -r '.timestamp // "unknown"')
        
        echo
        echo -e "${BOLD}Scenario Status${NC}"
        echo -e "Status:     ${GREEN}$status${NC}"
        echo -e "Scenario:   $scenario"
        echo -e "Version:    $version"
        echo -e "Timestamp:  $timestamp"
        echo
        
        if [[ "$verbose" == "true" ]]; then
            echo -e "${BOLD}Resources${NC}"
            local browserless_status templates_status
            browserless_status=$(echo "$health_response" | jq -r '.resources.browserless // false')
            templates_status=$(echo "$health_response" | jq -r '.resources.templates // false')
            
            echo -e "Browserless: $([ "$browserless_status" == "true" ] && echo -e "${GREEN}OK${NC}" || echo -e "${RED}FAIL${NC}")"
            echo -e "Templates:   $([ "$templates_status" == "true" ] && echo -e "${GREEN}OK${NC}" || echo -e "${RED}FAIL${NC}")"
            echo
            
            echo -e "${BOLD}Build Statistics${NC}"
            local total_builds active_builds completed_builds failed_builds
            total_builds=$(echo "$health_response" | jq -r '.stats.total_builds // 0')
            active_builds=$(echo "$health_response" | jq -r '.stats.active_builds // 0')
            completed_builds=$(echo "$health_response" | jq -r '.stats.completed_builds // 0')
            failed_builds=$(echo "$health_response" | jq -r '.stats.failed_builds // 0')
            
            echo -e "Total Builds:     $total_builds"
            echo -e "Active Builds:    $active_builds"
            echo -e "Completed Builds: $completed_builds"
            echo -e "Failed Builds:    $failed_builds"
        fi
    fi
}

cmd_generate() {
    local scenario_name="$1"

    if [[ -z "$scenario_name" ]]; then
        error "Scenario name is required. Usage: scenario-to-extension generate <scenario_name>"
    fi

    shift
    
    # Default options
    local template="full"
    local permissions="storage,activeTab"
    local host_permissions="<all_urls>"
    local output_dir="./platforms/extension"
    local api_endpoint="http://localhost:3000"
    local debug_mode="false"
    
    # Parse flags
    while [[ $# -gt 0 ]]; do
        case $1 in
            --template)
                template="$2"
                shift 2
                ;;
            --permissions)
                permissions="$2"
                shift 2
                ;;
            --host-permissions)
                host_permissions="$2"
                shift 2
                ;;
            --output)
                output_dir="$2"
                shift 2
                ;;
            --api-endpoint)
                api_endpoint="$2"
                shift 2
                ;;
            --debug)
                debug_mode="true"
                shift
                ;;
            *)
                error "Unknown generate option: $1"
                ;;
        esac
    done
    
    log "Generating extension for scenario: $scenario_name"
    debug "Template: $template"
    debug "Permissions: $permissions"
    debug "Host permissions: $host_permissions"
    debug "Output directory: $output_dir"
    debug "API endpoint: $api_endpoint"
    
    # Convert comma-separated strings to JSON arrays
    local permissions_json
    local host_permissions_json
    permissions_json=$(echo "$permissions" | jq -R 'split(",") | map(select(length > 0))')
    host_permissions_json=$(echo "$host_permissions" | jq -R 'split(",") | map(select(length > 0))')
    
    # Prepare request payload
    local payload
    payload=$(jq -n \
        --arg scenario_name "$scenario_name" \
        --arg template_type "$template" \
        --arg app_name "$scenario_name Extension" \
        --arg description "Browser extension for $scenario_name scenario" \
        --arg api_endpoint "$api_endpoint" \
        --argjson permissions "$permissions_json" \
        --argjson host_permissions "$host_permissions_json" \
        '{
            scenario_name: $scenario_name,
            template_type: $template_type,
            config: {
                app_name: $app_name,
                app_description: $description,
                api_endpoint: $api_endpoint,
                permissions: $permissions,
                host_permissions: $host_permissions,
                version: "1.0.0",
                author_name: "Vrooli Scenario Generator",
                license: "MIT"
            }
        }')
    
    debug "Request payload: $payload"
    
    # Make API request
    local response
    response=$(api_request "POST" "/api/v1/extension/generate" "$payload")
    
    if [[ -z "$response" ]]; then
        error "Failed to generate extension - no response from API"
    fi
    
    # Parse response
    local build_id extension_path status
    build_id=$(echo "$response" | jq -r '.build_id // empty')
    extension_path=$(echo "$response" | jq -r '.extension_path // empty')
    status=$(echo "$response" | jq -r '.status // empty')
    
    if [[ -z "$build_id" ]]; then
        error "Extension generation failed: $(echo "$response" | jq -r '.error // "Unknown error"')"
    fi
    
    echo
    echo -e "${GREEN}✓${NC} Extension generation started"
    echo -e "Build ID:        $build_id"
    echo -e "Extension Path:  $extension_path"
    echo -e "Status:          $status"
    echo
    echo -e "${BOLD}Next steps:${NC}"
    echo "1. Check generation status: scenario-to-extension status"
    echo "2. Monitor build progress:  scenario-to-extension builds"
    echo "3. Test the extension:      scenario-to-extension test \"$extension_path\""
    echo
    
    # Show install instructions
    local install_instructions
    install_instructions=$(echo "$response" | jq -r '.install_instructions // empty')
    if [[ -n "$install_instructions" ]]; then
        echo -e "${BOLD}Installation Instructions:${NC}"
        echo "$install_instructions"
    fi
}

cmd_build() {
    local extension_path="$1"

    if [[ -z "$extension_path" ]]; then
        error "Extension path is required. Usage: scenario-to-extension build <extension_path>"
    fi

    shift
    
    if [[ ! -d "$extension_path" ]]; then
        error "Extension directory does not exist: $extension_path"
    fi
    
    # Default options
    local watch_mode=false
    local minify_mode=false
    
    # Parse flags
    while [[ $# -gt 0 ]]; do
        case $1 in
            --watch)
                watch_mode=true
                shift
                ;;
            --minify)
                minify_mode=true
                shift
                ;;
            *)
                error "Unknown build option: $1"
                ;;
        esac
    done
    
    log "Building extension at: $extension_path"
    
    # Check for package.json
    if [[ ! -f "$extension_path/package.json" ]]; then
        warn "No package.json found. Creating basic package.json..."
        cd "$extension_path"
        npm init -y > /dev/null 2>&1
        cd - > /dev/null
    fi
    
    # Check for build script
    if [[ ! -f "$extension_path/build.js" ]]; then
        warn "No build.js found. Using basic build process..."
    fi
    
    cd "$extension_path"
    
    # Install dependencies if needed
    if [[ -f "package.json" ]] && [[ ! -d "node_modules" ]]; then
        log "Installing dependencies..."
        npm install
    fi
    
    # Run build command
    if [[ "$watch_mode" == "true" ]]; then
        log "Starting build in watch mode..."
        if command -v npm >/dev/null 2>&1; then
            npm run dev 2>/dev/null || node build.js --watch 2>/dev/null || error "Build script not found"
        else
            node build.js --watch 2>/dev/null || error "Build script not found"
        fi
    else
        log "Building extension..."
        if command -v npm >/dev/null 2>&1; then
            if [[ "$minify_mode" == "true" ]]; then
                npm run build:prod 2>/dev/null || npm run build 2>/dev/null || node build.js --minify 2>/dev/null || error "Build failed"
            else
                npm run build 2>/dev/null || node build.js 2>/dev/null || error "Build failed"
            fi
        else
            if [[ "$minify_mode" == "true" ]]; then
                node build.js --minify 2>/dev/null || error "Build failed"
            else
                node build.js 2>/dev/null || error "Build failed"
            fi
        fi
        
        echo -e "${GREEN}✓${NC} Extension built successfully"
        
        if [[ -d "dist" ]]; then
            echo -e "Output directory: $(pwd)/dist"
        fi
    fi
}

cmd_test() {
    local extension_path="$1"

    if [[ -z "$extension_path" ]]; then
        error "Extension path is required. Usage: scenario-to-extension test <extension_path>"
    fi

    shift
    
    if [[ ! -d "$extension_path" ]]; then
        error "Extension directory does not exist: $extension_path"
    fi
    
    # Default options
    local test_sites="https://example.com"
    local headless_mode=false
    local screenshot_mode=true
    local browser_type="chrome"
    
    # Parse flags
    while [[ $# -gt 0 ]]; do
        case $1 in
            --sites)
                test_sites="$2"
                shift 2
                ;;
            --headless)
                headless_mode=true
                shift
                ;;
            --screenshot)
                screenshot_mode=true
                shift
                ;;
            --no-screenshot)
                screenshot_mode=false
                shift
                ;;
            --browser)
                browser_type="$2"
                shift 2
                ;;
            *)
                error "Unknown test option: $1"
                ;;
        esac
    done
    
    log "Testing extension at: $extension_path"
    debug "Test sites: $test_sites"
    debug "Headless mode: $headless_mode"
    debug "Screenshot mode: $screenshot_mode"
    debug "Browser type: $browser_type"
    
    # Convert comma-separated sites to JSON array
    local test_sites_json
    test_sites_json=$(echo "$test_sites" | jq -R 'split(",") | map(select(length > 0))')
    
    # Prepare test request
    local test_payload
    test_payload=$(jq -n \
        --arg extension_path "$extension_path" \
        --argjson test_sites "$test_sites_json" \
        --argjson screenshot "$screenshot_mode" \
        --argjson headless "$headless_mode" \
        '{
            extension_path: $extension_path,
            test_sites: $test_sites,
            screenshot: $screenshot,
            headless: $headless
        }')
    
    debug "Test payload: $test_payload"
    
    # Make test request
    local response
    response=$(api_request "POST" "/api/v1/extension/test" "$test_payload")
    
    if [[ -z "$response" ]]; then
        error "Extension test failed - no response from API"
    fi
    
    # Parse test results
    local success total_tests passed failed success_rate
    success=$(echo "$response" | jq -r '.success // false')
    total_tests=$(echo "$response" | jq -r '.summary.total_tests // 0')
    passed=$(echo "$response" | jq -r '.summary.passed // 0')
    failed=$(echo "$response" | jq -r '.summary.failed // 0')
    success_rate=$(echo "$response" | jq -r '.summary.success_rate // 0')
    
    echo
    echo -e "${BOLD}Extension Test Results${NC}"
    echo -e "Overall Success: $([ "$success" == "true" ] && echo -e "${GREEN}PASS${NC}" || echo -e "${RED}FAIL${NC}")"
    echo -e "Total Tests:     $total_tests"
    echo -e "Passed:          $passed"
    echo -e "Failed:          $failed"
    echo -e "Success Rate:    ${success_rate}%"
    echo
    
    # Show detailed results
    local test_results
    test_results=$(echo "$response" | jq -r '.test_results[]')
    
    if [[ -n "$test_results" ]]; then
        echo -e "${BOLD}Detailed Results:${NC}"
        echo "$response" | jq -r '.test_results[] | "  " + .site + ": " + (if .loaded then "✓ PASS" else "✗ FAIL" end) + (if (.errors | length) > 0 then " (" + (.errors | join(", ")) + ")" else "" end)'
    fi
    
    # Exit with error code if tests failed
    if [[ "$success" != "true" ]]; then
        exit 1
    fi
}

cmd_templates() {
    log "Fetching available templates..."
    
    local response
    response=$(api_request "GET" "/api/v1/extension/templates")
    
    if [[ -z "$response" ]]; then
        error "Failed to fetch templates"
    fi
    
    echo
    echo -e "${BOLD}Available Extension Templates${NC}"
    echo
    
    echo "$response" | jq -r '.templates[] | "  " + .name + " - " + .display_name + "\n    " + .description + "\n    Files: " + (.files | join(", ")) + "\n"'
}

cmd_builds() {
    log "Fetching recent builds..."
    
    local response
    response=$(api_request "GET" "/api/v1/extension/builds")
    
    if [[ -z "$response" ]]; then
        error "Failed to fetch builds"
    fi
    
    local count
    count=$(echo "$response" | jq -r '.count // 0')
    
    echo
    echo -e "${BOLD}Recent Extension Builds${NC} ($count total)"
    echo
    
    if [[ "$count" -eq 0 ]]; then
        echo "No builds found."
    else
        echo "$response" | jq -r '.builds[] | "  " + .build_id + " - " + .scenario_name + " (" + .status + ")\n    Created: " + .created_at + "\n    Path: " + .extension_path + "\n"'
    fi
}

# Main command dispatch
main() {
    if [[ $# -eq 0 ]]; then
        cmd_help
        exit 0
    fi
    
    local command="$1"
    shift
    
    case "$command" in
        help|--help|-h)
            cmd_help
            ;;
        version|--version|-v)
            cmd_version
            ;;
        status)
            cmd_status "$@"
            ;;
        generate)
            cmd_generate "$@"
            ;;
        build)
            cmd_build "$@"
            ;;
        test)
            cmd_test "$@"
            ;;
        templates)
            cmd_templates
            ;;
        builds)
            cmd_builds
            ;;
        *)
            error "Unknown command: $command. Use 'scenario-to-extension help' for usage information."
            ;;
    esac
}

# Check dependencies
if ! command -v curl >/dev/null 2>&1; then
    error "curl is required but not installed"
fi

if ! command -v jq >/dev/null 2>&1; then
    error "jq is required but not installed"
fi

# Run main function
main "$@"