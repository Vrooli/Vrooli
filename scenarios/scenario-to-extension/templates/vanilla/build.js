#!/usr/bin/env node

/**
 * Build Script for {{APP_NAME}} Extension
 * 
 * This script:
 * - Processes template variables in source files
 * - Copies static assets to dist directory
 * - Validates manifest.json
 * - Optionally watches for file changes
 * 
 * Generated by scenario-to-extension for Vrooli
 */

const fs = require('fs');
const path = require('path');
const { execSync } = require('child_process');

// ============================================
// Configuration
// ============================================

const CONFIG = {
    sourceDir: '.',
    distDir: 'dist',
    templateVars: {
        // These will be replaced during extension generation
        APP_NAME: '{{APP_NAME}}',
        VERSION: '{{VERSION}}',
        APP_DESCRIPTION: '{{APP_DESCRIPTION}}',
        AUTHOR_NAME: '{{AUTHOR_NAME}}',
        LICENSE: '{{LICENSE}}',
        SCENARIO_NAME: '{{SCENARIO_NAME}}',
        API_ENDPOINT: '{{API_ENDPOINT}}',
        PACKAGE_NAME: '{{PACKAGE_NAME}}',
        DEBUG_MODE: {{DEBUG_MODE}},
        
        // Extension-specific variables
        PERMISSIONS: {{PERMISSIONS}},
        HOST_PERMISSIONS: {{HOST_PERMISSIONS}},
        CONTENT_SCRIPTS: {{CONTENT_SCRIPTS}},
        COMMANDS: {{COMMANDS}},
        WEB_ACCESSIBLE_RESOURCES: {{WEB_ACCESSIBLE_RESOURCES}},
        
        // Custom template sections
        CUSTOM_CSS: '{{CUSTOM_CSS}}',
        AUTH_FIELDS: '{{AUTH_FIELDS}}',
        AUTH_CREDENTIAL_MAPPING: '{{AUTH_CREDENTIAL_MAPPING}}',
        STATS_CARDS: '{{STATS_CARDS}}',
        ACTION_BUTTONS: '{{ACTION_BUTTONS}}',
        SCENARIO_SPECIFIC_CONTENT: '{{SCENARIO_SPECIFIC_CONTENT}}',
        
        // JavaScript template sections
        CUSTOM_MESSAGE_HANDLERS: '{{CUSTOM_MESSAGE_HANDLERS}}',
        CUSTOM_EVENT_HANDLERS: '{{CUSTOM_EVENT_HANDLERS}}',
        CUSTOM_ALARM_HANDLERS: '{{CUSTOM_ALARM_HANDLERS}}',
        CUSTOM_COMMAND_HANDLERS: '{{CUSTOM_COMMAND_HANDLERS}}',
        CONTEXT_MENU_SETUP: '{{CONTEXT_MENU_SETUP}}',
        PAGE_LOAD_HANDLERS: '{{PAGE_LOAD_HANDLERS}}',
        TAB_ACTIVATION_HANDLERS: '{{TAB_ACTIVATION_HANDLERS}}',
        UPDATE_HANDLERS: '{{UPDATE_HANDLERS}}',
        
        // Content script sections
        SCENARIO_SPECIFIC_FUNCTIONS: '{{SCENARIO_SPECIFIC_FUNCTIONS}}',
        PAGE_PROCESSING_LOGIC: '{{PAGE_PROCESSING_LOGIC}}',
        AUTO_INJECTION_LOGIC: '{{AUTO_INJECTION_LOGIC}}',
        CUSTOM_CONTENT_MESSAGE_HANDLERS: '{{CUSTOM_CONTENT_MESSAGE_HANDLERS}}',
        CUSTOM_CONTENT_ACTIONS: '{{CUSTOM_CONTENT_ACTIONS}}',
        AUTO_INJECT: {{AUTO_INJECT}},
        
        // Popup sections
        CUSTOM_ACTION_HANDLERS: '{{CUSTOM_ACTION_HANDLERS}}',
        DASHBOARD_RENDER_LOGIC: '{{DASHBOARD_RENDER_LOGIC}}',
        STATS_RENDER_LOGIC: '{{STATS_RENDER_LOGIC}}',
        ACTIONS_RENDER_LOGIC: '{{ACTIONS_RENDER_LOGIC}}'
    }
};

// ============================================
// File Processing
// ============================================

class FileProcessor {
    static processTemplateFile(filePath, templateVars) {
        let content = fs.readFileSync(filePath, 'utf8');
        
        // Replace template variables
        Object.entries(templateVars).forEach(([key, value]) => {
            const regex = new RegExp(`{{${key}}}`, 'g');
            const replacement = typeof value === 'string' ? value : JSON.stringify(value);
            content = content.replace(regex, replacement);
        });
        
        return content;
    }
    
    static copyStaticFiles(sourceDir, distDir) {
        const staticFiles = [
            'icons',
            '_locales',
            'assets',
            'images'
        ];
        
        staticFiles.forEach(item => {
            const sourcePath = path.join(sourceDir, item);
            const distPath = path.join(distDir, item);
            
            if (fs.existsSync(sourcePath)) {
                this.copyRecursive(sourcePath, distPath);
                console.log(`Copied ${item} to dist/`);
            }
        });
    }
    
    static copyRecursive(source, target) {
        if (fs.lstatSync(source).isDirectory()) {
            if (!fs.existsSync(target)) {
                fs.mkdirSync(target, { recursive: true });
            }
            
            fs.readdirSync(source).forEach(file => {
                this.copyRecursive(
                    path.join(source, file),
                    path.join(target, file)
                );
            });
        } else {
            fs.copyFileSync(source, target);
        }
    }
}

// ============================================
// Manifest Validation
// ============================================

class ManifestValidator {
    static validate(manifestPath) {
        try {
            const manifest = JSON.parse(fs.readFileSync(manifestPath, 'utf8'));
            
            // Required fields
            const requiredFields = ['manifest_version', 'name', 'version'];
            for (const field of requiredFields) {
                if (!manifest[field]) {
                    throw new Error(`Missing required field: ${field}`);
                }
            }
            
            // Validate manifest version
            if (manifest.manifest_version !== 3) {
                console.warn('Warning: Using Manifest V2. Consider upgrading to V3.');
            }
            
            // Validate permissions
            if (manifest.permissions) {
                this.validatePermissions(manifest.permissions);
            }
            
            // Validate content scripts
            if (manifest.content_scripts) {
                this.validateContentScripts(manifest.content_scripts);
            }
            
            console.log('✓ Manifest validation passed');
            return true;
            
        } catch (error) {
            console.error('✗ Manifest validation failed:', error.message);
            return false;
        }
    }
    
    static validatePermissions(permissions) {
        const knownPermissions = [
            'activeTab', 'alarms', 'background', 'bookmarks', 'browsingData',
            'clipboardRead', 'clipboardWrite', 'contentSettings', 'contextMenus',
            'cookies', 'declarativeContent', 'desktopCapture', 'downloads',
            'enterprise.deviceAttributes', 'enterprise.hardwarePlatform',
            'enterprise.machineId', 'enterprise.platformKeys', 'fileBrowserHandler',
            'fileSystemProvider', 'fontSettings', 'gcm', 'geolocation', 'history',
            'identity', 'idle', 'loginState', 'management', 'nativeMessaging',
            'notifications', 'pageCapture', 'power', 'printerProvider', 'privacy',
            'processes', 'proxy', 'scripting', 'search', 'sessions', 'storage',
            'system.cpu', 'system.display', 'system.memory', 'system.storage',
            'tabCapture', 'tabs', 'topSites', 'tts', 'ttsEngine', 'unlimitedStorage',
            'vpnProvider', 'wallpaper', 'webNavigation', 'webRequest',
            'webRequestBlocking'
        ];
        
        const unknownPermissions = permissions.filter(p => !knownPermissions.includes(p));
        if (unknownPermissions.length > 0) {
            console.warn('Warning: Unknown permissions:', unknownPermissions);
        }
    }
    
    static validateContentScripts(contentScripts) {
        contentScripts.forEach((script, index) => {
            if (!script.matches || script.matches.length === 0) {
                console.warn(`Warning: Content script ${index} has no matches`);
            }
            
            if (!script.js && !script.css) {
                console.warn(`Warning: Content script ${index} has no js or css files`);
            }
        });
    }
}

// ============================================
// Build Process
// ============================================

class Builder {
    constructor(config) {
        this.config = config;
        this.isWatching = false;
    }
    
    async build() {
        console.log('Building extension...');
        
        try {
            // Clean dist directory
            if (fs.existsSync(this.config.distDir)) {
                fs.rmSync(this.config.distDir, { recursive: true });
            }
            fs.mkdirSync(this.config.distDir, { recursive: true });
            
            // Process template files
            const templateFiles = [
                'manifest.json',
                'background.js',
                'content.js',
                'popup.html',
                'popup.js'
            ];
            
            for (const file of templateFiles) {
                const sourcePath = path.join(this.config.sourceDir, file);
                const distPath = path.join(this.config.distDir, file);
                
                if (fs.existsSync(sourcePath)) {
                    const processedContent = FileProcessor.processTemplateFile(
                        sourcePath,
                        this.config.templateVars
                    );
                    fs.writeFileSync(distPath, processedContent);
                    console.log(`Processed ${file}`);
                }
            }
            
            // Copy static files
            FileProcessor.copyStaticFiles(this.config.sourceDir, this.config.distDir);
            
            // Create default icons if none exist
            this.createDefaultIcons();
            
            // Validate manifest
            const manifestPath = path.join(this.config.distDir, 'manifest.json');
            if (fs.existsSync(manifestPath)) {
                ManifestValidator.validate(manifestPath);
            }
            
            console.log('✓ Build completed successfully');
            
        } catch (error) {
            console.error('✗ Build failed:', error.message);
            process.exit(1);
        }
    }
    
    createDefaultIcons() {
        const iconsDir = path.join(this.config.distDir, 'icons');
        if (!fs.existsSync(iconsDir)) {
            fs.mkdirSync(iconsDir, { recursive: true });
            
            // Create simple placeholder icons (would be better to use actual icons)
            const iconSizes = [16, 32, 48, 128];
            iconSizes.forEach(size => {
                const iconPath = path.join(iconsDir, `icon-${size}.png`);
                // In a real implementation, you'd create actual PNG files
                // For now, just create empty files as placeholders
                fs.writeFileSync(iconPath, '');
                console.log(`Created placeholder icon-${size}.png`);
            });
        }
    }
    
    async watch() {
        if (this.isWatching) return;
        
        console.log('Watching for file changes...');
        this.isWatching = true;
        
        const chokidar = require('chokidar');
        const watcher = chokidar.watch(this.config.sourceDir, {
            ignored: [this.config.distDir, 'node_modules', '.git'],
            persistent: true
        });
        
        watcher.on('change', (filePath) => {
            console.log(`File changed: ${filePath}`);
            this.build();
        });
        
        watcher.on('add', (filePath) => {
            console.log(`File added: ${filePath}`);
            this.build();
        });
        
        watcher.on('unlink', (filePath) => {
            console.log(`File removed: ${filePath}`);
            this.build();
        });
    }
}

// ============================================
// CLI Interface
// ============================================

function main() {
    const args = process.argv.slice(2);
    const isWatch = args.includes('--watch') || args.includes('-w');
    
    console.log(`{{APP_NAME}} Extension Builder v{{VERSION}}`);
    console.log('Generated by scenario-to-extension for Vrooli\n');
    
    const builder = new Builder(CONFIG);
    
    if (isWatch) {
        builder.build().then(() => {
            builder.watch();
        });
    } else {
        builder.build();
    }
}

// Run if called directly
if (require.main === module) {
    main();
}

module.exports = { Builder, FileProcessor, ManifestValidator };