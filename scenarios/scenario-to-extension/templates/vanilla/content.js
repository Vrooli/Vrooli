/**
 * Content Script for {{APP_NAME}} Extension
 * 
 * This script runs in the context of web pages and handles:
 * - Page data extraction and analysis
 * - DOM manipulation and enhancement
 * - User interaction monitoring
 * - Communication with background service worker
 * 
 * Generated by scenario-to-extension for Vrooli
 */

// ============================================
// Configuration
// ============================================

const CONTENT_CONFIG = {
    SCENARIO_NAME: '{{SCENARIO_NAME}}',
    VERSION: '{{VERSION}}',
    DEBUG: {{DEBUG_MODE}},
    AUTO_INJECT: {{AUTO_INJECT}},
    OBSERVER_CONFIG: {
        childList: true,
        subtree: true,
        attributes: true,
        attributeOldValue: true
    }
};

// ============================================
// State Management
// ============================================

class ContentState {
    constructor() {
        this.isInitialized = false;
        this.isActive = true;
        this.pageData = {};
        this.observers = new Set();
        this.injectedElements = new Set();
        this.eventListeners = new Map();
    }
    
    cleanup() {
        // Remove observers
        this.observers.forEach(observer => observer.disconnect());
        this.observers.clear();
        
        // Remove injected elements
        this.injectedElements.forEach(element => {
            if (element.parentNode) {
                element.parentNode.removeChild(element);
            }
        });
        this.injectedElements.clear();
        
        // Remove event listeners
        this.eventListeners.forEach((listener, element) => {
            element.removeEventListener(listener.event, listener.handler);
        });
        this.eventListeners.clear();
        
        this.isActive = false;
    }
}

const contentState = new ContentState();

// ============================================
// Background Communication
// ============================================

class BackgroundMessenger {
    static async send(type, data = {}) {
        return new Promise((resolve) => {
            chrome.runtime.sendMessage({ type, data }, (response) => {
                if (chrome.runtime.lastError) {
                    console.error('Message error:', chrome.runtime.lastError);
                    resolve({ error: chrome.runtime.lastError.message });
                } else {
                    resolve(response || { success: true });
                }
            });
        });
    }
    
    static async getState() {
        return this.send('GET_STATE');
    }
    
    static async syncData(data) {
        return this.send('CONTENT_SCRIPT_DATA', { 
            ...data, 
            url: window.location.href,
            timestamp: Date.now(),
            syncToScenario: true
        });
    }
    
    static async executeAction(action, payload) {
        return this.send('SCENARIO_ACTION', { action, data: payload });
    }
    
    static async getPageInfo() {
        return this.send('GET_CURRENT_PAGE');
    }
}

// ============================================
// Page Analysis
// ============================================

class PageAnalyzer {
    static extractBasicInfo() {
        return {
            title: document.title,
            url: window.location.href,
            domain: window.location.hostname,
            path: window.location.pathname,
            timestamp: Date.now()
        };
    }
    
    static extractMetadata() {
        const meta = {};
        
        // Standard meta tags
        document.querySelectorAll('meta').forEach(tag => {
            const name = tag.getAttribute('name') || tag.getAttribute('property');
            const content = tag.getAttribute('content');
            if (name && content) {
                meta[name] = content;
            }
        });
        
        // Structured data
        const jsonLdScripts = document.querySelectorAll('script[type="application/ld+json"]');
        const structuredData = [];
        jsonLdScripts.forEach(script => {
            try {
                const data = JSON.parse(script.textContent);
                structuredData.push(data);
            } catch (e) {
                console.debug('Failed to parse JSON-LD:', e);
            }
        });
        
        return { meta, structuredData };
    }
    
    static extractContent() {
        const content = {
            headings: [],
            paragraphs: [],
            links: [],
            images: [],
            forms: []
        };
        
        // Headings
        document.querySelectorAll('h1, h2, h3, h4, h5, h6').forEach(heading => {
            content.headings.push({
                level: parseInt(heading.tagName.substring(1)),
                text: heading.textContent.trim(),
                id: heading.id || null
            });
        });
        
        // Paragraphs (sample first few)
        const paragraphs = document.querySelectorAll('p');
        for (let i = 0; i < Math.min(paragraphs.length, 10); i++) {
            const p = paragraphs[i];
            if (p.textContent.trim().length > 20) {
                content.paragraphs.push(p.textContent.trim().substring(0, 200));
            }
        }
        
        // Links (external only)
        document.querySelectorAll('a[href]').forEach(link => {
            const href = link.getAttribute('href');
            if (href && (href.startsWith('http') || href.startsWith('//'))) {
                content.links.push({
                    text: link.textContent.trim(),
                    href: href,
                    title: link.getAttribute('title') || null
                });
            }
        });
        
        // Images
        document.querySelectorAll('img[src]').forEach(img => {
            content.images.push({
                src: img.getAttribute('src'),
                alt: img.getAttribute('alt') || null,
                title: img.getAttribute('title') || null
            });
        });
        
        // Forms
        document.querySelectorAll('form').forEach(form => {
            const inputs = [];
            form.querySelectorAll('input, select, textarea').forEach(input => {
                inputs.push({
                    type: input.type || input.tagName.toLowerCase(),
                    name: input.name || null,
                    id: input.id || null,
                    placeholder: input.placeholder || null
                });
            });
            
            content.forms.push({
                action: form.getAttribute('action') || null,
                method: form.getAttribute('method') || 'get',
                inputs: inputs
            });
        });
        
        return content;
    }
    
    static async analyzeFullPage() {
        const basicInfo = this.extractBasicInfo();
        const metadata = this.extractMetadata();
        const content = this.extractContent();
        
        return {
            ...basicInfo,
            ...metadata,
            content,
            analysisTimestamp: Date.now()
        };
    }
}

// ============================================
// DOM Enhancement
// ============================================

class DOMEnhancer {
    static createScenarioElement(tag, attributes = {}, content = '') {
        const element = document.createElement(tag);
        
        // Add scenario-specific attributes
        element.setAttribute('data-scenario', CONTENT_CONFIG.SCENARIO_NAME);
        element.setAttribute('data-version', CONTENT_CONFIG.VERSION);
        
        // Apply provided attributes
        Object.entries(attributes).forEach(([key, value]) => {
            element.setAttribute(key, value);
        });
        
        if (content) {
            element.innerHTML = content;
        }
        
        contentState.injectedElements.add(element);
        return element;
    }
    
    static injectCSS(cssText) {
        const style = this.createScenarioElement('style', {
            'data-scenario-css': 'true'
        }, cssText);
        
        document.head.appendChild(style);
        return style;
    }
    
    static injectFloatingWidget(content, position = 'bottom-right') {
        const widget = this.createScenarioElement('div', {
            'data-scenario-widget': 'true',
            'style': `
                position: fixed;
                z-index: 999999;
                background: white;
                border: 2px solid #4CAF50;
                border-radius: 8px;
                padding: 12px;
                box-shadow: 0 4px 12px rgba(0,0,0,0.15);
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
                font-size: 14px;
                max-width: 300px;
                ${position === 'bottom-right' ? 'bottom: 20px; right: 20px;' : ''}
                ${position === 'bottom-left' ? 'bottom: 20px; left: 20px;' : ''}
                ${position === 'top-right' ? 'top: 20px; right: 20px;' : ''}
                ${position === 'top-left' ? 'top: 20px; left: 20px;' : ''}
            `
        }, content);
        
        document.body.appendChild(widget);
        
        // Make draggable
        this.makeDraggable(widget);
        
        return widget;
    }
    
    static makeDraggable(element) {
        let isDragging = false;
        let startX, startY, startLeft, startTop;
        
        element.style.cursor = 'move';
        
        const onMouseDown = (e) => {
            isDragging = true;
            startX = e.clientX;
            startY = e.clientY;
            const rect = element.getBoundingClientRect();
            startLeft = rect.left;
            startTop = rect.top;
            element.style.opacity = '0.8';
        };
        
        const onMouseMove = (e) => {
            if (!isDragging) return;
            
            const deltaX = e.clientX - startX;
            const deltaY = e.clientY - startY;
            
            element.style.left = `${startLeft + deltaX}px`;
            element.style.top = `${startTop + deltaY}px`;
            element.style.right = 'auto';
            element.style.bottom = 'auto';
        };
        
        const onMouseUp = () => {
            isDragging = false;
            element.style.opacity = '1';
        };
        
        element.addEventListener('mousedown', onMouseDown);
        document.addEventListener('mousemove', onMouseMove);
        document.addEventListener('mouseup', onMouseUp);
        
        // Store event listeners for cleanup
        contentState.eventListeners.set(element, {
            event: 'mousedown',
            handler: onMouseDown
        });
    }
    
    static highlightElements(selector, highlightClass = 'scenario-highlight') {
        const elements = document.querySelectorAll(selector);
        elements.forEach(element => {
            element.classList.add(highlightClass);
        });
        
        // Inject highlight CSS if not already present
        if (!document.querySelector('style[data-scenario-highlight]')) {
            this.injectCSS(`
                .scenario-highlight {
                    outline: 2px solid #4CAF50 !important;
                    outline-offset: 2px !important;
                    background-color: rgba(76, 175, 80, 0.1) !important;
                }
            `).setAttribute('data-scenario-highlight', 'true');
        }
        
        return elements;
    }
}

// ============================================
// Event Monitoring
// ============================================

class EventMonitor {
    static setupPageChangeObserver() {
        const observer = new MutationObserver((mutations) => {
            const significantChanges = mutations.some(mutation => 
                mutation.type === 'childList' && mutation.addedNodes.length > 0
            );
            
            if (significantChanges) {
                deferredPageAnalysis();
            }
        });
        
        observer.observe(document.body, CONTENT_CONFIG.OBSERVER_CONFIG);
        contentState.observers.add(observer);
        
        return observer;
    }
    
    static setupInteractionTracking() {
        const trackedEvents = ['click', 'input', 'change', 'submit'];
        
        trackedEvents.forEach(eventType => {
            const handler = (event) => {
                // Filter to relevant interactions
                if (this.isRelevantElement(event.target)) {
                    this.trackInteraction(eventType, event);
                }
            };
            
            document.addEventListener(eventType, handler, true);
            contentState.eventListeners.set(document, {
                event: eventType,
                handler: handler
            });
        });
    }
    
    static isRelevantElement(element) {
        const relevantTags = ['input', 'button', 'select', 'textarea', 'a', 'form'];
        const tagName = element.tagName.toLowerCase();
        
        return relevantTags.includes(tagName) || 
               element.hasAttribute('data-action') ||
               element.classList.contains('btn') ||
               element.classList.contains('button');
    }
    
    static async trackInteraction(eventType, event) {
        const interactionData = {
            type: eventType,
            element: {
                tagName: event.target.tagName.toLowerCase(),
                id: event.target.id || null,
                className: event.target.className || null,
                text: event.target.textContent?.trim().substring(0, 100) || null
            },
            timestamp: Date.now()
        };
        
        // Send to background script for processing
        await BackgroundMessenger.syncData({
            type: 'interaction',
            data: interactionData
        });
    }
}

// ============================================
// Scenario-Specific Features
// ============================================

{{SCENARIO_SPECIFIC_FUNCTIONS}}

// ============================================
// Initialization and Lifecycle
// ============================================

let pageAnalysisTimeout;

function deferredPageAnalysis() {
    clearTimeout(pageAnalysisTimeout);
    pageAnalysisTimeout = setTimeout(async () => {
        if (!contentState.isActive) return;
        
        try {
            const pageData = await PageAnalyzer.analyzeFullPage();
            contentState.pageData = pageData;
            
            // Sync with background script
            await BackgroundMessenger.syncData({
                type: 'page_analysis',
                data: pageData
            });
            
            // Execute scenario-specific page processing
            await processPageForScenario(pageData);
            
        } catch (error) {
            console.error('Page analysis failed:', error);
        }
    }, 1000); // Debounce page changes
}

async function processPageForScenario(pageData) {
    {{PAGE_PROCESSING_LOGIC}}
}

async function initializeContentScript() {
    if (contentState.isInitialized) return;
    
    console.log(`{{APP_NAME}} content script initializing on ${window.location.href}`);
    
    try {
        // Get extension state from background
        const state = await BackgroundMessenger.getState();
        
        if (!state.isAuthenticated) {
            console.log('Extension not authenticated, limited functionality');
        }
        
        // Set up monitoring
        EventMonitor.setupPageChangeObserver();
        EventMonitor.setupInteractionTracking();
        
        // Perform initial page analysis
        deferredPageAnalysis();
        
        // Auto-inject scenario features if enabled
        if (CONTENT_CONFIG.AUTO_INJECT) {
            await autoInjectScenarioFeatures();
        }
        
        contentState.isInitialized = true;
        console.log(`{{APP_NAME}} content script initialized`);
        
    } catch (error) {
        console.error('Content script initialization failed:', error);
    }
}

async function autoInjectScenarioFeatures() {
    {{AUTO_INJECTION_LOGIC}}
}

// ============================================
// Message Handling from Background
// ============================================

chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
    if (sender.id !== chrome.runtime.id) return;
    
    handleBackgroundMessage(message, sendResponse);
    return true; // Keep channel open
});

async function handleBackgroundMessage(message, sendResponse) {
    try {
        switch (message.type) {
            case 'EXECUTE_CONTENT_ACTION':
                const result = await executeContentAction(message.action, message.data);
                sendResponse({ success: true, result });
                break;
                
            case 'GET_PAGE_DATA':
                sendResponse({ 
                    success: true, 
                    data: contentState.pageData 
                });
                break;
                
            case 'HIGHLIGHT_ELEMENTS':
                const elements = DOMEnhancer.highlightElements(message.selector);
                sendResponse({ 
                    success: true, 
                    count: elements.length 
                });
                break;
                
            case 'INJECT_CONTENT':
                DOMEnhancer.injectFloatingWidget(message.content, message.position);
                sendResponse({ success: true });
                break;
                
            {{CUSTOM_CONTENT_MESSAGE_HANDLERS}}
                
            default:
                sendResponse({ success: false, error: 'Unknown content action' });
        }
    } catch (error) {
        console.error('Content message handling failed:', error);
        sendResponse({ success: false, error: error.message });
    }
}

async function executeContentAction(action, data) {
    switch (action) {
        {{CUSTOM_CONTENT_ACTIONS}}
        
        default:
            throw new Error(`Unknown content action: ${action}`);
    }
}

// ============================================
// Cleanup
// ============================================

function cleanup() {
    console.log('{{APP_NAME}} content script cleaning up');
    contentState.cleanup();
    clearTimeout(pageAnalysisTimeout);
}

// Handle page navigation/refresh
window.addEventListener('beforeunload', cleanup);

// Handle extension unload
chrome.runtime.onConnect.addListener((port) => {
    port.onDisconnect.addListener(cleanup);
});

// ============================================
// Initialization
// ============================================

// Initialize when DOM is ready
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initializeContentScript);
} else {
    initializeContentScript();
}

console.log(`{{APP_NAME}} content script loaded (v${CONTENT_CONFIG.VERSION})`);