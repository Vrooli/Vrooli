/**
 * Background Service Worker for {{APP_NAME}} Extension
 * 
 * This service worker handles:
 * - API communication with {{APP_NAME}} scenario
 * - Cross-component messaging (popup <-> content scripts)
 * - Browser event handling and automation
 * - Persistent state management
 * 
 * Generated by scenario-to-extension for Vrooli
 */

// ============================================
// Configuration
// ============================================

const CONFIG = {
    API_BASE: '{{API_ENDPOINT}}',
    SCENARIO_NAME: '{{SCENARIO_NAME}}',
    VERSION: '{{VERSION}}',
    DEBUG: {{DEBUG_MODE}},
};

// ============================================
// State Management
// ============================================

class ExtensionState {
    constructor() {
        this.isAuthenticated = false;
        this.user = null;
        this.lastSync = 0;
        this.scenarioData = {};
        this.activeFeatures = new Set();
    }
    
    async load() {
        const saved = await chrome.storage.local.get('extensionState');
        if (saved.extensionState) {
            Object.assign(this, saved.extensionState);
            this.activeFeatures = new Set(saved.extensionState.activeFeatures || []);
        }
    }
    
    async save() {
        await chrome.storage.local.set({ 
            extensionState: {
                ...this,
                activeFeatures: Array.from(this.activeFeatures)
            }
        });
    }
}

const state = new ExtensionState();

// ============================================
// Lifecycle Events
// ============================================

chrome.runtime.onInstalled.addListener(async (details) => {
    console.log(`{{APP_NAME}} Extension ${details.reason}`);
    
    if (details.reason === 'install') {
        await initializeExtension();
        // Optional: Open scenario welcome page
        // chrome.tabs.create({ url: '{{API_ENDPOINT}}/welcome' });
    } else if (details.reason === 'update') {
        await handleUpdate(details.previousVersion);
    }
});

chrome.runtime.onStartup.addListener(async () => {
    console.log('{{APP_NAME}} Extension started');
    await initializeExtension();
});

// ============================================
// Message Handling
// ============================================

chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
    console.log('Message received:', message);
    
    handleMessage(message, sender, sendResponse);
    return true; // Keep channel open for async response
});

async function handleMessage(message, sender, sendResponse) {
    try {
        switch (message.type) {
            case 'GET_STATE':
                sendResponse({ 
                    isAuthenticated: state.isAuthenticated, 
                    user: state.user,
                    scenarioData: state.scenarioData,
                    features: Array.from(state.activeFeatures)
                });
                break;
                
            case 'AUTHENTICATE':
                const authResult = await handleAuthentication(message.credentials);
                sendResponse(authResult);
                break;
                
            case 'SCENARIO_ACTION':
                const actionResult = await executeScenarioAction(message.action, message.data);
                sendResponse(actionResult);
                break;
                
            case 'SYNC_DATA':
                await syncWithScenario();
                sendResponse({ success: true, lastSync: state.lastSync });
                break;
                
            case 'GET_CURRENT_PAGE':
                const pageInfo = await getCurrentPageInfo(sender.tab);
                sendResponse({ pageInfo });
                break;
                
            case 'CONTENT_SCRIPT_DATA':
                await handleContentScriptData(message.data, sender.tab);
                sendResponse({ received: true });
                break;
                
            {{CUSTOM_MESSAGE_HANDLERS}}
                
            default:
                sendResponse({ error: 'Unknown message type: ' + message.type });
        }
    } catch (error) {
        console.error('Error handling message:', error);
        sendResponse({ error: error.message, stack: error.stack });
    }
}

// ============================================
// Scenario API Communication
// ============================================

class ScenarioAPI {
    static async request(endpoint, options = {}) {
        const token = await chrome.storage.local.get('authToken');
        
        const response = await fetch(`${CONFIG.API_BASE}${endpoint}`, {
            ...options,
            headers: {
                'Content-Type': 'application/json',
                'X-Extension-Version': CONFIG.VERSION,
                'X-Scenario-Name': CONFIG.SCENARIO_NAME,
                ...(token.authToken && { 'Authorization': `Bearer ${token.authToken}` }),
                ...options.headers,
            },
        });
        
        if (!response.ok) {
            throw new Error(`Scenario API error: ${response.status} ${response.statusText}`);
        }
        
        return response.json();
    }
    
    static async authenticate(credentials) {
        return this.request('/auth/extension', {
            method: 'POST',
            body: JSON.stringify({
                ...credentials,
                extensionId: chrome.runtime.id,
                extensionVersion: CONFIG.VERSION
            })
        });
    }
    
    static async getScenarioData(dataType) {
        return this.request(`/api/v1/extension/data/${dataType}`);
    }
    
    static async executeAction(action, payload) {
        return this.request(`/api/v1/extension/action/${action}`, {
            method: 'POST',
            body: JSON.stringify(payload)
        });
    }
    
    static async syncState(extensionState) {
        return this.request('/api/v1/extension/sync', {
            method: 'POST',
            body: JSON.stringify(extensionState)
        });
    }
}

// ============================================
// Core Functions
// ============================================

async function initializeExtension() {
    await state.load();
    await checkAuthentication();
    await syncWithScenario();
    updateBadge();
    setupPeriodicSync();
}

async function handleAuthentication(credentials) {
    try {
        const response = await ScenarioAPI.authenticate(credentials);
        
        state.isAuthenticated = true;
        state.user = response.user;
        
        await chrome.storage.local.set({ authToken: response.token });
        await state.save();
        
        updateBadge();
        
        return { success: true, user: response.user };
    } catch (error) {
        console.error('Authentication failed:', error);
        return { success: false, error: error.message };
    }
}

async function checkAuthentication() {
    const { authToken } = await chrome.storage.local.get('authToken');
    if (authToken) {
        try {
            const response = await ScenarioAPI.request('/auth/verify');
            state.isAuthenticated = true;
            state.user = response.user;
        } catch (error) {
            console.error('Auth verification failed:', error);
            state.isAuthenticated = false;
            await chrome.storage.local.remove('authToken');
        }
    }
}

async function executeScenarioAction(action, data) {
    if (!state.isAuthenticated) {
        throw new Error('Extension not authenticated with scenario');
    }
    
    try {
        const result = await ScenarioAPI.executeAction(action, {
            ...data,
            extensionContext: await getExtensionContext()
        });
        
        // Update local state if needed
        if (result.stateUpdate) {
            Object.assign(state.scenarioData, result.stateUpdate);
            await state.save();
        }
        
        return result;
    } catch (error) {
        console.error('Scenario action failed:', error);
        throw error;
    }
}

async function syncWithScenario() {
    if (!state.isAuthenticated) return;
    
    try {
        console.log('Syncing with scenario...');
        
        const syncResult = await ScenarioAPI.syncState({
            lastSync: state.lastSync,
            extensionData: state.scenarioData,
            browserContext: await getBrowserContext()
        });
        
        if (syncResult.dataUpdate) {
            Object.assign(state.scenarioData, syncResult.dataUpdate);
        }
        
        state.lastSync = Date.now();
        await state.save();
        
        updateBadge();
        
    } catch (error) {
        console.error('Sync failed:', error);
    }
}

function updateBadge() {
    if (state.isAuthenticated) {
        chrome.action.setBadgeText({ text: '' });
        chrome.action.setBadgeBackgroundColor({ color: '#4CAF50' });
        chrome.action.setTitle({ title: `{{APP_NAME}} - Connected` });
    } else {
        chrome.action.setBadgeText({ text: '!' });
        chrome.action.setBadgeBackgroundColor({ color: '#FF9800' });
        chrome.action.setTitle({ title: `{{APP_NAME}} - Not Connected` });
    }
}

function setupPeriodicSync() {
    // Sync every 5 minutes
    chrome.alarms.create('scenarioSync', { periodInMinutes: 5 });
}

// ============================================
// Browser Event Handling
// ============================================

chrome.tabs.onUpdated.addListener(async (tabId, changeInfo, tab) => {
    if (changeInfo.status === 'complete' && tab.url) {
        await handlePageLoad(tab);
    }
});

chrome.tabs.onActivated.addListener(async (activeInfo) => {
    const tab = await chrome.tabs.get(activeInfo.tabId);
    await handleTabActivation(tab);
});

{{CUSTOM_EVENT_HANDLERS}}

// ============================================
// Alarm Handling
// ============================================

chrome.alarms.onAlarm.addListener(async (alarm) => {
    switch (alarm.name) {
        case 'scenarioSync':
            await syncWithScenario();
            break;
        {{CUSTOM_ALARM_HANDLERS}}
    }
});

// ============================================
// Keyboard Commands
// ============================================

chrome.commands.onCommand.addListener(async (command) => {
    console.log('Command triggered:', command);
    
    switch (command) {
        {{CUSTOM_COMMAND_HANDLERS}}
        default:
            console.warn('Unknown command:', command);
    }
});

// ============================================
// Context Menu Handling
// ============================================

{{CONTEXT_MENU_SETUP}}

// ============================================
// Helper Functions
// ============================================

async function getCurrentPageInfo(tab) {
    if (!tab) {
        const [activeTab] = await chrome.tabs.query({ active: true, currentWindow: true });
        tab = activeTab;
    }
    
    return {
        url: tab.url,
        title: tab.title,
        id: tab.id,
        windowId: tab.windowId,
        active: tab.active
    };
}

async function handleContentScriptData(data, tab) {
    console.log('Content script data received:', data);
    
    // Process content script data and potentially sync with scenario
    state.scenarioData.pageData = state.scenarioData.pageData || {};
    state.scenarioData.pageData[tab.url] = {
        ...data,
        lastUpdated: Date.now()
    };
    
    await state.save();
    
    // Optionally send to scenario API
    if (state.isAuthenticated && data.syncToScenario) {
        try {
            await ScenarioAPI.executeAction('processPageData', {
                url: tab.url,
                data: data
            });
        } catch (error) {
            console.error('Failed to sync page data to scenario:', error);
        }
    }
}

async function getExtensionContext() {
    return {
        version: CONFIG.VERSION,
        id: chrome.runtime.id,
        activeFeatures: Array.from(state.activeFeatures),
        lastSync: state.lastSync
    };
}

async function getBrowserContext() {
    const [activeTab] = await chrome.tabs.query({ active: true, currentWindow: true });
    return {
        activeTab: activeTab ? {
            url: activeTab.url,
            title: activeTab.title,
            id: activeTab.id
        } : null,
        timestamp: Date.now()
    };
}

async function handlePageLoad(tab) {
    console.log('Page loaded:', tab.url);
    
    {{PAGE_LOAD_HANDLERS}}
}

async function handleTabActivation(tab) {
    console.log('Tab activated:', tab.url);
    
    {{TAB_ACTIVATION_HANDLERS}}
}

async function handleUpdate(previousVersion) {
    console.log(`Updated from version ${previousVersion}`);
    
    // Handle version migrations
    {{UPDATE_HANDLERS}}
}

// ============================================
// Error Handling
// ============================================

self.addEventListener('unhandledrejection', (event) => {
    console.error('Unhandled promise rejection:', event.reason);
    
    // Optional: Report to scenario error tracking
    if (state.isAuthenticated) {
        ScenarioAPI.executeAction('reportError', {
            type: 'unhandledRejection',
            error: event.reason?.toString(),
            stack: event.reason?.stack,
            context: 'background_service_worker'
        }).catch(err => console.error('Failed to report error:', err));
    }
});

// ============================================
// Initialization
// ============================================

console.log(`{{APP_NAME}} Background Service Worker loaded (v${CONFIG.VERSION})`);

// Initialize when the service worker starts
initializeExtension().catch(error => {
    console.error('Failed to initialize extension:', error);
});