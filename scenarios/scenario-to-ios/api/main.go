package main

import (
	"encoding/json"
	"fmt"
	"log"
	"net/http"
	"os"
	"path/filepath"
	"strings"
	"time"
)

type Server struct {
	router *http.ServeMux
	logger *log.Logger
}

type BuildRequest struct {
	ScenarioName    string                 `json:"scenario_name"`
	ConfigOverrides map[string]interface{} `json:"config_overrides,omitempty"`
}

type BuildResponse struct {
	Success  bool              `json:"success"`
	IPAPath  string            `json:"ipa_path,omitempty"`
	BuildID  string            `json:"build_id,omitempty"`
	Metadata map[string]string `json:"metadata,omitempty"`
	Error    string            `json:"error,omitempty"`
}

func (s *Server) respondJSON(w http.ResponseWriter, data interface{}) {
	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(data)
}

func (s *Server) respondError(w http.ResponseWriter, statusCode int, errMsg string) {
	w.WriteHeader(statusCode)
	s.respondJSON(w, BuildResponse{
		Success: false,
		Error:   errMsg,
	})
}

func (s *Server) handleHealth(w http.ResponseWriter, r *http.Request) {
	response := map[string]string{
		"status":    "healthy",
		"service":   "scenario-to-ios",
		"timestamp": time.Now().UTC().Format(time.RFC3339),
	}
	s.respondJSON(w, response)
}

func (s *Server) handleBuild(w http.ResponseWriter, r *http.Request) {
	if r.Method != http.MethodPost {
		s.respondError(w, http.StatusMethodNotAllowed, "Only POST method allowed")
		return
	}

	var req BuildRequest
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		s.respondError(w, http.StatusBadRequest, fmt.Sprintf("Invalid JSON: %v", err))
		return
	}

	// Validate scenario name
	if req.ScenarioName == "" {
		s.respondError(w, http.StatusBadRequest, "scenario_name is required")
		return
	}

	// Sanitize scenario name (prevent path traversal)
	scenarioName := filepath.Base(req.ScenarioName)
	if scenarioName != req.ScenarioName || strings.Contains(scenarioName, "..") {
		s.respondError(w, http.StatusBadRequest, "Invalid scenario_name format")
		return
	}

	s.logInfo("Building iOS app for scenario: %s", scenarioName)

	// Check if scenario exists (stub - will verify actual scenario path later)
	scenarioPath := fmt.Sprintf("/home/matthalloran8/Vrooli/scenarios/%s", scenarioName)
	if _, err := os.Stat(scenarioPath); os.IsNotExist(err) {
		s.respondError(w, http.StatusNotFound, fmt.Sprintf("Scenario not found: %s", scenarioName))
		return
	}

	// Generate build ID
	buildID := fmt.Sprintf("ios-%s-%d", scenarioName, time.Now().Unix())

	// Create build output directory
	buildDir := fmt.Sprintf("/tmp/builds/%s", buildID)
	if err := os.MkdirAll(buildDir, 0755); err != nil {
		s.logError("Failed to create build directory: %v", err)
		s.respondError(w, http.StatusInternalServerError, fmt.Sprintf("Failed to create build directory: %v", err))
		return
	}

	// Expand template
	expander := NewTemplateExpander(scenarioName)
	projectDir := filepath.Join(buildDir, "project")
	if err := expander.ExpandTemplate(projectDir); err != nil {
		s.logError("Template expansion failed: %v", err)
		s.respondError(w, http.StatusInternalServerError, fmt.Sprintf("Template expansion failed: %v", err))
		return
	}

	s.logInfo("Template expanded successfully to: %s", projectDir)

	// Build metadata
	metadata := map[string]string{
		"scenario_name":        scenarioName,
		"status":               "template_expanded",
		"message":              "iOS project generated, IPA build requires Xcode on macOS",
		"minimum_ios_version":  "15.0",
		"supported_devices":    "iPhone, iPad",
		"implementation_stage": "template_expansion_complete",
		"project_path":         projectDir,
		"build_directory":      buildDir,
	}

	// IPA path (would be generated by Xcode build)
	ipaPath := fmt.Sprintf("%s/%s.ipa", buildDir, scenarioName)

	response := BuildResponse{
		Success:  true,
		BuildID:  buildID,
		IPAPath:  ipaPath,
		Metadata: metadata,
	}

	s.logInfo("Build request processed: %s (template expanded)", buildID)
	s.respondJSON(w, response)
}

func (s *Server) logInfo(msg string, fields ...interface{}) {
	s.logger.Printf("[INFO] "+msg, fields...)
}

func (s *Server) logError(msg string, fields ...interface{}) {
	s.logger.Printf("[ERROR] "+msg, fields...)
}

func main() {
	// Lifecycle protection check
	if os.Getenv("VROOLI_LIFECYCLE_MANAGED") != "true" {
		fmt.Fprintf(os.Stderr, `‚ùå This binary must be run through the Vrooli lifecycle system.

üöÄ Instead, use:
   vrooli scenario start scenario-to-ios

üí° The lifecycle system provides environment variables, port allocation,
   and dependency management automatically. Direct execution is not supported.
`)
		os.Exit(1)
	}

	// Get port from environment variable (fail fast if missing)
	port := os.Getenv("API_PORT")
	if port == "" {
		fmt.Fprintf(os.Stderr, `‚ùå API_PORT environment variable is required but not set.

üöÄ The lifecycle system should set this automatically. If you see this error:
   - Verify the scenario is started via: vrooli scenario start scenario-to-ios
   - Check .vrooli/service.json for port configuration
   - Ensure port registry has allocated a port for this scenario

üí° This variable must be explicitly configured - defaults are not allowed for ports
   as they may cause conflicts or security issues.
`)
		os.Exit(1)
	}

	logger := log.New(os.Stdout, "", log.LstdFlags)
	s := &Server{
		router: http.NewServeMux(),
		logger: logger,
	}

	// Health check at root level (required for lifecycle system)
	s.router.HandleFunc("/health", s.handleHealth)

	// Health check (also available under API prefix)
	s.router.HandleFunc("/api/v1/health", s.handleHealth)

	// iOS conversion endpoints
	s.router.HandleFunc("/api/v1/ios/build", s.handleBuild)

	addr := ":" + port
	s.logInfo("scenario-to-ios API starting on %s", addr)
	if err := http.ListenAndServe(addr, s.router); err != nil {
		s.logger.Fatalf("[ERROR] Server failed: %v", err)
	}
}
