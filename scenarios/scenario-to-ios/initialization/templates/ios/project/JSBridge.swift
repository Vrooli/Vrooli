//
//  JSBridge.swift
//  VrooliScenario
//
//  Generated by scenario-to-ios
//

import Foundation
import WebKit
import UIKit
import CoreLocation
import UserNotifications
import LocalAuthentication

class JSBridge: NSObject {
    static let shared = JSBridge()
    
    private override init() {
        super.init()
    }
    
    func initialize() {
        // Request necessary permissions
        requestNotificationPermission()
    }
    
    var injectionScript: String {
        return """
        window.vrooliNative = {
            platform: 'ios',
            version: '\(UIDevice.current.systemVersion)',
            
            // Device information
            getDeviceInfo: function() {
                return window.webkit.messageHandlers.vrooliNative.postMessage({
                    action: 'getDeviceInfo'
                });
            },
            
            // Notifications
            requestNotificationPermission: function() {
                return window.webkit.messageHandlers.vrooliNative.postMessage({
                    action: 'requestNotificationPermission'
                });
            },
            
            scheduleNotification: function(title, body, delay) {
                return window.webkit.messageHandlers.vrooliNative.postMessage({
                    action: 'scheduleNotification',
                    data: { title: title, body: body, delay: delay }
                });
            },
            
            // Storage
            saveToKeychain: function(key, value) {
                return window.webkit.messageHandlers.vrooliNative.postMessage({
                    action: 'saveToKeychain',
                    data: { key: key, value: value }
                });
            },
            
            loadFromKeychain: function(key) {
                return window.webkit.messageHandlers.vrooliNative.postMessage({
                    action: 'loadFromKeychain',
                    data: { key: key }
                });
            },
            
            // Biometric authentication
            authenticateWithBiometrics: function(reason) {
                return window.webkit.messageHandlers.vrooliNative.postMessage({
                    action: 'authenticateWithBiometrics',
                    data: { reason: reason }
                });
            },
            
            // Share
            share: function(text, url) {
                return window.webkit.messageHandlers.vrooliNative.postMessage({
                    action: 'share',
                    data: { text: text, url: url }
                });
            },
            
            // Haptic feedback
            hapticFeedback: function(style) {
                return window.webkit.messageHandlers.vrooliNative.postMessage({
                    action: 'hapticFeedback',
                    data: { style: style }
                });
            },
            
            // Camera
            takePicture: function() {
                return window.webkit.messageHandlers.vrooliNative.postMessage({
                    action: 'takePicture'
                });
            },
            
            // Location
            getCurrentLocation: function() {
                return window.webkit.messageHandlers.vrooliNative.postMessage({
                    action: 'getCurrentLocation'
                });
            }
        };
        
        // Dispatch ready event
        window.dispatchEvent(new Event('vrooliNativeReady'));
        """
    }
    
    func handleMessage(message: WKScriptMessage, webView: WKWebView?) {
        guard let body = message.body as? [String: Any],
              let action = body["action"] as? String else { return }
        
        switch action {
        case "getDeviceInfo":
            handleGetDeviceInfo(webView: webView)
            
        case "requestNotificationPermission":
            requestNotificationPermission()
            
        case "scheduleNotification":
            if let data = body["data"] as? [String: Any] {
                scheduleNotification(data: data)
            }
            
        case "saveToKeychain":
            if let data = body["data"] as? [String: Any] {
                saveToKeychain(data: data, webView: webView)
            }
            
        case "loadFromKeychain":
            if let data = body["data"] as? [String: Any] {
                loadFromKeychain(data: data, webView: webView)
            }
            
        case "authenticateWithBiometrics":
            if let data = body["data"] as? [String: Any] {
                authenticateWithBiometrics(data: data, webView: webView)
            }
            
        case "share":
            if let data = body["data"] as? [String: Any] {
                share(data: data)
            }
            
        case "hapticFeedback":
            if let data = body["data"] as? [String: Any] {
                hapticFeedback(data: data)
            }
            
        case "takePicture":
            takePicture(webView: webView)
            
        case "getCurrentLocation":
            getCurrentLocation(webView: webView)
            
        default:
            break
        }
    }
    
    // MARK: - Native Implementations
    
    private func handleGetDeviceInfo(webView: WKWebView?) {
        let device = UIDevice.current
        let info: [String: Any] = [
            "model": device.model,
            "systemName": device.systemName,
            "systemVersion": device.systemVersion,
            "name": device.name,
            "identifierForVendor": device.identifierForVendor?.uuidString ?? ""
        ]
        
        let jsonData = try? JSONSerialization.data(withJSONObject: info, options: [])
        if let jsonString = String(data: jsonData ?? Data(), encoding: .utf8) {
            let js = "window.vrooliNativeCallback('deviceInfo', \(jsonString));"
            webView?.evaluateJavaScript(js, completionHandler: nil)
        }
    }
    
    private func requestNotificationPermission() {
        UNUserNotificationCenter.current().requestAuthorization(options: [.alert, .badge, .sound]) { granted, error in
            DispatchQueue.main.async {
                UIApplication.shared.registerForRemoteNotifications()
            }
        }
    }
    
    private func scheduleNotification(data: [String: Any]) {
        guard let title = data["title"] as? String,
              let body = data["body"] as? String,
              let delay = data["delay"] as? TimeInterval else { return }
        
        let content = UNMutableNotificationContent()
        content.title = title
        content.body = body
        content.sound = .default
        
        let trigger = UNTimeIntervalNotificationTrigger(timeInterval: delay, repeats: false)
        let request = UNNotificationRequest(identifier: UUID().uuidString, content: content, trigger: trigger)
        
        UNUserNotificationCenter.current().add(request) { error in
            if let error = error {
                print("Error scheduling notification: \(error)")
            }
        }
    }
    
    private func saveToKeychain(data: [String: Any], webView: WKWebView?) {
        guard let key = data["key"] as? String,
              let value = data["value"] as? String else { return }
        
        let query: [String: Any] = [
            kSecClass as String: kSecClassGenericPassword,
            kSecAttrAccount as String: key,
            kSecValueData as String: value.data(using: .utf8)!
        ]
        
        SecItemDelete(query as CFDictionary)
        let status = SecItemAdd(query as CFDictionary, nil)
        
        let success = status == errSecSuccess
        let js = "window.vrooliNativeCallback('keychainSave', { success: \(success) });"
        webView?.evaluateJavaScript(js, completionHandler: nil)
    }
    
    private func loadFromKeychain(data: [String: Any], webView: WKWebView?) {
        guard let key = data["key"] as? String else { return }
        
        let query: [String: Any] = [
            kSecClass as String: kSecClassGenericPassword,
            kSecAttrAccount as String: key,
            kSecReturnData as String: true,
            kSecMatchLimit as String: kSecMatchLimitOne
        ]
        
        var dataTypeRef: AnyObject?
        let status = SecItemCopyMatching(query as CFDictionary, &dataTypeRef)
        
        if status == errSecSuccess,
           let data = dataTypeRef as? Data,
           let value = String(data: data, encoding: .utf8) {
            let js = "window.vrooliNativeCallback('keychainLoad', { value: '\(value)' });"
            webView?.evaluateJavaScript(js, completionHandler: nil)
        } else {
            let js = "window.vrooliNativeCallback('keychainLoad', { error: 'Not found' });"
            webView?.evaluateJavaScript(js, completionHandler: nil)
        }
    }
    
    private func authenticateWithBiometrics(data: [String: Any], webView: WKWebView?) {
        let reason = data["reason"] as? String ?? "Authenticate to continue"
        
        let context = LAContext()
        var error: NSError?
        
        if context.canEvaluatePolicy(.deviceOwnerAuthenticationWithBiometrics, error: &error) {
            context.evaluatePolicy(.deviceOwnerAuthenticationWithBiometrics, localizedReason: reason) { success, error in
                DispatchQueue.main.async {
                    let js = "window.vrooliNativeCallback('biometricAuth', { success: \(success) });"
                    webView?.evaluateJavaScript(js, completionHandler: nil)
                }
            }
        } else {
            let js = "window.vrooliNativeCallback('biometricAuth', { error: 'Biometrics not available' });"
            webView?.evaluateJavaScript(js, completionHandler: nil)
        }
    }
    
    private func share(data: [String: Any]) {
        var items: [Any] = []
        
        if let text = data["text"] as? String {
            items.append(text)
        }
        
        if let urlString = data["url"] as? String, let url = URL(string: urlString) {
            items.append(url)
        }
        
        guard !items.isEmpty else { return }
        
        let activityViewController = UIActivityViewController(activityItems: items, applicationActivities: nil)
        
        if let viewController = UIApplication.shared.windows.first?.rootViewController {
            if UIDevice.current.userInterfaceIdiom == .pad {
                activityViewController.popoverPresentationController?.sourceView = viewController.view
                activityViewController.popoverPresentationController?.sourceRect = CGRect(x: viewController.view.bounds.midX, y: viewController.view.bounds.midY, width: 0, height: 0)
            }
            viewController.present(activityViewController, animated: true, completion: nil)
        }
    }
    
    private func hapticFeedback(data: [String: Any]) {
        let style = data["style"] as? String ?? "light"
        
        switch style {
        case "light":
            UIImpactFeedbackGenerator(style: .light).impactOccurred()
        case "medium":
            UIImpactFeedbackGenerator(style: .medium).impactOccurred()
        case "heavy":
            UIImpactFeedbackGenerator(style: .heavy).impactOccurred()
        case "success":
            UINotificationFeedbackGenerator().notificationOccurred(.success)
        case "warning":
            UINotificationFeedbackGenerator().notificationOccurred(.warning)
        case "error":
            UINotificationFeedbackGenerator().notificationOccurred(.error)
        default:
            UIImpactFeedbackGenerator(style: .light).impactOccurred()
        }
    }
    
    private func takePicture(webView: WKWebView?) {
        // This would need to be implemented with UIImagePickerController
        // For now, just send back a placeholder response
        let js = "window.vrooliNativeCallback('camera', { error: 'Camera not implemented in template' });"
        webView?.evaluateJavaScript(js, completionHandler: nil)
    }
    
    private func getCurrentLocation(webView: WKWebView?) {
        // This would need to be implemented with CLLocationManager
        // For now, just send back a placeholder response
        let js = "window.vrooliNativeCallback('location', { error: 'Location not implemented in template' });"
        webView?.evaluateJavaScript(js, completionHandler: nil)
    }
}