package registry

import (
	"encoding/json"
	"fmt"
	"os"
	"path/filepath"
	"sort"
	"strings"
	"time"

	"test-genie/internal/playbooks/types"
)

// Builder creates playbook registry files by scanning scenario directories.
type Builder struct {
	scenarioDir string
}

// NewBuilder creates a new registry builder for the given scenario directory.
func NewBuilder(scenarioDir string) *Builder {
	return &Builder{scenarioDir: scenarioDir}
}

// BuildResult contains the result of building a registry.
type BuildResult struct {
	Registry      types.Registry
	RegistryPath  string
	PlaybookCount int
}

// Build scans the scenario directory and generates a registry.
func (b *Builder) Build() (*BuildResult, error) {
	basRoot := filepath.Join(b.scenarioDir, "bas")
	// Separation of concerns: test-genie executes only bas/cases/** as "test cases".
	// Other bas/* directories (actions/, flows/, etc.) exist for reusable automation
	// building blocks and are intentionally not executed by the Playbooks phase.
	playbooksRoot := filepath.Join(basRoot, "cases")
	requirementsDir := filepath.Join(b.scenarioDir, "requirements")
	registryPath := filepath.Join(basRoot, RegistryFileName)

	// Check required directories exist
	if _, err := os.Stat(playbooksRoot); os.IsNotExist(err) {
		return nil, fmt.Errorf("bas/cases directory not found at %s", playbooksRoot)
	}
	if _, err := os.Stat(requirementsDir); os.IsNotExist(err) {
		return nil, fmt.Errorf("requirements directory not found at %s", requirementsDir)
	}

	// Collect requirement validations (maps playbook paths to requirement IDs)
	validationsByFile, err := b.collectRequirementValidations(requirementsDir)
	if err != nil {
		return nil, fmt.Errorf("failed to collect requirement validations: %w", err)
	}

	// Collect all playbook files
	playbookFiles, err := b.collectPlaybooks(playbooksRoot)
	if err != nil {
		return nil, fmt.Errorf("failed to collect playbooks: %w", err)
	}

	// Build registry
	registry := types.Registry{
		Note:      "AUTO-GENERATED by test-genie registry build â€” run 'test-genie registry build' to refresh. Do not edit manually.",
		Scenario:  filepath.Base(b.scenarioDir),
		Generated: time.Now().UTC().Format(time.RFC3339),
		Playbooks: make([]types.Entry, 0, len(playbookFiles)),
	}

	for _, pf := range playbookFiles {
		entry, err := b.buildEntry(pf, validationsByFile)
		if err != nil {
			return nil, fmt.Errorf("failed to build entry for %s: %w", pf.path, err)
		}
		registry.Playbooks = append(registry.Playbooks, entry)
	}

	// Write registry file
	data, err := json.MarshalIndent(registry, "", "  ")
	if err != nil {
		return nil, fmt.Errorf("failed to marshal registry: %w", err)
	}

	if err := os.WriteFile(registryPath, data, 0o644); err != nil {
		return nil, fmt.Errorf("failed to write registry: %w", err)
	}

	return &BuildResult{
		Registry:      registry,
		RegistryPath:  registryPath,
		PlaybookCount: len(registry.Playbooks),
	}, nil
}

// playbookFile represents a discovered playbook file with its computed order.
type playbookFile struct {
	path  string
	order string
}

// collectPlaybooks recursively collects all playbook JSON files.
func (b *Builder) collectPlaybooks(playbooksRoot string) ([]playbookFile, error) {
	var collected []playbookFile

	var traverse func(dir string, segments []string) error
	traverse = func(dir string, segments []string) error {
		entries, err := os.ReadDir(dir)
		if err != nil {
			if os.IsNotExist(err) {
				return nil
			}
			return err
		}

		// Filter and sort entries
		var filtered []os.DirEntry
		for _, entry := range entries {
			// Skip directories starting with __
			if strings.HasPrefix(entry.Name(), "__") {
				continue
			}
			filtered = append(filtered, entry)
		}
		sort.Slice(filtered, func(i, j int) bool {
			// Use case-insensitive comparison to match JS localeCompare behavior
			return strings.ToLower(filtered[i].Name()) < strings.ToLower(filtered[j].Name())
		})

		index := 1
		for _, entry := range filtered {
			segment := fmt.Sprintf("%02d", index)
			nextSegments := append(append([]string{}, segments...), segment)
			absPath := filepath.Join(dir, entry.Name())

			if entry.IsDir() {
				if err := traverse(absPath, nextSegments); err != nil {
					return err
				}
			} else if filepath.Ext(entry.Name()) == ".json" {
				// Skip registry.json at root level
				if len(segments) == 0 && entry.Name() == RegistryFileName {
					continue
				}
				collected = append(collected, playbookFile{
					path:  absPath,
					order: strings.Join(nextSegments, "."),
				})
			}
			index++
		}
		return nil
	}

	if err := traverse(playbooksRoot, nil); err != nil {
		return nil, err
	}

	return collected, nil
}

// requirementsIndex represents the structure of requirements/index.json.
type requirementsIndex struct {
	Imports []string `json:"imports"`
}

// requirementModule represents a requirement module file.
type requirementModule struct {
	Requirements []requirementDef `json:"requirements"`
}

// requirementDef represents a single requirement definition.
type requirementDef struct {
	ID         string          `json:"id"`
	Validation []validationRef `json:"validation"`
}

// validationRef represents a validation reference.
type validationRef struct {
	Ref string `json:"ref"`
}

// collectRequirementValidations builds a map from playbook file paths to requirement IDs.
func (b *Builder) collectRequirementValidations(requirementsDir string) (map[string][]string, error) {
	result := make(map[string][]string)

	indexPath := filepath.Join(requirementsDir, "index.json")
	indexData, err := os.ReadFile(indexPath)
	if err != nil {
		if os.IsNotExist(err) {
			return result, nil
		}
		return nil, fmt.Errorf("failed to read requirements index: %w", err)
	}

	var index requirementsIndex
	if err := json.Unmarshal(indexData, &index); err != nil {
		return nil, fmt.Errorf("failed to parse requirements index: %w", err)
	}

	// Process each imported module
	for _, relModule := range index.Imports {
		modulePath := filepath.Join(requirementsDir, relModule)
		moduleData, err := os.ReadFile(modulePath)
		if err != nil {
			if os.IsNotExist(err) {
				continue
			}
			return nil, fmt.Errorf("failed to read module %s: %w", relModule, err)
		}

		var module requirementModule
		if err := json.Unmarshal(moduleData, &module); err != nil {
			return nil, fmt.Errorf("failed to parse module %s: %w", relModule, err)
		}

		for _, req := range module.Requirements {
			for _, validation := range req.Validation {
				if validation.Ref == "" {
					continue
				}
				if !strings.HasPrefix(validation.Ref, "bas/") {
					continue
				}
				result[validation.Ref] = append(result[validation.Ref], req.ID)
			}
		}
	}

	// Sort requirement IDs for deterministic output
	for key := range result {
		sort.Strings(result[key])
	}

	return result, nil
}

// buildEntry builds a registry entry from a playbook file.
func (b *Builder) buildEntry(pf playbookFile, validationsByFile map[string][]string) (types.Entry, error) {
	data, err := os.ReadFile(pf.path)
	if err != nil {
		return types.Entry{}, fmt.Errorf("failed to read playbook: %w", err)
	}

	var doc map[string]any
	if err := json.Unmarshal(data, &doc); err != nil {
		return types.Entry{}, fmt.Errorf("failed to parse playbook: %w", err)
	}

	// Normalize path to use forward slashes
	relPath, err := filepath.Rel(b.scenarioDir, pf.path)
	if err != nil {
		return types.Entry{}, fmt.Errorf("failed to compute relative path: %w", err)
	}
	relPath = filepath.ToSlash(relPath)
	if !strings.HasPrefix(relPath, "bas/cases/") {
		return types.Entry{}, fmt.Errorf("registry entries must live under bas/cases (got %s)", relPath)
	}

	// Extract fixtures from nodes
	fixtures := extractFixturesFromWorkflow(doc)

	// Get requirements from validation map
	requirements := validationsByFile[relPath]
	if requirements == nil {
		requirements = []string{}
	}

	description := getString(doc, "metadata", "description")

	// Validate reset value
	reset := getString(doc, "metadata", "labels", "reset")
	if reset == "" {
		reset = getString(doc, "metadata", "reset")
	}
	if reset == "" {
		reset = "none"
	}
	if reset != "none" && reset != "full" {
		return types.Entry{}, fmt.Errorf("invalid metadata.reset %q (allowed: none, full)", reset)
	}

	return types.Entry{
		File:         relPath,
		Description:  description,
		Order:        pf.order,
		Requirements: requirements,
		Fixtures:     fixtures,
		Reset:        reset,
	}, nil
}

func extractFixturesFromWorkflow(workflow map[string]any) []string {
	nodesAny, ok := workflow["nodes"].([]any)
	if !ok || len(nodesAny) == 0 {
		return []string{}
	}

	seen := make(map[string]bool)
	fixtures := make([]string, 0)

	for _, nodeAny := range nodesAny {
		node, ok := nodeAny.(map[string]any)
		if !ok {
			continue
		}

		// Legacy: "@fixture/<slug>(...)" in data.workflowId.
		workflowID := getString(node, "data", "workflowId")
		if strings.HasPrefix(workflowID, "@fixture/") {
			slug := strings.TrimPrefix(workflowID, "@fixture/")
			if idx := strings.Index(slug, "("); idx != -1 {
				slug = slug[:idx]
			}
			slug = strings.TrimSpace(slug)
			if slug != "" && !seen[slug] {
				seen[slug] = true
				fixtures = append(fixtures, slug)
			}
			continue
		}

		// Current BAS: action.subflow.workflow_path: "actions/<slug>.json".
		subflowPath := getString(node, "action", "subflow", "workflow_path")
		if subflowPath == "" {
			subflowPath = getString(node, "action", "subflow", "workflowPath")
		}
		if subflowPath == "" {
			// Older UI schema: type=subflow data.workflowPath.
			subflowPath = getString(node, "data", "workflowPath")
		}
		subflowPath = strings.TrimSpace(subflowPath)
		if subflowPath == "" {
			continue
		}
		if strings.HasPrefix(subflowPath, "actions/") {
			base := filepath.Base(subflowPath)
			slug := strings.TrimSuffix(base, filepath.Ext(base))
			slug = strings.TrimSpace(slug)
			if slug != "" && !seen[slug] {
				seen[slug] = true
				fixtures = append(fixtures, slug)
			}
		}
	}

	sort.Strings(fixtures)
	return fixtures
}

func getNestedString(m map[string]any, path ...string) (string, bool) {
	var cur any = m
	for _, key := range path {
		next, ok := cur.(map[string]any)
		if !ok {
			return "", false
		}
		cur, ok = next[key]
		if !ok {
			return "", false
		}
	}
	s, ok := cur.(string)
	return s, ok
}

func getString(m map[string]any, path ...string) string {
	v, _ := getNestedString(m, path...)
	return v
}
