package existence

import (
	"fmt"
	"io"
	"os"
	"path/filepath"
)

// Validator validates that required filesystem entries exist for business validation.
type Validator interface {
	// ValidateRequirementsDir checks that the requirements directory exists.
	ValidateRequirementsDir() Result

	// ValidateIndexFile checks that requirements/index.json exists.
	ValidateIndexFile() Result
}

// validator is the default implementation of Validator.
type validator struct {
	scenarioDir string
	logWriter   io.Writer
}

// New creates a new existence validator for the given scenario directory.
func New(scenarioDir string, logWriter io.Writer) Validator {
	return &validator{
		scenarioDir: scenarioDir,
		logWriter:   logWriter,
	}
}

// ValidateRequirementsDir implements Validator.
func (v *validator) ValidateRequirementsDir() Result {
	requirementsDir := filepath.Join(v.scenarioDir, "requirements")
	if err := ensureDir(requirementsDir); err != nil {
		logError(v.logWriter, "Missing requirements directory")
		return FailMisconfiguration(
			err,
			"Restore the requirements registry generated by `vrooli scenario requirements init`.",
		)
	}
	logSuccess(v.logWriter, "requirements directory validated: %s", requirementsDir)
	return OK().WithObservations(NewSuccessObservation("requirements registry found"))
}

// ValidateIndexFile implements Validator.
func (v *validator) ValidateIndexFile() Result {
	indexPath := filepath.Join(v.scenarioDir, "requirements", "index.json")
	if err := ensureFile(indexPath); err != nil {
		logError(v.logWriter, "Missing requirements index file")
		return FailMisconfiguration(
			err,
			"Regenerate requirements/index.json so operational targets can sync coverage.",
		)
	}
	logInfo(v.logWriter, "requirements index confirmed: %s", indexPath)
	return OK().WithObservations(NewSuccessObservation("requirements index found"))
}

// ensureDir verifies that a path exists and is a directory.
func ensureDir(path string) error {
	info, err := os.Stat(path)
	if err != nil {
		if os.IsNotExist(err) {
			return fmt.Errorf("directory not found: %s", path)
		}
		return fmt.Errorf("failed to stat %s: %w", path, err)
	}
	if !info.IsDir() {
		return fmt.Errorf("path is not a directory: %s", path)
	}
	return nil
}

// ensureFile verifies that a path exists and is a file (not a directory).
func ensureFile(path string) error {
	info, err := os.Stat(path)
	if err != nil {
		if os.IsNotExist(err) {
			return fmt.Errorf("file not found: %s", path)
		}
		return fmt.Errorf("failed to stat %s: %w", path, err)
	}
	if info.IsDir() {
		return fmt.Errorf("path is a directory, expected file: %s", path)
	}
	return nil
}

// Logging helpers

func logInfo(w io.Writer, format string, args ...interface{}) {
	if w == nil {
		return
	}
	msg := fmt.Sprintf(format, args...)
	fmt.Fprintf(w, "üîç %s\n", msg)
}

func logSuccess(w io.Writer, format string, args ...interface{}) {
	if w == nil {
		return
	}
	msg := fmt.Sprintf(format, args...)
	fmt.Fprintf(w, "[SUCCESS] ‚úÖ %s\n", msg)
}

func logError(w io.Writer, format string, args ...interface{}) {
	if w == nil {
		return
	}
	msg := fmt.Sprintf(format, args...)
	fmt.Fprintf(w, "[ERROR] ‚ùå %s\n", msg)
}
