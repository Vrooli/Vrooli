package phases

import (
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"os"
	"path/filepath"
	"sort"
	"strings"

	"test-genie/internal/orchestrator/workspace"
)

type requirementModuleFile struct {
	Requirements []requirementDefinition `json:"requirements"`
}

type requirementDefinition struct {
	ID          string                 `json:"id"`
	Title       string                 `json:"title"`
	Description string                 `json:"description"`
	Criticality string                 `json:"criticality"`
	Status      string                 `json:"status"`
	Validation  []requirementValidator `json:"validation"`
}

type requirementValidator struct {
	Type string `json:"type"`
	Ref  string `json:"ref"`
}

type requirementModuleRef struct {
	Name string
	Path string
}

// runBusinessPhase inspects the requirements registry to guarantee it is populated and well-formed.
func runBusinessPhase(ctx context.Context, env workspace.Environment, logWriter io.Writer) RunReport {
	if err := ctx.Err(); err != nil {
		return RunReport{Err: err, FailureClassification: FailureClassSystem}
	}

	var observations []Observation
	requirementsDir := filepath.Join(env.ScenarioDir, "requirements")
	if err := workspace.EnsureDir(requirementsDir); err != nil {
		return RunReport{
			Err:                   err,
			FailureClassification: FailureClassMisconfiguration,
			Remediation:           "Restore the requirements registry generated by `vrooli scenario requirements init`.",
		}
	}
	logPhaseStep(logWriter, "requirements directory validated: %s", requirementsDir)
	observations = append(observations, NewSuccessObservation("requirements registry found"))

	indexPath := filepath.Join(requirementsDir, "index.json")
	if err := workspace.EnsureFile(indexPath); err != nil {
		return RunReport{
			Err:                   err,
			FailureClassification: FailureClassMisconfiguration,
			Remediation:           "Regenerate requirements/index.json so operational targets can sync coverage.",
			Observations:          observations,
		}
	}
	logPhaseStep(logWriter, "requirements index confirmed: %s", indexPath)

	modules, err := discoverRequirementModules(requirementsDir)
	if err != nil {
		return RunReport{
			Err:                   err,
			FailureClassification: FailureClassSystem,
			Remediation:           "Ensure Test Genie can read module files under requirements/.",
			Observations:          observations,
		}
	}
	if len(modules) == 0 {
		return RunReport{
			Err:                   fmt.Errorf("no requirement modules found under %s", requirementsDir),
			FailureClassification: FailureClassMisconfiguration,
			Remediation:           "Run `vrooli scenario requirements init` to scaffold P0/P1 modules for this scenario.",
			Observations:          observations,
		}
	}

	tracker := &requirementModuleTracker{}
	for _, module := range modules {
		if err := ctx.Err(); err != nil {
			return RunReport{Err: err, FailureClassification: FailureClassSystem}
		}
		logPhaseStep(logWriter, "validating module %s", module.Name)
		observations = append(observations, NewObservation(fmt.Sprintf("module detected: %s", module.Name)))
		if err := tracker.Audit(module); err != nil {
			return RunReport{
				Err:                   err,
				FailureClassification: FailureClassSystem,
				Remediation:           "Fix malformed JSON in the module file and rerun the phase.",
				Observations:          observations,
			}
		}
	}

	if tracker.HasIssues() {
		return RunReport{
			Err:                   errors.New(tracker.Summary()),
			FailureClassification: FailureClassMisconfiguration,
			Remediation:           tracker.Remediation(),
			Observations:          observations,
		}
	}

	logPhaseStep(logWriter, "business validation complete")
	observations = append(observations, NewSuccessObservation(fmt.Sprintf("modules validated: %d", len(modules))))
	return RunReport{Observations: observations}
}

func discoverRequirementModules(dir string) ([]requirementModuleRef, error) {
	entries, err := os.ReadDir(dir)
	if err != nil {
		return nil, fmt.Errorf("failed to read requirements directory: %w", err)
	}
	var modules []requirementModuleRef
	for _, entry := range entries {
		if !entry.IsDir() {
			continue
		}
		modulePath := filepath.Join(dir, entry.Name(), "module.json")
		if !fileExists(modulePath) {
			continue
		}
		modules = append(modules, requirementModuleRef{
			Name: entry.Name(),
			Path: modulePath,
		})
	}
	sort.Slice(modules, func(i, j int) bool {
		return modules[i].Name < modules[j].Name
	})
	return modules, nil
}

type requirementModuleTracker struct {
	issues []string
}

func (t *requirementModuleTracker) Audit(ref requirementModuleRef) error {
	raw, err := os.ReadFile(ref.Path)
	if err != nil {
		return fmt.Errorf("failed to read %s: %w", ref.Path, err)
	}
	var doc requirementModuleFile
	if err := json.Unmarshal(raw, &doc); err != nil {
		return fmt.Errorf("failed to parse %s: %w", ref.Path, err)
	}
	if len(doc.Requirements) == 0 {
		t.addIssue(ref.Name, "module declares zero requirements")
		return nil
	}
	for idx, req := range doc.Requirements {
		t.inspectRequirement(ref.Name, idx, req)
	}
	return nil
}

func (t *requirementModuleTracker) inspectRequirement(module string, idx int, req requirementDefinition) {
	label := strings.TrimSpace(req.ID)
	if label == "" {
		label = fmt.Sprintf("requirement #%d", idx+1)
	}
	if strings.TrimSpace(req.ID) == "" {
		t.addIssue(module, fmt.Sprintf("%s missing id", label))
	}
	if strings.TrimSpace(req.Title) == "" {
		t.addIssue(module, fmt.Sprintf("%s missing title", label))
	}
	if strings.TrimSpace(req.Criticality) == "" {
		t.addIssue(module, fmt.Sprintf("%s missing criticality", label))
	}
	if strings.TrimSpace(req.Status) == "" {
		t.addIssue(module, fmt.Sprintf("%s missing status", label))
	}
	if len(req.Validation) == 0 {
		t.addIssue(module, fmt.Sprintf("%s missing validation entries", label))
	}
}

func (t *requirementModuleTracker) addIssue(module, detail string) {
	t.issues = append(t.issues, fmt.Sprintf("%s: %s", module, detail))
}

func (t *requirementModuleTracker) HasIssues() bool {
	return len(t.issues) > 0
}

func (t *requirementModuleTracker) Summary() string {
	if len(t.issues) == 0 {
		return ""
	}
	ordered := append([]string(nil), t.issues...)
	sort.Strings(ordered)
	return fmt.Sprintf("requirements registry issues detected: %s", strings.Join(ordered, "; "))
}

func (t *requirementModuleTracker) Remediation() string {
	return "Fill in missing metadata for each requirement (id, title, criticality, status, and validation entries) inside requirements/*/module.json."
}
