#!/bin/bash
# test-genie - Command-line interface for Test Genie

set -euo pipefail

readonly CLI_NAME="test-genie"
readonly CLI_VERSION="1.1.0"
readonly CONFIG_DIR="$HOME/.${CLI_NAME}"
readonly CONFIG_FILE="$CONFIG_DIR/config.json"
readonly SCENARIO_ID="test-genie"
readonly DEFAULT_TOKEN=""
CONFIG_API_BASE=""
API_BASE=""

readonly RED='\033[0;31m'
readonly GREEN='\033[0;32m'
readonly YELLOW='\033[1;33m'
readonly BLUE='\033[0;34m'
readonly NC='\033[0m'

init_config() {
    if [[ ! -d "$CONFIG_DIR" ]]; then
        mkdir -p "$CONFIG_DIR"
    fi
    
    if [[ ! -f "$CONFIG_FILE" ]]; then
        cat > "$CONFIG_FILE" <<JSON
{
  "api_base": "",
  "api_token": "$DEFAULT_TOKEN",
  "output_format": "json",
  "created_at": "$(date -u +"%Y-%m-%dT%H:%M:%SZ")"
}
JSON
        echo -e "${GREEN}✓${NC} Configuration created at $CONFIG_FILE"
    fi
}

load_config() {
    if [[ -f "$CONFIG_FILE" ]]; then
        CONFIG_API_BASE=$(jq -r '.api_base // ""' "$CONFIG_FILE" 2>/dev/null || echo "")
        API_TOKEN=$(jq -r '.api_token // ""' "$CONFIG_FILE" 2>/dev/null || echo "")
    else
        CONFIG_API_BASE=""
        API_TOKEN=""
    fi
}

detect_api_port() {
    if command -v vrooli >/dev/null 2>&1; then
        vrooli scenario port "$SCENARIO_ID" API_PORT 2>/dev/null || true
    fi
}

detect_api_base() {
    if [[ -n "${API_BASE_URL:-}" ]]; then
        echo "${API_BASE_URL%/}"
        return 0
    fi

    if [[ -n "${API_PORT:-}" ]]; then
        echo "http://${API_HOST:-localhost}:${API_PORT}/api/v1"
        return 0
    fi

    local detected_port
    detected_port="$(detect_api_port)"
    if [[ -n "$detected_port" ]]; then
        echo "http://localhost:${detected_port}/api/v1"
        return 0
    fi

    return 1
}

normalize_api_base() {
    local value="$1"
    if [[ -z "$value" || "$value" == "null" ]]; then
        return 1
    fi
    echo "${value%/}"
}

resolve_api_base() {
    local candidate

    if candidate=$(normalize_api_base "$1" 2>/dev/null); then
        echo "$candidate"
        return 0
    fi

    local detected
    if detected=$(detect_api_base); then
        echo "$detected"
        return 0
    fi

    return 1
}

ensure_api_base() {
    local action="${1:-communicate with the API}"
    if [[ -n "$API_BASE" ]]; then
        return 0
    fi
    if ! API_BASE=$(resolve_api_base "$CONFIG_API_BASE"); then
        echo -e "${RED}✗${NC} Unable to determine API base URL required to ${action}."
        echo "Ensure the scenario is running via 'vrooli scenario start $SCENARIO_ID' or configure it with '$CLI_NAME configure api_base <url>'."
        exit 1
    fi
}

api_request() {
    local method="$1"
    local endpoint="$2"
    local body="${3:-}"
    local url="${API_BASE}${endpoint}"

    if [[ -z "$API_BASE" ]]; then
        echo -e "${RED}✗${NC} API base URL is not configured. Start the scenario via 'vrooli scenario run test-genie' or run '$CLI_NAME configure api_base <url>'." >&2
        return 1
    fi

    local headers=(-H 'Content-Type: application/json')
    if [[ -n "${API_TOKEN:-}" ]]; then
        headers+=(-H "Authorization: Bearer $API_TOKEN")
    fi

    local -a curl_args=(-sS -X "$method" "${headers[@]}")
    if [[ -n "$body" ]]; then
        curl_args+=(-d "$body")
    fi

    curl "${curl_args[@]}" "$url"
}

cmd_status() {
    ensure_api_base "check system health"
    echo -e "${BLUE}Checking system health...${NC}"
    response=$(api_request GET "/health" || true)
    if [[ -z "$response" ]]; then
        echo -e "${RED}✗${NC} API is not reachable"
        return 1
    fi

    status=$(echo "$response" | jq -r '.status // "unknown"' 2>/dev/null || echo "unknown")
    if [[ "$status" == "healthy" ]]; then
        echo -e "${GREEN}✓${NC} Service is healthy"
    else
        echo -e "${YELLOW}⚠${NC} Service status: $status"
    fi

    echo "$response" | jq -r '
        "  Service: \(.service // "unknown")",
        "  Version: \(.version // "unknown")",
        "  Database: \(.dependencies.database // "unknown")"
    ' 2>/dev/null || true

    queue_json=$(echo "$response" | jq -c '.operations.queue // empty' 2>/dev/null || echo "")
    if [[ -n "$queue_json" && "$queue_json" != "null" ]]; then
        pending=$(echo "$queue_json" | jq -r '.pending // 0')
        queued=$(echo "$queue_json" | jq -r '.queued // 0')
        delegated=$(echo "$queue_json" | jq -r '.delegated // 0')
        running=$(echo "$queue_json" | jq -r '.running // 0')
        failed=$(echo "$queue_json" | jq -r '.failed // 0')
        echo "  Queue: pending=${pending} (queued=${queued}, delegated=${delegated}, running=${running}, failed=${failed})"
        oldest_age=$(echo "$queue_json" | jq -r '.oldestQueuedAgeSeconds // empty' 2>/dev/null || echo "")
        if [[ -n "$oldest_age" && "$oldest_age" != "null" ]]; then
            echo "         Oldest pending request age: ${oldest_age}s"
        fi
    fi

    last_exec=$(echo "$response" | jq -c '.operations.lastExecution // empty' 2>/dev/null || echo "")
    if [[ -n "$last_exec" && "$last_exec" != "null" ]]; then
        scenario=$(echo "$last_exec" | jq -r '.scenario // "unknown"')
        success=$(echo "$last_exec" | jq -r '.success // false')
        completed=$(echo "$last_exec" | jq -r '.completedAt // "n/a"')
        phases=$(echo "$last_exec" | jq -r '.phaseSummary.total // 0')
        failed_phases=$(echo "$last_exec" | jq -r '.phaseSummary.failed // 0')
        icon="${GREEN}✓${NC}"
        if [[ "$success" != "true" ]]; then
            icon="${RED}✗${NC}"
        fi
        echo -e "  Last execution: ${icon} ${scenario} (phases=${phases}, failed=${failed_phases}) completed ${completed}"
    fi
}

cmd_configure() {
    local key="${1:-}"
    local value="${2:-}"

    if [[ -z "$key" ]]; then
        cat "$CONFIG_FILE" | jq '.' 2>/dev/null || cat "$CONFIG_FILE"
        return 0
    fi

    case "$key" in
        api|api_base)
            jq --arg v "$value" '.api_base = $v' "$CONFIG_FILE" > "${CONFIG_FILE}.tmp" && mv "${CONFIG_FILE}.tmp" "$CONFIG_FILE"
            echo -e "${GREEN}✓${NC} API base set to: $value"
            CONFIG_API_BASE="$value"
            ;;
        token|api_token)
            jq --arg v "$value" '.api_token = $v' "$CONFIG_FILE" > "${CONFIG_FILE}.tmp" && mv "${CONFIG_FILE}.tmp" "$CONFIG_FILE"
            echo -e "${GREEN}✓${NC} API token updated"
            API_TOKEN="$value"
            ;;
        *)
            echo -e "${RED}✗${NC} Unknown configuration key: $key"
            echo "Valid keys: api_base, api_token"
            return 1
            ;;
    esac
}

cmd_version() {
    echo "$CLI_NAME version $CLI_VERSION"
    if [[ -n "$API_BASE" ]]; then
        echo "API endpoint: $API_BASE"
    else
        echo "API endpoint: (auto-detect when scenario is running)"
    fi
}

cmd_help() {
    cat <<'EOF'
test-genie - Command-line interface for Test Genie

Usage: test-genie <command>

Commands:
    generate        Queue AI-powered test suite generation for a scenario
    execute         Run scenario test phases through the Go orchestrator
    status          Check API and dependency health
    configure       View or update CLI configuration
    version         Show CLI version
    help            Show this help message
EOF
}

parse_types_argument() {
    local value="$1"
    if [[ -z "$value" ]]; then
        echo "null"
        return 0
    fi
    printf '%s' "$value" | jq -R '[ split(",")[] | gsub("^\\s+|\\s+$"; "") | select(length>0) ]'
}

parse_list_argument() {
    local value="$1"
    if [[ -z "$value" ]]; then
        echo "[]"
        return 0
    fi
    printf '%s' "$value" | jq -R '[ split(",")[] | gsub("^\\s+|\\s+$"; "") | select(length>0) ]'
}

cmd_generate() {
    local scenario="${1:-}"
    if [[ -z "$scenario" ]]; then
        echo -e "${RED}✗${NC} Scenario name is required. Usage: $CLI_NAME generate <scenario> [options]"
        return 1
    fi
    shift || true

    local types_arg=""
    local coverage_value=""
    local priority_value=""
    local notes_value=""
    local notes_file=""
    local output_json=false

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --types)
                types_arg="${2:-}"
                shift
                ;;
            --coverage)
                coverage_value="${2:-}"
                shift
                ;;
            --priority)
                priority_value="${2:-}"
                shift
                ;;
            --notes)
                notes_value="${2:-}"
                shift
                ;;
            --notes-file)
                notes_file="${2:-}"
                shift
                ;;
            --json|--raw)
                output_json=true
                ;;
            --help|-h)
                echo "Usage: $CLI_NAME generate <scenario> [--types unit,integration] [--coverage 95] [--priority normal] [--notes \"text\"] [--notes-file path] [--json]"
                return 0
                ;;
            *)
                echo -e "${RED}✗${NC} Unknown generate option: $1"
                echo "Use '--help' for usage information."
                return 1
                ;;
        esac
        shift || true
    done

    if [[ -n "$notes_file" ]]; then
        if [[ ! -f "$notes_file" ]]; then
            echo -e "${RED}✗${NC} Notes file not found: ${notes_file}"
            return 1
        fi
        notes_value="$(<"$notes_file")"
    fi

    if [[ -n "$coverage_value" ]]; then
        if ! [[ "$coverage_value" =~ ^[0-9]+$ ]]; then
            echo -e "${RED}✗${NC} Coverage must be a numeric value between 1 and 100."
            return 1
        fi
        if (( coverage_value < 1 || coverage_value > 100 )); then
            echo -e "${RED}✗${NC} Coverage must be between 1 and 100."
            return 1
        fi
    fi

    if [[ -n "$priority_value" ]]; then
        priority_value="$(echo "$priority_value" | tr '[:upper:]' '[:lower:]')"
        case "$priority_value" in
            low|normal|high|urgent) ;;
            *)
                echo -e "${RED}✗${NC} Priority must be one of: low, normal, high, urgent."
                return 1
                ;;
        esac
    fi

    local types_json
    if ! types_json=$(parse_types_argument "$types_arg"); then
        echo -e "${RED}✗${NC} Unable to parse requested types."
        return 1
    fi
    local coverage_json="null"
    if [[ -n "$coverage_value" ]]; then
        coverage_json="$coverage_value"
    fi

    local payload
    payload=$(jq -n \
        --arg scenario "$scenario" \
        --argjson types "$types_json" \
        --argjson coverage "$coverage_json" \
        --arg priority "$priority_value" \
        --arg notes "$notes_value" '
        {scenarioName: $scenario}
        + (if $types != null and ($types | length) > 0 then {requestedTypes: $types} else {} end)
        + (if $coverage != null then {coverageTarget: $coverage} else {} end)
        + (if $priority != "" then {priority: $priority} else {} end)
        + (if $notes != "" then {notes: $notes} else {} end)
    ')

    ensure_api_base "queue suite generation"
    local response
    if ! response=$(api_request POST "/suite-requests" "$payload"); then
        echo -e "${RED}✗${NC} Failed to reach Test Genie API."
        return 1
    fi

    local parsed_ok=true
    echo "$response" | jq '.' >/dev/null 2>&1 || parsed_ok=false
    if [[ "$parsed_ok" = false ]]; then
        echo -e "${RED}✗${NC} API returned a non-JSON response:"
        echo "$response"
        return 1
    fi

    local error_message
    error_message=$(echo "$response" | jq -r '.error // empty')
    if [[ -n "$error_message" ]]; then
        echo -e "${RED}✗${NC} API error: $error_message"
        return 1
    fi

    if [[ "$output_json" = true ]]; then
        echo "$response" | jq '.'
        return 0
    fi

    local suite_id scenario_name queue_status queue_eta requested_types coverage_target priority_report
    suite_id=$(echo "$response" | jq -r '.id // empty')
    scenario_name=$(echo "$response" | jq -r '.scenarioName // "'"$scenario"'"')
    queue_status=$(echo "$response" | jq -r '.status // "queued"')
    queue_eta=$(echo "$response" | jq -r '.estimatedQueueTimeSeconds // empty')
    requested_types=$(echo "$response" | jq -r '(.requestedTypes // []) | join(", ")')
    coverage_target=$(echo "$response" | jq -r '.coverageTarget // "'"${coverage_value:-95}"'"')
    priority_report=$(echo "$response" | jq -r '.priority // "'"${priority_value:-normal}"'"')

    echo -e "${GREEN}✓${NC} Suite request queued for ${scenario_name}"
    if [[ -n "$suite_id" ]]; then
        echo "  Request ID : ${suite_id}"
    fi
    echo "  Status     : ${queue_status}"
    if [[ -n "$requested_types" ]]; then
        echo "  Types      : ${requested_types}"
    fi
    if [[ -n "$coverage_target" ]]; then
        echo "  Coverage   : ${coverage_target}%"
    fi
    echo "  Priority   : ${priority_report}"
    if [[ -n "$queue_eta" && "$queue_eta" != "null" ]]; then
        echo "  ETA        : ~${queue_eta}s"
    fi
}

cmd_execute() {
    local scenario="${1:-}"
    if [[ -z "$scenario" ]]; then
        echo -e "${RED}✗${NC} Scenario name is required. Usage: $CLI_NAME execute <scenario> [options]"
        return 1
    fi
    shift || true

    local preset=""
    local phases_arg=""
    local skip_arg=""
    local fail_fast=false
    local output_json=false
    local suite_request_id=""

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --preset)
                preset="${2:-}"
                shift
                ;;
            --phases|--only)
                phases_arg="${2:-}"
                shift
                ;;
            --skip)
                skip_arg="${2:-}"
                shift
                ;;
            --request-id)
                suite_request_id="${2:-}"
                shift
                ;;
            --fail-fast)
                fail_fast=true
                ;;
            --json|--raw)
                output_json=true
                ;;
            --help|-h)
                echo "Usage: $CLI_NAME execute <scenario> [--preset quick] [--phases structure,unit] [--skip performance] [--request-id <suite-id>] [--fail-fast] [--json]"
                return 0
                ;;
            *)
                echo -e "${RED}✗${NC} Unknown execute option: $1"
                return 1
                ;;
        esac
        shift || true
    done

    local phases_json skip_json
    if ! phases_json=$(parse_list_argument "$phases_arg"); then
        echo -e "${RED}✗${NC} Unable to parse phases."
        return 1
    fi
    if ! skip_json=$(parse_list_argument "$skip_arg"); then
        echo -e "${RED}✗${NC} Unable to parse skip phases."
        return 1
    fi

    local payload
    payload=$(jq -n \
        --arg scenario "$scenario" \
        --arg preset "$preset" \
        --argjson phases "$phases_json" \
        --argjson skip "$skip_json" \
        --arg failFast "$fail_fast" \
        --arg suiteRequestId "$suite_request_id" '
        {scenarioName: $scenario, failFast: ($failFast == "true")}
        + (if ($preset | length) > 0 then {preset: $preset} else {} end)
        + (if ($phases | length) > 0 then {phases: $phases} else {} end)
        + (if ($skip | length) > 0 then {skip: $skip} else {} end)
        + (if ($suiteRequestId | length) > 0 then {suiteRequestId: $suiteRequestId} else {} end)
    ')

    ensure_api_base "execute scenario tests"
    local response
    if ! response=$(api_request POST "/executions" "$payload"); then
        echo -e "${RED}✗${NC} Failed to reach Test Genie API."
        return 1
    fi

    local parsed_ok=true
    echo "$response" | jq '.' >/dev/null 2>&1 || parsed_ok=false
    if [[ "$parsed_ok" = false ]]; then
        echo -e "${RED}✗${NC} API returned a non-JSON response:"
        echo "$response"
        return 1
    fi

    local error_message
    error_message=$(echo "$response" | jq -r '.error // empty')
    if [[ -n "$error_message" ]]; then
        echo -e "${RED}✗${NC} API error: $error_message"
        return 1
    fi

    if [[ "$output_json" = true ]]; then
        echo "$response" | jq '.'
        return 0
    fi

    local success
    success=$(echo "$response" | jq -r '.success // false')
    local preset_used
    preset_used=$(echo "$response" | jq -r '.presetUsed // empty')
    local started completed
    started=$(echo "$response" | jq -r '.startedAt // empty')
    completed=$(echo "$response" | jq -r '.completedAt // empty')
    local execution_id linked_request
    execution_id=$(echo "$response" | jq -r '.executionId // empty')
    linked_request=$(echo "$response" | jq -r '.suiteRequestId // empty')

    if [[ "$success" == "true" ]]; then
        echo -e "${GREEN}✓${NC} Suite executed successfully for ${scenario}"
    else
        echo -e "${YELLOW}⚠${NC} Suite execution completed with failures for ${scenario}"
    fi
    if [[ -n "$execution_id" && "$execution_id" != "null" ]]; then
        echo "  Execution : ${execution_id}"
    fi
    if [[ -n "$linked_request" && "$linked_request" != "null" ]]; then
        echo "  Request   : ${linked_request}"
    fi
    if [[ -n "$preset_used" ]]; then
        echo "  Preset   : ${preset_used}"
    fi
    if [[ -n "$started" ]]; then
        echo "  Started  : ${started}"
    fi
    if [[ -n "$completed" ]]; then
        echo "  Finished : ${completed}"
    fi

    echo ""
    echo "Phase results:"
    echo "$response" | jq -c '.phases // [] | .[]' | while IFS= read -r row; do
        local name status duration log error
        name=$(echo "$row" | jq -r '.name')
        status=$(echo "$row" | jq -r '.status')
        duration=$(echo "$row" | jq -r '.durationSeconds // 0')
        log=$(echo "$row" | jq -r '.logPath // empty')
        error=$(echo "$row" | jq -r '.error // empty')

        local icon="$GREEN✓${NC}"
        if [[ "$status" != "passed" ]]; then
            icon="${RED}✗${NC}"
        fi
        printf "  %b %-12s status=%-6s duration=%ss\n" "$icon" "$name" "$status" "$duration"
        if [[ -n "$log" && "$log" != "null" ]]; then
            echo "      log: $log"
        fi
        if [[ -n "$error" && "$error" != "null" ]]; then
            echo "      error: $error"
        fi
    done

    if [[ "$success" == "true" ]]; then
        return 0
    fi
    return 1
}

main() {
    init_config
    load_config

    local command="${1:-help}"
    shift || true

    local env_prefix
    env_prefix="$(printf "%s" "$CLI_NAME" | tr '[:lower:]' '[:upper:]' | tr -c 'A-Z0-9' '_')"
    local env_api_base_var="${env_prefix}_API_BASE"
    local env_api_token_var="${env_prefix}_API_TOKEN"

    local env_api_base="${!env_api_base_var:-}"
    local env_api_token="${!env_api_token_var:-}"

    if [[ -n "$env_api_token" ]]; then
        API_TOKEN="$env_api_token"
    fi

    if [[ -n "$env_api_base" ]]; then
        API_BASE="${env_api_base%/}"
    fi

    case "$command" in
        generate)
            cmd_generate "$@"
            ;;
        execute|run|test)
            cmd_execute "$@"
            ;;
        status)
            cmd_status
            ;;
        configure|config)
            cmd_configure "$@"
            ;;
        version|--version|-v)
            cmd_version
            ;;
        help|--help|-h)
            cmd_help
            ;;
        *)
            echo -e "${RED}✗${NC} Unknown command: $command"
            echo "Run '$CLI_NAME help' for usage information"
            exit 1
            ;;
    esac
}

main "$@"
