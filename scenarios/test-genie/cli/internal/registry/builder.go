// Package registry provides playbook registry building functionality.
package registry

import (
	"encoding/json"
	"fmt"
	"os"
	"path/filepath"
	"sort"
	"strings"
	"time"
)

// Registry represents the playbook registry file structure.
type Registry struct {
	Note       string  `json:"_note,omitempty"`
	Scenario   string  `json:"scenario"`
	Generated  string  `json:"generated_at"`
	Playbooks  []Entry `json:"playbooks"`
	Deprecated []Entry `json:"deprecated_playbooks,omitempty"`
}

// Entry represents a single playbook entry in the registry.
type Entry struct {
	File         string   `json:"file"`
	Description  string   `json:"description"`
	Order        string   `json:"order"`
	Requirements []string `json:"requirements"`
	Fixtures     []string `json:"fixtures"`
	Reset        string   `json:"reset"`
}

const RegistryFileName = "registry.json"

// Builder creates playbook registry files by scanning scenario directories.
type Builder struct {
	scenarioDir string
}

// NewBuilder creates a new registry builder for the given scenario directory.
func NewBuilder(scenarioDir string) *Builder {
	return &Builder{scenarioDir: scenarioDir}
}

// BuildResult contains the result of building a registry.
type BuildResult struct {
	Registry      Registry
	RegistryPath  string
	PlaybookCount int
}

// Build scans the scenario directory and generates a registry.
func (b *Builder) Build() (*BuildResult, error) {
	playbooksRoot := filepath.Join(b.scenarioDir, "test", "playbooks")
	requirementsDir := filepath.Join(b.scenarioDir, "requirements")
	registryPath := filepath.Join(playbooksRoot, RegistryFileName)

	// Check required directories exist
	if _, err := os.Stat(playbooksRoot); os.IsNotExist(err) {
		return nil, fmt.Errorf("test/playbooks directory not found at %s", playbooksRoot)
	}
	if _, err := os.Stat(requirementsDir); os.IsNotExist(err) {
		return nil, fmt.Errorf("requirements directory not found at %s", requirementsDir)
	}

	// Collect requirement validations (maps playbook paths to requirement IDs)
	validationsByFile, err := b.collectRequirementValidations(requirementsDir)
	if err != nil {
		return nil, fmt.Errorf("failed to collect requirement validations: %w", err)
	}

	// Collect all playbook files
	playbookFiles, err := b.collectPlaybooks(playbooksRoot)
	if err != nil {
		return nil, fmt.Errorf("failed to collect playbooks: %w", err)
	}

	// Build registry
	registry := Registry{
		Note:      "AUTO-GENERATED by test-genie registry build â€” run 'test-genie registry build' to refresh. Do not edit manually.",
		Scenario:  filepath.Base(b.scenarioDir),
		Generated: time.Now().UTC().Format(time.RFC3339),
		Playbooks: make([]Entry, 0, len(playbookFiles)),
	}

	for _, pf := range playbookFiles {
		entry, err := b.buildEntry(pf, validationsByFile)
		if err != nil {
			return nil, fmt.Errorf("failed to build entry for %s: %w", pf.path, err)
		}
		registry.Playbooks = append(registry.Playbooks, entry)
	}

	// Write registry file
	data, err := json.MarshalIndent(registry, "", "  ")
	if err != nil {
		return nil, fmt.Errorf("failed to marshal registry: %w", err)
	}

	if err := os.WriteFile(registryPath, data, 0o644); err != nil {
		return nil, fmt.Errorf("failed to write registry: %w", err)
	}

	return &BuildResult{
		Registry:      registry,
		RegistryPath:  registryPath,
		PlaybookCount: len(registry.Playbooks),
	}, nil
}

// playbookFile represents a discovered playbook file with its computed order.
type playbookFile struct {
	path  string
	order string
}

// collectPlaybooks recursively collects all playbook JSON files.
func (b *Builder) collectPlaybooks(playbooksRoot string) ([]playbookFile, error) {
	var collected []playbookFile

	var traverse func(dir string, segments []string) error
	traverse = func(dir string, segments []string) error {
		entries, err := os.ReadDir(dir)
		if err != nil {
			if os.IsNotExist(err) {
				return nil
			}
			return err
		}

		// Filter and sort entries
		var filtered []os.DirEntry
		for _, entry := range entries {
			// Skip directories starting with __
			if strings.HasPrefix(entry.Name(), "__") {
				continue
			}
			filtered = append(filtered, entry)
		}
		sort.Slice(filtered, func(i, j int) bool {
			// Use case-insensitive comparison to match JS localeCompare behavior
			return strings.ToLower(filtered[i].Name()) < strings.ToLower(filtered[j].Name())
		})

		index := 1
		for _, entry := range filtered {
			segment := fmt.Sprintf("%02d", index)
			nextSegments := append(append([]string{}, segments...), segment)
			absPath := filepath.Join(dir, entry.Name())

			if entry.IsDir() {
				if err := traverse(absPath, nextSegments); err != nil {
					return err
				}
			} else if filepath.Ext(entry.Name()) == ".json" {
				// Skip registry.json at root level
				if len(segments) == 0 && entry.Name() == RegistryFileName {
					continue
				}
				collected = append(collected, playbookFile{
					path:  absPath,
					order: strings.Join(nextSegments, "."),
				})
			}
			index++
		}
		return nil
	}

	if err := traverse(playbooksRoot, nil); err != nil {
		return nil, err
	}

	return collected, nil
}

// requirementsIndex represents the structure of requirements/index.json.
type requirementsIndex struct {
	Imports []string `json:"imports"`
}

// requirementModule represents a requirement module file.
type requirementModule struct {
	Requirements []requirementDef `json:"requirements"`
}

// requirementDef represents a single requirement definition.
type requirementDef struct {
	ID         string          `json:"id"`
	Validation []validationRef `json:"validation"`
}

// validationRef represents a validation reference.
type validationRef struct {
	Ref string `json:"ref"`
}

// collectRequirementValidations builds a map from playbook file paths to requirement IDs.
func (b *Builder) collectRequirementValidations(requirementsDir string) (map[string][]string, error) {
	result := make(map[string][]string)

	indexPath := filepath.Join(requirementsDir, "index.json")
	indexData, err := os.ReadFile(indexPath)
	if err != nil {
		if os.IsNotExist(err) {
			return result, nil
		}
		return nil, fmt.Errorf("failed to read requirements index: %w", err)
	}

	var index requirementsIndex
	if err := json.Unmarshal(indexData, &index); err != nil {
		return nil, fmt.Errorf("failed to parse requirements index: %w", err)
	}

	// Process each imported module
	for _, relModule := range index.Imports {
		modulePath := filepath.Join(requirementsDir, relModule)
		moduleData, err := os.ReadFile(modulePath)
		if err != nil {
			if os.IsNotExist(err) {
				continue
			}
			return nil, fmt.Errorf("failed to read module %s: %w", relModule, err)
		}

		var module requirementModule
		if err := json.Unmarshal(moduleData, &module); err != nil {
			return nil, fmt.Errorf("failed to parse module %s: %w", relModule, err)
		}

		for _, req := range module.Requirements {
			for _, validation := range req.Validation {
				if validation.Ref == "" {
					continue
				}
				if !strings.HasPrefix(validation.Ref, "test/playbooks/") {
					continue
				}
				result[validation.Ref] = append(result[validation.Ref], req.ID)
			}
		}
	}

	// Sort requirement IDs for deterministic output
	for key := range result {
		sort.Strings(result[key])
	}

	return result, nil
}

// playbookMetadata represents the metadata section of a playbook file.
type playbookMetadata struct {
	Description string `json:"description"`
	Reset       string `json:"reset"`
}

// playbookDocument represents a playbook JSON file.
type playbookDocument struct {
	Metadata playbookMetadata `json:"metadata"`
	Nodes    []playbookNode   `json:"nodes"`
}

// playbookNode represents a node in a playbook.
type playbookNode struct {
	Data nodeData `json:"data"`
}

// nodeData represents the data section of a node.
type nodeData struct {
	WorkflowID string `json:"workflowId"`
}

// buildEntry builds a registry entry from a playbook file.
func (b *Builder) buildEntry(pf playbookFile, validationsByFile map[string][]string) (Entry, error) {
	data, err := os.ReadFile(pf.path)
	if err != nil {
		return Entry{}, fmt.Errorf("failed to read playbook: %w", err)
	}

	var doc playbookDocument
	if err := json.Unmarshal(data, &doc); err != nil {
		return Entry{}, fmt.Errorf("failed to parse playbook: %w", err)
	}

	// Normalize path to use forward slashes
	relPath, err := filepath.Rel(b.scenarioDir, pf.path)
	if err != nil {
		return Entry{}, fmt.Errorf("failed to compute relative path: %w", err)
	}
	relPath = filepath.ToSlash(relPath)

	// Extract fixtures from nodes
	fixtures := b.extractFixtures(doc.Nodes)

	// Get requirements from validation map
	requirements := validationsByFile[relPath]
	if requirements == nil {
		requirements = []string{}
	}

	// Validate reset value
	reset := doc.Metadata.Reset
	if reset == "" {
		reset = "none"
	}
	if reset != "none" && reset != "full" {
		return Entry{}, fmt.Errorf("invalid metadata.reset %q (allowed: none, full)", reset)
	}

	return Entry{
		File:         relPath,
		Description:  doc.Metadata.Description,
		Order:        pf.order,
		Requirements: requirements,
		Fixtures:     fixtures,
		Reset:        reset,
	}, nil
}

// extractFixtures extracts fixture slugs from playbook nodes.
func (b *Builder) extractFixtures(nodes []playbookNode) []string {
	seen := make(map[string]bool)
	fixtures := make([]string, 0) // Initialize to empty slice, not nil

	for _, node := range nodes {
		workflowID := node.Data.WorkflowID
		if !strings.HasPrefix(workflowID, "@fixture/") {
			continue
		}

		// Extract slug: @fixture/some-slug or @fixture/some-slug(args)
		slug := strings.TrimPrefix(workflowID, "@fixture/")
		if idx := strings.Index(slug, "("); idx != -1 {
			slug = slug[:idx]
		}
		slug = strings.TrimSpace(slug)

		if slug != "" && !seen[slug] {
			seen[slug] = true
			fixtures = append(fixtures, slug)
		}
	}

	sort.Strings(fixtures)
	return fixtures
}
