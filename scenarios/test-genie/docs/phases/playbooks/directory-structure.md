# Playbooks Directory Structure

> **Canonical layout for `test/playbooks/` in any scenario**

This document defines the standard directory structure for playbook-based UI automation. All scenarios using playbooks should follow this layout for consistency and tooling compatibility.

## Directory Layout

```
test/playbooks/
├── registry.json           # AUTO-GENERATED manifest of all playbooks
├── README.md               # Scenario-specific notes (optional)
├── capabilities/           # Feature-surface tests (mirrors PRD)
│   ├── 01-foundation/      # Two-digit prefix for ordering
│   │   ├── 01-projects/
│   │   │   ├── create-project.json
│   │   │   └── delete-project.json
│   │   └── 02-workflows/
│   │       └── workflow-crud.json
│   └── 02-builder/
│       ├── 01-canvas/
│       └── 02-toolbar/
├── journeys/               # Multi-surface user flows
│   └── 01-new-user/
│       └── onboarding-happy-path.json
├── __subflows/             # Reusable fixtures (prefix: __)
│   ├── open-demo-project.json
│   └── load-seed-state.json
└── __seeds/                # Seed entrypoint (prefix: __)
    └── seed.go             # or seed.sh
```

## Directory Purposes

| Directory | Purpose | Prefix Convention |
|-----------|---------|-------------------|
| `capabilities/` | Tests organized by PRD operational targets | `NN-name` (e.g., `01-foundation`) |
| `journeys/` | End-to-end flows spanning multiple features | `NN-name` (e.g., `01-new-user`) |
| `__subflows/` | Reusable workflow fragments (fixtures) | Double underscore prefix |
| `__seeds/` | Database/state setup entrypoint | Double underscore prefix |

### capabilities/

Mirrors your PRD's operational targets. Each subfolder represents a feature area, further divided by UI surface:

```
capabilities/
├── 01-foundation/          # Core CRUD operations
│   ├── 01-projects/        # Project management
│   ├── 02-workflows/       # Workflow management
│   └── 03-executions/      # Execution history
├── 02-builder/             # Visual workflow builder
│   ├── 01-canvas/          # Canvas interactions
│   ├── 02-palette/         # Node palette
│   └── 03-toolbar/         # Toolbar actions
└── 03-execution/           # Runtime execution
    ├── 01-automation/      # Backend automation tests
    └── 02-ui/              # Execution UI tests
```

### journeys/

Composite flows that test complete user stories across multiple features:

```
journeys/
├── 01-new-user/
│   └── onboarding-happy-path.json    # First project + first workflow
└── 02-power-user/
    └── batch-operations.json          # Advanced multi-step flow
```

### __subflows/

Reusable workflow fragments referenced via `@fixture/<slug>`. The double underscore prefix (`__`) ensures these are excluded from the registry as standalone tests.

```
__subflows/
├── load-seed-state.json      # Load seed data into workflow context
├── open-demo-project.json    # Navigate to seeded demo project
└── open-demo-workflow.json   # Open workflow in builder
```

### __seeds/

Single entrypoint for deterministic test data setup. Runs once before playbook execution.

```
__seeds/
└── seed.go      # Preferred (go run), or seed.sh as a lightweight alternative
```

## Naming Conventions

### Two-Digit Ordinal Prefixes

**Required** for all folders under `capabilities/` and `journeys/`:

```
01-foundation/    # First capability area
02-builder/       # Second capability area
03-execution/     # Third capability area
```

**Why?** Ensures deterministic execution order. Workflows execute in lexicographic order of their paths, so `01-` runs before `02-`.

### Workflow File Names

Use kebab-case with action verbs:

```
✅ create-project.json
✅ workflow-version-restore.json
✅ palette-search-filter.json

❌ projectCreate.json        # No camelCase
❌ test1.json                # Non-descriptive
❌ new_project.json          # No underscores
```

## Registry File

`registry.json` is **auto-generated** and tracks all playbooks:

```json
{
  "_note": "AUTO-GENERATED by test-genie registry build — run 'test-genie registry build' to refresh.",
  "scenario": "my-scenario",
  "generated_at": "2025-12-05T10:00:00Z",
  "playbooks": [
    {
      "file": "test/playbooks/capabilities/01-foundation/01-projects/create-project.json",
      "description": "Creates a new project and verifies navigation",
      "order": "01.01.01",
      "requirements": ["MY-PROJECT-CREATE"],
      "fixtures": ["open-demo-project"],
      "reset": "full"
    }
  ]
}
```

### Registry Fields

| Field | Description |
|-------|-------------|
| `file` | Relative path from scenario root |
| `description` | From workflow's `metadata.description` |
| `order` | Computed from directory structure (determines execution order) |
| `requirements` | Requirement IDs this workflow validates |
| `fixtures` | Fixture slugs this workflow depends on |
| `reset` | Whether to reseed before next workflow (`none` or `full`) |

### Regenerating the Registry

After adding, moving, or modifying playbooks:

```bash
# From scenario directory
test-genie registry build

# Or specify scenario path explicitly
test-genie registry build --scenario /path/to/scenario
```

## Fixture System

Fixtures are reusable workflow fragments stored in `__subflows/`.

### Fixture Metadata

Every fixture must declare `fixture_id` in its metadata:

```json
{
  "metadata": {
    "description": "Navigates to the seeded demo project",
    "fixture_id": "open-demo-project",
    "parameters": [
      {
        "name": "projectId",
        "type": "string",
        "required": true,
        "default": "@seed/projectId",
        "description": "Project identifier from seed"
      }
    ],
    "requirements": ["MY-DEMO-SEED"],
    "reset": "none"
  },
  "nodes": [...],
  "edges": [...]
}
```

### Fixture Metadata Fields

| Field | Required | Description |
|-------|----------|-------------|
| `fixture_id` | Yes | Slug used in `@fixture/<slug>` references |
| `parameters` | No | Array of parameter definitions |
| `requirements` | No | Requirement IDs this fixture covers (propagated to callers) |

### Parameter Definition

```json
{
  "name": "projectName",
  "type": "string",           // string, number, boolean, enum
  "required": true,
  "default": "@seed/projectName",
  "enumValues": ["a", "b"],   // Only for type: enum
  "description": "Human-readable explanation"
}
```

### Calling Fixtures

Reference fixtures in workflow nodes using `@fixture/<slug>`:

```json
{
  "id": "setup-state",
  "type": "subflow",
  "data": {
    "label": "Load demo project",
    "workflowId": "@fixture/open-demo-project"
  }
}
```

With parameters:

```json
{
  "workflowId": "@fixture/open-demo-project(projectId=\"abc-123\")"
}
```

With store references:

```json
{
  "workflowId": "@fixture/open-workflow(project=@store/seed.projectName)"
}
```

## Token Types

Three token prefixes are used in workflows:

| Token | Resolution Time | Purpose |
|-------|-----------------|---------|
| `@fixture/<slug>` | Resolution | Reference a subflow from `__subflows/` |
| `@selector/<key>` | Resolution | Reference from `ui/src/consts/selectors.ts` |
| `@seed/<key>` | Resolution | Literal value from seed-state.json |
| `@store/<key>` | Runtime | Dynamic value stored during execution |

### @seed vs @store

- **@seed/key**: Resolved **before execution** using `coverage/runtime/seed-state.json`. Use for literal strings (selectors, labels) derived from seed data.

- **@store/key**: Resolved **during execution** by BAS. Use for values that change during workflow execution or are set by previous steps.

## Reset Behavior

The `metadata.reset` field controls seed state between workflows:

| Value | Behavior |
|-------|----------|
| `"none"` | Share state with previous workflow (read-only tests) |
| `"full"` | Re-run seeds before next workflow (mutating tests) |

**Example**: A workflow that creates a project should set `"reset": "full"` so the next workflow starts with clean state.

## Seed Scripts

### seed.go / seed.sh

Creates deterministic test data and outputs state to `coverage/runtime/seed-state.json`:

```bash
package main

import (
  "encoding/json"
  "log"
  "net/http"
  "os"
)

func main() {
  api := os.Getenv("API_URL")
  // create data via API...
  seed := map[string]string{"projectId": "demo-123", "projectName": "Demo Project"}

  path := "coverage/runtime/seed-state.json"
  _ = os.MkdirAll("coverage/runtime", 0o755)
  f, _ := os.Create(path)
  defer f.Close()
  json.NewEncoder(f).Encode(seed)
  log.Printf("seed state written to %s", path)
  _ = http.Get(api) // placeholder
}
```

## Authoring Checklist

When adding a new playbook:

1. **Choose location**: `capabilities/<target>/<surface>/` or `journeys/<flow>/`
2. **Create folder** if needed with two-digit prefix (e.g., `04-new-feature/`)
3. **Name file** using kebab-case with verb (e.g., `create-widget.json`)
4. **Add metadata** with `description`, `version`, and `reset`
5. **Use selectors** via `@selector/<key>` (never hardcode CSS)
6. **Reference fixtures** via `@fixture/<slug>` for reusable setup
7. **Link requirements** in `requirements/*.json` via `validation.ref`
8. **Regenerate registry**: `test-genie registry build`
9. **Verify order**: Check `registry.json` has correct `order` value

## Structure Phase Integration

The [Structure Phase](../structure/README.md) documents the expected playbooks layout. When `test/playbooks/` exists, scenarios should follow these conventions:

- `registry.json` must exist and be valid JSON
- Directories under `capabilities/` and `journeys/` should use two-digit prefixes
- `__subflows/` fixtures must declare `fixture_id`

> **Note**: Structure phase validation for playbooks layout is currently informational. Future versions may enforce these conventions automatically.

See [Structure Phase](../structure/README.md) for details on how playbooks structure fits into overall scenario validation.

## See Also

- [Playbooks Phase](README.md) - Phase overview and execution
- [UI Automation with BAS](ui-automation-with-bas.md) - Writing workflow JSON
- [Structure Phase](../structure/README.md) - File and config validation
- [Business Phase](../business/README.md) - Requirements coverage tracking
