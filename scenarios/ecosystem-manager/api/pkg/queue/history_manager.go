package queue

import (
	"encoding/json"
	"fmt"
	"log"
	"os"
	"path/filepath"
	"sort"
	"strings"
	"sync"
	"time"

	"github.com/ecosystem-manager/api/pkg/systemlog"
)

// HistoryManager handles execution history persistence and retrieval.
// It provides caching to avoid expensive filesystem operations on repeated calls.
type HistoryManager struct {
	taskLogsDir string

	// Execution history cache (simple time-based invalidation)
	cacheMu   sync.RWMutex
	cache     []ExecutionHistory
	cacheTime time.Time
}

// NewHistoryManager creates a new HistoryManager with the specified logs directory.
func NewHistoryManager(taskLogsDir string) *HistoryManager {
	return &HistoryManager{
		taskLogsDir: taskLogsDir,
	}
}

// getExecutionHistoryDir returns the directory for a task's execution history.
func (hm *HistoryManager) getExecutionHistoryDir(taskID string) string {
	return filepath.Join(hm.taskLogsDir, taskID, "executions")
}

// GetExecutionDir returns the directory for a specific execution.
func (hm *HistoryManager) GetExecutionDir(taskID, executionID string) string {
	return filepath.Join(hm.getExecutionHistoryDir(taskID), executionID)
}

// GetExecutionFilePath returns the full path to a file within an execution directory.
func (hm *HistoryManager) GetExecutionFilePath(taskID, executionID, filename string) string {
	return filepath.Join(hm.GetExecutionDir(taskID, executionID), filename)
}

// SavePromptToHistory stores the assembled prompt in execution history.
func (hm *HistoryManager) SavePromptToHistory(taskID, executionID, prompt string) (string, error) {
	execDir := hm.GetExecutionDir(taskID, executionID)
	if err := os.MkdirAll(execDir, 0o755); err != nil {
		return "", fmt.Errorf("create execution directory: %w", err)
	}

	promptPath := filepath.Join(execDir, "prompt.txt")
	if err := os.WriteFile(promptPath, []byte(prompt), 0o644); err != nil {
		return "", fmt.Errorf("write prompt file: %w", err)
	}

	// Return relative path from task-runs root
	relPath := filepath.Join(taskID, "executions", executionID, "prompt.txt")
	return relPath, nil
}

// SaveExecutionMetadata persists execution metadata to disk.
func (hm *HistoryManager) SaveExecutionMetadata(history ExecutionHistory) error {
	execDir := hm.GetExecutionDir(history.TaskID, history.ExecutionID)
	if err := os.MkdirAll(execDir, 0o755); err != nil {
		return fmt.Errorf("create execution directory: %w", err)
	}

	metadataPath := filepath.Join(execDir, "metadata.json")
	data, err := json.MarshalIndent(history, "", "  ")
	if err != nil {
		return fmt.Errorf("marshal metadata: %w", err)
	}

	if err := os.WriteFile(metadataPath, data, 0o644); err != nil {
		return fmt.Errorf("write metadata file: %w", err)
	}

	// Invalidate cache since we just added a new execution
	hm.InvalidateCache()

	return nil
}

// SaveOutputToHistory moves the execution log to the history directory.
func (hm *HistoryManager) SaveOutputToHistory(taskID, executionID string) (string, error) {
	execDir := hm.GetExecutionDir(taskID, executionID)
	if err := os.MkdirAll(execDir, 0o755); err != nil {
		return "", fmt.Errorf("create execution directory: %w", err)
	}

	// The output log is generated by TaskLogger
	// We need to move it from the flat structure to the execution-specific directory
	oldLogPath := filepath.Join(hm.taskLogsDir, fmt.Sprintf("%s.log", taskID))
	newLogPath := filepath.Join(execDir, "output.log")

	// If old log exists, move it
	if _, err := os.Stat(oldLogPath); err == nil {
		// Read and rewrite to new location (can't rename across directories safely)
		data, readErr := os.ReadFile(oldLogPath)
		if readErr == nil {
			if writeErr := os.WriteFile(newLogPath, data, 0o644); writeErr != nil {
				return "", fmt.Errorf("write output to history: %w", writeErr)
			}
			// Remove old log after successful copy
			os.Remove(oldLogPath)
		}
	}

	// Return relative path from task-runs root
	relPath := filepath.Join(taskID, "executions", executionID, "output.log")
	return relPath, nil
}

// LoadExecutionHistory loads all execution history for a task.
func (hm *HistoryManager) LoadExecutionHistory(taskID string) ([]ExecutionHistory, error) {
	historyDir := hm.getExecutionHistoryDir(taskID)
	entries, err := os.ReadDir(historyDir)
	if err != nil {
		if os.IsNotExist(err) {
			return []ExecutionHistory{}, nil // No history yet
		}
		return nil, fmt.Errorf("read history directory: %w", err)
	}

	var history []ExecutionHistory
	for _, entry := range entries {
		if !entry.IsDir() {
			continue
		}

		metadataPath := filepath.Join(historyDir, entry.Name(), "metadata.json")
		data, err := os.ReadFile(metadataPath)
		if err != nil {
			log.Printf("Warning: could not read execution metadata %s: %v", metadataPath, err)
			continue
		}

		var exec ExecutionHistory
		if err := json.Unmarshal(data, &exec); err != nil {
			log.Printf("Warning: could not parse execution metadata %s: %v", metadataPath, err)
			continue
		}

		history = append(history, exec)
	}

	// Ensure newest executions are returned first for consistent consumers
	sort.Slice(history, func(i, j int) bool {
		a := history[i]
		b := history[j]

		// Prefer non-zero StartTime when available
		if !a.StartTime.IsZero() && !b.StartTime.IsZero() {
			if a.StartTime.Equal(b.StartTime) {
				return a.ExecutionID > b.ExecutionID
			}
			return a.StartTime.After(b.StartTime)
		}
		if a.StartTime.IsZero() && !b.StartTime.IsZero() {
			return false
		}
		if !a.StartTime.IsZero() && b.StartTime.IsZero() {
			return true
		}

		// Fallback to execution IDs (timestamp-based) when times are missing
		return a.ExecutionID > b.ExecutionID
	})

	return history, nil
}

// LoadAllExecutionHistory loads execution history for all tasks.
// Uses a simple time-based cache to avoid expensive filesystem operations.
func (hm *HistoryManager) LoadAllExecutionHistory() ([]ExecutionHistory, error) {
	// Check cache first
	hm.cacheMu.RLock()
	if time.Since(hm.cacheTime) < ExecutionHistoryCacheTTL && hm.cache != nil {
		cached := hm.cache
		hm.cacheMu.RUnlock()
		log.Printf("Returning cached execution history (%d entries, age: %v)", len(cached), time.Since(hm.cacheTime))
		return cached, nil
	}
	hm.cacheMu.RUnlock()

	// Cache miss - load from disk
	taskDirs, err := os.ReadDir(hm.taskLogsDir)
	if err != nil {
		if os.IsNotExist(err) {
			return []ExecutionHistory{}, nil
		}
		return nil, fmt.Errorf("read task logs directory: %w", err)
	}

	var allHistory []ExecutionHistory
	for _, taskDir := range taskDirs {
		if !taskDir.IsDir() {
			continue
		}

		taskID := taskDir.Name()
		history, err := hm.LoadExecutionHistory(taskID)
		if err != nil {
			log.Printf("Warning: could not load execution history for task %s: %v", taskID, err)
			continue
		}

		allHistory = append(allHistory, history...)
	}

	// Sort by start time (most recent first)
	sort.Slice(allHistory, func(i, j int) bool {
		return allHistory[i].StartTime.After(allHistory[j].StartTime)
	})

	// Update cache
	hm.cacheMu.Lock()
	hm.cache = allHistory
	hm.cacheTime = time.Now()
	hm.cacheMu.Unlock()

	log.Printf("Loaded execution history from disk (%d entries)", len(allHistory))
	return allHistory, nil
}

// LatestExecutionOutputPath returns the absolute path to the most recent execution output.
func (hm *HistoryManager) LatestExecutionOutputPath(taskID string) string {
	history, err := hm.LoadExecutionHistory(taskID)
	if err != nil || len(history) == 0 {
		return ""
	}

	latest := history[0]

	resolve := func(rel string) string {
		if strings.TrimSpace(rel) == "" {
			return ""
		}
		return filepath.Join(hm.taskLogsDir, rel)
	}

	if path := resolve(latest.CleanOutputPath); path != "" {
		return path
	}

	return resolve(latest.OutputPath)
}

// CleanupOldExecutions removes execution history older than the specified retention period.
func (hm *HistoryManager) CleanupOldExecutions(taskID string, retentionDays int) error {
	if retentionDays <= 0 {
		return nil // Retention disabled
	}

	history, err := hm.LoadExecutionHistory(taskID)
	if err != nil {
		return err
	}

	cutoff := time.Now().AddDate(0, 0, -retentionDays)
	removedCount := 0

	for _, exec := range history {
		if exec.StartTime.Before(cutoff) {
			execDir := hm.GetExecutionDir(taskID, exec.ExecutionID)
			if err := os.RemoveAll(execDir); err != nil {
				log.Printf("Warning: failed to remove old execution %s: %v", execDir, err)
			} else {
				removedCount++
			}
		}
	}

	if removedCount > 0 {
		systemlog.Infof("Cleaned up %d old executions for task %s (retention: %d days)", removedCount, taskID, retentionDays)
		// Invalidate cache after cleanup
		hm.InvalidateCache()
	}

	return nil
}

// InvalidateCache clears the execution history cache.
func (hm *HistoryManager) InvalidateCache() {
	hm.cacheMu.Lock()
	hm.cache = nil
	hm.cacheTime = time.Time{}
	hm.cacheMu.Unlock()
}

// TaskLogsDir returns the task logs directory path.
func (hm *HistoryManager) TaskLogsDir() string {
	return hm.taskLogsDir
}
