package main

import (
	"bytes"
	"fmt"
	"os"
	"path/filepath"
	"reflect"
	"runtime"
	"sort"
	"strings"
	"time"

	"github.com/google/uuid"
	"github.com/vrooli/browser-automation-studio/automation/contracts"
	"github.com/vrooli/browser-automation-studio/services/export"
)

type generator struct {
	overrides map[reflect.Type]string
	names     map[reflect.Type]string
	visited   map[reflect.Type]bool
	order     []reflect.Type
}

func newGenerator(overrides map[reflect.Type]string) *generator {
	return &generator{
		overrides: overrides,
		names:     make(map[reflect.Type]string),
		visited:   make(map[reflect.Type]bool),
		order:     make([]reflect.Type, 0, len(overrides)),
	}
}

func (g *generator) registerRoot(t reflect.Type, name string) {
	t = indirectType(t)
	if _, exists := g.names[t]; exists {
		return
	}
	if name == "" {
		name = g.nameForType(t)
	}
	g.names[t] = name
	g.order = append(g.order, t)
	g.walk(t)
}

func (g *generator) nameForType(t reflect.Type) string {
	if name, ok := g.overrides[t]; ok {
		return name
	}
	if t.Name() != "" {
		return t.Name()
	}
	panic(fmt.Sprintf("unmapped anonymous type %v", t))
}

func (g *generator) ensureType(t reflect.Type) string {
	t = indirectType(t)
	if name, ok := g.names[t]; ok {
		if !g.visited[t] {
			g.walk(t)
		}
		return name
	}
	name := g.nameForType(t)
	g.names[t] = name
	g.order = append(g.order, t)
	g.walk(t)
	return name
}

func (g *generator) walk(t reflect.Type) {
	t = indirectType(t)
	if t.Kind() != reflect.Struct {
		return
	}
	if g.visited[t] {
		return
	}
	g.visited[t] = true

	for i := 0; i < t.NumField(); i++ {
		field := t.Field(i)
		if field.PkgPath != "" { // unexported field
			continue
		}
		if tag := field.Tag.Get("json"); tag == "-" {
			continue
		}
		g.queue(field.Type)
	}
}

func (g *generator) queue(t reflect.Type) {
	switch t.Kind() {
	case reflect.Pointer:
		g.queue(t.Elem())
	case reflect.Slice, reflect.Array:
		if t.Elem().Kind() == reflect.Uint8 {
			return
		}
		g.queue(t.Elem())
	case reflect.Map:
		g.queue(t.Elem())
	case reflect.Struct:
		if isTimeType(t) || isUUIDType(t) {
			return
		}
		g.ensureType(t)
	}
}

func (g *generator) tsType(t reflect.Type) string {
	switch t.Kind() {
	case reflect.Pointer:
		return g.tsType(t.Elem())
	case reflect.Bool:
		return "boolean"
	case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64,
		reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr,
		reflect.Float32, reflect.Float64:
		return "number"
	case reflect.String:
		return "string"
	case reflect.Slice, reflect.Array:
		if t.Elem().Kind() == reflect.Uint8 {
			return "string"
		}
		return fmt.Sprintf("%s[]", g.tsType(t.Elem()))
	case reflect.Map:
		if t.Key().Kind() != reflect.String {
			return "Record<string, unknown>"
		}
		return fmt.Sprintf("Record<string, %s>", g.tsType(t.Elem()))
	case reflect.Interface:
		return "unknown"
	case reflect.Struct:
		if isTimeType(t) {
			return "string"
		}
		if isUUIDType(t) {
			return "string"
		}
		return g.ensureType(t)
	default:
		return "unknown"
	}
}

func (g *generator) render() ([]byte, error) {
	var buf bytes.Buffer
	buf.WriteString("// Code generated by go run api/cmd/movie-spec-gen/main.go. DO NOT EDIT.\n")
	buf.WriteString("// Generated at " + time.Now().UTC().Format(time.RFC3339) + "\n\n")

	order := make([]reflect.Type, len(g.order))
	copy(order, g.order)
	sort.SliceStable(order, func(i, j int) bool {
		if order[i] == order[j] {
			return false
		}
		nameI := g.names[order[i]]
		nameJ := g.names[order[j]]
		if nameI == "ReplayMovieSpec" {
			return true
		}
		if nameJ == "ReplayMovieSpec" {
			return false
		}
		return nameI < nameJ
	})

	type fieldInfo struct {
		name        string
		tsType      string
		optional    bool
		occurrences int
		order       int
	}

	groups := make([]struct {
		name  string
		types []reflect.Type
	}, 0, len(order))
	indexByName := make(map[string]int)
	for _, t := range order {
		name := g.names[t]
		if name == "" {
			continue
		}
		if idx, ok := indexByName[name]; ok {
			groups[idx].types = append(groups[idx].types, t)
		} else {
			indexByName[name] = len(groups)
			groups = append(groups, struct {
				name  string
				types []reflect.Type
			}{name: name, types: []reflect.Type{t}})
		}
	}

	for _, group := range groups {
		buf.WriteString(fmt.Sprintf("export interface %s {\n", group.name))

		fieldOrder := make([]string, 0, 32)
		fieldMap := make(map[string]*fieldInfo)

		for _, t := range group.types {
			for i := 0; i < t.NumField(); i++ {
				field := t.Field(i)
				if field.PkgPath != "" {
					continue
				}
				jsonTag := field.Tag.Get("json")
				if jsonTag == "-" {
					continue
				}
				jsonName, opts := parseJSONTag(jsonTag)
				if jsonName == "" {
					jsonName = toSnake(field.Name)
				}
				if jsonName == "-" {
					continue
				}
				optional := strings.Contains(opts, "omitempty") || field.Type.Kind() == reflect.Pointer
				ts := g.tsType(field.Type)

				if existing, ok := fieldMap[jsonName]; ok {
					existing.occurrences++
					existing.optional = existing.optional || optional
					if existing.tsType != ts {
						existing.tsType = "unknown"
					}
				} else {
					fieldMap[jsonName] = &fieldInfo{
						name:        jsonName,
						tsType:      ts,
						optional:    optional,
						occurrences: 1,
						order:       len(fieldOrder),
					}
					fieldOrder = append(fieldOrder, jsonName)
				}
			}
		}

		totalTypes := len(group.types)
		if len(fieldOrder) == 0 {
			buf.WriteString("  [key: string]: unknown;\n")
		} else {
			for _, name := range fieldOrder {
				info := fieldMap[name]
				if info.occurrences < totalTypes {
					info.optional = true
				}
				if info.optional {
					buf.WriteString(fmt.Sprintf("  %s?: %s;\n", info.name, info.tsType))
				} else {
					buf.WriteString(fmt.Sprintf("  %s: %s;\n", info.name, info.tsType))
				}
			}
		}
		buf.WriteString("}\n\n")
	}

	return buf.Bytes(), nil
}

func parseJSONTag(tag string) (string, string) {
	if tag == "" {
		return "", ""
	}
	parts := strings.Split(tag, ",")
	name := parts[0]
	opts := strings.Join(parts[1:], ",")
	return name, opts
}

func toSnake(value string) string {
	if value == "" {
		return ""
	}
	var output []rune
	var prevLower bool
	for _, r := range value {
		isUpper := r >= 'A' && r <= 'Z'
		if len(output) > 0 && isUpper && prevLower {
			output = append(output, '_')
		}
		prevLower = r >= 'a' && r <= 'z'
		if isUpper {
			r = r - 'A' + 'a'
		}
		output = append(output, r)
	}
	return string(output)
}

func indirectType(t reflect.Type) reflect.Type {
	for t.Kind() == reflect.Pointer {
		t = t.Elem()
	}
	return t
}

func isTimeType(t reflect.Type) bool {
	return t.PkgPath() == "time" && t.Name() == "Time"
}

func isUUIDType(t reflect.Type) bool {
	return t == reflect.TypeOf(uuid.UUID{})
}

func main() {
	overrides := map[reflect.Type]string{
		reflect.TypeOf(export.ReplayMovieSpec{}):           "ReplayMovieSpec",
		reflect.TypeOf(services.ExportSummary{}):           "ReplayMovieSummary",
		reflect.TypeOf(services.ExportExecutionMetadata{}): "ReplayMovieExecutionMetadata",
		reflect.TypeOf(services.ExportAsset{}):             "ReplayMovieAsset",
		reflect.TypeOf(services.ExportBrowserChrome{}):     "ReplayMovieBrowserChrome",
		reflect.TypeOf(services.ExportTheme{}):             "ReplayMovieTheme",
		reflect.TypeOf(services.ExportCursorTrail{}):       "ReplayMovieCursorTrail",
		reflect.TypeOf(services.ExportClickPulse{}):        "ReplayMovieClickPulse",
		reflect.TypeOf(services.ExportCursorSpec{}):        "ReplayMovieCursorSpec",
		reflect.TypeOf(services.ExportDecor{}):             "ReplayMovieDecor",
		reflect.TypeOf(services.ExportDimensions{}):        "ReplayMovieDimensions",
		reflect.TypeOf(services.ExportNormalizedPoint{}):   "ReplayMovieNormalizedPoint",
		reflect.TypeOf(services.ExportNormalizedRect{}):    "ReplayMovieNormalizedRect",
		reflect.TypeOf(services.ExportResilience{}):        "ReplayMovieResilience",
		reflect.TypeOf(export.ExportFrame{}):               "ReplayMovieFrame",
		reflect.TypeOf(services.RetryHistoryEntry{}):       "ReplayMovieRetryHistoryEntry",
		reflect.TypeOf(contracts.HighlightRegion{}):        "ReplayMovieRegion",
		reflect.TypeOf(contracts.MaskRegion{}):             "ReplayMovieRegion",
		reflect.TypeOf(contracts.ElementFocus{}):           "ReplayMovieFocusedElement",
		reflect.TypeOf(contracts.BoundingBox{}):            "ReplayMovieRegionBounds",
		reflect.TypeOf(contracts.Point{}):                  "ReplayMovieCursorTrailPoint",
		reflect.TypeOf(contracts.AssertionOutcome{}):       "ReplayMovieAssertion",
		reflect.TypeOf(services.ExportPlayback{}):          "ReplayMoviePlayback",
		reflect.TypeOf(services.ExportPresentation{}):      "ReplayMoviePresentation",
		reflect.TypeOf(export.ExportFrameRect{}):           "ReplayMovieFrameRect",
		reflect.TypeOf(services.ExportCursorMotion{}):      "ReplayMovieCursorMotion",
	}

	gen := newGenerator(overrides)
	gen.registerRoot(reflect.TypeOf(export.ReplayMovieSpec{}), "ReplayMovieSpec")

	content, err := gen.render()
	if err != nil {
		panic(err)
	}

	_, callerFile, _, ok := runtime.Caller(0)
	if !ok {
		panic("unable to determine caller path")
	}
	root := filepath.Clean(filepath.Join(filepath.Dir(callerFile), "..", "..", ".."))
	target := filepath.Join(root, "ui", "src", "types", "export.ts")

	if err := os.WriteFile(target, content, 0o644); err != nil {
		panic(fmt.Errorf("failed to write %s: %w", target, err))
	}
}
