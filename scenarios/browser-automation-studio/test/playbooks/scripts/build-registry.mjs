#!/usr/bin/env node
import fs from 'node:fs';
import path from 'node:path';
import { fileURLToPath } from 'node:url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const playbooksRoot = path.resolve(__dirname, '..');
const scenarioRoot = path.resolve(playbooksRoot, '..', '..');
const requirementsDir = path.join(scenarioRoot, 'requirements');
const registryPath = path.join(playbooksRoot, 'registry.json');

function readJSON(filePath) {
  return JSON.parse(fs.readFileSync(filePath, 'utf8'));
}

function normalizePlaybookPath(absPath) {
  const rel = path.relative(scenarioRoot, absPath);
  return rel.split(path.sep).join('/');
}

function collectRequirementValidations() {
  const indexPath = path.join(requirementsDir, 'index.json');
  const indexData = readJSON(indexPath);
  const imports = indexData.imports || [];
  const validationsByFile = new Map();

  for (const relModule of imports) {
    const modulePath = path.join(requirementsDir, relModule);
    if (!fs.existsSync(modulePath)) continue;
    const moduleData = readJSON(modulePath);
    for (const req of moduleData.requirements || []) {
      for (const validation of req.validation || []) {
        if (validation.type !== 'automation' || typeof validation.ref !== 'string') continue;
        if (!validation.ref.startsWith('test/playbooks/')) continue;
        const key = validation.ref;
        if (!validationsByFile.has(key)) {
          validationsByFile.set(key, []);
        }
        validationsByFile.get(key).push({
          requirement: req.id,
          requirementTitle: req.title,
          phase: validation.phase || 'unknown',
          status: validation.status || 'unknown'
        });
      }
    }
  }

  return validationsByFile;
}

function getFixtures(playbook) {
  const fixtures = new Set();
  const nodes = Array.isArray(playbook.nodes) ? playbook.nodes : [];
  for (const node of nodes) {
    const workflowId = node?.data?.workflowId;
    if (typeof workflowId === 'string' && workflowId.startsWith('@fixture/')) {
      fixtures.add(workflowId.slice('@fixture/'.length));
    }
  }
  return Array.from(fixtures).sort();
}

function collectPlaybooks() {
  const targets = [
    path.join(playbooksRoot, 'capabilities'),
    path.join(playbooksRoot, 'journeys')
  ];
  const files = [];
  for (const target of targets) {
    if (!fs.existsSync(target)) continue;
    const stack = [target];
    while (stack.length) {
      const current = stack.pop();
      const stat = fs.statSync(current);
      if (stat.isDirectory()) {
        for (const child of fs.readdirSync(current)) {
          stack.push(path.join(current, child));
        }
      } else if (path.extname(current) === '.json') {
        files.push(current);
      }
    }
  }
  return files;
}

const validationsByFile = collectRequirementValidations();
const playbookFiles = collectPlaybooks();
const registry = {
  _note: 'AUTO-GENERATED by test/playbooks/scripts/build-registry.mjs â€” run `make test` (or rerun this script) to refresh. Do not edit manually.',
  generated_at: new Date().toISOString(),
  playbooks: []
};

for (const absPath of playbookFiles.sort()) {
  const relPath = normalizePlaybookPath(absPath);
  const data = readJSON(absPath);
  const fixtures = getFixtures(data);
  const metadata = data.metadata || {};
  const validations = validationsByFile.get(relPath) || [];
  registry.playbooks.push({
    file: relPath,
    requirement: metadata.requirement || null,
    description: metadata.description || '',
    version: metadata.version ?? null,
    fixtures,
    validations
  });
}

fs.writeFileSync(registryPath, JSON.stringify(registry, null, 2));
console.log(`Playbook registry updated: ${path.relative(scenarioRoot, registryPath)}`);
