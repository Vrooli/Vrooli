/**
 * Enum Parity Test
 *
 * Verifies that TypeScript enum-to-string converters produce the same output
 * as the Go API. This ensures handler dispatch strings match across languages.
 *
 * The fixture is generated by running:
 *   go test -run TestGenerateEnumParityFixture ./packages/proto/examples/
 *
 * Run this test with:
 *   pnpm test:unit src/proto/__tests__/enum-parity.test.ts
 */

import * as fs from 'fs';
import * as path from 'path';

import {
  ActionType,
  MouseButton,
  KeyboardModifier,
  NavigateWaitEvent,
  WaitState,
  ScrollBehavior,
  KeyAction,
  ExtractType,
  FrameSwitchAction,
  TabSwitchAction,
  CookieOperation,
  StorageType,
  CookieSameSite,
  GestureType,
  SwipeDirection,
  NetworkMockOperation,
  DeviceOrientation,
} from '@vrooli/proto-types/browser-automation-studio/v1/actions/action_pb';
import { AssertionMode } from '@vrooli/proto-types/browser-automation-studio/v1/base/shared_pb';

// Import the converter functions we're testing
// Note: These are private functions in index.ts, so we recreate them here for testing.
// The actual converters are used via the get*Params() functions.

function actionTypeToString(actionType: ActionType): string {
  switch (actionType) {
    case ActionType.NAVIGATE: return 'navigate';
    case ActionType.CLICK: return 'click';
    case ActionType.INPUT: return 'input';
    case ActionType.WAIT: return 'wait';
    case ActionType.ASSERT: return 'assert';
    case ActionType.SCROLL: return 'scroll';
    case ActionType.SELECT: return 'select';
    case ActionType.EVALUATE: return 'evaluate';
    case ActionType.KEYBOARD: return 'keyboard';
    case ActionType.HOVER: return 'hover';
    case ActionType.SCREENSHOT: return 'screenshot';
    case ActionType.FOCUS: return 'focus';
    case ActionType.BLUR: return 'blur';
    case ActionType.SUBFLOW: return 'subflow';
    case ActionType.EXTRACT: return 'extract';
    case ActionType.UPLOAD_FILE: return 'uploadfile';
    case ActionType.DOWNLOAD: return 'download';
    case ActionType.FRAME_SWITCH: return 'frameswitch';
    case ActionType.TAB_SWITCH: return 'tabswitch';
    case ActionType.COOKIE_STORAGE: return 'cookiestorage';
    case ActionType.SHORTCUT: return 'shortcut';
    case ActionType.DRAG_DROP: return 'dragdrop';
    case ActionType.GESTURE: return 'gesture';
    case ActionType.NETWORK_MOCK: return 'networkmock';
    case ActionType.ROTATE: return 'rotate';
    default: return 'unknown';
  }
}

function mouseButtonToString(button: MouseButton): string {
  switch (button) {
    case MouseButton.LEFT: return 'left';
    case MouseButton.RIGHT: return 'right';
    case MouseButton.MIDDLE: return 'middle';
    default: return '';
  }
}

function keyboardModifierToString(modifier: KeyboardModifier): string {
  switch (modifier) {
    case KeyboardModifier.CTRL: return 'ctrl';
    case KeyboardModifier.SHIFT: return 'shift';
    case KeyboardModifier.ALT: return 'alt';
    case KeyboardModifier.META: return 'meta';
    default: return '';
  }
}

function navigateWaitEventToString(event: NavigateWaitEvent): string {
  switch (event) {
    case NavigateWaitEvent.LOAD: return 'load';
    case NavigateWaitEvent.DOMCONTENTLOADED: return 'domcontentloaded';
    case NavigateWaitEvent.NETWORKIDLE: return 'networkidle';
    default: return '';
  }
}

function waitStateToString(state: WaitState): string {
  switch (state) {
    case WaitState.ATTACHED: return 'attached';
    case WaitState.DETACHED: return 'detached';
    case WaitState.VISIBLE: return 'visible';
    case WaitState.HIDDEN: return 'hidden';
    default: return '';
  }
}

function assertionModeToString(mode: AssertionMode): string {
  switch (mode) {
    case AssertionMode.EXISTS: return 'exists';
    case AssertionMode.NOT_EXISTS: return 'notexists';
    case AssertionMode.VISIBLE: return 'visible';
    case AssertionMode.HIDDEN: return 'hidden';
    case AssertionMode.TEXT_EQUALS: return 'text_equals';
    case AssertionMode.TEXT_CONTAINS: return 'text_contains';
    case AssertionMode.ATTRIBUTE_EQUALS: return 'attribute_equals';
    case AssertionMode.ATTRIBUTE_CONTAINS: return 'attribute_contains';
    default: return 'exists';
  }
}

function scrollBehaviorToString(behavior: ScrollBehavior): string {
  switch (behavior) {
    case ScrollBehavior.AUTO: return 'auto';
    case ScrollBehavior.SMOOTH: return 'smooth';
    default: return '';
  }
}

function keyActionToString(action: KeyAction): string {
  switch (action) {
    case KeyAction.PRESS: return 'press';
    case KeyAction.DOWN: return 'down';
    case KeyAction.UP: return 'up';
    default: return '';
  }
}

function extractTypeToString(type: ExtractType): string {
  switch (type) {
    case ExtractType.TEXT: return 'text';
    case ExtractType.INNER_HTML: return 'innerHTML';
    case ExtractType.OUTER_HTML: return 'outerHTML';
    case ExtractType.ATTRIBUTE: return 'attribute';
    case ExtractType.PROPERTY: return 'property';
    case ExtractType.VALUE: return 'value';
    default: return 'text';
  }
}

function frameSwitchActionToString(action: FrameSwitchAction): string {
  switch (action) {
    case FrameSwitchAction.ENTER: return 'enter';
    case FrameSwitchAction.PARENT: return 'parent';
    case FrameSwitchAction.EXIT: return 'exit';
    default: return 'enter';
  }
}

function tabSwitchActionToString(action: TabSwitchAction): string {
  switch (action) {
    case TabSwitchAction.OPEN: return 'open';
    case TabSwitchAction.SWITCH: return 'switch';
    case TabSwitchAction.CLOSE: return 'close';
    case TabSwitchAction.LIST: return 'list';
    default: return 'switch';
  }
}

function cookieOperationToString(operation: CookieOperation): string {
  switch (operation) {
    case CookieOperation.GET: return 'get';
    case CookieOperation.SET: return 'set';
    case CookieOperation.DELETE: return 'delete';
    case CookieOperation.CLEAR: return 'clear';
    default: return 'get';
  }
}

function storageTypeToString(type: StorageType): string {
  switch (type) {
    case StorageType.COOKIE: return 'cookie';
    case StorageType.LOCAL_STORAGE: return 'localStorage';
    case StorageType.SESSION_STORAGE: return 'sessionStorage';
    default: return 'cookie';
  }
}

function cookieSameSiteToString(sameSite: CookieSameSite): string {
  switch (sameSite) {
    case CookieSameSite.STRICT: return 'Strict';
    case CookieSameSite.LAX: return 'Lax';
    case CookieSameSite.NONE: return 'None';
    default: return '';
  }
}

function gestureTypeToString(type: GestureType): string {
  switch (type) {
    case GestureType.SWIPE: return 'swipe';
    case GestureType.PINCH: return 'pinch';
    case GestureType.ZOOM: return 'zoom';
    case GestureType.LONG_PRESS: return 'longPress';
    case GestureType.DOUBLE_TAP: return 'doubleTap';
    default: return 'swipe';
  }
}

function swipeDirectionToString(direction: SwipeDirection): string {
  switch (direction) {
    case SwipeDirection.UP: return 'up';
    case SwipeDirection.DOWN: return 'down';
    case SwipeDirection.LEFT: return 'left';
    case SwipeDirection.RIGHT: return 'right';
    default: return '';
  }
}

function networkMockOperationToString(operation: NetworkMockOperation): string {
  switch (operation) {
    case NetworkMockOperation.MOCK: return 'mock';
    case NetworkMockOperation.BLOCK: return 'block';
    case NetworkMockOperation.MODIFY_REQUEST: return 'modifyRequest';
    case NetworkMockOperation.MODIFY_RESPONSE: return 'modifyResponse';
    case NetworkMockOperation.CLEAR: return 'clear';
    default: return 'mock';
  }
}

function deviceOrientationToString(orientation: DeviceOrientation): string {
  switch (orientation) {
    case DeviceOrientation.PORTRAIT: return 'portrait';
    case DeviceOrientation.LANDSCAPE: return 'landscape';
    default: return 'portrait';
  }
}

// Load the fixture generated by Go tests
interface EnumParityFixture {
  actionType: Record<string, string>;
  mouseButton: Record<string, string>;
  keyboardModifier: Record<string, string>;
  navigateWaitEvent: Record<string, string>;
  waitState: Record<string, string>;
  assertionMode: Record<string, string>;
  scrollBehavior: Record<string, string>;
  keyAction: Record<string, string>;
  extractType: Record<string, string>;
  frameSwitchAction: Record<string, string>;
  tabSwitchAction: Record<string, string>;
  cookieOperation: Record<string, string>;
  storageType: Record<string, string>;
  cookieSameSite: Record<string, string>;
  gestureType: Record<string, string>;
  swipeDirection: Record<string, string>;
  networkMockOperation: Record<string, string>;
  deviceOrientation: Record<string, string>;
}

// Find the fixture file - it's in packages/proto/examples/testdata/
// Path from tests/unit/proto: 6 levels up to Vrooli root
const fixturePathFromDriver = path.resolve(
  __dirname,
  '../../../../../../packages/proto/examples/testdata/enum_parity_fixture.json'
);

let fixture: EnumParityFixture;

// Load fixture before running tests
beforeAll(() => {
  if (!fs.existsSync(fixturePathFromDriver)) {
    throw new Error(
      `Fixture not found at ${fixturePathFromDriver}. ` +
      'Run: go test -run TestGenerateEnumParityFixture ./packages/proto/examples/'
    );
  }
  const raw = fs.readFileSync(fixturePathFromDriver, 'utf-8');
  fixture = JSON.parse(raw) as EnumParityFixture;
});

describe('Enum Parity with Go API', () => {

  describe('ActionType', () => {
    it.each([
      ['NAVIGATE', ActionType.NAVIGATE],
      ['CLICK', ActionType.CLICK],
      ['INPUT', ActionType.INPUT],
      ['WAIT', ActionType.WAIT],
      ['ASSERT', ActionType.ASSERT],
      ['SCROLL', ActionType.SCROLL],
      ['SELECT', ActionType.SELECT],
      ['EVALUATE', ActionType.EVALUATE],
      ['KEYBOARD', ActionType.KEYBOARD],
      ['HOVER', ActionType.HOVER],
      ['SCREENSHOT', ActionType.SCREENSHOT],
      ['FOCUS', ActionType.FOCUS],
      ['BLUR', ActionType.BLUR],
      ['SUBFLOW', ActionType.SUBFLOW],
      ['EXTRACT', ActionType.EXTRACT],
      ['UPLOAD_FILE', ActionType.UPLOAD_FILE],
      ['DOWNLOAD', ActionType.DOWNLOAD],
      ['FRAME_SWITCH', ActionType.FRAME_SWITCH],
      ['TAB_SWITCH', ActionType.TAB_SWITCH],
      ['COOKIE_STORAGE', ActionType.COOKIE_STORAGE],
      ['SHORTCUT', ActionType.SHORTCUT],
      ['DRAG_DROP', ActionType.DRAG_DROP],
      ['GESTURE', ActionType.GESTURE],
      ['NETWORK_MOCK', ActionType.NETWORK_MOCK],
      ['ROTATE', ActionType.ROTATE],
    ])('%s matches Go', (key, enumValue) => {
      const tsValue = actionTypeToString(enumValue);
      const goValue = fixture.actionType[key];
      expect(tsValue).toBe(goValue);
    });
  });

  describe('MouseButton', () => {
    it.each([
      ['LEFT', MouseButton.LEFT],
      ['RIGHT', MouseButton.RIGHT],
      ['MIDDLE', MouseButton.MIDDLE],
    ])('%s matches Go', (key, enumValue) => {
      expect(mouseButtonToString(enumValue)).toBe(fixture.mouseButton[key]);
    });
  });

  describe('KeyboardModifier', () => {
    it.each([
      ['CTRL', KeyboardModifier.CTRL],
      ['SHIFT', KeyboardModifier.SHIFT],
      ['ALT', KeyboardModifier.ALT],
      ['META', KeyboardModifier.META],
    ])('%s matches Go', (key, enumValue) => {
      expect(keyboardModifierToString(enumValue)).toBe(fixture.keyboardModifier[key]);
    });
  });

  describe('NavigateWaitEvent', () => {
    it.each([
      ['LOAD', NavigateWaitEvent.LOAD],
      ['DOMCONTENTLOADED', NavigateWaitEvent.DOMCONTENTLOADED],
      ['NETWORKIDLE', NavigateWaitEvent.NETWORKIDLE],
    ])('%s matches Go', (key, enumValue) => {
      expect(navigateWaitEventToString(enumValue)).toBe(fixture.navigateWaitEvent[key]);
    });
  });

  describe('WaitState', () => {
    it.each([
      ['ATTACHED', WaitState.ATTACHED],
      ['DETACHED', WaitState.DETACHED],
      ['VISIBLE', WaitState.VISIBLE],
      ['HIDDEN', WaitState.HIDDEN],
    ])('%s matches Go', (key, enumValue) => {
      expect(waitStateToString(enumValue)).toBe(fixture.waitState[key]);
    });
  });

  describe('AssertionMode', () => {
    it.each([
      ['EXISTS', AssertionMode.EXISTS],
      ['NOT_EXISTS', AssertionMode.NOT_EXISTS],
      ['VISIBLE', AssertionMode.VISIBLE],
      ['HIDDEN', AssertionMode.HIDDEN],
      ['TEXT_EQUALS', AssertionMode.TEXT_EQUALS],
      ['TEXT_CONTAINS', AssertionMode.TEXT_CONTAINS],
      ['ATTRIBUTE_EQUALS', AssertionMode.ATTRIBUTE_EQUALS],
      ['ATTRIBUTE_CONTAINS', AssertionMode.ATTRIBUTE_CONTAINS],
    ])('%s matches Go', (key, enumValue) => {
      expect(assertionModeToString(enumValue)).toBe(fixture.assertionMode[key]);
    });
  });

  describe('ScrollBehavior', () => {
    it.each([
      ['AUTO', ScrollBehavior.AUTO],
      ['SMOOTH', ScrollBehavior.SMOOTH],
    ])('%s matches Go', (key, enumValue) => {
      expect(scrollBehaviorToString(enumValue)).toBe(fixture.scrollBehavior[key]);
    });
  });

  describe('KeyAction', () => {
    it.each([
      ['PRESS', KeyAction.PRESS],
      ['DOWN', KeyAction.DOWN],
      ['UP', KeyAction.UP],
    ])('%s matches Go', (key, enumValue) => {
      expect(keyActionToString(enumValue)).toBe(fixture.keyAction[key]);
    });
  });

  describe('ExtractType', () => {
    it.each([
      ['TEXT', ExtractType.TEXT],
      ['INNER_HTML', ExtractType.INNER_HTML],
      ['OUTER_HTML', ExtractType.OUTER_HTML],
      ['ATTRIBUTE', ExtractType.ATTRIBUTE],
      ['PROPERTY', ExtractType.PROPERTY],
      ['VALUE', ExtractType.VALUE],
    ])('%s matches Go', (key, enumValue) => {
      expect(extractTypeToString(enumValue)).toBe(fixture.extractType[key]);
    });
  });

  describe('FrameSwitchAction', () => {
    it.each([
      ['ENTER', FrameSwitchAction.ENTER],
      ['PARENT', FrameSwitchAction.PARENT],
      ['EXIT', FrameSwitchAction.EXIT],
    ])('%s matches Go', (key, enumValue) => {
      expect(frameSwitchActionToString(enumValue)).toBe(fixture.frameSwitchAction[key]);
    });
  });

  describe('TabSwitchAction', () => {
    it.each([
      ['OPEN', TabSwitchAction.OPEN],
      ['SWITCH', TabSwitchAction.SWITCH],
      ['CLOSE', TabSwitchAction.CLOSE],
      ['LIST', TabSwitchAction.LIST],
    ])('%s matches Go', (key, enumValue) => {
      expect(tabSwitchActionToString(enumValue)).toBe(fixture.tabSwitchAction[key]);
    });
  });

  describe('CookieOperation', () => {
    it.each([
      ['GET', CookieOperation.GET],
      ['SET', CookieOperation.SET],
      ['DELETE', CookieOperation.DELETE],
      ['CLEAR', CookieOperation.CLEAR],
    ])('%s matches Go', (key, enumValue) => {
      expect(cookieOperationToString(enumValue)).toBe(fixture.cookieOperation[key]);
    });
  });

  describe('StorageType', () => {
    it.each([
      ['COOKIE', StorageType.COOKIE],
      ['LOCAL_STORAGE', StorageType.LOCAL_STORAGE],
      ['SESSION_STORAGE', StorageType.SESSION_STORAGE],
    ])('%s matches Go', (key, enumValue) => {
      expect(storageTypeToString(enumValue)).toBe(fixture.storageType[key]);
    });
  });

  describe('CookieSameSite', () => {
    it.each([
      ['STRICT', CookieSameSite.STRICT],
      ['LAX', CookieSameSite.LAX],
      ['NONE', CookieSameSite.NONE],
    ])('%s matches Go', (key, enumValue) => {
      expect(cookieSameSiteToString(enumValue)).toBe(fixture.cookieSameSite[key]);
    });
  });

  describe('GestureType', () => {
    it.each([
      ['SWIPE', GestureType.SWIPE],
      ['PINCH', GestureType.PINCH],
      ['ZOOM', GestureType.ZOOM],
      ['LONG_PRESS', GestureType.LONG_PRESS],
      ['DOUBLE_TAP', GestureType.DOUBLE_TAP],
    ])('%s matches Go', (key, enumValue) => {
      expect(gestureTypeToString(enumValue)).toBe(fixture.gestureType[key]);
    });
  });

  describe('SwipeDirection', () => {
    it.each([
      ['UP', SwipeDirection.UP],
      ['DOWN', SwipeDirection.DOWN],
      ['LEFT', SwipeDirection.LEFT],
      ['RIGHT', SwipeDirection.RIGHT],
    ])('%s matches Go', (key, enumValue) => {
      expect(swipeDirectionToString(enumValue)).toBe(fixture.swipeDirection[key]);
    });
  });

  describe('NetworkMockOperation', () => {
    it.each([
      ['MOCK', NetworkMockOperation.MOCK],
      ['BLOCK', NetworkMockOperation.BLOCK],
      ['MODIFY_REQUEST', NetworkMockOperation.MODIFY_REQUEST],
      ['MODIFY_RESPONSE', NetworkMockOperation.MODIFY_RESPONSE],
      ['CLEAR', NetworkMockOperation.CLEAR],
    ])('%s matches Go', (key, enumValue) => {
      expect(networkMockOperationToString(enumValue)).toBe(fixture.networkMockOperation[key]);
    });
  });

  describe('DeviceOrientation', () => {
    it.each([
      ['PORTRAIT', DeviceOrientation.PORTRAIT],
      ['LANDSCAPE', DeviceOrientation.LANDSCAPE],
    ])('%s matches Go', (key, enumValue) => {
      expect(deviceOrientationToString(enumValue)).toBe(fixture.deviceOrientation[key]);
    });
  });
});
