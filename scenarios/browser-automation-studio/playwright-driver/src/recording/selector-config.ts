/**
 * Selector Configuration
 *
 * CHANGE AXIS: Selector Strategy Configuration
 *
 * This module is the SINGLE SOURCE OF TRUTH for selector generation configuration.
 * Both selectors.ts (reference implementation) and injector.ts (browser runtime)
 * should derive their configuration from here.
 *
 * When modifying selector behavior:
 * 1. Update constants here
 * 2. If adding new patterns, update both selectors.ts and injector.ts implementations
 * 3. Add tests in tests/unit/recording/selector-config.test.ts
 *
 * IMPORTANT: Values in this file must be serializable for browser injection.
 * Use string patterns that can be converted to RegExp, not RegExp objects directly.
 */

/**
 * Selector strategy types in order of preference (highest confidence first).
 */
export const SELECTOR_STRATEGIES = [
  'data-testid',
  'id',
  'aria',
  'text',
  'data-attr',
  'css',
  'xpath',
] as const;

export type SelectorStrategyType = (typeof SELECTOR_STRATEGIES)[number];

/**
 * Test ID attribute names to check, in order of preference.
 * These attributes are considered explicit test hooks with highest confidence.
 */
export const TEST_ID_ATTRIBUTES = [
  'data-testid',
  'data-test-id',
  'data-test',
  'data-cy',
  'data-qa',
] as const;

/**
 * Patterns for CSS classes that should be filtered out as unstable.
 * These are typically generated by CSS-in-JS libraries, CSS modules, etc.
 *
 * Stored as string patterns for serialization to browser context.
 * Convert to RegExp using: new RegExp(pattern, flags)
 */
export const UNSTABLE_CLASS_PATTERNS: ReadonlyArray<{ pattern: string; flags: string }> = [
  { pattern: '^css-[a-z0-9]+$', flags: 'i' }, // CSS-in-JS (Emotion, etc.)
  { pattern: '^sc-[a-zA-Z]+$', flags: '' }, // styled-components
  { pattern: '^_[a-zA-Z0-9]+$', flags: '' }, // CSS modules
  { pattern: '^[a-zA-Z]+-[0-9]+$', flags: '' }, // Generic hash patterns
  { pattern: '^jsx-[a-z0-9]+$', flags: 'i' }, // Next.js styled-jsx
  { pattern: '^svelte-[a-z0-9]+$', flags: 'i' }, // Svelte scoped styles
  { pattern: '^v-[a-z0-9]+$', flags: 'i' }, // Vue scoped styles
];

/**
 * Patterns for IDs that appear to be dynamically generated.
 * These get lower confidence scores.
 *
 * Stored as string patterns for serialization to browser context.
 */
export const DYNAMIC_ID_PATTERNS: ReadonlyArray<{ pattern: string; flags: string }> = [
  { pattern: '^[a-f0-9]{8,}$', flags: 'i' }, // Hex hash
  { pattern: '^\\d+$', flags: '' }, // Pure numbers
  { pattern: ':r[0-9]+:', flags: '' }, // React auto IDs
  { pattern: '^:r', flags: '' }, // React 18 useId
  { pattern: '^ember\\d+$', flags: '' }, // Ember
  { pattern: '^___gatsby', flags: '' }, // Gatsby
  { pattern: '_\\d{10,}', flags: '' }, // Timestamp-based
  { pattern: '^[a-z]+_[a-z0-9]{6,}$', flags: 'i' }, // Component_hash pattern
];

/**
 * Semantic class patterns that indicate stable, meaningful class names.
 * These boost confidence for CSS selectors.
 */
export const SEMANTIC_CLASS_PATTERNS: ReadonlyArray<{ pattern: string; flags: string }> = [
  { pattern: '^btn-', flags: '' },
  { pattern: '^button-', flags: '' },
  { pattern: '^nav-', flags: '' },
  { pattern: '^header-', flags: '' },
  { pattern: '^footer-', flags: '' },
  { pattern: '^card-', flags: '' },
  { pattern: '^form-', flags: '' },
  { pattern: '^input-', flags: '' },
  { pattern: '^modal-', flags: '' },
  { pattern: '^sidebar-', flags: '' },
  { pattern: '^menu-', flags: '' },
];

/**
 * HTML tags that commonly have meaningful visible text.
 * Used for tag:has-text() selector generation.
 */
export const TEXT_CONTENT_TAGS = [
  'button',
  'a',
  'span',
  'div',
  'p',
  'h1',
  'h2',
  'h3',
  'h4',
  'h5',
  'h6',
  'label',
  'li',
  'td',
  'th',
] as const;

/**
 * Interesting attributes to include in element metadata.
 */
export const RELEVANT_ATTRIBUTES = [
  'type',
  'name',
  'placeholder',
  'title',
  'alt',
  'href',
  'src',
  'value',
  'for',
  'action',
  'method',
  'role',
  'aria-label',
] as const;

/**
 * Default configuration values for selector generation.
 */
export const SELECTOR_DEFAULTS = {
  /** Maximum depth for CSS path traversal */
  maxCssDepth: 5,

  /** Whether to include XPath as fallback strategy */
  includeXPath: true,

  /** Whether to prefer data-testid selectors */
  preferTestIds: true,

  /** Minimum confidence threshold to include a candidate */
  minConfidence: 0.3,

  /** Maximum text length to use in selectors */
  maxTextLength: 100,

  /** Maximum text length for selector text content */
  selectorTextMaxLength: 30,

  /** Minimum text length to consider for text-based selectors */
  minTextLength: 3,

  /** Maximum text length to consider for text-based selectors */
  maxTextLengthForSelector: 50,
} as const;

/**
 * Confidence scores for different selector strategies.
 * Higher scores indicate more stable, reliable selectors.
 */
export const CONFIDENCE_SCORES = {
  /** data-testid attribute - explicitly stable */
  dataTestId: 0.98,

  /** Unique ID - very stable unless dynamic */
  id: 0.95,

  /** Dynamic ID - less stable */
  idDynamic: 0.6,

  /** ARIA label - semantically stable */
  ariaLabel: 0.85,

  /** ARIA labelledby */
  ariaLabelledby: 0.8,

  /** ARIA describedby */
  ariaDescribedby: 0.75,

  /** Other data attributes */
  dataAttr: 0.7,

  /** CSS path baseline */
  cssPath: 0.65,

  /** CSS with nth-child (less stable) */
  cssNthChild: 0.5,

  /** Text-based selector (longer text) */
  textLong: 0.6,

  /** Text-based selector (shorter text) */
  textShort: 0.55,

  /** XPath text-based */
  xpathText: 0.55,

  /** XPath positional */
  xpathPositional: 0.4,
} as const;

/**
 * Specificity scores for selector ranking.
 * Higher scores indicate more specific selectors.
 */
export const SPECIFICITY_SCORES = {
  dataTestId: 100,
  id: 95,
  ariaLabel: 80,
  ariaLabelledby: 75,
  ariaDescribedby: 70,
  dataAttr: 65,
  cssPath: 60,
  text: 50,
  cssNthChild: 40,
  xpathText: 35,
  xpathPositional: 25,
} as const;

/**
 * Debounce timings for recording event capture (ms).
 */
export const RECORDING_DEBOUNCE = {
  /** Debounce for input events to batch keystrokes */
  input: 500,

  /** Debounce for scroll events */
  scroll: 150,

  /** Debounce for resize events */
  resize: 200,
} as const;

/**
 * Convert string pattern definitions to RegExp objects.
 * Used by Node.js code (selectors.ts, types.ts).
 */
export function patternsToRegExp(
  patterns: ReadonlyArray<{ pattern: string; flags: string }>
): RegExp[] {
  return patterns.map((p) => new RegExp(p.pattern, p.flags));
}

/**
 * Get unstable class patterns as RegExp objects.
 */
export function getUnstableClassPatterns(): RegExp[] {
  return patternsToRegExp(UNSTABLE_CLASS_PATTERNS);
}

/**
 * Get dynamic ID patterns as RegExp objects.
 */
export function getDynamicIdPatterns(): RegExp[] {
  return patternsToRegExp(DYNAMIC_ID_PATTERNS);
}

/**
 * Get semantic class patterns as RegExp objects.
 */
export function getSemanticClassPatterns(): RegExp[] {
  return patternsToRegExp(SEMANTIC_CLASS_PATTERNS);
}

/**
 * Serialize configuration for browser injection.
 * Returns a JavaScript string that can be injected into page context.
 */
export function serializeConfigForBrowser(): string {
  return `{
  TEST_ID_ATTRIBUTES: ${JSON.stringify(TEST_ID_ATTRIBUTES)},
  UNSTABLE_CLASS_PATTERNS: [
    ${UNSTABLE_CLASS_PATTERNS.map((p) => `new RegExp(${JSON.stringify(p.pattern)}, ${JSON.stringify(p.flags)})`).join(',\n    ')}
  ],
  DYNAMIC_ID_PATTERNS: [
    ${DYNAMIC_ID_PATTERNS.map((p) => `new RegExp(${JSON.stringify(p.pattern)}, ${JSON.stringify(p.flags)})`).join(',\n    ')}
  ],
  SEMANTIC_CLASS_PATTERNS: [
    ${SEMANTIC_CLASS_PATTERNS.map((p) => `new RegExp(${JSON.stringify(p.pattern)}, ${JSON.stringify(p.flags)})`).join(',\n    ')}
  ],
  TEXT_CONTENT_TAGS: ${JSON.stringify(TEXT_CONTENT_TAGS)},
  SELECTOR_DEFAULTS: ${JSON.stringify(SELECTOR_DEFAULTS)},
  CONFIDENCE_SCORES: ${JSON.stringify(CONFIDENCE_SCORES)},
  SPECIFICITY_SCORES: ${JSON.stringify(SPECIFICITY_SCORES)},
  RECORDING_DEBOUNCE: ${JSON.stringify(RECORDING_DEBOUNCE)}
}`;
}
