#!/bin/bash

# Vrooli Ascension CLI
# Visual browser automation with AI-powered workflow builder

set -e

if command -v readlink >/dev/null 2>&1; then
    SCRIPT_PATH="$(readlink -f "${BASH_SOURCE[0]}")"
else
    SCRIPT_PATH="${BASH_SOURCE[0]}"
fi
SCRIPT_DIR="$(cd "$(dirname "${SCRIPT_PATH}")" && pwd)"
SCENARIO_ROOT="$(cd "${SCRIPT_DIR}/.." && pwd)"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

resolve_api_url() {
    local resolved_port="${API_PORT:-}"
    if [ -z "$resolved_port" ] && [ -z "${BROWSER_AUTOMATION_API_URL:-}" ]; then
        if command -v vrooli >/dev/null 2>&1; then
            resolved_port=$(vrooli scenario port browser-automation-studio API_PORT 2>/dev/null || true)
        fi
    fi

    if [ -n "$resolved_port" ]; then
        API_PORT="$resolved_port"
        API_HOST="${API_HOST:-localhost}"
        API_URL="http://${API_HOST}:${API_PORT}/api/v1"
    elif [ -n "${BROWSER_AUTOMATION_API_URL:-}" ]; then
        API_URL="${BROWSER_AUTOMATION_API_URL}"
    else
        echo -e "${RED}Error: API_PORT environment variable is required${NC}"
        echo "Use 'vrooli scenario start browser-automation-studio' or set BROWSER_AUTOMATION_API_URL"
        exit 1
    fi
}

resolve_api_url

TIMELINE_SUMMARY_FILTER=$(cat <<'JQ'
.frames
| sort_by(.step_index // 0)
| to_entries
| .[]
| .value as $frame
| ($frame.step_index // 0) + 1 as $number
| ($frame.step_type // "step") as $type
| ($frame.status // "unknown") as $status
| ($frame.success == true) as $success
| ($frame.duration_ms // 0) as $duration
| ($frame.total_duration_ms // 0) as $total
| (($frame.highlight_regions // []) | length) as $highlights
| (($frame.mask_regions // []) | length) as $masks
| ($frame.console_log_count // 0) as $console
| ($frame.network_event_count // 0) as $network
| ($frame.focused_element.selector // "") as $focus
| ($frame.screenshot != null and $frame.screenshot != {}) as $hasShot
| ($frame.final_url // "") as $url
| ($frame.error // "") as $error
| ($frame.assertion // {}) as $assert
| ($assert.success // true) as $assertSuccess
| ($assert.selector // ($assert.mode // "")) as $assertLabel
| ($assert.message // "") as $assertMessage
| ($frame.retry_attempt // 0) as $retryAttempt
| ($frame.retry_max_attempts // 0) as $retryMax
| "\($number). \($type) [\($status)] \(if $success then \"‚úì\" else \"‚úó\" end) - \($duration)ms\(if ($total > 0 and $total != $duration) then \" (total \($total)ms)\" else \"\" end) - console: \($console) network: \($network)\(if $hasShot then \" - screenshot\" else \"\" end)\(if $focus != \"\" then \" - focus: \($focus)\" else \"\" end)\(if $highlights > 0 then \" - highlights: \($highlights)\" else \"\" end)\(if $masks > 0 then \" - masks: \($masks)\" else \"\" end)\(if $url != \"\" then \" - url: \($url)\" else \"\" end)\(if $error != \"\" then \" - error: \($error)\" else \"\" end)\(if $retryAttempt > 1 then \" - retry: \($retryAttempt)\" + (if $retryMax > 0 then \"/\($retryMax)\" else \"\" end) else \"\" end)\(if $assertLabel != \"\" then \" - assertion: \($assertLabel)\" + (if $assertSuccess then \" (ok)\" else \" (failed)\" end) + (if (!$assertSuccess and $assertMessage != \"\") then \" - \($assertMessage)\" else \"\" end) else \"\" end)"
JQ
)

EXECUTION_LIST_FILTER=$(cat <<'JQ'
if (.executions // []) | length > 0 then
  .executions[] | "  üìä \(.id // \"unknown\") [\(.status // \"unknown\")] - " + ((.started_at // \"\") | split("T")[0])
else
  empty
end
JQ
)

show_help() {
    cat << EOF
Vrooli Ascension - Visual Workflow Builder CLI

USAGE:
    browser-automation-studio <command> [arguments] [flags]

COMMANDS:
    status                    Show operational status and resource health
    playbooks order           Show registry-defined execution order/reset summary
    playbooks scaffold        Scaffold a new workflow JSON in test/playbooks/
    playbooks verify          Validate playbook folder prefixes/order metadata
    workflow create          Create a workflow from file or AI prompt
    workflow execute         Execute a workflow by ID or name
    workflow lint           Validate workflow JSON files via the API
    workflow list           List all workflows in tree structure
    workflow delete         Delete a workflow
    workflow versions list  Show saved versions for a workflow
    workflow versions get   Inspect a specific workflow version
    workflow versions restore  Restore a workflow to a saved version
    execution watch         Watch live execution with screenshots
    execution list          List all executions
    execution stop          Stop a running execution
    execution export        Generate replay export metadata for an execution
    execution render        Build a marketing-style HTML replay package for an execution
    execution render-video  Generate an MP4/WEBM replay video via the API's Browserless renderer
    recording import        Import a Chrome extension recording archive
    help                    Display this help message
    version                 Show CLI and API version information

WORKFLOW COMMANDS:
    workflow create <name> [flags]
        --folder <path>      Folder path for organization (default: /)
        --from-file <file>   Import from JSON file
        --ai-prompt <text>   Generate from natural language

    workflow lint <files...> [--strict] [--json]
        Validate one or more workflow playbooks via /api/v1/workflows/validate

    workflow execute <workflow> [flags]
        --params <json>      JSON parameters for workflow
        --wait              Wait for completion
        --output-screenshots <dir>  Save screenshots to directory

    workflow list [flags]
        --folder <path>      Filter by folder path
        --json              Output as JSON

    workflow delete <id>
        Delete a workflow by ID

    workflow versions list <workflow-id> [--limit <n>] [--json]
        List saved versions for a workflow

    workflow versions get <workflow-id> <version>
        Show details for a specific workflow version

    workflow versions restore <workflow-id> <version> [--change-description <text>]
        Restore a workflow to a saved version

EXECUTION COMMANDS:
    execution watch <execution-id>
        Watch live execution with real-time updates

    execution list [flags]
        --workflow <id>      Filter by workflow ID
        --status <status>    Filter by status
        --json              Output as JSON

    execution stop <execution-id>
        Stop a running execution

    execution export <execution-id> [--output <file>]
        Generate replay export metadata (JSON). Use --output to save response.

    execution render <execution-id> [--output <dir>] [--overwrite]
    execution render-video <execution-id> [--output <file>] [--format mp4|webm] [--overwrite]
        Generate a standalone HTML replay using captured screenshots and timeline metadata.

RECORDING COMMANDS:
    recording import <archive.zip> [flags]
        --project-id <uuid>     Associate recording with an existing project
        --project-name <name>   Resolve project by name (defaults to demo seed)
        --workflow-id <uuid>    Attach to an existing workflow
        --workflow-name <name>  Create/resolve workflow label for the recording
        --json                  Output raw API response JSON

EXAMPLES:
    # Create a workflow from AI prompt
    browser-automation-studio workflow create "test-flow" \\
        --ai-prompt "Navigate to google.com and search for automation"

    # Execute a workflow and wait for completion
    browser-automation-studio workflow execute "test-flow" --wait

    # List all workflows in JSON format
    browser-automation-studio workflow list --json

    # Watch a live execution
    browser-automation-studio execution watch abc123

    # Generate replay export package and save to file
    browser-automation-studio execution export abc123 --output bas-export.json

EOF
}

show_playbook_order() {
    local scenario_dir="$SCENARIO_ROOT"
    local json_output=false

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --scenario)
                if [ -z "${2:-}" ]; then
                    echo -e "${RED}Error: --scenario requires a path${NC}"
                    return 1
                fi
                scenario_dir="$(cd "${2}" && pwd)"
                shift 2
                ;;
            --json)
                json_output=true
                shift
                ;;
            --help|-h)
                echo "Usage: browser-automation-studio playbooks order [--scenario <dir>] [--json]"
                echo "  --scenario <dir>  Override scenario directory (defaults to CLI parent)"
                echo "  --json            Print the processed playbook list as JSON"
                return 0
                ;;
            *)
                echo -e "${RED}Unknown option: $1${NC}"
                return 1
                ;;
        esac
    done

    local registry_path="$scenario_dir/test/playbooks/registry.json"
    if [ ! -f "$registry_path" ]; then
        echo -e "${RED}Registry not found at ${registry_path}${NC}"
        return 1
    fi

    if [ "$json_output" = true ]; then
        if command -v jq >/dev/null 2>&1; then
            jq '{playbooks: [.playbooks[] | {order, reset: (.reset // "project"), requirements, file, description}]}' "$registry_path"
        else
            cat "$registry_path"
        fi
        return 0
    fi

    if ! command -v jq >/dev/null 2>&1; then
        echo -e "${RED}Error: jq is required to render the playbook order${NC}"
        echo "Install jq or rerun with --json to view the raw registry"
        return 1
    fi

    printf "%-12s %-8s %-4s %s\n" "ORDER" "RESET" "REQ" "PLAYBOOK"
    jq -r '.playbooks[] | [.order, (.reset // "project"), ((.requirements // []) | length), .file, (.description // "")] | @tsv' "$registry_path" | while IFS=$'\t' read -r order reset reqs file desc; do
        if [ -n "$desc" ] && [ "$desc" != "null" ]; then
            printf "%-12s %-8s %-4s %s - %s\n" "$order" "$reset" "$reqs" "$file" "$desc"
        else
            printf "%-12s %-8s %-4s %s\n" "$order" "$reset" "$reqs" "$file"
        fi
    done
}

scaffold_playbook() {
    local scenario_dir="$SCENARIO_ROOT"
    local reset_mode="project"
    local description=""
    local -a positional=()

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --scenario)
                if [ -z "${2:-}" ]; then
                    echo -e "${RED}Error: --scenario requires a path${NC}"
                    return 1
                fi
                scenario_dir="$(cd "${2}" && pwd)"
                shift 2
                ;;
            --reset)
                reset_mode="${2:-}"
                shift 2
                ;;
            --description)
                description="${2:-}"
                shift 2
                ;;
            --help|-h)
                cat <<'EOF'
Usage: browser-automation-studio playbooks scaffold <folder> <name> [--reset <mode>] [--description <text>]

Positional arguments:
  folder   Path under test/playbooks (e.g., capabilities/01-foundation/projects)
  name     Human-friendly workflow name used for metadata/slug

Options:
  --reset <mode>       Reset mode (none|project|global). Defaults to project.
  --description <text> Optional description, defaults to the workflow name.
  --scenario <dir>     Override scenario directory (defaults to CLI root).
EOF
                return 0
                ;;
            --*)
                echo -e "${RED}Unknown option: $1${NC}"
                return 1
                ;;
            *)
                positional+=("$1")
                shift
                ;;
        esac
    done

    if [ ${#positional[@]} -lt 2 ]; then
        echo -e "${RED}Error: provide a folder and workflow name${NC}"
        echo "Example: browser-automation-studio playbooks scaffold capabilities/01-foundation/projects \"Toast visibility\""
        return 1
    fi

    local target_folder="${positional[0]#/}"
    target_folder="${target_folder%/}"
    local workflow_name="${positional[1]}"

    if [[ -z "$target_folder" ]]; then
        echo -e "${RED}Error: folder must not be empty${NC}"
        return 1
    fi
    if [[ "$target_folder" == *"../"* ]] || [[ "$target_folder" == ".." ]] || [[ "$target_folder" == */.. ]] || [[ "$target_folder" == ../* ]]; then
        echo -e "${RED}Error: folder must not contain '..' segments${NC}"
        return 1
    fi

    local normalized_reset
    normalized_reset=$(printf '%s' "$reset_mode" | tr '[:upper:]' '[:lower:]')
    case "$normalized_reset" in
        none|project|global)
            reset_mode="$normalized_reset"
            ;;
        *)
            echo -e "${YELLOW}Warning:${NC} Unknown reset mode '${reset_mode}', defaulting to project"
            reset_mode="project"
            ;;
    esac

    local slug
    slug=$(printf '%s' "$workflow_name" | tr '[:upper:]' '[:lower:]' | sed 's/[^a-z0-9]\{1,\}/-/g; s/^-//; s/-$//')
    if [ -z "$slug" ]; then
        slug="workflow"
    fi

    local base_dir="$scenario_dir/test/playbooks"
    local target_dir="$base_dir/$target_folder"
    local target_file="$target_dir/${slug}.json"

    mkdir -p "$target_dir"
    if [ -e "$target_file" ]; then
        echo -e "${RED}Error:${NC} ${target_file} already exists"
        return 1
    fi

    local template_desc="$workflow_name"
    if [ -n "$description" ]; then
        template_desc="$description"
    fi

    if ! command -v python3 >/dev/null 2>&1; then
        echo -e "${RED}python3 is required to scaffold workflows${NC}"
        return 1
    fi

    local json_payload
    if ! json_payload=$(python3 - "$workflow_name" "$template_desc" "$reset_mode" <<'PY'
import json
import sys

name, desc, reset = sys.argv[1:4]
template = {
    "metadata": {
        "name": name,
        "description": desc,
        "version": 1,
        "reset": reset
    },
    "settings": {
        "executionViewport": {
            "width": 1440,
            "height": 900,
            "preset": "desktop"
        }
    },
    "nodes": [
        {
            "id": "navigate-app",
            "type": "navigate",
            "data": {
                "label": "Open BAS homepage",
                "destinationType": "scenario",
                "scenario": "browser-automation-studio",
                "scenarioPath": "/",
                "waitUntil": "networkidle",
                "timeoutMs": 45000,
                "waitForMs": 2000
            }
        },
        {
            "id": "wait-for-ui",
            "type": "wait",
            "data": {
                "label": "Wait for UI to settle",
                "waitType": "duration",
                "durationMs": 1000
            }
        }
    ],
    "edges": [
        {
            "id": "edge-initial",
            "source": "navigate-app",
            "target": "wait-for-ui",
            "type": "smoothstep"
        }
    ]
}
print(json.dumps(template, indent=2))
PY
); then
        echo -e "${RED}Failed to build workflow template${NC}"
        return 1
    fi

    printf '%s\n' "$json_payload" >"$target_file"
    echo -e "${GREEN}‚úì Created ${target_file}${NC}"
    echo "Next steps:"
    echo "  ‚Ä¢ Edit the JSON to add real nodes and selectors"
    echo "  ‚Ä¢ Link the workflow from requirements/*.json"
    echo "  ‚Ä¢ Regenerate the registry (node scripts/.../build-registry.mjs --scenario ${scenario_dir})"
}

verify_playbook_prefixes() {
    local scenario_dir="$SCENARIO_ROOT"

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --scenario)
                if [ -z "${2:-}" ]; then
                    echo -e "${RED}Error: --scenario requires a path${NC}"
                    return 1
                fi
                scenario_dir="$(cd "${2}" && pwd)"
                shift 2
                ;;
            --help|-h)
                echo "Usage: browser-automation-studio playbooks verify [--scenario <dir>]"
                echo "Checks that every directory under test/playbooks (excluding __*) begins with a two-digit prefix"
                return 0
                ;;
            *)
                echo -e "${RED}Unknown option: $1${NC}"
                return 1
                ;;
        esac
    done

    local base_dir="$scenario_dir/test/playbooks"
    if [ ! -d "$base_dir" ]; then
        echo -e "${RED}Playbooks directory not found at ${base_dir}${NC}"
        return 1
    fi

    local issues=0

    verify_prefix_tree() {
        local root="$1"
        local rel="$2"
        if [ ! -d "$root" ]; then
            return 0
        fi
        local entries=()
        while IFS= read -r -d '' entry; do
            entries+=("$entry")
        done < <(find "$root" -maxdepth 1 -mindepth 1 -type d ! -name '__*' -printf '%f\0' | sort -z)

        local name
        for name in "${entries[@]}"; do
            [ -z "$name" ] && continue
            local full_path="$root/$name"
            if [[ ! "$name" =~ ^[0-9]{2}- ]]; then
                echo -e "${YELLOW}‚ö† ${rel}${name}${NC} is missing a two-digit prefix"
                issues=$((issues + 1))
            fi
            verify_prefix_tree "$full_path" "${rel}${name}/"
        done
    }

    verify_prefix_tree "$base_dir/capabilities" "capabilities/"
    verify_prefix_tree "$base_dir/journeys" "journeys/"

    if [ "$issues" -eq 0 ]; then
        echo -e "${GREEN}‚úì All playbook folders include numeric prefixes${NC}"
        return 0
    fi

    echo -e "${RED}${issues} folder(s) missing numeric prefixes${NC}"
    return 1
}

check_api_health() {
    if ! curl -s "${API_URL%/api/v1}/health" > /dev/null 2>&1; then
        echo -e "${RED}Error: API server is not responding at ${API_URL%/api/v1}${NC}"
        echo "Please ensure the browser-automation-studio API is running"
        exit 1
    fi
}

show_status() {
    local json_output=false

    # Parse flags
    while [[ $# -gt 0 ]]; do
        case $1 in
            --json)
                json_output=true
                shift
                ;;
            *)
                echo -e "${RED}Unknown option: $1${NC}" >&2
                exit 1
                ;;
        esac
    done

    # Check API health
    local api_running=false
    if curl -s "${API_URL%/api/v1}/health" > /dev/null 2>&1; then
        api_running=true
    fi

    # Check browserless
    local browserless_status="not_installed"
    if command -v resource-browserless &> /dev/null; then
        if resource-browserless status 2>/dev/null | grep -q "running"; then
            browserless_status="running"
        else
            browserless_status="stopped"
        fi
    fi

    # Get workflow count
    local workflow_count=0
    if [ "$api_running" = true ]; then
        workflow_count=$(curl -s "${API_URL}/workflows" 2>/dev/null | grep -o '"id"' | wc -l || echo "0")
    fi

    if [ "$json_output" = true ]; then
        # Output as JSON
        cat << EOF
{
  "api_server": {
    "running": $api_running,
    "url": "${API_URL}"
  },
  "browserless": {
    "status": "${browserless_status}"
  },
  "workflows": {
    "count": ${workflow_count}
  }
}
EOF
    else
        # Human-readable output
        echo -e "${BLUE}Vrooli Ascension Status${NC}"
        echo "================================"

        if [ "$api_running" = true ]; then
            echo -e "API Server: ${GREEN}‚úì Running${NC}"
        else
            echo -e "API Server: ${RED}‚úó Not responding${NC}"
        fi

        case "$browserless_status" in
            running)
                echo -e "Browserless: ${GREEN}‚úì Available${NC}"
                ;;
            stopped)
                echo -e "Browserless: ${YELLOW}‚ö† Not running${NC}"
                ;;
            *)
                echo -e "Browserless: ${RED}‚úó Not installed${NC}"
                ;;
        esac

        echo -e "Workflows: ${workflow_count}"

        echo ""
        echo -e "${GREEN}Ready for automation!${NC}"
    fi
}

create_workflow() {
    local name="$1"

    # Validate required name argument
    if [ -z "$name" ] || [[ "$name" == --* ]]; then
        echo -e "${RED}Error: Workflow name is required${NC}"
        echo "Usage: browser-automation-studio workflow create <name> [options]"
        exit 1
    fi

    shift

    local folder="/"
    local from_file=""
    local ai_prompt=""

    while [[ $# -gt 0 ]]; do
        case $1 in
            --folder)
                folder="$2"
                shift 2
                ;;
            --from-file)
                from_file="$2"
                shift 2
                ;;
            --ai-prompt)
                ai_prompt="$2"
                shift 2
                ;;
            *)
                echo -e "${RED}Unknown option: $1${NC}"
                exit 1
                ;;
        esac
    done
    
    local json_payload="{\"name\": \"$name\", \"folder_path\": \"$folder\""
    
    if [ -n "$from_file" ]; then
        if [ ! -f "$from_file" ]; then
            echo -e "${RED}File not found: $from_file${NC}"
            exit 1
        fi
        local flow_def=$(cat "$from_file")
        json_payload="$json_payload, \"flow_definition\": $flow_def"
    elif [ -n "$ai_prompt" ]; then
        json_payload="$json_payload, \"ai_prompt\": \"$ai_prompt\""
    fi
    
    json_payload="$json_payload}"
    
    echo -e "${BLUE}Creating workflow: $name${NC}"
    
    response=$(curl -s -X POST \
        -H "Content-Type: application/json" \
        -d "$json_payload" \
        "${API_URL}/workflows/create")
    
    if echo "$response" | grep -q "workflow_id"; then
        workflow_id=$(echo "$response" | grep -o '"workflow_id":"[^"]*' | cut -d'"' -f4)
        echo -e "${GREEN}‚úì Workflow created successfully!${NC}"
        echo "Workflow ID: $workflow_id"
        echo "Folder: $folder"
        
        if [ -n "$ai_prompt" ]; then
            echo -e "${YELLOW}AI generated workflow from prompt${NC}"
        fi
    else
        echo -e "${RED}Failed to create workflow${NC}"
        echo "$response"
        exit 1
    fi
}

execute_workflow() {
    local workflow="$1"

    # Validate required workflow argument
    if [ -z "$workflow" ] || [[ "$workflow" == --* ]]; then
        echo -e "${RED}Error: Workflow ID or name is required${NC}"
        echo "Usage: browser-automation-studio workflow execute <workflow> [options]"
        exit 1
    fi

    shift

    local params="{}"
    local wait=false
    local output_dir=""

    while [[ $# -gt 0 ]]; do
        case $1 in
            --params)
                params="$2"
                shift 2
                ;;
            --wait)
                wait=true
                shift
                ;;
            --output-screenshots)
                output_dir="$2"
                shift 2
                ;;
            *)
                echo -e "${RED}Unknown option: $1${NC}"
                exit 1
                ;;
        esac
    done
    
    echo -e "${BLUE}Executing workflow: $workflow${NC}"
    
    response=$(curl -s -X POST \
        -H "Content-Type: application/json" \
        -d "{\"parameters\": $params, \"wait_for_completion\": $wait}" \
        "${API_URL}/workflows/$workflow/execute")
    
    if echo "$response" | grep -q "execution_id"; then
        execution_id=$(echo "$response" | grep -o '"execution_id":"[^"]*' | cut -d'"' -f4)
        echo -e "${GREEN}‚úì Execution started!${NC}"
        echo "Execution ID: $execution_id"
        
        if [ "$wait" = true ]; then
            echo "Waiting for completion..."
            # Poll for completion status
            max_attempts=60  # 5 minutes max
            attempt=1
            
            while [ $attempt -le $max_attempts ]; do
                status_response=$(curl -s "${API_URL}/executions/${execution_id}")
                status=$(echo "$status_response" | grep -o '"status":"[^"]*' | cut -d'"' -f4)
                
                if [ "$status" = "completed" ]; then
                    echo -e "${GREEN}‚úì Execution completed successfully${NC}"
                    break
                elif [ "$status" = "failed" ]; then
                    echo -e "${RED}‚úó Execution failed${NC}"
                    error=$(echo "$status_response" | grep -o '"error":"[^"]*' | cut -d'"' -f4)
                    if [ -n "$error" ]; then
                        echo "Error: $error"
                    fi
                    break
                fi
                
                echo -n "."
                sleep 5
                attempt=$((attempt + 1))
            done
            
            if [ $attempt -gt $max_attempts ]; then
                echo -e "${YELLOW}‚ö† Timeout waiting for execution completion${NC}"
            fi
        fi
        
        if [ -n "$output_dir" ]; then
            mkdir -p "$output_dir"
            echo "Screenshots saved to: $output_dir"
        fi
    else
        echo -e "${RED}Failed to start execution${NC}"
        echo "$response"
        exit 1
    fi
}

import_recording() {
    if [ $# -eq 0 ]; then
        echo -e "${RED}Error: Recording archive path is required${NC}"
        echo "Usage: browser-automation-studio recording import <file.zip> [options]"
        echo "Options:"
        echo "  --project-id <uuid>"
        echo "  --project-name <name>"
        echo "  --workflow-id <uuid>"
        echo "  --workflow-name <name>"
        echo "  --json"
        exit 1
    fi

    local file_path=""
    local project_id=""
    local project_name=""
    local workflow_id=""
    local workflow_name=""
    local json_output=false

    while [[ $# -gt 0 ]]; do
        case $1 in
            --project-id)
                project_id="$2"
                shift 2
                ;;
            --project-name)
                project_name="$2"
                shift 2
                ;;
            --workflow-id)
                workflow_id="$2"
                shift 2
                ;;
            --workflow-name)
                workflow_name="$2"
                shift 2
                ;;
            --json)
                json_output=true
                shift
                ;;
            --*)
                echo -e "${RED}Unknown option: $1${NC}"
                exit 1
                ;;
            *)
                if [ -z "$file_path" ]; then
                    file_path="$1"
                else
                    echo -e "${RED}Unexpected argument: $1${NC}"
                    exit 1
                fi
                shift
                ;;
        esac
    done

    if [ -z "$file_path" ]; then
        echo -e "${RED}Error: Recording archive path is required${NC}"
        exit 1
    fi

    if [ ! -f "$file_path" ]; then
        echo -e "${RED}Error:${NC} Recording archive not found at ${file_path}"
        exit 1
    fi

    check_api_health

    local response_file
    response_file=$(mktemp)

    local curl_args=(-s -o "$response_file" -w "%{http_code}" -X POST "${API_URL}/recordings/import" -H "Accept: application/json" -F "file=@${file_path}")
    if [ -n "$project_id" ]; then
        curl_args+=(-F "project_id=${project_id}")
    fi
    if [ -n "$project_name" ]; then
        curl_args+=(-F "project_name=${project_name}")
    fi
    if [ -n "$workflow_id" ]; then
        curl_args+=(-F "workflow_id=${workflow_id}")
    fi
    if [ -n "$workflow_name" ]; then
        curl_args+=(-F "workflow_name=${workflow_name}")
    fi

    set +e
    local status_code
    status_code=$(curl "${curl_args[@]}")
    local curl_exit=$?
    set -e

    if [ "$curl_exit" -ne 0 ]; then
        rm -f "$response_file"
        echo -e "${RED}Error:${NC} Failed to reach the API for recording import"
        exit 1
    fi

    local body
    body=$(cat "$response_file")
    rm -f "$response_file"

    if [[ ! "$status_code" =~ ^2 ]]; then
        if command -v jq >/dev/null 2>&1; then
            local message
            message=$(printf '%s' "$body" | jq -r '.message // .error // empty' 2>/dev/null)
            if [ -n "$message" ]; then
                echo -e "${RED}Import failed:${NC} ${message}"
            else
                echo -e "${RED}Import failed:${NC} ${body}"
            fi
        else
            echo -e "${RED}Import failed:${NC} ${body}"
        fi
        exit 1
    fi

    if [ "$json_output" = true ]; then
        printf '%s\n' "$body"
        return
    fi

    if command -v jq >/dev/null 2>&1; then
        local execution_id workflow_label frame_count asset_count
        execution_id=$(printf '%s' "$body" | jq -r '.execution_id // empty' 2>/dev/null)
        workflow_label=$(printf '%s' "$body" | jq -r '.workflow_name // empty' 2>/dev/null)
        frame_count=$(printf '%s' "$body" | jq -r '.frame_count // empty' 2>/dev/null)
        asset_count=$(printf '%s' "$body" | jq -r '.asset_count // empty' 2>/dev/null)
        echo -e "${GREEN}‚úì Recording imported${NC}"
        [ -n "$workflow_label" ] && echo "Workflow: ${workflow_label}"
        [ -n "$execution_id" ] && echo "Execution ID: ${execution_id}"
        if [ -n "$frame_count" ] || [ -n "$asset_count" ]; then
            echo "Frames: ${frame_count:-?}, Assets: ${asset_count:-?}"
        fi
    else
        echo -e "${GREEN}‚úì Recording imported${NC}"
        echo "$body"
    fi
}

list_workflows() {
    local folder=""
    local json_output=false
    
    while [[ $# -gt 0 ]]; do
        case $1 in
            --folder)
                folder="$2"
                shift 2
                ;;
            --json)
                json_output=true
                shift
                ;;
            *)
                echo -e "${RED}Unknown option: $1${NC}"
                exit 1
                ;;
        esac
    done
    
    response=$(curl -s "${API_URL}/workflows")
    
    if [ "$json_output" = true ]; then
        echo "$response"
    else
        echo -e "${BLUE}Workflows${NC}"
        echo "========="
        
        if echo "$response" | grep -q '"workflows"'; then
            # Parse and display workflows with folder organization
            echo "$response" | grep -o '"name":"[^"]*\|"folder_path":"[^"]*\|"created_at":"[^"]*' | \
            awk 'BEGIN{print ""} 
                 /name/{name=$0; gsub(/.*"name":"/, "", name); gsub(/".*/, "", name)} 
                 /folder_path/{folder=$0; gsub(/.*"folder_path":"/, "", folder); gsub(/".*/, "", folder)} 
                 /created_at/{created=$0; gsub(/.*"created_at":"/, "", created); gsub(/T.*/, "", created); 
                           printf "  üìÅ %s (%s) - %s\n", name, folder, created}'
        else
            echo "No workflows found"
        fi
    fi
}

lint_workflows_cli() {
    if [ $# -eq 0 ]; then
        echo "Usage: browser-automation-studio workflow lint <files...> [--strict] [--json]" >&2
        return 1
    fi

    if ! command -v jq >/dev/null 2>&1; then
        echo -e "${RED}jq is required for workflow linting${NC}" >&2
        return 1
    fi

    local strict=false
    local json_output=false
    local -a files=()

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --strict)
                strict=true
                shift
                ;;
            --json)
                json_output=true
                shift
                ;;
            -h|--help)
                echo "Usage: browser-automation-studio workflow lint <files...> [--strict] [--json]" >&2
                return 0
                ;;
            --)
                shift
                while [[ $# -gt 0 ]]; do
                    files+=("$1")
                    shift
                done
                ;;
            *)
                files+=("$1")
                shift
                ;;
        esac
    done

    if [ ${#files[@]} -eq 0 ]; then
        echo "Provide one or more workflow JSON files" >&2
        return 1
    fi

    local strict_value=false
    [ "$strict" = true ] && strict_value=true

    local lint_failed=0
    local -a json_results=()

    for file_path in "${files[@]}"; do
        if [ ! -f "$file_path" ]; then
            if [ "$json_output" = true ]; then
                json_results+=("$(jq -n --arg file "$file_path" --arg error "file not found" '{file:$file,error:$error}')")
            else
                echo -e "${RED}‚úó ${file_path}${NC}"
                echo "  File not found"
            fi
            lint_failed=1
            continue
        fi

        local payload
        if ! payload=$(jq -cs --argjson strict "$strict_value" '{workflow: .[0], strict: $strict}' "$file_path" 2>/dev/null); then
            if [ "$json_output" = true ]; then
                json_results+=("$(jq -n --arg file "$file_path" --arg error "invalid JSON" '{file:$file,error:$error}')")
            else
                echo -e "${RED}‚úó ${file_path}${NC}"
                echo "  Invalid JSON"
            fi
            lint_failed=1
            continue
        fi

        local response_file
        response_file=$(mktemp)
        local curl_status curl_rc=0
        curl_status=$(curl -s -o "$response_file" -w "%{http_code}" -X POST -H 'Content-Type: application/json' -d "$payload" "${API_URL}/workflows/validate") || curl_rc=$?

        if [ "$curl_rc" -ne 0 ]; then
            if [ "$json_output" = true ]; then
                json_results+=("$(jq -n --arg file "$file_path" --arg error "curl exit $curl_rc" '{file:$file,error:$error}')")
            else
                echo -e "${RED}‚úó ${file_path}${NC}"
                echo "  Failed to contact API (curl exit $curl_rc)"
            fi
            rm -f "$response_file"
            lint_failed=1
            continue
        fi

        if [ "$curl_status" != "200" ]; then
            local detail
            detail=$(jq -r '.message // .error // empty' "$response_file" 2>/dev/null)
            if [ -z "$detail" ]; then
                detail="HTTP $curl_status"
            fi
            if [ "$json_output" = true ]; then
                json_results+=("$(jq -n --arg file "$file_path" --arg status "$curl_status" --arg error "$detail" '{file:$file, status:$status, error:$error}')")
            else
                echo -e "${RED}‚úó ${file_path}${NC}"
                echo "  ${detail}"
            fi
            lint_failed=1
            rm -f "$response_file"
            continue
        fi

        local valid
        valid=$(jq -r '.valid // false' "$response_file" 2>/dev/null)
        local node_count edge_count
        node_count=$(jq -r '.stats.node_count // 0' "$response_file" 2>/dev/null)
        edge_count=$(jq -r '.stats.edge_count // 0' "$response_file" 2>/dev/null)

        if [ "$json_output" = true ]; then
            json_results+=("$(jq -c --arg file "$file_path" '. + {file: $file}' "$response_file")")
        else
            if [ "$valid" = "true" ]; then
                echo -e "${GREEN}‚úì ${file_path}${NC} (${node_count} nodes, ${edge_count} edges)"
            else
                echo -e "${RED}‚úó ${file_path}${NC} (${node_count} nodes, ${edge_count} edges)"
            fi

            jq -r '.errors[]? | "  [" + (.code // "error") + "] " + (.message // "") + (if .node_id then " (node: " + .node_id + ")" else "" end) + (if .pointer then " @ " + .pointer else "" end)' "$response_file"
            jq -r '.warnings[]? | "  [warn:" + (.code // "warning") + "] " + (.message // "") + (if .node_id then " (node: " + .node_id + ")" else "" end) + (if .pointer then " @ " + .pointer else "" end)' "$response_file"
        fi

        if [ "$valid" != "true" ]; then
            lint_failed=1
        fi

        rm -f "$response_file"
    done

    if [ "$json_output" = true ]; then
        if [ ${#json_results[@]} -eq 0 ]; then
            echo '{"results":[]}'
        else
            printf '%s\n' "${json_results[@]}" | jq -cs '{results: .}'
        fi
    fi

    return $lint_failed
}

list_workflow_versions() {
    local workflow_id="$1"
    shift || true

    if [ -z "$workflow_id" ]; then
        echo -e "${RED}Workflow ID is required${NC}"
        echo "Usage: browser-automation-studio workflow versions list <workflow-id> [--limit <n>] [--json]"
        exit 1
    fi

    local limit=50
    local json_output=false

    while [[ $# -gt 0 ]]; do
        case $1 in
            --limit)
                limit="$2"
                shift 2
                ;;
            --json)
                json_output=true
                shift
                ;;
            *)
                echo -e "${RED}Unknown option: $1${NC}"
                exit 1
                ;;
        esac
    done

    local response status body
    response=$(curl -s -w '\n%{http_code}' "${API_URL}/workflows/${workflow_id}/versions?limit=${limit}")
    status=$(echo "$response" | tail -n1)
    body=$(echo "$response" | sed '$d')

    if [ "$status" != "200" ]; then
        echo -e "${RED}Failed to load workflow versions${NC} (status ${status})"
        echo "$body"
        exit 1
    fi

    if [ "$json_output" = true ]; then
        echo "$body"
        return
    fi

    if command -v jq >/dev/null 2>&1; then
        echo "$body" | jq -r '"Workflow Versions", "=================", (.versions[] | "v\(.version) ‚Ä¢ " + (.change_description // ""))' | sed '3,$s/^v/  v/'
    else
        echo "$body"
    fi
}

get_workflow_version_details() {
    local workflow_id="$1"
    local version="$2"

    if [ -z "$workflow_id" ] || [ -z "$version" ]; then
        echo -e "${RED}Usage:${NC} browser-automation-studio workflow versions get <workflow-id> <version>"
        exit 1
    fi

    local response status body
    response=$(curl -s -w '\n%{http_code}' "${API_URL}/workflows/${workflow_id}/versions/${version}")
    status=$(echo "$response" | tail -n1)
    body=$(echo "$response" | sed '$d')

    if [ "$status" != "200" ]; then
        echo -e "${RED}Failed to load workflow version${NC} (status ${status})"
        echo "$body"
        exit 1
    fi

    if command -v jq >/dev/null 2>&1; then
        echo "$body" | jq
    else
        echo "$body"
    fi
}

restore_workflow_version_cli() {
    local workflow_id="$1"
    local version="$2"
    shift 2 || true

    if [ -z "$workflow_id" ] || [ -z "$version" ]; then
        echo -e "${RED}Usage:${NC} browser-automation-studio workflow versions restore <workflow-id> <version> [--change-description <text>]"
        exit 1
    fi

    local change_description=""

    while [[ $# -gt 0 ]]; do
        case $1 in
            --change-description)
                change_description="$2"
                shift 2
                ;;
            *)
                echo -e "${RED}Unknown option: $1${NC}"
                exit 1
                ;;
        esac
    done

    local payload='{}'
    if [ -n "$change_description" ]; then
        payload=$(python3 - "$change_description" <<'PY'
import json, sys
print(json.dumps({"change_description": sys.argv[1]}))
PY
)
    fi

    local response status body
    response=$(curl -s -w '\n%{http_code}' -X POST -H 'Content-Type: application/json' -d "$payload" "${API_URL}/workflows/${workflow_id}/versions/${version}/restore")
    status=$(echo "$response" | tail -n1)
    body=$(echo "$response" | sed '$d')

    if [ "$status" != "200" ]; then
        echo -e "${RED}Failed to restore workflow version${NC} (status ${status})"
        echo "$body"
        exit 1
    fi

    echo -e "${GREEN}‚úì Workflow restored to version ${version}${NC}"
    if command -v jq >/dev/null 2>&1; then
        echo "$body" | jq '.restored_version | {version, change_description, created_by, created_at}'
    else
        echo "$body"
    fi
}

# Main command router
case "${1:-}" in
    status)
        show_status "${@:2}"
        ;;
    playbooks)
        case "${2:-}" in
            order)
                show_playbook_order "${@:3}"
                ;;
            scaffold)
                scaffold_playbook "${@:3}"
                ;;
            verify)
                verify_playbook_prefixes "${@:3}"
                ;;
            *)
                echo -e "${RED}Unknown playbooks command: ${2:-}${NC}"
                echo "Available subcommands: order, scaffold, verify"
                exit 1
                ;;
        esac
        ;;
    workflow)
        case "${2:-}" in
            create)
                check_api_health
                create_workflow "${@:3}"
                ;;
            execute)
                check_api_health
                execute_workflow "${@:3}"
                ;;
            lint)
                check_api_health
                lint_workflows_cli "${@:3}"
                ;;
            list)
                check_api_health
                list_workflows "${@:3}"
                ;;
            delete)
                check_api_health
                echo -e "${YELLOW}Delete workflow: ${3}${NC}"
                curl -X DELETE "${API_URL}/workflows/${3}"
                echo -e "${GREEN}‚úì Workflow deleted${NC}"
                ;;
            versions)
                check_api_health
                case "${3:-}" in
                    list)
                        list_workflow_versions "${4}" "${@:5}"
                        ;;
                    get)
                        get_workflow_version_details "${4}" "${5}"
                        ;;
                    restore)
                        restore_workflow_version_cli "${4}" "${5}" "${@:6}"
                        ;;
                    *)
                        echo -e "${RED}Unknown workflow versions command: ${3}${NC}"
                        echo "Available subcommands: list, get, restore"
                        exit 1
                        ;;
                esac
                ;;
            *)
                echo -e "${RED}Unknown workflow command: ${2}${NC}"
                show_help
                exit 1
                ;;
        esac
        ;;
    execution)
        case "${2:-}" in
            watch)
                check_api_health
                execution_id="${3}"
                if [ -z "$execution_id" ]; then
                    echo -e "${RED}Error: Execution ID required${NC}"
                    exit 1
                fi

                echo -e "${BLUE}Watching execution: ${execution_id}${NC}"
                echo "Press Ctrl+C to stop watching"
                echo ""

                ws_pid=""
                trap 'if [ -n "${ws_pid}" ]; then kill "${ws_pid}" 2>/dev/null; wait "${ws_pid}" 2>/dev/null; fi; exit 130' INT
                trap 'if [ -n "${ws_pid}" ]; then kill "${ws_pid}" 2>/dev/null; wait "${ws_pid}" 2>/dev/null; fi' TERM EXIT

                if command -v node >/dev/null 2>&1; then
                    ws_base="${API_URL%/api/v1}"
                    if [ -z "$ws_base" ] || [ "$ws_base" = "$API_URL" ]; then
                        ws_base="$API_URL"
                    fi
                    if [[ "$ws_base" == https:* ]]; then
                        ws_endpoint="${ws_base/https:/wss:}"
                    else
                        ws_endpoint="${ws_base/http:/ws:}"
                    fi
                    ws_endpoint="${ws_endpoint%%/}/ws?execution_id=${execution_id}"
                    node - "$ws_endpoint" "$execution_id" <<'NODE' &
const url = process.argv[2];
const executionId = process.argv[3] || '';

if (!url) {
  process.exit(0);
}

if (typeof WebSocket === 'undefined') {
  console.error('[stream] WebSocket API unavailable in this Node runtime.');
  process.exit(0);
}

const ws = new WebSocket(url);

const HEARTBEAT_WARN_MS = 8000;
const HEARTBEAT_STALL_MS = 15000;

let lastHeartbeatAt = Date.now();
let heartbeatInitialized = false;
let heartbeatState = 'init';
let lastHeartbeatStep = '';

const describeStep = () => (lastHeartbeatStep ? ` (${lastHeartbeatStep})` : '');

const notifyState = (state, deltaMs) => {
  const deltaLabel = typeof deltaMs === 'number' && Number.isFinite(deltaMs)
    ? ` (${Math.round(deltaMs / 1000)}s)`
    : '';
  switch (state) {
    case 'awaiting_warn':
      console.log(`[stream] ‚Ä¶ awaiting first heartbeat${deltaLabel}`);
      break;
    case 'awaiting_stalled':
      console.log(`[stream] ‚ö† no heartbeat yet${deltaLabel}`);
      break;
    case 'delayed':
      console.log(`[stream] ‚Ä¶ heartbeat delayed${describeStep()}${deltaLabel}`);
      break;
    case 'stalled':
      console.log(`[stream] ‚ö† heartbeat stalled${describeStep()}${deltaLabel}`);
      break;
    case 'recovered_initial':
      console.log(`[stream] üíì first heartbeat received${describeStep()}`);
      break;
    case 'recovered':
      console.log(`[stream] üíì heartbeat recovered${describeStep()}`);
      break;
    default:
      break;
  }
};

const evaluateHeartbeat = () => {
  const delta = Date.now() - lastHeartbeatAt;
  if (!heartbeatInitialized) {
    if (delta >= HEARTBEAT_STALL_MS) {
      if (heartbeatState !== 'awaiting_stalled') {
        heartbeatState = 'awaiting_stalled';
        notifyState('awaiting_stalled', delta);
      }
    } else if (delta >= HEARTBEAT_WARN_MS) {
      if (heartbeatState !== 'awaiting_warn') {
        heartbeatState = 'awaiting_warn';
        notifyState('awaiting_warn', delta);
      }
    }
    return;
  }

  if (delta >= HEARTBEAT_STALL_MS) {
    if (heartbeatState !== 'stalled') {
      heartbeatState = 'stalled';
      notifyState('stalled', delta);
    }
    return;
  }

  if (delta >= HEARTBEAT_WARN_MS) {
    if (heartbeatState !== 'delayed') {
      heartbeatState = 'delayed';
      notifyState('delayed', delta);
    }
    return;
  }

  heartbeatState = 'healthy';
};

const heartbeatTicker = setInterval(evaluateHeartbeat, 2000);

const labelFor = (event) => {
  if (typeof event.step_node_id === 'string' && event.step_node_id.trim().length > 0) {
    return event.step_node_id;
  }
  if (typeof event.step_type === 'string' && event.step_type.trim().length > 0) {
    return event.step_type;
  }
  if (typeof event.step_index === 'number') {
    return `step ${event.step_index + 1}`;
  }
  return 'step';
};

const summarizeTelemetry = (payload, label) => {
  const consoleLogs = Array.isArray(payload?.console_logs) ? payload.console_logs.length : 0;
  const networkEvents = Array.isArray(payload?.network_events) ? payload.network_events.length : 0;
  if (consoleLogs === 0 && networkEvents === 0) {
    return;
  }
  console.log(`[stream] ‚öô ${label}: console ${consoleLogs}, network ${networkEvents}`);
};

const fmtDuration = (payload) => {
  const direct = payload?.duration_ms ?? payload?.durationMs;
  if (typeof direct === 'number' && Number.isFinite(direct)) {
    return `${direct}ms`;
  }
  return '';
};

ws.onopen = () => {
  const note = executionId ? ` (${executionId})` : '';
  console.log(`[stream] Connected to execution telemetry${note}`);
};

ws.onmessage = (event) => {
  const text = typeof event.data === 'string' ? event.data : '';
  let payload;
  try {
    payload = text ? JSON.parse(text) : null;
  } catch (error) {
    payload = null;
  }

  if (!payload) {
    if (text) {
      console.log(`[stream] ${text}`);
    }
    return;
  }

  if (payload.type === 'event' && payload.data) {
    const evt = payload.data;
    const label = labelFor(evt);
    switch (evt.type) {
      case 'execution.started':
        console.log('[stream] ‚ñ∂ execution started');
        return;
      case 'execution.completed':
        console.log('[stream] ‚úÖ execution completed');
        return;
      case 'execution.failed':
        console.log(`[stream] ‚ùå execution failed${evt.message ? ` - ${evt.message}` : ''}`);
        return;
      case 'execution.cancelled':
        console.log('[stream] ‚èπ execution cancelled');
        return;
      case 'step.started':
        console.log(`[stream] ‚û§ ${label} started`);
        return;
      case 'step.completed':
        console.log(`[stream] ‚úì ${label} completed ${fmtDuration(evt.payload)}`.trim());
        return;
      case 'step.failed':
        console.log(`[stream] ‚úó ${label} failed${evt.message ? ` - ${evt.message}` : ''}`);
        return;
      case 'step.heartbeat': {
        const elapsedMs = typeof evt.payload?.elapsed_ms === 'number' ? evt.payload.elapsed_ms : null;
        const elapsedLabel = elapsedMs !== null ? ` (${Math.round(elapsedMs / 1000)}s)` : '';
        console.log(`[stream] ‚Ä¶ ${label} heartbeat${elapsedLabel}`);
        lastHeartbeatStep = label;
        lastHeartbeatAt = Date.now();
        if (!heartbeatInitialized) {
          heartbeatInitialized = true;
          if (heartbeatState === 'awaiting_warn' || heartbeatState === 'awaiting_stalled') {
            notifyState('recovered_initial');
          }
        } else if (heartbeatState === 'delayed' || heartbeatState === 'stalled') {
          notifyState('recovered');
        }
        heartbeatState = 'healthy';
        return;
      }
      case 'step.screenshot': {
        const shotLabel = evt.payload?.url || evt.payload?.artifact_id ? 'stored' : 'inline';
        console.log(`[stream] üì∏ ${label} screenshot (${shotLabel})`);
        return;
      }
      case 'step.telemetry':
        summarizeTelemetry(evt.payload || {}, label);
        return;
      default:
        return;
    }
  }

  if (payload.type === 'progress') {
    const progress = typeof payload.progress === 'number' ? `${payload.progress}%` : '';
    const currentStep = payload.current_step ? ` - ${payload.current_step}` : '';
    console.log(`[stream] progress ${progress}${currentStep}`.trim());
    return;
  }

  if (payload.type === 'completed') {
    console.log('[stream] ‚úÖ execution completed');
    return;
  }

  if (payload.type === 'failed') {
    console.log(`[stream] ‚ùå execution failed${payload.message ? ` - ${payload.message}` : ''}`);
    return;
  }
};

ws.onerror = (error) => {
  const message = error?.message || String(error);
  console.error(`[stream] WebSocket error: ${message}`);
};

ws.onclose = () => {
  console.log('[stream] Telemetry stream closed');
  clearInterval(heartbeatTicker);
  process.exit(0);
};

const shutdown = () => {
  try {
    ws.close(1000);
  } catch (error) {
    // ignore
  }
  clearInterval(heartbeatTicker);
  setTimeout(() => process.exit(0), 150);
};

process.on('SIGINT', shutdown);
process.on('SIGTERM', shutdown);
NODE
                    ws_pid=$!
                else
                    echo -e "${YELLOW}Node.js not available; streaming telemetry disabled${NC}"
                fi

                # Poll for execution updates
                while true; do
                    # Get current execution status
                    response=$(curl -s "${API_URL}/executions/${execution_id}")
                    if echo "$response" | grep -q '"error"'; then
                        echo -e "${RED}‚úó Execution not found${NC}"
                        break
                    fi
                    
                    status=$(echo "$response" | grep -o '"status":"[^"]*' | cut -d'"' -f4)
                    progress=$(echo "$response" | grep -o '"progress":[0-9]*' | cut -d':' -f2)
                    current_step=$(echo "$response" | grep -o '"current_step":"[^"]*' | cut -d'"' -f4)
                    
                    # Show current status
                    printf "\r\033[K"  # Clear current line
                    printf "${BLUE}Status: ${status} | Progress: ${progress}%% | Step: ${current_step}${NC}"
                    
                    # Check if execution is complete
                    if [ "$status" = "completed" ] || [ "$status" = "failed" ]; then
                        echo ""
                        echo -e "${GREEN}‚úì Execution ${status}${NC}"
                        break
                    fi

                    sleep 2
                done

                if [ -n "$ws_pid" ]; then
                    kill "$ws_pid" 2>/dev/null
                    wait "$ws_pid" 2>/dev/null
                    ws_pid=""
                fi
                trap - INT TERM EXIT

                timeline_response=$(curl -s "${API_URL}/executions/${execution_id}/timeline")
                if [ -n "$timeline_response" ]; then
                    timeline_count=$(echo "$timeline_response" | jq -r "try (.frames | length) catch 'error'" 2>/dev/null)
                    if [ "$timeline_count" != "error" ] && printf '%s' "$timeline_count" | grep -Eq '^[0-9]+$'; then
                        if [ "$timeline_count" -gt 0 ]; then
                            echo ""
                            echo -e "${BLUE}Timeline Summary${NC}"
                            echo "$timeline_response" | jq -r "$TIMELINE_SUMMARY_FILTER"
                        elif [ "$timeline_count" -eq 0 ]; then
                            echo ""
                            echo -e "${YELLOW}No timeline artifacts available for this execution${NC}"
                        else
                            echo ""
                            echo -e "${YELLOW}Unable to parse execution timeline response${NC}"
                        fi
                    else
                        echo ""
                        echo -e "${YELLOW}Unable to parse execution timeline response${NC}"
                    fi
                else
                    echo ""
                    echo -e "${YELLOW}No timeline response received from API${NC}"
                fi
                ;;
            list)
                check_api_health

                # Shift to get arguments after "execution list"
                shift 2

                json_output=false
                workflow_filter=""
                status_filter=""

                # Parse flags
                while [[ $# -gt 0 ]]; do
                    case $1 in
                        --json)
                            json_output=true
                            shift
                            ;;
                        --workflow)
                            workflow_filter="$2"
                            shift 2
                            ;;
                        --status)
                            status_filter="$2"
                            shift 2
                            ;;
                        *)
                            echo -e "${RED}Unknown option: $1${NC}" >&2
                            exit 1
                            ;;
                    esac
                done

                # Build query params
                query_params=""
                if [ -n "$workflow_filter" ]; then
                    query_params="?workflow_id=${workflow_filter}"
                fi
                if [ -n "$status_filter" ]; then
                    if [ -n "$query_params" ]; then
                        query_params="${query_params}&status=${status_filter}"
                    else
                        query_params="?status=${status_filter}"
                    fi
                fi

                response=$(curl -s "${API_URL}/executions${query_params}")

                if [ "$json_output" = true ]; then
                    echo "$response"
                else
                    echo -e "${BLUE}Recent Executions${NC}"
                    echo "=================="

                    formatted=$(echo "$response" | jq -r "$EXECUTION_LIST_FILTER" 2>/dev/null)
                    if [ -n "$formatted" ]; then
                        printf '%s\n' "$formatted"
                    else
                        echo "No executions found"
                    fi
                fi
                ;;
            stop)
                check_api_health

                execution_id="${3}"
                if [ -z "$execution_id" ]; then
                    echo -e "${RED}Error: Execution ID is required${NC}"
                    echo "Usage: browser-automation-studio execution stop <execution-id>"
                    exit 1
                fi

                echo -e "${YELLOW}Stopping execution: ${execution_id}${NC}"
                response=$(curl -s -X POST "${API_URL}/executions/${execution_id}/stop")

                # Check if response indicates error
                if echo "$response" | grep -qi "error\|not found"; then
                    echo -e "${RED}‚úó Failed to stop execution${NC}"
                    echo "$response"
                    exit 1
                else
                    echo -e "${GREEN}‚úì Execution stopped${NC}"
                fi
                ;;
            export)
                check_api_health
                args=("${@:3}")
                execution_id=""
                output_path=""

                i=0
                while [ $i -lt ${#args[@]} ]; do
                    # Parse argument token (not a security credential - just CLI arg parser variable)
                    token="${args[$i]}"
                    case "$token" in
                        --output|--out)
                            next=$((i + 1))
                            if [ $next -ge ${#args[@]} ]; then
                                echo -e "${RED}Error:${NC} --output flag requires a file path"
                                exit 1
                            fi
                            output_path="${args[$next]}"
                            i=$((i + 2))
                            continue
                            ;;
                        --output=*|--out=*)
                            output_path="${token#*=}"
                            ;;
                        --*)
                            echo -e "${RED}Unknown option:${NC} ${token}"
                            exit 1
                            ;;
                        *)
                            if [ -z "$execution_id" ]; then
                                execution_id="$token"
                            else
                                echo -e "${RED}Unexpected argument:${NC} ${token}"
                                exit 1
                            fi
                            ;;
                    esac
                    i=$((i + 1))
                done

                if [ -z "$execution_id" ]; then
                    echo -e "${RED}Execution ID is required${NC}"
                    echo "Usage: browser-automation-studio execution export <execution-id> [--output <file>]"
                    exit 1
                fi

                tmp_file=$(mktemp)
                status_code=$(curl -s -o "$tmp_file" -w "%{http_code}" -X POST "${API_URL}/executions/${execution_id}/export")
                body=$(cat "$tmp_file")
                rm -f "$tmp_file"

                if [ "$status_code" = "404" ]; then
                    echo -e "${RED}‚úó Execution not found${NC}"
                    exit 1
                fi

                if [ "$status_code" != "200" ]; then
                    if command -v jq >/dev/null 2>&1; then
                        message=$(printf '%s' "$body" | jq -r '.message // empty' 2>/dev/null)
                    else
                        message=$(printf '%s' "$body" | grep -o '"message":"[^"]*' | head -n1 | cut -d'"' -f4)
                    fi

                    display_message="$message"
                    if [ -z "$display_message" ]; then
                        display_message="$body"
                    fi

                    printf "%bReceived response status %s:%b %s\n" "$YELLOW" "$status_code" "$NC" "$display_message"
                    exit 1
                fi

                if command -v jq >/dev/null 2>&1; then
                    message=$(printf '%s' "$body" | jq -r '.message // empty' 2>/dev/null)
                    statusLabel=$(printf '%s' "$body" | jq -r '.status // empty' 2>/dev/null)
                    frameCount=$(printf '%s' "$body" | jq -r '.package.summary.frame_count // empty' 2>/dev/null)
                    totalDuration=$(printf '%s' "$body" | jq -r '.package.summary.total_duration_ms // empty' 2>/dev/null)
                    accentColor=$(printf '%s' "$body" | jq -r '.package.theme.accent_color // empty' 2>/dev/null)
                else
                    message=$(printf '%s' "$body" | grep -o '"message":"[^"]*' | head -n1 | cut -d'"' -f4)
                    statusLabel=$(printf '%s' "$body" | grep -o '"status":"[^"]*' | head -n1 | cut -d'"' -f4)
                    frameCount=""
                    totalDuration=""
                    accentColor=""
                fi

                echo -e "${GREEN}‚úì Export ready${NC}: ${message:-Replay export generated}"
                if [ -n "$statusLabel" ]; then
                    echo -e "Status: ${statusLabel}"
                fi
                if [ -n "$frameCount" ] || [ -n "$totalDuration" ]; then
                    frameLabel=${frameCount:-"?"}
                    durationLabel=${totalDuration:-"?"}
                    echo -e "Frames: ${frameLabel}, Total Duration: ${durationLabel}ms"
                fi
                if [ -n "$accentColor" ]; then
                    echo -e "Theme Accent: ${accentColor}"
                fi

                if [ -n "$output_path" ]; then
                    mkdir -p "$(dirname "$output_path")" 2>/dev/null || true
                    if printf '%s\n' "$body" > "$output_path"; then
                        echo -e "Saved export package to ${output_path}"
                    else
                        echo -e "${RED}Failed to write export package to${NC} ${output_path}"
                    fi
                else
                    echo -e "Tip: use --output <file> to save the export package."
                fi
                ;;
            render)
                check_api_health
                if ! command -v node >/dev/null 2>&1; then
                    echo -e "${RED}Error:${NC} Node.js is required for replay rendering"
                    exit 1
                fi

                args=("${@:3}")
                execution_id=""
                output_dir=""
                overwrite_flag=0

                i=0
                while [ $i -lt ${#args[@]} ]; do
                    token="${args[$i]}"
                    case "$token" in
                        --output|--out|--dir)
                            next=$((i + 1))
                            if [ $next -ge ${#args[@]} ]; then
                                echo -e "${RED}Error:${NC} --output flag requires a directory path"
                                exit 1
                            fi
                            output_dir="${args[$next]}"
                            i=$((i + 2))
                            continue
                            ;;
                        --output=*|--out=*|--dir=*)
                            output_dir="${token#*=}"
                            ;;
                        --overwrite|-f)
                            overwrite_flag=1
                            ;;
                        --*)
                            echo -e "${RED}Unknown option:${NC} ${token}"
                            exit 1
                            ;;
                        *)
                            if [ -z "$execution_id" ]; then
                                execution_id="$token"
                            else
                                echo -e "${RED}Unexpected argument:${NC} ${token}"
                                exit 1
                            fi
                            ;;
                    esac
                    i=$((i + 1))
                done

                if [ -z "$execution_id" ]; then
                    echo -e "${RED}Execution ID is required${NC}"
                    echo "Usage: browser-automation-studio execution render <execution-id> [--output <dir>] [--overwrite]"
                    exit 1
                fi

                tmp_json=$(mktemp)
                status_code=$(curl -s -o "$tmp_json" -w "%{http_code}" -X POST "${API_URL}/executions/${execution_id}/export")
                if [ "$status_code" = "404" ]; then
                    rm -f "$tmp_json"
                    echo -e "${RED}‚úó Execution not found${NC}"
                    exit 1
                fi

                if [ "$status_code" != "200" ]; then
                    error_body=$(cat "$tmp_json")
                    rm -f "$tmp_json"
                    if command -v jq >/dev/null 2>&1; then
                        message=$(printf '%s' "$error_body" | jq -r '.message // empty' 2>/dev/null)
                    else
                        message=$(printf '%s' "$error_body" | grep -o '"message":"[^"]*' | head -n1 | cut -d'"' -f4)
                    fi
                    echo -e "${RED}Failed to generate export:${NC} ${message:-$error_body}"
                    exit 1
                fi

                if [ -z "$output_dir" ]; then
                    output_dir="bas-replay-${execution_id}"
                fi

                renderer="${SCRIPT_DIR}/render-export.js"
                if [ ! -f "$renderer" ]; then
                    rm -f "$tmp_json"
                    echo -e "${RED}Replay renderer script missing:${NC} ${renderer}"
                    exit 1
                fi

                base_url="${API_URL%/api/v1}"

                node_args=("$renderer" --input "$tmp_json" --output "$output_dir" --base-url "$base_url")
                if [ "$overwrite_flag" -eq 1 ]; then
                    node_args+=("--overwrite")
                fi

                if ! node "${node_args[@]}"; then
                    rm -f "$tmp_json"
                    echo -e "${RED}‚úó Failed to render replay${NC}"
                    exit 1
                fi

                rm -f "$tmp_json"
                echo -e "${GREEN}‚úì Replay package ready${NC}: open ${output_dir}/index.html"
                ;;
            render-video)
                check_api_health
                if ! command -v node >/dev/null 2>&1; then
                    echo -e "${RED}Error:${NC} Node.js is required for video rendering"
                    exit 1
                fi
                if ! command -v ffmpeg >/dev/null 2>&1; then
                    echo -e "${RED}Error:${NC} ffmpeg is required for video rendering"
                    exit 1
                fi

                args=("${@:3}")
                execution_id=""
                output_file=""
                format="mp4"
                overwrite_flag=0

                i=0
                while [ $i -lt ${#args[@]} ]; do
                    token="${args[$i]}"
                    case "$token" in
                        --output|--out|--file)
                            next=$((i + 1))
                            if [ $next -ge ${#args[@]} ]; then
                                echo -e "${RED}Error:${NC} --output flag requires a file path"
                                exit 1
                            fi
                            output_file="${args[$next]}"
                            i=$((i + 2))
                            continue
                            ;;
                        --output=*|--out=*|--file=*)
                            output_file="${token#*=}"
                            ;;
                        --format|--video-format)
                            next=$((i + 1))
                            if [ $next -ge ${#args[@]} ]; then
                                echo -e "${RED}Error:${NC} --format flag requires mp4 or webm"
                                exit 1
                            fi
                            format="${args[$next]}"
                            i=$((i + 2))
                            continue
                            ;;
                        --format=*|--video-format=*)
                            format="${token#*=}"
                            ;;
                        --overwrite|-f)
                            overwrite_flag=1
                            ;;
                        --*)
                            echo -e "${RED}Unknown option:${NC} ${token}"
                            exit 1
                            ;;
                        *)
                            if [ -z "$execution_id" ]; then
                                execution_id="$token"
                            else
                                echo -e "${RED}Unexpected argument:${NC} ${token}"
                                exit 1
                            fi
                            ;;
                    esac
                    i=$((i + 1))
                done

                format=$(printf '%s' "$format" | tr '[:upper:]' '[:lower:]')

                if [ -z "$execution_id" ]; then
                    echo -e "${RED}Execution ID is required${NC}"
                    echo "Usage: browser-automation-studio execution render-video <execution-id> [--output <file>] [--format mp4|webm] [--overwrite]"
                    exit 1
                fi

                if [ "$format" != "mp4" ] && [ "$format" != "webm" ]; then
                    echo -e "${RED}Unsupported format:${NC} ${format} - expected mp4 or webm"
                    exit 1
                fi

                tmp_json=$(mktemp)
                status_code=$(curl -s -o "$tmp_json" -w "%{http_code}" -X POST "${API_URL}/executions/${execution_id}/export" \
                    -H 'Content-Type: application/json' \
                    -d '{"format":"json"}')
                if [ "$status_code" = "404" ]; then
                    rm -f "$tmp_json"
                    echo -e "${RED}‚úó Execution not found${NC}"
                    exit 1
                fi

                if [ "$status_code" != "200" ]; then
                    error_body=$(cat "$tmp_json")
                    rm -f "$tmp_json"
                    if command -v jq >/dev/null 2>&1; then
                        message=$(printf '%s' "$error_body" | jq -r '.message // empty' 2>/dev/null)
                    else
                        message=$(printf '%s' "$error_body" | grep -o '"message":"[^"]*' | head -n1 | cut -d'"' -f4)
                    fi
                    echo -e "${RED}Failed to generate export:${NC} ${message:-$error_body}"
                    exit 1
                fi

                if [ -z "$output_file" ]; then
                    output_file="bas-replay-${execution_id}.${format}"
                fi

                if [ -f "$output_file" ] && [ "$overwrite_flag" -eq 0 ]; then
                    rm -f "$tmp_json"
                    echo -e "${RED}Error:${NC} ${output_file} already exists (use --overwrite)"
                    exit 1
                fi

                tmp_video="${output_file}.download"
                accept_header="video/mp4"
                if [ "$format" = "webm" ]; then
                    accept_header="video/webm"
                fi

                render_body=$(printf '{"format":"%s","file_name":"%s"}' "$format" "$(basename "$output_file")")
                status_code=$(curl -s -o "$tmp_video" -w "%{http_code}" -X POST "${API_URL}/executions/${execution_id}/export" \
                    -H 'Content-Type: application/json' \
                    -H "Accept: ${accept_header}" \
                    -d "$render_body")

                rm -f "$tmp_json"

                if [ "$status_code" = "404" ]; then
                    rm -f "$tmp_video"
                    echo -e "${RED}‚úó Execution not found${NC}"
                    exit 1
                fi

                if [ "$status_code" != "200" ]; then
                    error_body=$(cat "$tmp_video")
                    rm -f "$tmp_video"
                    if command -v jq >/dev/null 2>&1; then
                        message=$(printf '%s' "$error_body" | jq -r '.message // empty' 2>/dev/null)
                    else
                        message=$(printf '%s' "$error_body" | grep -o '"message":"[^"]*' | head -n1 | cut -d'"' -f4)
                    fi
                    echo -e "${RED}Failed to render replay:${NC} ${message:-$error_body}"
                    exit 1
                fi

                mv "$tmp_video" "$output_file"
                echo -e "${GREEN}‚úì Replay video ready${NC}: ${output_file}"
                ;;
            *)
                echo -e "${RED}Unknown execution command: ${2}${NC}"
                show_help
                exit 1
                ;;
        esac
        ;;
    recording)
        if [ "$#" -lt 2 ]; then
            echo -e "${RED}Error: recording command requires a subcommand${NC}"
            echo "Available subcommands: import"
            exit 1
        fi

        subcommand="$2"
        shift 2

        case "$subcommand" in
            import)
                import_recording "$@"
                ;;
            *)
                echo -e "${RED}Unknown recording command: ${subcommand}${NC}"
                echo "Available subcommands: import"
                exit 1
                ;;
        esac
        ;;
    version)
        echo "Vrooli Ascension CLI v1.0.0"
        echo "API Version: 1.0.0"
        ;;
    help|--help|-h)
        show_help
        ;;
    *)
        echo -e "${RED}Unknown command: ${1}${NC}"
        show_help
        exit 1
        ;;
esac
