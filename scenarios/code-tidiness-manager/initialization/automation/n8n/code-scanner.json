{
  "name": "Code Scanner Workflow",
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "code-scanner",
        "responseMode": "responseNode",
        "options": {}
      },
      "id": "webhook_trigger",
      "name": "Webhook Trigger",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 1.1,
      "position": [200, 300]
    },
    {
      "parameters": {},
      "id": "manual_trigger",
      "name": "Manual Trigger",
      "type": "n8n-nodes-base.manualTrigger",
      "typeVersion": 1,
      "position": [200, 500]
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// Test defaults for manual trigger\nreturn {\n  paths: ['/home/matthalloran8/Vrooli/scenarios/'],\n  types: ['backup_files', 'temp_files', 'empty_dirs'],\n  deep_scan: false,\n  limit: 100\n};"
      },
      "id": "set_test_defaults",
      "name": "Set Test Defaults",
      "type": "n8n-nodes-base.code",
      "typeVersion": 1,
      "position": [400, 500]
    },
    {
      "parameters": {},
      "id": "merge_triggers",
      "name": "Merge Triggers",
      "type": "n8n-nodes-base.merge",
      "typeVersion": 2.1,
      "position": [600, 400]
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// Validate and prepare scan parameters\nconst input = $input.item.json;\n\n// Extract parameters\nconst paths = Array.isArray(input.paths) ? input.paths : ['/home/matthalloran8/Vrooli/'];\nconst types = Array.isArray(input.types) ? input.types : ['backup_files', 'temp_files'];\nconst deepScan = input.deep_scan === true;\nconst limit = typeof input.limit === 'number' ? input.limit : 1000;\nconst excludePatterns = Array.isArray(input.exclude_patterns) ? input.exclude_patterns : ['node_modules', '.git', 'dist', 'build'];\n\n// Generate scan ID\nconst scanId = 'scan_' + Date.now() + '_' + Math.random().toString(36).substring(2, 8);\n\n// Build find commands for each type\nconst commands = [];\n\nif (types.includes('backup_files')) {\n  commands.push({\n    type: 'backup_files',\n    patterns: ['*.bak', '*~', '*.orig', '*.old'],\n    command: 'find ' + paths.join(' ') + ' -type f \\\\( -name \"*.bak\" -o -name \"*~\" -o -name \"*.orig\" -o -name \"*.old\" \\\\) 2>/dev/null | head -' + limit\n  });\n}\n\nif (types.includes('temp_files')) {\n  commands.push({\n    type: 'temp_files', \n    patterns: ['.*.swp', '.DS_Store', 'Thumbs.db', 'npm-debug.log*'],\n    command: 'find ' + paths.join(' ') + ' -type f \\\\( -name \".*.swp\" -o -name \".DS_Store\" -o -name \"Thumbs.db\" -o -name \"npm-debug.log*\" \\\\) 2>/dev/null | head -' + limit\n  });\n}\n\nif (types.includes('empty_dirs')) {\n  commands.push({\n    type: 'empty_dirs',\n    patterns: ['empty directories'],\n    command: 'find ' + paths.join(' ') + ' -type d -empty 2>/dev/null | head -' + limit\n  });\n}\n\nif (types.includes('large_files')) {\n  commands.push({\n    type: 'large_files',\n    patterns: ['files > 10MB'],\n    command: 'find ' + paths.join(' ') + ' -type f -size +10M 2>/dev/null | head -' + limit\n  });\n}\n\n// Build exclude patterns for find\nlet excludeArgs = '';\nif (excludePatterns.length > 0) {\n  excludeArgs = excludePatterns.map(p => '-path \"*/' + p + '\" -prune -o').join(' ');\n}\n\nreturn {\n  scan_id: scanId,\n  scan_config: {\n    paths: paths,\n    types: types,\n    deep_scan: deepScan,\n    limit: limit,\n    exclude_patterns: excludePatterns\n  },\n  commands: commands,\n  exclude_args: excludeArgs,\n  timestamp: new Date().toISOString()\n};"
      },
      "id": "prepare_scan",
      "name": "Prepare Scan",
      "type": "n8n-nodes-base.code",
      "typeVersion": 1,
      "position": [800, 400]
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// Execute scan commands\nconst scanConfig = $('Prepare Scan').item.json;\nconst results = [];\n\nfor (const cmd of scanConfig.commands) {\n  // Modify command to include excludes if needed\n  let fullCommand = cmd.command;\n  if (scanConfig.exclude_args) {\n    fullCommand = cmd.command.replace('find ', 'find ' + scanConfig.exclude_args + ' ');\n  }\n  \n  // Store command for execution\n  results.push({\n    type: cmd.type,\n    patterns: cmd.patterns,\n    command: fullCommand,\n    scan_id: scanConfig.scan_id\n  });\n}\n\nreturn results;"
      },
      "id": "build_commands",
      "name": "Build Commands",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1000, 400]
    },
    {
      "parameters": {
        "batchSize": 1,
        "options": {}
      },
      "id": "split_batch",
      "name": "Split in Batches",
      "type": "n8n-nodes-base.splitInBatches",
      "typeVersion": 3,
      "position": [1200, 400]
    },
    {
      "parameters": {
        "command": "={{ $json.command }}"
      },
      "id": "execute_scan",
      "name": "Execute Scan",
      "type": "n8n-nodes-base.executeCommand",
      "typeVersion": 1,
      "position": [1400, 400]
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// Process scan results\nconst commandResult = $input.item.json;\nconst scanInfo = $('Split in Batches').item.json;\n\nconst files = commandResult.stdout ? commandResult.stdout.trim().split('\\n').filter(f => f.length > 0) : [];\n\nconst issues = files.map(filePath => {\n  // Determine severity based on file type\n  let severity = 'low';\n  let confidence = 0.95;\n  let safeToAutomate = true;\n  \n  if (filePath.includes('.git') || filePath.includes('node_modules')) {\n    severity = 'low';\n    confidence = 0.80;\n  } else if (filePath.endsWith('.swp') || filePath.endsWith('.DS_Store')) {\n    severity = 'low';\n    confidence = 0.99;\n    safeToAutomate = true;\n  } else if (filePath.endsWith('.bak') || filePath.endsWith('~')) {\n    severity = 'medium';\n    confidence = 0.90;\n  } else if (scanInfo.type === 'large_files') {\n    severity = 'high';\n    confidence = 0.70;\n    safeToAutomate = false;\n  }\n  \n  // Get file size\n  const statCommand = 'stat -f \"%z\" \"' + filePath + '\" 2>/dev/null || stat -c \"%s\" \"' + filePath + '\" 2>/dev/null || echo 0';\n  \n  return {\n    file_path: filePath,\n    issue_type: scanInfo.type,\n    severity: severity,\n    confidence_score: confidence,\n    safe_to_automate: safeToAutomate,\n    cleanup_script: safeToAutomate ? 'rm -f \"' + filePath + '\"' : null,\n    description: 'Found ' + scanInfo.type.replace('_', ' ') + ': ' + filePath\n  };\n});\n\nreturn {\n  scan_id: scanInfo.scan_id,\n  type: scanInfo.type,\n  patterns: scanInfo.patterns,\n  issues_found: issues.length,\n  issues: issues\n};"
      },
      "id": "process_results",
      "name": "Process Results",
      "type": "n8n-nodes-base.code",
      "typeVersion": 1,
      "position": [1600, 400]
    },
    {
      "parameters": {},
      "id": "combine_results",
      "name": "Combine Results",
      "type": "n8n-nodes-base.aggregate",
      "typeVersion": 1,
      "position": [1800, 400]
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// Combine all scan results\nconst allResults = $input.all();\nconst scanConfig = $('Prepare Scan').item.json;\n\nlet totalIssues = 0;\nlet allIssueDetails = [];\nlet resultsByType = {};\n\nfor (const result of allResults) {\n  const data = result.json;\n  totalIssues += data.issues_found;\n  allIssueDetails = allIssueDetails.concat(data.issues);\n  resultsByType[data.type] = {\n    count: data.issues_found,\n    patterns: data.patterns\n  };\n}\n\n// Calculate statistics\nconst stats = {\n  total: totalIssues,\n  by_severity: {\n    critical: allIssueDetails.filter(i => i.severity === 'critical').length,\n    high: allIssueDetails.filter(i => i.severity === 'high').length,\n    medium: allIssueDetails.filter(i => i.severity === 'medium').length,\n    low: allIssueDetails.filter(i => i.severity === 'low').length\n  },\n  automatable: allIssueDetails.filter(i => i.safe_to_automate).length,\n  manual_review: allIssueDetails.filter(i => !i.safe_to_automate).length\n};\n\nreturn {\n  success: true,\n  scan_id: scanConfig.scan_id,\n  scan_config: scanConfig.scan_config,\n  started_at: scanConfig.timestamp,\n  completed_at: new Date().toISOString(),\n  statistics: stats,\n  results_by_type: resultsByType,\n  issues: allIssueDetails.slice(0, 100), // Limit to first 100 for response\n  total_issues: totalIssues\n};"
      },
      "id": "format_final_output",
      "name": "Format Final Output",
      "type": "n8n-nodes-base.code",
      "typeVersion": 1,
      "position": [2000, 400]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ JSON.stringify($json, null, 2) }}",
        "options": {
          "responseCode": 200,
          "responseHeaders": {
            "parameters": [
              {
                "name": "Content-Type",
                "value": "application/json"
              }
            ]
          }
        }
      },
      "id": "respond_to_webhook",
      "name": "Respond to Webhook",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1,
      "position": [2200, 300]
    }
  ],
  "connections": {
    "webhook_trigger": {
      "main": [
        [
          {
            "node": "merge_triggers",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "manual_trigger": {
      "main": [
        [
          {
            "node": "set_test_defaults",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "set_test_defaults": {
      "main": [
        [
          {
            "node": "merge_triggers",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "merge_triggers": {
      "main": [
        [
          {
            "node": "prepare_scan",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "prepare_scan": {
      "main": [
        [
          {
            "node": "build_commands",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "build_commands": {
      "main": [
        [
          {
            "node": "split_batch",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "split_batch": {
      "main": [
        [
          {
            "node": "execute_scan",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "execute_scan": {
      "main": [
        [
          {
            "node": "process_results",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "process_results": {
      "main": [
        [
          {
            "node": "combine_results",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "combine_results": {
      "main": [
        [
          {
            "node": "format_final_output",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "format_final_output": {
      "main": [
        [
          {
            "node": "respond_to_webhook",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": true,
  "settings": {
    "saveDataSuccessExecution": "all",
    "saveManualExecutions": true,
    "saveDataErrorExecution": "all",
    "saveExecutionProgress": true,
    "executionTimeout": 300
  },
  "tags": [],
  "updatedAt": "2024-09-04T00:00:00.000Z",
  "id": "code-scanner"
}