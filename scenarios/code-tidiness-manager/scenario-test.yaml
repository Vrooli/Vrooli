version: 1.0
scenario: code-tidiness-manager

# Scenario metadata
metadata:
  description: "Automated technical debt detection and cleanup management"
  category: maintenance
  priority: high
  tags:
    - code-quality
    - maintenance
    - cleanup
    - technical-debt

# Structure validation - files and directories that MUST exist
structure:
  required_files:
    - .vrooli/service.json
    - PRD.md
    - README.md
    - scenario-test.yaml
    - initialization/storage/postgres/schema.sql
    - initialization/storage/postgres/seed.sql
    - initialization/automation/n8n/code-scanner.json
    - initialization/automation/n8n/cleanup-executor.json
    - initialization/automation/n8n/pattern-analyzer.json
    
  required_dirs:
    - .vrooli
    - api
    - cli
    - ui
    - lib
    - docs
    - test
    - initialization
    - initialization/automation
    - initialization/automation/n8n
    - initialization/storage
    - initialization/storage/postgres

# Resource validation
resources:
  required:
    - postgres
    - redis
  optional:
    - qdrant
    - ollama
    - n8n
  health_timeout: 60  # Seconds to wait for resources to be healthy

# Declarative tests
tests:
  # Resource health checks
  - name: "PostgreSQL is accessible"
    type: resource_health
    service: postgres
    critical: true
    
  - name: "Redis is accessible"
    type: resource_health
    service: redis
    critical: true
    
  - name: "n8n workflows can be injected"
    type: resource_health
    service: n8n
    critical: false
    
  # Database schema tests
  - name: "Database schema is valid"
    type: sql
    service: postgres
    query: "SELECT COUNT(*) FROM information_schema.schemata WHERE schema_name = 'tidiness'"
    expect:
      rows:
        - count: 1
    critical: true
    
  - name: "Core tables exist"
    type: sql
    service: postgres
    query: |
      SELECT COUNT(*) FROM information_schema.tables 
      WHERE table_schema = 'tidiness' 
      AND table_name IN ('scan_history', 'scan_results', 'cleanup_actions', 'cleanup_rules')
    expect:
      rows:
        - count: 4
    critical: true
    
  - name: "Default cleanup rules loaded"
    type: sql
    service: postgres
    query: "SELECT COUNT(*) FROM tidiness.cleanup_rules WHERE enabled = true"
    expect:
      min_rows: 20
    critical: false
    
  # API endpoint tests (when implemented)
  - name: "API health endpoint responds"
    type: http
    service: api
    endpoint: /health
    method: GET
    expect:
      status: 200
      body:
        status: "healthy"
    critical: false
    enabled: false  # Enable when API is implemented
    
  - name: "Scan endpoint accepts requests"
    type: http
    service: api
    endpoint: /api/v1/tidiness/scan
    method: POST
    headers:
      Content-Type: application/json
    body:
      paths: ["test/"]
      types: ["backup_files"]
      dry_run: true
    expect:
      status: [201, 202]
      body:
        scan_id: "*"
        status: "started"
    critical: false
    enabled: false  # Enable when API is implemented
    
  # CLI command tests (when implemented)
  - name: "CLI is executable"
    type: exec
    command: "./cli/code-tidiness-manager --version"
    expect:
      exit_code: 0
      output_contains: ["1.0.0"]
    critical: false
    enabled: false  # Enable when CLI is implemented
    
  - name: "CLI help command works"
    type: exec
    command: "./cli/code-tidiness-manager --help"
    expect:
      exit_code: 0
      output_contains: ["scan", "cleanup", "suggestions"]
    critical: false
    enabled: false  # Enable when CLI is implemented
    
  # n8n workflow tests
  - name: "Code scanner workflow exists"
    type: n8n
    workflow: code-scanner
    expect:
      exists: true
      active: false  # Will be activated on scenario run
    critical: false
    
  - name: "Cleanup executor workflow exists"
    type: n8n
    workflow: cleanup-executor
    expect:
      exists: true
      active: false
    critical: false
    
  - name: "Pattern analyzer workflow exists"
    type: n8n
    workflow: pattern-analyzer
    expect:
      exists: true
      active: false
    critical: false
    
  # Functional tests
  - name: "Can detect backup files"
    type: exec
    command: |
      touch /tmp/test_ctm_$$.bak && \
      find /tmp -name "test_ctm_*.bak" | grep -q test_ctm && \
      rm -f /tmp/test_ctm_*.bak
    expect:
      exit_code: 0
    critical: false
    
  - name: "Redis cache is working"
    type: exec
    command: |
      redis-cli SET ctm:test:$$ "test_value" EX 10 && \
      redis-cli GET ctm:test:$$ | grep -q "test_value" && \
      redis-cli DEL ctm:test:$$
    expect:
      exit_code: 0
    critical: false

# Performance benchmarks
benchmarks:
  - name: "Scan performance"
    type: performance
    command: "code-tidiness-manager scan --types backup_files --limit 100"
    expect:
      max_duration_ms: 5000
      max_memory_mb: 256
    enabled: false  # Enable when implemented
    
  - name: "Database query performance"
    type: sql_performance
    query: "SELECT * FROM tidiness.latest_scan_summary"
    expect:
      max_duration_ms: 100
    critical: false

# Integration tests
integration:
  - name: "Scenario can be started"
    type: scenario_lifecycle
    action: start
    expect:
      success: true
      services_healthy: ["api", "ui"]
    timeout: 60
    enabled: false  # Enable when fully implemented
    
  - name: "Scenario can be stopped"
    type: scenario_lifecycle
    action: stop
    expect:
      success: true
      services_stopped: ["api", "ui"]
    timeout: 30
    enabled: false  # Enable when fully implemented

# Validation summary
validation:
  required_pass_rate: 0.8  # 80% of enabled tests must pass
  critical_must_pass: true  # All critical tests must pass
  categories:
    structure: required
    resources: required
    database: required
    api: optional  # Until implemented
    cli: optional  # Until implemented
    integration: optional  # Until fully implemented