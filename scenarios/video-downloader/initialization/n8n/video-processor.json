{
  "name": "Video Processor",
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "process-video",
        "responseMode": "responseNode",
        "options": {}
      },
      "id": "webhook_trigger",
      "name": "Webhook",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 1.1,
      "position": [200, 300]
    },
    {
      "parameters": {},
      "id": "manual_trigger",
      "name": "Manual Trigger",
      "type": "n8n-nodes-base.manualTrigger",
      "typeVersion": 1,
      "position": [200, 500]
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "return {\n  url: 'https://www.youtube.com/watch?v=dQw4w9WgXcQ',\n  quality: '720p',\n  format: 'mp4',\n  audio_format: 'mp3',\n  audio_quality: '192k',\n  audio_only: false,\n  generate_transcript: false,\n  whisper_model: 'base',\n  download_id: 1\n};"
      },
      "id": "test_defaults",
      "name": "Test Defaults",
      "type": "n8n-nodes-base.code",
      "typeVersion": 1,
      "position": [400, 500]
    },
    {
      "parameters": {},
      "id": "merge",
      "name": "Merge",
      "type": "n8n-nodes-base.merge",
      "typeVersion": 2.1,
      "position": [600, 400]
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "const input = $input.item.json;\n\n// Validate required fields\nif (!input.url) {\n  throw new Error('URL is required');\n}\n\nif (!input.download_id) {\n  throw new Error('Download ID is required');\n}\n\n// Set defaults for video/format options\nconst quality = input.quality || 'best';\nconst format = input.format || 'mp4';\nconst audioOnly = input.audio_only === true;\n\n// Enhanced audio format support with defaults\nconst audioFormat = input.audio_format || (audioOnly ? 'mp3' : '');\nconst audioQuality = input.audio_quality || '192k';\n\n// Transcript generation options\nconst generateTranscript = input.generate_transcript === true;\nconst whisperModel = input.whisper_model || 'base';\nconst targetLanguage = input.target_language || '';\n\n// Create download directory path\nconst timestamp = new Date().toISOString().split('T')[0];\nconst downloadDir = `/tmp/video-downloads/${timestamp}`;\nconst audioDir = `/tmp/audio-extracts/${timestamp}`;\n\nreturn {\n  url: input.url,\n  download_id: input.download_id,\n  quality: quality,\n  format: format,\n  audio_only: audioOnly,\n  audio_format: audioFormat,\n  audio_quality: audioQuality,\n  generate_transcript: generateTranscript,\n  whisper_model: whisperModel,\n  target_language: targetLanguage,\n  download_dir: downloadDir,\n  audio_dir: audioDir,\n  user_id: input.user_id || 'anonymous'\n};"
      },
      "id": "prepare_download",
      "name": "Prepare Download",
      "type": "n8n-nodes-base.code",
      "typeVersion": 1,
      "position": [800, 400]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "UPDATE downloads SET status = 'downloading', started_at = NOW() WHERE id = {{ $json.download_id }}",
        "options": {}
      },
      "id": "update_status_downloading",
      "name": "Update Status - Downloading",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.4,
      "position": [1000, 300],
      "credentials": {
        "postgres": {
          "id": "${service.postgres.credentialId}",
          "name": "Postgres"
        }
      }
    },
    {
      "parameters": {
        "command": "#!/bin/bash\n\n# Enhanced video/audio downloader with transcript support\nurl=\"{{ $json.url }}\"\nquality=\"{{ $json.quality }}\"\nformat=\"{{ $json.format }}\"\naudio_only=\"{{ $json.audio_only }}\"\naudio_format=\"{{ $json.audio_format }}\"\naudio_quality=\"{{ $json.audio_quality }}\"\ngenerate_transcript=\"{{ $json.generate_transcript }}\"\ndownload_dir=\"{{ $json.download_dir }}\"\naudio_dir=\"{{ $json.audio_dir }}\"\ndownload_id=\"{{ $json.download_id }}\"\n\n# Create directories\nmkdir -p \"$download_dir\"\nmkdir -p \"$audio_dir\"\n\n# Function to convert quality string to bitrate\nget_audio_bitrate() {\n  case \"$1\" in\n    \"320k\") echo \"320\" ;;\n    \"192k\") echo \"192\" ;;\n    \"128k\") echo \"128\" ;;\n    \"96k\") echo \"96\" ;;\n    *) echo \"192\" ;; # default\n  esac\n}\n\naudio_bitrate=$(get_audio_bitrate \"$audio_quality\")\n\n# Build yt-dlp command based on requirements\nif [ \"$audio_only\" = \"true\" ]; then\n  # Audio-only download with enhanced format support\n  case \"$audio_format\" in\n    \"flac\")\n      yt_command=\"yt-dlp -x --audio-format flac\"\n      ;;\n    \"aac\")\n      yt_command=\"yt-dlp -x --audio-format aac --audio-quality ${audio_bitrate}k\"\n      ;;\n    \"ogg\")\n      yt_command=\"yt-dlp -x --audio-format vorbis --audio-quality ${audio_bitrate}k\"\n      ;;\n    \"mp3\"|*)\n      yt_command=\"yt-dlp -x --audio-format mp3 --audio-quality ${audio_bitrate}k\"\n      ;;\n  esac\nelse\n  # Video download with quality selection\n  if [ \"$quality\" = \"best\" ]; then\n    yt_command=\"yt-dlp -f 'bestvideo[ext=mp4]+bestaudio[ext=m4a]/best[ext=mp4]/best'\"\n  else\n    # Try to get specific quality, fallback to best if not available\n    height=\"${quality%p}\"\n    yt_command=\"yt-dlp -f 'bestvideo[height<=${height}][ext=mp4]+bestaudio[ext=m4a]/best[height<=${height}][ext=mp4]/best[ext=mp4]/best'\"\n  fi\n  \n  # Add format conversion if needed\n  if [ \"$format\" != \"mp4\" ]; then\n    yt_command=\"$yt_command --recode-video $format\"\n  fi\nfi\n\n# Add output template and other options\nyt_command=\"$yt_command -o '$download_dir/%(title)s.%(ext)s' --restrict-filenames --no-playlist --write-info-json\"\n\n# Execute download\necho \"Executing: $yt_command '$url'\"\noutput=$(eval \"$yt_command '$url'\" 2>&1)\nstatus=$?\n\nif [ $status -eq 0 ]; then\n  # Get the downloaded file path\n  main_file=$(find \"$download_dir\" -type f \\( -name \"*.mp4\" -o -name \"*.webm\" -o -name \"*.mp3\" -o -name \"*.flac\" -o -name \"*.aac\" -o -name \"*.ogg\" \\) | head -1)\n  \n  if [ -n \"$main_file\" ]; then\n    file_size=$(stat -c%s \"$main_file\" 2>/dev/null || stat -f%z \"$main_file\" 2>/dev/null || echo 0)\n    \n    # Extract audio if video was downloaded and audio format specified\n    audio_path=\"\"\n    audio_size=0\n    \n    if [ \"$audio_only\" != \"true\" ] && [ -n \"$audio_format\" ]; then\n      # Use FFmpeg to extract audio from video\n      base_name=$(basename \"$main_file\" | sed 's/\\.[^.]*$//')\n      audio_path=\"$audio_dir/${base_name}.${audio_format}\"\n      \n      echo \"Extracting audio to: $audio_path\"\n      \n      case \"$audio_format\" in\n        \"mp3\")\n          ffmpeg_cmd=\"ffmpeg -i '$main_file' -vn -acodec libmp3lame -ab ${audio_bitrate}k '$audio_path'\"\n          ;;\n        \"flac\")\n          ffmpeg_cmd=\"ffmpeg -i '$main_file' -vn -acodec flac '$audio_path'\"\n          ;;\n        \"aac\")\n          ffmpeg_cmd=\"ffmpeg -i '$main_file' -vn -acodec aac -ab ${audio_bitrate}k '$audio_path'\"\n          ;;\n        \"ogg\")\n          ffmpeg_cmd=\"ffmpeg -i '$main_file' -vn -acodec libvorbis -aq 4 '$audio_path'\"\n          ;;\n        *)\n          ffmpeg_cmd=\"ffmpeg -i '$main_file' -vn -acodec libmp3lame -ab ${audio_bitrate}k '$audio_path'\"\n          ;;\n      esac\n      \n      eval \"$ffmpeg_cmd\" 2>&1\n      \n      if [ -f \"$audio_path\" ]; then\n        audio_size=$(stat -c%s \"$audio_path\" 2>/dev/null || stat -f%z \"$audio_path\" 2>/dev/null || echo 0)\n        echo \"Audio extracted successfully: $audio_path (${audio_size} bytes)\"\n      else\n        echo \"Audio extraction failed\"\n        audio_path=\"\"\n      fi\n    elif [ \"$audio_only\" = \"true\" ]; then\n      # For audio-only downloads, the main file IS the audio file\n      audio_path=\"$main_file\"\n      audio_size=\"$file_size\"\n    fi\n    \n    # Get video metadata from info.json if available\n    info_file=$(find \"$download_dir\" -name \"*.info.json\" | head -1)\n    title=\"Unknown\"\n    duration=0\n    \n    if [ -f \"$info_file\" ]; then\n      title=$(jq -r '.title // \"Unknown\"' \"$info_file\" 2>/dev/null || echo \"Unknown\")\n      duration=$(jq -r '.duration // 0' \"$info_file\" 2>/dev/null || echo 0)\n    fi\n    \n    echo \"{\\\"success\\\": true, \\\"file_path\\\": \\\"$main_file\\\", \\\"file_size\\\": $file_size, \\\"audio_path\\\": \\\"$audio_path\\\", \\\"audio_size\\\": $audio_size, \\\"title\\\": \\\"$title\\\", \\\"duration\\\": $duration, \\\"download_id\\\": $download_id, \\\"generate_transcript\\\": $generate_transcript}\"\n  else\n    echo \"{\\\"success\\\": false, \\\"error\\\": \\\"No media file found after download\\\", \\\"download_id\\\": $download_id}\"\n  fi\nelse\n  echo \"{\\\"success\\\": false, \\\"error\\\": \\\"Download failed: $output\\\", \\\"download_id\\\": $download_id}\"\nfi"
      },
      "id": "download_video",
      "name": "Download Video",
      "type": "n8n-nodes-base.executeCommand",
      "typeVersion": 1,
      "position": [1200, 400]
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "const result = JSON.parse($input.item.json.stdout || '{}');\nconst downloadData = $node[\"prepare_download\"].json;\n\nif (result.success) {\n  return {\n    success: true,\n    download_id: result.download_id,\n    file_path: result.file_path,\n    file_size: result.file_size,\n    // Enhanced audio and metadata support\n    audio_path: result.audio_path || '',\n    audio_size: result.audio_size || 0,\n    title: result.title || 'Unknown',\n    duration: result.duration || 0,\n    status: 'completed',\n    // Transcript generation flag for workflow chaining\n    generate_transcript: result.generate_transcript === 'true' || result.generate_transcript === true,\n    whisper_model: downloadData.whisper_model,\n    target_language: downloadData.target_language\n  };\n} else {\n  return {\n    success: false,\n    download_id: result.download_id,\n    error: result.error || 'Unknown error',\n    status: 'failed',\n    generate_transcript: false\n  };\n}"
      },
      "id": "process_result",
      "name": "Process Result",
      "type": "n8n-nodes-base.code",
      "typeVersion": 1,
      "position": [1400, 400]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "UPDATE downloads \nSET \n  status = '{{ $json.status }}',\n  file_path = {{ $json.file_path ? \"'\" + $json.file_path + \"'\" : 'NULL' }},\n  file_size = {{ $json.file_size || 'NULL' }},\n  audio_path = {{ $json.audio_path ? \"'\" + $json.audio_path + \"'\" : 'NULL' }},\n  audio_file_size = {{ $json.audio_size || 'NULL' }},\n  title = {{ $json.title ? \"'\" + $json.title.replace(/'/g, \"''\") + \"'\" : 'NULL' }},\n  duration = {{ $json.duration || 'NULL' }},\n  error_message = {{ $json.error ? \"'\" + $json.error.replace(/'/g, \"''\") + \"'\" : 'NULL' }},\n  completed_at = {{ $json.success ? 'NOW()' : 'NULL' }},\n  progress = {{ $json.success ? '100' : '0' }}\nWHERE id = {{ $json.download_id }}",
        "options": {}
      },
      "id": "update_final_status",
      "name": "Update Final Status",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.4,
      "position": [1600, 400],
      "credentials": {
        "postgres": {
          "id": "${service.postgres.credentialId}",
          "name": "Postgres"
        }
      }
    },
    {
      "parameters": {
        "respondWith": "allIncomingItems",
        "options": {}
      },
      "id": "respond",
      "name": "Respond to Webhook",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1,
      "position": [1800, 400]
    }
  ],
  "connections": {
    "webhook_trigger": {
      "main": [[{ "node": "merge", "type": "main", "index": 0 }]]
    },
    "manual_trigger": {
      "main": [[{ "node": "test_defaults", "type": "main", "index": 0 }]]
    },
    "test_defaults": {
      "main": [[{ "node": "merge", "type": "main", "index": 1 }]]
    },
    "merge": {
      "main": [[{ "node": "prepare_download", "type": "main", "index": 0 }]]
    },
    "prepare_download": {
      "main": [[{ "node": "update_status_downloading", "type": "main", "index": 0 }]]
    },
    "update_status_downloading": {
      "main": [[{ "node": "download_video", "type": "main", "index": 0 }]]
    },
    "download_video": {
      "main": [[{ "node": "process_result", "type": "main", "index": 0 }]]
    },
    "process_result": {
      "main": [[{ "node": "update_final_status", "type": "main", "index": 0 }]]
    },
    "update_final_status": {
      "main": [[{ "node": "respond", "type": "main", "index": 0 }]]
    }
  },
  "active": true,
  "settings": {
    "executionOrder": "v1"
  },
  "versionId": "01234567-89ab-cdef-0123-456789abcdef",
  "id": "video-downloader-processor",
  "meta": {
    "instanceId": "${service.n8n.instanceId}"
  },
  "tags": []
}