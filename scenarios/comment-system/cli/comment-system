#!/usr/bin/env bash

# Comment System CLI Tool
# Provides command-line interface for comment system management

set -e

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
API_URL="${API_URL:-http://localhost:8080}"
CONFIG_DIR="$HOME/.vrooli/comment-system"
CONFIG_FILE="$CONFIG_DIR/config.yaml"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
PURPLE='\033[0;35m'
NC='\033[0m' # No Color

# Create config directory if it doesn't exist
mkdir -p "$CONFIG_DIR"

# Utility functions
log_info() {
    echo -e "${BLUE}[INFO]${NC} $1"
}

log_success() {
    echo -e "${GREEN}[SUCCESS]${NC} $1"
}

log_warning() {
    echo -e "${YELLOW}[WARNING]${NC} $1"
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

# Load configuration
load_config() {
    if [[ -f "$CONFIG_FILE" ]]; then
        # Simple YAML parsing for basic config
        while IFS= read -r line; do
            if [[ $line =~ ^[[:space:]]*api_url:[[:space:]]*(.+)$ ]]; then
                API_URL="${BASH_REMATCH[1]}"
            fi
        done < "$CONFIG_FILE"
    fi
}

# HTTP request helper
make_request() {
    local method="$1"
    local endpoint="$2"
    local data="$3"
    local content_type="${4:-application/json}"

    local curl_args=(
        -s
        -X "$method"
        -H "Content-Type: $content_type"
        --max-time 30
    )

    if [[ -n "$data" ]]; then
        curl_args+=(-d "$data")
    fi

    curl "${curl_args[@]}" "$API_URL$endpoint" || {
        log_error "Failed to connect to API at $API_URL"
        return 1
    }
}

# Command implementations
cmd_status() {
    local json_output=false
    local verbose=false

    while [[ $# -gt 0 ]]; do
        case $1 in
            --json)
                json_output=true
                shift
                ;;
            --verbose)
                verbose=true
                shift
                ;;
            *)
                log_error "Unknown option: $1"
                return 1
                ;;
        esac
    done

    log_info "Checking Comment System status..."

    local response
    response=$(make_request GET "/health")
    local exit_code=$?

    if [[ $exit_code -ne 0 ]]; then
        if [[ $json_output == true ]]; then
            echo '{"status": "disconnected", "error": "Failed to connect to API"}'
        else
            log_error "Comment System API is not reachable"
        fi
        return 1
    fi

    if [[ $json_output == true ]]; then
        echo "$response" | jq '.' 2>/dev/null || echo "$response"
    else
        local status
        status=$(echo "$response" | jq -r '.status // "unknown"' 2>/dev/null)
        
        case $status in
            "healthy")
                log_success "Comment System is healthy"
                ;;
            "unhealthy")
                log_warning "Comment System is unhealthy"
                ;;
            *)
                log_error "Comment System status unknown"
                ;;
        esac

        if [[ $verbose == true ]]; then
            echo
            echo "Raw response:"
            echo "$response" | jq '.' 2>/dev/null || echo "$response"
        fi
    fi
}

cmd_list() {
    local scenario="$1"
    local format="${2:-table}"
    local limit="${3:-20}"
    local parent_id="$4"

    if [[ -z "$scenario" ]]; then
        log_error "Scenario name is required"
        echo "Usage: comment-system list <scenario> [format] [limit] [parent_id]"
        return 1
    fi

    local endpoint="/api/v1/comments/$scenario?limit=$limit"
    if [[ -n "$parent_id" ]]; then
        endpoint="$endpoint&parent_id=$parent_id"
    fi

    local response
    response=$(make_request GET "$endpoint")
    
    if [[ $? -ne 0 ]]; then
        return 1
    fi

    case $format in
        json)
            echo "$response" | jq '.'
            ;;
        table)
            echo "$response" | jq -r '.comments[] | [.id[0:8], (.author_name // "Anonymous"), .content[0:50], .created_at] | @tsv' | \
            {
                echo -e "ID\tAUTHOR\tCONTENT\tCREATED"
                echo -e "--------\t--------\t--------\t--------"
                cat
            } | column -t -s $'\t'
            ;;
        tree)
            echo "$response" | jq -r '.comments[] | [(.depth // 0), .id[0:8], (.author_name // "Anonymous"), .content[0:40]] | @tsv' | \
            while IFS=$'\t' read -r depth id author content; do
                local indent=""
                for ((i=0; i<depth; i++)); do
                    indent="  $indent"
                done
                echo "${indent}├─ [$id] $author: $content"
            done
            ;;
        *)
            log_error "Invalid format. Use: json, table, or tree"
            return 1
            ;;
    esac
}

cmd_create() {
    local scenario="$1"
    local content="$2"
    local parent_id="$3"
    local content_type="${4:-markdown}"

    if [[ -z "$scenario" || -z "$content" ]]; then
        log_error "Scenario and content are required"
        echo "Usage: comment-system create <scenario> <content> [parent_id] [content_type]"
        return 1
    fi

    local data
    data=$(jq -n \
        --arg content "$content" \
        --arg content_type "$content_type" \
        --arg parent_id "$parent_id" \
        '{
            content: $content,
            content_type: $content_type
        } + (if $parent_id != "" then {parent_id: $parent_id} else {} end)'
    )

    local response
    response=$(make_request POST "/api/v1/comments/$scenario" "$data")
    
    if [[ $? -eq 0 ]]; then
        local comment_id
        comment_id=$(echo "$response" | jq -r '.comment.id // "unknown"')
        log_success "Comment created with ID: $comment_id"
    else
        log_error "Failed to create comment"
        return 1
    fi
}

cmd_config() {
    local scenario="$1"
    local action="${2:-get}"
    
    if [[ -z "$scenario" ]]; then
        log_error "Scenario name is required"
        echo "Usage: comment-system config <scenario> [get|set] [options...]"
        return 1
    fi

    case $action in
        get)
            local response
            response=$(make_request GET "/api/v1/config/$scenario")
            
            if [[ $? -eq 0 ]]; then
                echo "$response" | jq '.config'
            else
                log_error "Failed to get configuration"
                return 1
            fi
            ;;
        set)
            shift 2  # Remove scenario and action from args
            
            local config_data="{}"
            while [[ $# -gt 0 ]]; do
                case $1 in
                    --auth-required)
                        config_data=$(echo "$config_data" | jq '. + {auth_required: true}')
                        ;;
                    --no-auth-required)
                        config_data=$(echo "$config_data" | jq '. + {auth_required: false}')
                        ;;
                    --allow-anonymous)
                        config_data=$(echo "$config_data" | jq '. + {allow_anonymous: true}')
                        ;;
                    --no-allow-anonymous)
                        config_data=$(echo "$config_data" | jq '. + {allow_anonymous: false}')
                        ;;
                    --rich-media)
                        config_data=$(echo "$config_data" | jq '. + {allow_rich_media: true}')
                        ;;
                    --no-rich-media)
                        config_data=$(echo "$config_data" | jq '. + {allow_rich_media: false}')
                        ;;
                    --moderation=*)
                        local level="${1#*=}"
                        config_data=$(echo "$config_data" | jq --arg level "$level" '. + {moderation_level: $level}')
                        ;;
                    *)
                        log_error "Unknown option: $1"
                        return 1
                        ;;
                esac
                shift
            done

            local response
            response=$(make_request POST "/api/v1/config/$scenario" "$config_data")
            
            if [[ $? -eq 0 ]]; then
                log_success "Configuration updated for scenario: $scenario"
                echo "$response" | jq '.config'
            else
                log_error "Failed to update configuration"
                return 1
            fi
            ;;
        *)
            log_error "Invalid action. Use 'get' or 'set'"
            return 1
            ;;
    esac
}

cmd_moderate() {
    local comment_id="$1"
    local action="$2"

    if [[ -z "$comment_id" || -z "$action" ]]; then
        log_error "Comment ID and action are required"
        echo "Usage: comment-system moderate <comment_id> <action>"
        echo "Actions: approve, delete, flag"
        return 1
    fi

    local data
    data=$(jq -n --arg action "$action" '{action: $action}')

    local response
    response=$(make_request POST "/admin/moderate/$comment_id" "$data")
    
    if [[ $? -eq 0 ]]; then
        log_success "Comment $comment_id has been $action"
    else
        log_error "Failed to moderate comment"
        return 1
    fi
}

cmd_help() {
    local command="$1"

    if [[ -z "$command" ]]; then
        cat << 'EOF'
Comment System CLI - Universal comment management for Vrooli scenarios

Usage: comment-system <command> [options...]

Commands:
    status          Check system health and connectivity
    list            List comments for a scenario  
    create          Create a new comment
    config          Manage scenario configurations
    moderate        Moderate comments (admin)
    help            Show help for commands
    version         Show version information

Global Options:
    --json          Output in JSON format (where applicable)
    --verbose       Show detailed information
    
Configuration:
    Config file: ~/.vrooli/comment-system/config.yaml
    Environment:
        API_URL     Comment System API endpoint

Examples:
    comment-system status --json
    comment-system list picker-wheel table 10
    comment-system create study-buddy "Great scenario!"
    comment-system config picker-wheel set --auth-required --moderation=manual

For detailed help on a specific command, use:
    comment-system help <command>

EOF
    else
        case $command in
            status)
                cat << 'EOF'
comment-system status - Check Comment System health

Usage: comment-system status [options]

Options:
    --json      Output status in JSON format
    --verbose   Show detailed health information

Examples:
    comment-system status
    comment-system status --json --verbose

EOF
                ;;
            list)
                cat << 'EOF'
comment-system list - List comments for a scenario

Usage: comment-system list <scenario> [format] [limit] [parent_id]

Arguments:
    scenario    Name of the scenario
    format      Output format (table, json, tree) [default: table]  
    limit       Maximum number of comments [default: 20]
    parent_id   Filter by parent comment ID (optional)

Examples:
    comment-system list picker-wheel
    comment-system list study-buddy json 50
    comment-system list retro-game tree 100
    comment-system list picker-wheel table 10 parent-comment-id

EOF
                ;;
            create)
                cat << 'EOF'
comment-system create - Create a new comment

Usage: comment-system create <scenario> <content> [parent_id] [content_type]

Arguments:
    scenario        Target scenario name
    content         Comment content
    parent_id       Parent comment ID for replies (optional)
    content_type    Content format (markdown, plaintext) [default: markdown]

Examples:
    comment-system create picker-wheel "Great tool!"
    comment-system create study-buddy "Very helpful" parent-id markdown
    comment-system create notes "Simple comment" "" plaintext

EOF
                ;;
            config)
                cat << 'EOF'
comment-system config - Manage scenario configurations

Usage: comment-system config <scenario> [get|set] [options...]

Actions:
    get     Show current configuration (default)
    set     Update configuration with options

Set Options:
    --auth-required     Require user authentication
    --no-auth-required  Don't require authentication  
    --allow-anonymous   Allow anonymous comments
    --no-allow-anonymous Disable anonymous comments
    --rich-media        Enable rich media attachments
    --no-rich-media     Disable rich media
    --moderation=LEVEL  Set moderation level (none, manual, ai_assisted)

Examples:
    comment-system config picker-wheel
    comment-system config study-buddy set --auth-required --moderation=manual
    comment-system config notes set --allow-anonymous --no-rich-media

EOF
                ;;
            moderate)
                cat << 'EOF'
comment-system moderate - Moderate comments (admin only)

Usage: comment-system moderate <comment_id> <action>

Arguments:
    comment_id  ID of the comment to moderate
    action      Moderation action (approve, delete, flag)

Examples:
    comment-system moderate abc123def456 approve
    comment-system moderate spam-comment-id delete
    comment-system moderate questionable-id flag

EOF
                ;;
            *)
                log_error "No help available for command: $command"
                return 1
                ;;
        esac
    fi
}

cmd_version() {
    cat << 'EOF'
Comment System CLI v1.0.0
Universal comment management for Vrooli scenarios

Features:
- Comment CRUD operations
- Scenario configuration management
- Admin moderation tools
- JSON and formatted output
- Integration with session-authenticator

API Compatibility: Comment System API v1.0
EOF
}

# Main command dispatcher
main() {
    load_config

    local command="${1:-help}"
    shift || true

    case $command in
        status)
            cmd_status "$@"
            ;;
        list|ls)
            cmd_list "$@"
            ;;
        create|add|post)
            cmd_create "$@"
            ;;
        config|configure)
            cmd_config "$@"
            ;;
        moderate|mod)
            cmd_moderate "$@"
            ;;
        help|-h|--help)
            cmd_help "$@"
            ;;
        version|-v|--version)
            cmd_version
            ;;
        *)
            log_error "Unknown command: $command"
            echo
            cmd_help
            exit 1
            ;;
    esac
}

# Check dependencies
check_dependencies() {
    local missing_deps=()

    if ! command -v curl >/dev/null 2>&1; then
        missing_deps+=("curl")
    fi

    if ! command -v jq >/dev/null 2>&1; then
        missing_deps+=("jq")
    fi

    if [[ ${#missing_deps[@]} -gt 0 ]]; then
        log_error "Missing required dependencies: ${missing_deps[*]}"
        echo "Please install the missing dependencies and try again."
        exit 1
    fi
}

# Entry point
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    check_dependencies
    main "$@"
fi