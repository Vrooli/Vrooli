{
  "name": "problem-scanner",
  "nodes": [
    {
      "parameters": {
        "rule": {
          "interval": [
            {
              "field": "minutes",
              "minutesInterval": 5
            }
          ]
        }
      },
      "id": "trigger",
      "name": "Every 5 Minutes",
      "type": "n8n-nodes-base.scheduleTrigger",
      "typeVersion": 1.1,
      "position": [250, 300]
    },
    {
      "parameters": {
        "functionCode": "// Read problem scanning configuration\nconst vrooliRoot = process.env.VROOLI_ROOT || (process.env.HOME + '/Vrooli');\nconst scanPaths = [\n  vrooliRoot + '/PROBLEMS.md',\n  vrooliRoot + '/resources/*/PROBLEMS.md',\n  vrooliRoot + '/scenarios/*/PROBLEMS.md',\n  vrooliRoot + '/resources/*/TROUBLESHOOTING.md',\n  vrooliRoot + '/scenarios/*/TROUBLESHOOTING.md'\n];\n\n// Expand glob patterns\nconst fs = require('fs');\nconst glob = require('glob');\nconst allPaths = [];\n\nfor (const pattern of scanPaths) {\n  if (pattern.includes('*')) {\n    // Use glob to expand pattern\n    const matches = glob.sync(pattern);\n    allPaths.push(...matches);\n  } else {\n    // Direct path\n    if (fs.existsSync(pattern)) {\n      allPaths.push(pattern);\n    }\n  }\n}\n\n// Mark file type for appropriate parsing\nreturn allPaths.map(path => ({ \n  json: { \n    scan_path: path,\n    file_type: path.endsWith('PROBLEMS.md') ? 'problems' : 'troubleshooting'\n  } \n}));"
      },
      "id": "prepare-scan-paths",
      "name": "Prepare Scan Paths",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [450, 300]
    },
    {
      "parameters": {
        "url": "http://localhost:8095/api/problems/scan",
        "method": "POST",
        "sendBody": true,
        "bodyParameters": {
          "parameters": [
            {
              "name": "scan_path",
              "value": "={{$json.scan_path}}"
            },
            {
              "name": "file_type",
              "value": "={{$json.file_type}}"
            },
            {
              "name": "force",
              "value": "false"
            }
          ]
        },
        "options": {
          "timeout": 30000
        }
      },
      "id": "scan-problems",
      "name": "Scan Problems",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 3,
      "position": [650, 300]
    },
    {
      "parameters": {
        "functionCode": "// Aggregate all problem scan results\nconst allProblems = [];\nconst scanResults = [];\n\nfor (const item of $input.all()) {\n  if (item.json.problems_found > 0) {\n    scanResults.push({\n      path: item.json.scanned_path,\n      count: item.json.problems_found,\n      problems: item.json.new_problems || []\n    });\n    \n    if (item.json.new_problems) {\n      allProblems.push(...item.json.new_problems);\n    }\n  }\n}\n\n// Summary statistics\nconst totalProblems = scanResults.reduce((sum, r) => sum + r.count, 0);\nconst criticalProblems = allProblems.filter(p => p.includes('critical')).length;\nconst highProblems = allProblems.filter(p => p.includes('high')).length;\n\nreturn [{\n  json: {\n    timestamp: new Date().toISOString(),\n    totalProblems,\n    criticalProblems,\n    highProblems,\n    scanResults,\n    allProblems,\n    shouldCreateTasks: criticalProblems > 0 || highProblems > 0\n  }\n}];"
      },
      "id": "aggregate-results",
      "name": "Aggregate Results",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [850, 300]
    },
    {
      "parameters": {
        "conditions": {
          "boolean": [
            {
              "value1": "={{$json.shouldCreateTasks}}",
              "value2": true
            }
          ]
        }
      },
      "id": "check-critical",
      "name": "Critical/High Problems?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 1,
      "position": [1050, 300]
    },
    {
      "parameters": {
        "url": "http://localhost:8095/api/config",
        "method": "GET",
        "options": {}
      },
      "id": "get-config",
      "name": "Get Config",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 3,
      "position": [1250, 200]
    },
    {
      "parameters": {
        "conditions": {
          "boolean": [
            {
              "value1": "={{$json.yolo_mode}}",
              "value2": true
            }
          ]
        }
      },
      "id": "check-yolo",
      "name": "YOLO Mode?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 1,
      "position": [1450, 200]
    },
    {
      "parameters": {
        "functionCode": "// Create tasks for critical/high problems\nconst tasks = [];\nconst problems = $node['aggregate-results'].json.allProblems;\n\nfor (const problemId of problems) {\n  // Only create tasks for critical/high severity\n  if (problemId.includes('critical') || problemId.includes('high')) {\n    const task = {\n      title: `Resolve problem: ${problemId}`,\n      type: 'problem-resolution',\n      priority_estimates: {\n        impact: problemId.includes('critical') ? 10 : 8,\n        urgency: problemId.includes('critical') ? 'critical' : 'high',\n        success_prob: 0.8,\n        resource_cost: 'moderate'\n      },\n      source: 'problem-scanner',\n      problem_id: problemId,\n      auto_generated: true,\n      created_at: new Date().toISOString()\n    };\n    tasks.push(task);\n  }\n}\n\nreturn tasks.map(task => ({ json: task }));"
      },
      "id": "prepare-tasks",
      "name": "Prepare Tasks",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [1650, 100]
    },
    {
      "parameters": {
        "url": "http://localhost:8095/api/tasks",
        "method": "POST",
        "sendBody": true,
        "bodyParameters": {
          "parameters": [
            {
              "name": "title",
              "value": "={{$json.title}}"
            },
            {
              "name": "type",
              "value": "={{$json.type}}"
            },
            {
              "name": "priority_estimates",
              "value": "={{$json.priority_estimates}}"
            },
            {
              "name": "source",
              "value": "={{$json.source}}"
            },
            {
              "name": "problem_id",
              "value": "={{$json.problem_id}}"
            },
            {
              "name": "auto_generated",
              "value": "={{$json.auto_generated}}"
            }
          ]
        },
        "options": {}
      },
      "id": "create-task",
      "name": "Create Task",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 3,
      "position": [1850, 100]
    },
    {
      "parameters": {
        "functionCode": "// Send notification about critical problems\nconst criticalCount = $node['aggregate-results'].json.criticalProblems;\nconst highCount = $node['aggregate-results'].json.highProblems;\n\nif (criticalCount > 0) {\n  // Log critical alert\n  console.error(`CRITICAL: ${criticalCount} critical problems detected!`);\n  \n  // In production, this would send alerts via:\n  // - Slack/Discord webhook\n  // - Email notification\n  // - PagerDuty incident\n  // - System monitoring dashboard\n}\n\nreturn [{\n  json: {\n    alert_sent: criticalCount > 0,\n    message: `Found ${criticalCount} critical and ${highCount} high severity problems`,\n    timestamp: new Date().toISOString()\n  }\n}];"
      },
      "id": "send-alerts",
      "name": "Send Alerts",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [1650, 300]
    },
    {
      "parameters": {
        "functionCode": "// Log scan results for monitoring\nconst results = $node['aggregate-results'].json;\n\n// Write to decision log\nconst fs = require('fs');\nconst vrooliRoot = process.env.VROOLI_ROOT || (process.env.HOME + '/Vrooli');\nconst logDir = vrooliRoot + '/scenarios/swarm-manager/logs/decisions';\nconst logFile = `${logDir}/problem-scan-${Date.now()}.json`;\n\nconst logEntry = {\n  timestamp: new Date().toISOString(),\n  scan_type: 'scheduled_problem_scan',\n  results: {\n    total_problems: results.totalProblems,\n    critical: results.criticalProblems,\n    high: results.highProblems,\n    paths_scanned: results.scanResults.length,\n    tasks_created: $node['create-task'] ? $node['create-task'].length : 0\n  },\n  scan_details: results.scanResults\n};\n\n// Ensure log directory exists\nif (!fs.existsSync(logDir)) {\n  fs.mkdirSync(logDir, { recursive: true });\n}\n\n// Write log\nfs.writeFileSync(logFile, JSON.stringify(logEntry, null, 2));\n\nreturn [{ json: { logged: true, logFile } }];"
      },
      "id": "log-results",
      "name": "Log Results",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [1050, 500]
    },
    {
      "parameters": {
        "functionCode": "// Clean up old completed/failed tasks if over threshold\nconst MAX_COMPLETED = 100;\nconst MAX_FAILED = 50;\n\nconst fs = require('fs');\nconst path = require('path');\n\nfunction cleanOldTasks(dir, maxCount) {\n  const files = fs.readdirSync(dir)\n    .filter(f => f.endsWith('.yaml'))\n    .map(f => ({\n      name: f,\n      path: path.join(dir, f),\n      mtime: fs.statSync(path.join(dir, f)).mtime\n    }))\n    .sort((a, b) => b.mtime - a.mtime); // Newest first\n  \n  if (files.length > maxCount) {\n    const toDelete = files.slice(maxCount);\n    for (const file of toDelete) {\n      fs.unlinkSync(file.path);\n    }\n    return toDelete.length;\n  }\n  return 0;\n}\n\nconst vrooliRoot = process.env.VROOLI_ROOT || (process.env.HOME + '/Vrooli');\nconst completedDir = vrooliRoot + '/scenarios/swarm-manager/tasks/completed';\nconst failedDir = vrooliRoot + '/scenarios/swarm-manager/tasks/failed';\n\nconst deletedCompleted = cleanOldTasks(completedDir, MAX_COMPLETED);\nconst deletedFailed = cleanOldTasks(failedDir, MAX_FAILED);\n\nreturn [{\n  json: {\n    cleanup_performed: true,\n    deleted_completed: deletedCompleted,\n    deleted_failed: deletedFailed,\n    timestamp: new Date().toISOString()\n  }\n}];"
      },
      "id": "cleanup-old-tasks",
      "name": "Cleanup Old Tasks",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [650, 500]
    }
  ],
  "connections": {
    "trigger": {
      "main": [
        [
          {
            "node": "prepare-scan-paths",
            "type": "main",
            "index": 0
          },
          {
            "node": "cleanup-old-tasks",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "prepare-scan-paths": {
      "main": [
        [
          {
            "node": "scan-problems",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "scan-problems": {
      "main": [
        [
          {
            "node": "aggregate-results",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "aggregate-results": {
      "main": [
        [
          {
            "node": "check-critical",
            "type": "main",
            "index": 0
          },
          {
            "node": "log-results",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "check-critical": {
      "main": [
        [
          {
            "node": "get-config",
            "type": "main",
            "index": 0
          },
          {
            "node": "send-alerts",
            "type": "main",
            "index": 0
          }
        ],
        []
      ]
    },
    "get-config": {
      "main": [
        [
          {
            "node": "check-yolo",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "check-yolo": {
      "main": [
        [
          {
            "node": "prepare-tasks",
            "type": "main",
            "index": 0
          }
        ],
        []
      ]
    },
    "prepare-tasks": {
      "main": [
        [
          {
            "node": "create-task",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": true,
  "settings": {
    "executionOrder": "v1",
    "saveManualExecutions": true,
    "callerPolicy": "workflowsFromSameOwner",
    "errorWorkflow": ""
  },
  "versionId": "1.0.0",
  "tags": [],
  "triggerCount": 1
}