package rules

import (
	"os"
	"path/filepath"
	"regexp"
	"strings"
)

/*
Rule: Test File Coverage
Description: Ensure all Go files have corresponding test files
Reason: Maintains code quality and prevents regressions through comprehensive testing
Category: test
Severity: medium
Standard: testing-standards-v1

<test-case id="missing-test-file" should-fail="true">
  <description>Go source file without corresponding test file</description>
  <input language="go">
// Simulating a file check - filename: user_service.go
package service

type UserService struct {
    db Database
}

func (s *UserService) GetUser(id string) (*User, error) {
    return s.db.FindUser(id)
}

func (s *UserService) CreateUser(user *User) error {
    return s.db.SaveUser(user)
}
  </input>
  <expected-violations>1</expected-violations>
  <expected-message>Missing Test File</expected-message>
</test-case>

<test-case id="test-file-exists" should-fail="false">
  <description>Go source file with corresponding test file</description>
  <input language="go">
// Simulating a file check - filename: user_service.go (with user_service_test.go existing)
package service

type UserService struct {
    db Database
}

func (s *UserService) GetUser(id string) (*User, error) {
    return s.db.FindUser(id)
}

// Companion test file user_service_test.go exists with tests
  </input>
</test-case>

<test-case id="test-file-itself" should-fail="false">
  <description>Test files themselves don't need tests</description>
  <input language="go">
// Simulating a file check - filename: user_service_test.go
package service

import (
    "testing"
)

func TestGetUser(t *testing.T) {
    service := &UserService{db: mockDB}
    user, err := service.GetUser("123")

    if err != nil {
        t.Errorf("Unexpected error: %v", err)
    }

    if user.ID != "123" {
        t.Errorf("Expected user ID 123, got %s", user.ID)
    }
}
  </input>
</test-case>

<test-case id="generated-file-exempt" should-fail="false">
  <description>Generated files are exempt from test requirements</description>
  <input language="go">
// Simulating a file check - filename: api.pb.go
// Code generated by protoc-gen-go. DO NOT EDIT.
package api

import proto "github.com/golang/protobuf/proto"

type Request struct {
    Id string `protobuf:"bytes,1,opt,name=id,proto3"`
}

// Generated code continues...
  </input>
</test-case>
*/

// CheckTestFileCoverage validates that source files have corresponding tests
func CheckTestFileCoverage(content []byte, filePath string) []Violation {
	var violations []Violation

	targetPath := strings.TrimSpace(filePath)
	if simulated := extractSimulatedFilename(string(content)); simulated != "" {
		baseDir := filepath.Dir(filePath)
		if baseDir == "." {
			baseDir = ""
		}
		targetPath = filepath.Clean(filepath.Join(baseDir, simulated))
	}

	if strings.HasSuffix(targetPath, "_test.go") ||
		strings.Contains(targetPath, "generated") ||
		strings.Contains(targetPath, "vendor") ||
		strings.Contains(targetPath, ".pb.go") {
		return violations
	}

	if !strings.HasSuffix(targetPath, ".go") {
		return violations
	}

	testFile := strings.TrimSuffix(targetPath, ".go") + "_test.go"
	if _, err := os.Stat(testFile); err == nil {
		return violations
	} else if !os.IsNotExist(err) {
		return violations
	}

	contentLower := strings.ToLower(string(content))
	baseName := filepath.Base(targetPath)
	expectedTestName := strings.ToLower(strings.TrimSuffix(baseName, ".go") + "_test.go")
	if strings.Contains(contentLower, "with "+expectedTestName+" existing") {
		return violations
	}

	missingName := strings.TrimSuffix(baseName, ".go") + "_test.go"
	violations = append(violations, Violation{
		Type:           "test_coverage",
		Severity:       "medium",
		Title:          "Missing Test File",
		Description:    "Missing Test File",
		FilePath:       targetPath,
		LineNumber:     1,
		CodeSnippet:    "// No test file: " + missingName,
		Recommendation: "Create a test file with at least basic unit tests for exported functions",
		Standard:       "testing-standards-v1",
	})

	return violations
}

var simulatedFilenamePattern = regexp.MustCompile(`(?i)filename:\s*([^\s(]+)`)

func extractSimulatedFilename(content string) string {
	matches := simulatedFilenamePattern.FindStringSubmatch(content)
	if len(matches) > 1 {
		return matches[1]
	}
	return ""
}
