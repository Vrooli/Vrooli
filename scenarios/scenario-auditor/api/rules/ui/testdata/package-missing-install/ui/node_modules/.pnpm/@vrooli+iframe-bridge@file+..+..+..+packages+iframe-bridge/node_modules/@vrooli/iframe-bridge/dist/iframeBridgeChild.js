const DEFAULT_LOG_BUFFER_SIZE = 500;
const DEFAULT_NETWORK_BUFFER_SIZE = 250;
const MIN_BUFFER_SIZE = 50;
const SERIALIZE_MAX_DEPTH = 3;
const SERIALIZE_MAX_KEYS = 20;
const SERIALIZE_MAX_STRING = 10000;
const LOG_LEVELS = ['log', 'info', 'warn', 'error', 'debug'];
const loadHtml2Canvas = (() => {
    let loader = null;
    return () => {
        if (typeof window !== 'undefined' && typeof window.html2canvas === 'function') {
            return Promise.resolve(window.html2canvas);
        }
        if (!loader) {
            loader = new Promise((resolve, reject) => {
                const existing = document.querySelector('script[data-html2canvas="true"]');
                if (existing) {
                    existing.addEventListener('load', () => {
                        if (typeof window.html2canvas === 'function') {
                            resolve(window.html2canvas);
                        }
                        else {
                            reject(new Error('html2canvas failed to initialize'));
                        }
                    });
                    existing.addEventListener('error', () => reject(new Error('Failed to load html2canvas script')));
                    return;
                }
                const script = document.createElement('script');
                script.src = 'https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js';
                script.async = true;
                script.crossOrigin = 'anonymous';
                script.dataset.html2canvas = 'true';
                script.onload = () => {
                    if (typeof window.html2canvas === 'function') {
                        resolve(window.html2canvas);
                    }
                    else {
                        reject(new Error('html2canvas failed to initialize'));
                    }
                };
                script.onerror = () => reject(new Error('Failed to load html2canvas script'));
                document.head.appendChild(script);
            });
        }
        return loader;
    };
})();
const clampClipToCanvas = (clip, canvasWidth, canvasHeight) => {
    const x = Math.min(Math.max(Math.round(clip.x), 0), canvasWidth);
    const y = Math.min(Math.max(Math.round(clip.y), 0), canvasHeight);
    const remainingWidth = canvasWidth - x;
    const remainingHeight = canvasHeight - y;
    if (remainingWidth <= 0 || remainingHeight <= 0) {
        return null;
    }
    const width = Math.max(1, Math.min(Math.round(clip.width), remainingWidth));
    const height = Math.max(1, Math.min(Math.round(clip.height), remainingHeight));
    if (width <= 0 || height <= 0) {
        return null;
    }
    return { x, y, width, height };
};
const scaleRect = (rect, factor) => {
    return {
        x: rect.x * factor,
        y: rect.y * factor,
        width: rect.width * factor,
        height: rect.height * factor,
    };
};
const getViewportRect = () => {
    const viewport = window.visualViewport;
    if (viewport) {
        const width = viewport.width > 0 ? viewport.width : window.innerWidth;
        const height = viewport.height > 0 ? viewport.height : window.innerHeight;
        return {
            x: Math.max(0, viewport.pageLeft),
            y: Math.max(0, viewport.pageTop),
            width: Math.max(1, width || document.documentElement.clientWidth || document.body.clientWidth || 0),
            height: Math.max(1, height || document.documentElement.clientHeight || document.body.clientHeight || 0),
        };
    }
    const width = Math.max(1, window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth || 0);
    const height = Math.max(1, window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight || 0);
    return {
        x: Math.max(0, window.scrollX),
        y: Math.max(0, window.scrollY),
        width,
        height,
    };
};
const inferParentOrigin = () => {
    try {
        if (document.referrer) {
            const referrer = new URL(document.referrer);
            return referrer.origin;
        }
    }
    catch (error) {
        console.warn('[BridgeChild] Failed to parse document.referrer', error);
    }
    return null;
};
const buildLocationPayload = () => ({
    v: 1,
    t: 'LOCATION',
    href: window.location.href,
    path: `${window.location.pathname}${window.location.search}${window.location.hash}`,
    title: document.title,
    canGoBack: true,
    canGoFwd: true,
});
const performanceNow = () => {
    if (typeof performance !== 'undefined' && typeof performance.now === 'function') {
        return performance.now();
    }
    return Date.now();
};
const elapsedMs = (start) => {
    const diff = performanceNow() - start;
    return diff < 0 ? 0 : diff;
};
const sanitizeBufferSize = (value, fallback) => {
    if (typeof value !== 'number' || !Number.isFinite(value)) {
        return Math.max(MIN_BUFFER_SIZE, fallback);
    }
    return Math.max(MIN_BUFFER_SIZE, Math.floor(value));
};
const createRingBuffer = (limit) => {
    let max = Math.max(MIN_BUFFER_SIZE, limit);
    let data = [];
    return {
        push: (value) => {
            data.push(value);
            if (data.length > max) {
                data.splice(0, data.length - max);
            }
        },
        values: () => data.slice(),
        setLimit: (next) => {
            max = Math.max(MIN_BUFFER_SIZE, next);
            if (data.length > max) {
                data.splice(0, data.length - max);
            }
        },
        clear: () => {
            data = [];
        },
    };
};
const serializeBridgeValue = (value, depth = 0, seen) => {
    if (value === null || typeof value === 'number' || typeof value === 'boolean') {
        return value;
    }
    if (typeof value === 'undefined') {
        return undefined;
    }
    if (typeof value === 'string') {
        return value.length > SERIALIZE_MAX_STRING ? `${value.slice(0, SERIALIZE_MAX_STRING)}…` : value;
    }
    if (typeof value === 'bigint') {
        return value.toString();
    }
    if (typeof value === 'symbol') {
        return value.toString();
    }
    if (typeof value === 'function') {
        return `[Function ${value.name || 'anonymous'}]`;
    }
    if (value instanceof Error) {
        return {
            name: value.name,
            message: value.message,
            stack: value.stack,
        };
    }
    if (value instanceof Date) {
        return value.toISOString();
    }
    if (typeof URL !== 'undefined' && value instanceof URL) {
        return value.toString();
    }
    if (typeof Node !== 'undefined' && value instanceof Node) {
        return `[DOM ${value.nodeName}]`;
    }
    if (Array.isArray(value)) {
        if (depth >= SERIALIZE_MAX_DEPTH) {
            return `[Array(${value.length})]`;
        }
        const seenSet = seen !== null && seen !== void 0 ? seen : new WeakSet();
        const limited = value.slice(0, SERIALIZE_MAX_KEYS).map(item => serializeBridgeValue(item, depth + 1, seenSet));
        if (value.length > SERIALIZE_MAX_KEYS) {
            limited.push(`…${value.length - SERIALIZE_MAX_KEYS} more`);
        }
        return limited;
    }
    if (value && typeof value === 'object') {
        const obj = value;
        const seenSet = seen !== null && seen !== void 0 ? seen : new WeakSet();
        if (seenSet.has(obj)) {
            return '[Circular]';
        }
        seenSet.add(obj);
        if (depth >= SERIALIZE_MAX_DEPTH) {
            return '[Object]';
        }
        const output = {};
        let count = 0;
        for (const [key, val] of Object.entries(obj)) {
            output[key] = serializeBridgeValue(val, depth + 1, seenSet);
            count += 1;
            if (count >= SERIALIZE_MAX_KEYS) {
                output.__truncated__ = true;
                break;
            }
        }
        return output;
    }
    return value;
};
const describeError = (error) => {
    if (error instanceof Error) {
        return error.message || error.name || 'Unknown error';
    }
    if (typeof error === 'string') {
        return error;
    }
    try {
        return JSON.stringify(error);
    }
    catch {
        return String(error);
    }
};
const createRequestId = (prefix) => {
    if (typeof crypto !== 'undefined' && typeof crypto.randomUUID === 'function') {
        return `${prefix}-${crypto.randomUUID()}`;
    }
    return `${prefix}-${Date.now()}-${Math.random().toString(16).slice(2)}`;
};
const normalizeLogOptions = (option) => {
    var _a, _b;
    if (option === false) {
        return { supported: false, enabled: false, streaming: false, bufferSize: DEFAULT_LOG_BUFFER_SIZE };
    }
    if (option === true || option === undefined) {
        return { supported: true, enabled: true, streaming: false, bufferSize: DEFAULT_LOG_BUFFER_SIZE };
    }
    const enabled = (_a = option.enabled) !== null && _a !== void 0 ? _a : true;
    const streaming = enabled ? (_b = option.streaming) !== null && _b !== void 0 ? _b : false : false;
    const bufferSize = sanitizeBufferSize(option.bufferSize, DEFAULT_LOG_BUFFER_SIZE);
    let levels;
    if (Array.isArray(option.levels) && option.levels.length > 0) {
        levels = option.levels.filter((level) => LOG_LEVELS.includes(level));
    }
    return { supported: true, enabled, streaming, bufferSize, levels };
};
const normalizeNetworkOptions = (option) => {
    var _a, _b;
    if (option === false) {
        return { supported: false, enabled: false, streaming: false, bufferSize: DEFAULT_NETWORK_BUFFER_SIZE };
    }
    if (option === true || option === undefined) {
        return { supported: true, enabled: true, streaming: false, bufferSize: DEFAULT_NETWORK_BUFFER_SIZE };
    }
    const enabled = (_a = option.enabled) !== null && _a !== void 0 ? _a : true;
    const streaming = enabled ? (_b = option.streaming) !== null && _b !== void 0 ? _b : false : false;
    const bufferSize = sanitizeBufferSize(option.bufferSize, DEFAULT_NETWORK_BUFFER_SIZE);
    return { supported: true, enabled, streaming, bufferSize };
};
const setupLogCapture = (post, options) => {
    if (!options.supported) {
        return null;
    }
    const buffer = createRingBuffer(options.bufferSize);
    let bufferLimit = options.bufferSize;
    let seq = 0;
    let enabled = options.enabled;
    let streaming = options.streaming;
    let levelFilter = options.levels ? new Set(options.levels) : undefined;
    const shouldRecordLevel = (level) => {
        if (!enabled) {
            return false;
        }
        if (!levelFilter || levelFilter.size === 0) {
            return true;
        }
        return levelFilter.has(level);
    };
    const recordEvent = (level, args, source, message, context) => {
        if (!shouldRecordLevel(level)) {
            return;
        }
        const event = {
            seq: ++seq,
            ts: Date.now(),
            level,
            args: args.map(arg => serializeBridgeValue(arg)),
            source,
            message,
            context,
        };
        buffer.push(event);
        if (streaming) {
            post({ v: 1, t: 'LOG_EVENT', event });
        }
    };
    const originalConsole = {};
    const consoleAny = console;
    LOG_LEVELS.forEach(level => {
        const existing = consoleAny[level];
        if (typeof existing !== 'function') {
            return;
        }
        originalConsole[level] = existing.bind(console);
        consoleAny[level] = (...args) => {
            var _a, _b;
            try {
                recordEvent(level, args, 'console');
            }
            catch (error) {
                const fallback = (_a = originalConsole.warn) !== null && _a !== void 0 ? _a : originalConsole.log;
                fallback === null || fallback === void 0 ? void 0 : fallback('[BridgeChild] Failed to record console event', error);
            }
            (_b = originalConsole[level]) === null || _b === void 0 ? void 0 : _b.call(originalConsole, ...args);
        };
    });
    const handleWindowError = (event) => {
        recordEvent('error', [event.message], 'runtime', event.message, {
            filename: event.filename,
            lineno: event.lineno,
            colno: event.colno,
            error: event.error ? serializeBridgeValue(event.error) : undefined,
        });
    };
    const handleUnhandledRejection = (event) => {
        recordEvent('error', [event.reason], 'runtime', undefined, {
            unhandledRejection: true,
            reason: serializeBridgeValue(event.reason),
        });
    };
    window.addEventListener('error', handleWindowError);
    window.addEventListener('unhandledrejection', handleUnhandledRejection);
    const snapshot = (options) => {
        let events = buffer.values();
        if (typeof (options === null || options === void 0 ? void 0 : options.afterSeq) === 'number') {
            events = events.filter(event => event.seq > options.afterSeq);
        }
        if (typeof (options === null || options === void 0 ? void 0 : options.since) === 'number') {
            events = events.filter(event => event.ts >= options.since);
        }
        if (typeof (options === null || options === void 0 ? void 0 : options.limit) === 'number' && options.limit > 0 && events.length > options.limit) {
            events = events.slice(events.length - options.limit);
        }
        return events;
    };
    const getState = () => ({
        enabled,
        streaming,
        levels: levelFilter && levelFilter.size > 0 ? Array.from(levelFilter) : undefined,
    });
    const setConfig = (command) => {
        if (typeof command.enable === 'boolean') {
            enabled = command.enable;
        }
        if (typeof command.streaming === 'boolean') {
            streaming = command.streaming;
        }
        if (typeof command.bufferSize === 'number') {
            bufferLimit = sanitizeBufferSize(command.bufferSize, bufferLimit);
            buffer.setLimit(bufferLimit);
        }
        if (Array.isArray(command.levels)) {
            if (command.levels.length === 0) {
                levelFilter = undefined;
            }
            else {
                const filtered = command.levels.filter((level) => LOG_LEVELS.includes(level));
                levelFilter = filtered.length > 0 ? new Set(filtered) : undefined;
            }
        }
        return getState();
    };
    const emitState = () => {
        post({ v: 1, t: 'LOG_STATE', state: getState() });
    };
    const dispose = () => {
        LOG_LEVELS.forEach(level => {
            if (originalConsole[level]) {
                consoleAny[level] = originalConsole[level];
            }
        });
        window.removeEventListener('error', handleWindowError);
        window.removeEventListener('unhandledrejection', handleUnhandledRejection);
        buffer.clear();
    };
    return {
        supported: true,
        recordConsole: (level, args) => recordEvent(level, args, 'console'),
        recordRuntimeError: (message, context) => recordEvent('error', [message], 'runtime', message, context),
        snapshot,
        setConfig,
        emitState,
        getState,
        dispose,
    };
};
const setupNetworkCapture = (post, options) => {
    if (!options.supported) {
        return null;
    }
    const buffer = createRingBuffer(options.bufferSize);
    let bufferLimit = options.bufferSize;
    let seq = 0;
    let enabled = options.enabled;
    let streaming = options.streaming;
    const recordEvent = (event) => {
        var _a;
        if (!enabled) {
            return;
        }
        const entry = {
            ...event,
            seq: ++seq,
            ts: (_a = event.ts) !== null && _a !== void 0 ? _a : Date.now(),
        };
        buffer.push(entry);
        if (streaming) {
            post({ v: 1, t: 'NETWORK_EVENT', event: entry });
        }
    };
    const snapshot = (options) => {
        let events = buffer.values();
        if (typeof (options === null || options === void 0 ? void 0 : options.afterSeq) === 'number') {
            events = events.filter(event => event.seq > options.afterSeq);
        }
        if (typeof (options === null || options === void 0 ? void 0 : options.since) === 'number') {
            events = events.filter(event => event.ts >= options.since);
        }
        if (typeof (options === null || options === void 0 ? void 0 : options.limit) === 'number' && options.limit > 0 && events.length > options.limit) {
            events = events.slice(events.length - options.limit);
        }
        return events;
    };
    const getState = () => ({ enabled, streaming });
    const setConfig = (command) => {
        if (typeof command.enable === 'boolean') {
            enabled = command.enable;
        }
        if (typeof command.streaming === 'boolean') {
            streaming = command.streaming;
        }
        if (typeof command.bufferSize === 'number') {
            bufferLimit = sanitizeBufferSize(command.bufferSize, bufferLimit);
            buffer.setLimit(bufferLimit);
        }
        return getState();
    };
    const emitState = () => {
        post({ v: 1, t: 'NETWORK_STATE', state: getState() });
    };
    const originalFetch = typeof window.fetch === 'function' ? window.fetch.bind(window) : undefined;
    if (originalFetch) {
        window.fetch = async (...args) => {
            var _a;
            const requestId = createRequestId('fetch');
            const { method, url } = (() => {
                var _a;
                try {
                    if (args[0] instanceof Request) {
                        return { method: args[0].method || 'GET', url: args[0].url };
                    }
                    const init = (_a = args[1]) !== null && _a !== void 0 ? _a : {};
                    const method = typeof init.method === 'string' ? init.method : 'GET';
                    return { method, url: typeof args[0] === 'string' ? args[0] : String(args[0]) };
                }
                catch {
                    return { method: 'GET', url: 'unknown' };
                }
            })();
            const upperMethod = ((_a = method === null || method === void 0 ? void 0 : method.toUpperCase) === null || _a === void 0 ? void 0 : _a.call(method)) || 'GET';
            const start = performanceNow();
            try {
                const response = await originalFetch(...args);
                recordEvent({
                    kind: 'fetch',
                    requestId,
                    method: upperMethod,
                    url,
                    status: response.status,
                    ok: response.ok,
                    durationMs: Math.round(elapsedMs(start)),
                });
                return response;
            }
            catch (error) {
                recordEvent({
                    kind: 'fetch',
                    requestId,
                    method: upperMethod,
                    url,
                    ok: false,
                    error: describeError(error),
                    durationMs: Math.round(elapsedMs(start)),
                });
                throw error;
            }
        };
    }
    const originalXHROpen = XMLHttpRequest.prototype.open;
    const originalXHRSend = XMLHttpRequest.prototype.send;
    XMLHttpRequest.prototype.open = function patchedOpen(method, url, async, username, password) {
        var _a;
        this.__vrooliBridgeMeta = {
            method: typeof method === 'string' ? method.toUpperCase() : 'GET',
            url: typeof url === 'string' ? url : (_a = url === null || url === void 0 ? void 0 : url.toString()) !== null && _a !== void 0 ? _a : 'unknown',
            requestId: createRequestId('xhr'),
            startTime: 0,
        };
        const normalizedAsync = typeof async === 'boolean' ? async : true;
        return originalXHROpen.call(this, method, url, normalizedAsync, username, password);
    };
    XMLHttpRequest.prototype.send = function patchedSend(body) {
        if (!this.__vrooliBridgeMeta) {
            this.__vrooliBridgeMeta = {
                method: 'GET',
                url: 'unknown',
                requestId: createRequestId('xhr'),
                startTime: 0,
            };
        }
        const meta = this.__vrooliBridgeMeta;
        meta.startTime = performanceNow();
        meta.completed = false;
        const finalize = (error) => {
            if (meta.completed) {
                return;
            }
            meta.completed = true;
            if (error) {
                recordEvent({
                    kind: 'xhr',
                    requestId: meta.requestId,
                    method: meta.method,
                    url: meta.url,
                    ok: false,
                    error,
                    durationMs: Math.round(elapsedMs(meta.startTime)),
                    readyState: this.readyState,
                    responseType: this.responseType,
                });
            }
            else {
                const status = this.status;
                recordEvent({
                    kind: 'xhr',
                    requestId: meta.requestId,
                    method: meta.method,
                    url: meta.url,
                    status,
                    ok: status >= 200 && status < 400,
                    durationMs: Math.round(elapsedMs(meta.startTime)),
                    readyState: this.readyState,
                    responseType: this.responseType,
                });
            }
        };
        this.addEventListener('loadend', () => finalize(), { once: true });
        this.addEventListener('error', () => finalize('error'), { once: true });
        this.addEventListener('abort', () => finalize('aborted'), { once: true });
        this.addEventListener('timeout', () => finalize('timeout'), { once: true });
        return originalXHRSend.apply(this, [body]);
    };
    const dispose = () => {
        buffer.clear();
        if (originalFetch) {
            window.fetch = originalFetch;
        }
        XMLHttpRequest.prototype.open = originalXHROpen;
        XMLHttpRequest.prototype.send = originalXHRSend;
    };
    return {
        supported: true,
        snapshot,
        setConfig,
        emitState,
        getState,
        dispose,
    };
};
export function initIframeBridgeChild(options = {}) {
    var _a, _b;
    if (typeof window === 'undefined' || typeof document === 'undefined') {
        return {
            notify: () => undefined,
            dispose: () => undefined,
        };
    }
    if (window.parent === window) {
        return {
            notify: () => undefined,
            dispose: () => undefined,
        };
    }
    if (window.__vrooliBridgeChildInstalled) {
        return {
            notify: () => undefined,
            dispose: () => undefined,
        };
    }
    const caps = ['history', 'hash', 'title', 'deeplink', 'screenshot'];
    let resolvedOrigin = (_b = (_a = options.parentOrigin) !== null && _a !== void 0 ? _a : inferParentOrigin()) !== null && _b !== void 0 ? _b : '*';
    const post = payload => {
        try {
            window.parent.postMessage(payload, resolvedOrigin);
        }
        catch (error) {
            console.warn('[BridgeChild] postMessage failed', error);
        }
    };
    const logCapture = setupLogCapture(post, normalizeLogOptions(options.captureLogs));
    if (logCapture === null || logCapture === void 0 ? void 0 : logCapture.supported) {
        caps.push('logs');
    }
    const networkCapture = setupNetworkCapture(post, normalizeNetworkOptions(options.captureNetwork));
    if (networkCapture === null || networkCapture === void 0 ? void 0 : networkCapture.supported) {
        caps.push('network');
    }
    const notify = () => {
        var _a;
        const payload = buildLocationPayload();
        post(payload);
        (_a = options.onNav) === null || _a === void 0 ? void 0 : _a.call(options, payload.href);
    };
    const handleMessage = (event) => {
        var _a;
        if (resolvedOrigin !== '*' && event.origin !== resolvedOrigin) {
            return;
        }
        if (resolvedOrigin === '*' && event.origin) {
            resolvedOrigin = event.origin;
        }
        const message = event.data;
        if (!message || typeof message !== 'object' || message.v !== 1) {
            return;
        }
        if (message.t === 'NAV') {
            try {
                if (message.cmd === 'BACK') {
                    history.back();
                }
                else if (message.cmd === 'FWD') {
                    history.forward();
                }
                else if (message.cmd === 'GO' && typeof message.to === 'string') {
                    const resolved = new URL(message.to, window.location.href);
                    if (resolved.origin !== window.location.origin) {
                        window.location.assign(resolved.href);
                        return;
                    }
                    history.pushState({}, '', `${resolved.pathname}${resolved.search}${resolved.hash}`);
                    window.dispatchEvent(new PopStateEvent('popstate', { state: history.state }));
                }
                notify();
            }
            catch (error) {
                post({ v: 1, t: 'ERROR', code: 'NAV_FAILED', detail: String((_a = error === null || error === void 0 ? void 0 : error.message) !== null && _a !== void 0 ? _a : error) });
            }
            return;
        }
        if (message.t === 'PING' && typeof message.ts === 'number') {
            post({ v: 1, t: 'PONG', ts: message.ts });
            return;
        }
        if (message.t === 'CAPTURE' && message.cmd === 'SCREENSHOT' && typeof message.id === 'string') {
            const capture = async () => {
                var _a;
                try {
                    const html2canvas = await loadHtml2Canvas();
                    const requestOptions = (typeof message.options === 'object' && message.options)
                        ? message.options
                        : {};
                    const scale = typeof requestOptions.scale === 'number' && Number.isFinite(requestOptions.scale) && requestOptions.scale > 0
                        ? requestOptions.scale
                        : window.devicePixelRatio || 1;
                    let captureMode = requestOptions.mode === 'full-page' ? 'full-page' : 'viewport';
                    const target = document.documentElement;
                    const captureOptions = {
                        scale,
                        logging: false,
                        useCORS: true,
                    };
                    let viewportRect = null;
                    if (captureMode === 'viewport') {
                        viewportRect = getViewportRect();
                        captureOptions.scrollX = viewportRect.x;
                        captureOptions.scrollY = viewportRect.y;
                        captureOptions.windowWidth = viewportRect.width;
                        captureOptions.windowHeight = viewportRect.height;
                        captureOptions.x = viewportRect.x;
                        captureOptions.y = viewportRect.y;
                        captureOptions.width = viewportRect.width;
                        captureOptions.height = viewportRect.height;
                    }
                    const canvas = await html2canvas(target, captureOptions);
                    let resultCanvas = canvas;
                    let note;
                    let clipMetadata;
                    if (captureMode === 'viewport') {
                        const effectiveViewport = viewportRect !== null && viewportRect !== void 0 ? viewportRect : getViewportRect();
                        const scaledClip = scaleRect(effectiveViewport, scale);
                        const clampedClip = clampClipToCanvas(scaledClip, canvas.width, canvas.height);
                        if (clampedClip) {
                            const requiresCrop = clampedClip.x !== 0
                                || clampedClip.y !== 0
                                || clampedClip.width !== canvas.width
                                || clampedClip.height !== canvas.height;
                            clipMetadata = {
                                x: clampedClip.x / scale,
                                y: clampedClip.y / scale,
                                width: clampedClip.width / scale,
                                height: clampedClip.height / scale,
                            };
                            if (requiresCrop) {
                                const viewportCanvas = document.createElement('canvas');
                                viewportCanvas.width = clampedClip.width;
                                viewportCanvas.height = clampedClip.height;
                                const context = viewportCanvas.getContext('2d');
                                if (context) {
                                    context.drawImage(canvas, clampedClip.x, clampedClip.y, clampedClip.width, clampedClip.height, 0, 0, clampedClip.width, clampedClip.height);
                                    resultCanvas = viewportCanvas;
                                    note = 'Captured the currently visible viewport.';
                                }
                            }
                            else {
                                note = 'Captured the currently visible viewport.';
                            }
                        }
                        else {
                            note = 'Unable to determine viewport bounds; captured the full page instead.';
                            captureMode = 'full-page';
                        }
                    }
                    const dataUrl = resultCanvas.toDataURL('image/png');
                    const base64 = dataUrl.replace(/^data:image\/png;base64,/, '');
                    post({
                        v: 1,
                        t: 'SCREENSHOT_RESULT',
                        id: message.id,
                        ok: true,
                        data: base64,
                        width: resultCanvas.width,
                        height: resultCanvas.height,
                        note,
                        mode: captureMode,
                        clip: clipMetadata,
                    });
                }
                catch (error) {
                    post({
                        v: 1,
                        t: 'SCREENSHOT_RESULT',
                        id: message.id,
                        ok: false,
                        error: (_a = error === null || error === void 0 ? void 0 : error.message) !== null && _a !== void 0 ? _a : String(error),
                    });
                }
            };
            void capture();
            return;
        }
        if (message.t === 'LOGS') {
            if (!logCapture) {
                return;
            }
            if (message.cmd === 'PULL' && typeof message.requestId === 'string') {
                const events = logCapture.snapshot(message.options);
                post({ v: 1, t: 'LOG_BATCH', requestId: message.requestId, events });
            }
            else if (message.cmd === 'SET') {
                const state = logCapture.setConfig(message);
                post({ v: 1, t: 'LOG_STATE', state });
            }
            return;
        }
        if (message.t === 'NETWORK') {
            if (!networkCapture) {
                return;
            }
            if (message.cmd === 'PULL' && typeof message.requestId === 'string') {
                const events = networkCapture.snapshot(message.options);
                post({ v: 1, t: 'NETWORK_BATCH', requestId: message.requestId, events });
            }
            else if (message.cmd === 'SET') {
                const state = networkCapture.setConfig(message);
                post({ v: 1, t: 'NETWORK_STATE', state });
            }
            return;
        }
    };
    const interceptHistory = () => {
        const originalPush = history.pushState;
        const originalReplace = history.replaceState;
        history.pushState = function pushState(...args) {
            originalPush.apply(history, args);
            notify();
        };
        history.replaceState = function replaceState(...args) {
            originalReplace.apply(history, args);
            notify();
        };
    };
    const setupObservers = () => {
        window.addEventListener('message', handleMessage);
        window.addEventListener('popstate', notify);
        window.addEventListener('hashchange', notify);
        if (document.readyState === 'complete') {
            notify();
        }
        else {
            window.addEventListener('load', notify, { once: true });
        }
        const titleElement = document.querySelector('title') || document.head;
        const observer = new MutationObserver(() => notify());
        observer.observe(titleElement, { childList: true, subtree: true });
        return observer;
    };
    window.__vrooliBridgeChildInstalled = true;
    post({
        v: 1,
        t: 'HELLO',
        appId: options.appId,
        title: document.title,
        caps,
        logs: logCapture ? logCapture.getState() : undefined,
        network: networkCapture ? networkCapture.getState() : undefined,
    });
    interceptHistory();
    const observer = setupObservers();
    queueMicrotask(() => {
        post({ v: 1, t: 'READY' });
        logCapture === null || logCapture === void 0 ? void 0 : logCapture.emitState();
        networkCapture === null || networkCapture === void 0 ? void 0 : networkCapture.emitState();
    });
    return {
        notify,
        dispose: () => {
            observer.disconnect();
            window.removeEventListener('message', handleMessage);
            window.removeEventListener('popstate', notify);
            window.removeEventListener('hashchange', notify);
            window.__vrooliBridgeChildInstalled = false;
            logCapture === null || logCapture === void 0 ? void 0 : logCapture.dispose();
            networkCapture === null || networkCapture === void 0 ? void 0 : networkCapture.dispose();
        },
    };
}
