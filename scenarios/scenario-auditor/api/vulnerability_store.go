package main

import (
	"encoding/json"
	"fmt"
	"os"
	"path/filepath"
	"scenario-auditor/scanners"
	"sort"
	"sync"
	"time"
)

// VulnerabilityStore provides persistent storage for vulnerabilities
type VulnerabilityStore struct {
	mu              sync.RWMutex
	vulnerabilities map[string][]StoredVulnerability // key is scenario name
	lastScan        map[string]time.Time             // key is scenario name
	filePath        string                           // path to persistent storage file
}

// VulnerabilityData represents the persistent data structure
type VulnerabilityData struct {
	Vulnerabilities map[string][]StoredVulnerability `json:"vulnerabilities"`
	LastScan        map[string]time.Time             `json:"last_scan"`
	LastUpdate      time.Time                        `json:"last_update"`
}

// StoredVulnerability represents a vulnerability in storage
type StoredVulnerability struct {
	ID             string     `json:"id"`
	ScenarioName   string     `json:"scenario_name"`
	Type           string     `json:"type"`
	Severity       string     `json:"severity"`
	Title          string     `json:"title"`
	Description    string     `json:"description"`
	FilePath       string     `json:"file_path"`
	LineNumber     int        `json:"line_number"`
	CodeSnippet    string     `json:"code_snippet,omitempty"`
	Recommendation string     `json:"recommendation"`
	Status         string     `json:"status"`
	DiscoveredAt   time.Time  `json:"discovered_at"`
	FixedAt        *time.Time `json:"fixed_at,omitempty"`
}

var vulnStore = initVulnerabilityStore()

func initVulnerabilityStore() *VulnerabilityStore {
	fmt.Fprintf(os.Stderr, "[INIT] Initializing vulnerability store...\n")
	store := &VulnerabilityStore{
		vulnerabilities: make(map[string][]StoredVulnerability),
		lastScan:        make(map[string]time.Time),
	}

	// Try to enable persistence, but don't fail if we can't
	fmt.Fprintf(os.Stderr, "[INIT] Enabling vulnerability store persistence...\n")
	store.enablePersistence()
	fmt.Fprintf(os.Stderr, "[INIT] Vulnerability store initialized\n")

	return store
}

// enablePersistence attempts to enable file-based persistence
func (vs *VulnerabilityStore) enablePersistence() {

	// Get Vrooli root directory
	vrooliRoot := os.Getenv("VROOLI_ROOT")
	if vrooliRoot == "" {
		vrooliRoot = os.Getenv("HOME") + "/Vrooli"
	}

	// Create data directory if it doesn't exist
	dataDir := filepath.Join(vrooliRoot, ".vrooli", "data", "scenario-auditor")

	// Check if parent directory exists first
	parentDir := filepath.Join(vrooliRoot, ".vrooli", "data")
	if _, err := os.Stat(parentDir); os.IsNotExist(err) {
		// Try to create parent directory structure
		if err := os.MkdirAll(parentDir, 0755); err != nil {
			logger.Error(fmt.Sprintf("Failed to create parent data directory %s", parentDir), err)
			logger.Info("Vulnerability store will operate in memory-only mode (no persistence)")
			return
		}
	}

	// Now create our specific directory
	if err := os.MkdirAll(dataDir, 0755); err != nil {
		logger.Error(fmt.Sprintf("Failed to create scenario-auditor data directory %s", dataDir), err)
		logger.Info("Vulnerability store will operate in memory-only mode (no persistence)")
		return
	}

	// Set the file path
	vs.filePath = filepath.Join(dataDir, "vulnerabilities.json")

	// Try to load existing data
	if err := vs.loadFromFile(); err != nil {
		logger.Error(fmt.Sprintf("Failed to load existing vulnerability data from %s", vs.filePath), err)
		// Continue anyway - we can still save new data
	} else {
		count := 0
		for _, vulns := range vs.vulnerabilities {
			count += len(vulns)
		}
		if count > 0 {
			logger.Info(fmt.Sprintf("Loaded %d existing vulnerabilities from persistent storage", count))
		}
	}

	logger.Info(fmt.Sprintf("Vulnerability store persistence enabled at: %s", vs.filePath))
}

// StoreVulnerabilities stores scan results in memory and optionally to disk
func (vs *VulnerabilityStore) StoreVulnerabilities(scenarioName string, result *scanners.AggregatedScanResult) {
	vs.mu.Lock()
	defer vs.mu.Unlock()

	// Clear existing vulnerabilities for this scenario
	vs.vulnerabilities[scenarioName] = []StoredVulnerability{}

	// Store new vulnerabilities
	for _, finding := range result.Findings {
		vuln := StoredVulnerability{
			ID:             finding.ID,
			ScenarioName:   scenarioName,
			Type:           finding.Category,
			Severity:       string(finding.Severity),
			Title:          finding.Title,
			Description:    finding.Description,
			FilePath:       finding.FilePath,
			LineNumber:     finding.LineNumber,
			CodeSnippet:    finding.CodeSnippet,
			Recommendation: finding.Recommendation,
			Status:         "open",
			DiscoveredAt:   time.Now(),
		}
		vs.vulnerabilities[scenarioName] = append(vs.vulnerabilities[scenarioName], vuln)
	}

	vs.lastScan[scenarioName] = time.Now()

	// Save to file if persistence is enabled
	if vs.filePath != "" {
		if err := vs.saveToFile(); err != nil {
			logger.Error("Failed to persist vulnerabilities to disk", err)
			// Continue anyway - in-memory storage still works
		}
	}
}

// GetVulnerabilities retrieves vulnerabilities from memory
func (vs *VulnerabilityStore) GetVulnerabilities(scenarioName string) []StoredVulnerability {
	vs.mu.RLock()
	defer vs.mu.RUnlock()

	if scenarioName == "" || scenarioName == "all" {
		// Return all vulnerabilities
		var allVulns []StoredVulnerability
		for _, vulns := range vs.vulnerabilities {
			allVulns = append(allVulns, vulns...)
		}
		return allVulns
	}

	return vs.vulnerabilities[scenarioName]
}

// GetAllVulnerabilities returns all stored vulnerabilities
func (vs *VulnerabilityStore) GetAllVulnerabilities() []StoredVulnerability {
	return vs.GetVulnerabilities("")
}

// ListScenarios returns the list of scenarios that have stored vulnerabilities.
func (vs *VulnerabilityStore) ListScenarios() []string {
	vs.mu.RLock()
	defer vs.mu.RUnlock()

	if len(vs.vulnerabilities) == 0 {
		return nil
	}

	names := make([]string, 0, len(vs.vulnerabilities))
	for scenario := range vs.vulnerabilities {
		names = append(names, scenario)
	}
	sort.Strings(names)
	return names
}

// GetLastScanTime returns when a scenario was last scanned
func (vs *VulnerabilityStore) GetLastScanTime(scenarioName string) *time.Time {
	vs.mu.RLock()
	defer vs.mu.RUnlock()

	if t, exists := vs.lastScan[scenarioName]; exists {
		return &t
	}
	return nil
}

// ClearVulnerabilities clears vulnerabilities for a scenario
func (vs *VulnerabilityStore) ClearVulnerabilities(scenarioName string) {
	vs.mu.Lock()
	defer vs.mu.Unlock()

	delete(vs.vulnerabilities, scenarioName)
	delete(vs.lastScan, scenarioName)

	// Save to file if persistence is enabled
	if vs.filePath != "" {
		if err := vs.saveToFile(); err != nil {
			logger.Error("Failed to persist cleared vulnerabilities to disk", err)
		}
	}
}

// GetStats returns vulnerability statistics
func (vs *VulnerabilityStore) GetStats() map[string]any {
	vs.mu.RLock()
	defer vs.mu.RUnlock()

	stats := map[string]any{
		"total":                          0,
		"critical":                       0,
		"high":                           0,
		"medium":                         0,
		"low":                            0,
		"info":                           0,
		"scenarios_with_vulnerabilities": 0,
	}

	scenariosWithVulns := make(map[string]bool)

	for scenario, vulns := range vs.vulnerabilities {
		if len(vulns) > 0 {
			scenariosWithVulns[scenario] = true
		}
		for _, vuln := range vulns {
			stats["total"] = stats["total"].(int) + 1
			switch vuln.Severity {
			case "critical":
				stats["critical"] = stats["critical"].(int) + 1
			case "high":
				stats["high"] = stats["high"].(int) + 1
			case "medium":
				stats["medium"] = stats["medium"].(int) + 1
			case "low":
				stats["low"] = stats["low"].(int) + 1
			case "info":
				stats["info"] = stats["info"].(int) + 1
			}
		}
	}

	stats["scenarios_with_vulnerabilities"] = len(scenariosWithVulns)
	return stats
}

// saveToFile persists the current data to disk
func (vs *VulnerabilityStore) saveToFile() error {
	// Skip persistence if no file path (in-memory mode)
	if vs.filePath == "" {
		return nil
	}

	data := VulnerabilityData{
		Vulnerabilities: vs.vulnerabilities,
		LastScan:        vs.lastScan,
		LastUpdate:      time.Now(),
	}

	jsonData, err := json.MarshalIndent(data, "", "  ")
	if err != nil {
		return fmt.Errorf("failed to marshal vulnerability data: %w", err)
	}

	if err := os.WriteFile(vs.filePath, jsonData, 0644); err != nil {
		return fmt.Errorf("failed to write vulnerability data to %s: %w", vs.filePath, err)
	}

	return nil
}

// loadFromFile loads persisted data from disk
func (vs *VulnerabilityStore) loadFromFile() error {
	// Skip loading if no file path (in-memory mode)
	if vs.filePath == "" {
		return nil
	}

	data, err := os.ReadFile(vs.filePath)
	if err != nil {
		if os.IsNotExist(err) {
			// File doesn't exist yet, that's okay
			return nil
		}
		return fmt.Errorf("failed to read vulnerability data from %s: %w", vs.filePath, err)
	}

	var vulnData VulnerabilityData
	if err := json.Unmarshal(data, &vulnData); err != nil {
		return fmt.Errorf("failed to unmarshal vulnerability data from %s: %w", vs.filePath, err)
	}

	// Load the data
	vs.vulnerabilities = vulnData.Vulnerabilities
	vs.lastScan = vulnData.LastScan

	// Initialize maps if they're nil
	if vs.vulnerabilities == nil {
		vs.vulnerabilities = make(map[string][]StoredVulnerability)
	}
	if vs.lastScan == nil {
		vs.lastScan = make(map[string]time.Time)
	}

	return nil
}
