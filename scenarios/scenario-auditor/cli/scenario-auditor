#!/bin/bash
################################################################################
# Scenario Auditor CLI - Lightweight API Wrapper
# 
# Standards enforcement for Vrooli scenarios
# Port discovery uses vrooli scenario port command for dynamic allocation
################################################################################

set -e

# Configuration
SCENARIO_NAME="scenario-auditor"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
NC='\033[0m' # No Color

# Track lifecycle management
AUDITOR_STARTED_BY_CLI=0

################################################################################
# Port Discovery - Dynamic port lookup
################################################################################
try_get_api_url() {
    local api_port
    api_port=$(vrooli scenario port "${SCENARIO_NAME}" API_PORT 2>/dev/null || true)
    if [[ -z "$api_port" ]]; then
        return 1
    fi
    printf "http://localhost:%s" "$api_port"
    return 0
}

get_api_url() {
    local url
    if url=$(try_get_api_url); then
        echo "$url"
        return 0
    fi

    echo -e "${RED}‚ùå Error: ${SCENARIO_NAME} is not running${NC}" >&2
    echo "   Start it with: vrooli scenario run ${SCENARIO_NAME}" >&2
    exit 1
}

ensure_auditor_running() {
    local url
    if url=$(try_get_api_url); then
        echo "$url"
        return 0
    fi

    echo -e "${YELLOW}‚öôÔ∏è  Starting ${SCENARIO_NAME}...${NC}" >&2
    if ! vrooli scenario run "${SCENARIO_NAME}" >/dev/null 2>&1; then
        echo -e "${RED}‚ùå Failed to start ${SCENARIO_NAME}${NC}" >&2
        exit 1
    fi

    AUDITOR_STARTED_BY_CLI=1

    local attempts=0
    local max_attempts=30
    local sleep_seconds=2
    while (( attempts < max_attempts )); do
        if url=$(try_get_api_url); then
            echo "$url"
            return 0
        fi
        sleep "$sleep_seconds"
        attempts=$((attempts+1))
    done

    echo -e "${RED}‚ùå Timed out waiting for ${SCENARIO_NAME} to start${NC}" >&2
    exit 1
}

cleanup_auditor() {
    if [[ "$AUDITOR_STARTED_BY_CLI" == "1" ]]; then
        echo -e "${BLUE}‚ÑπÔ∏è  Stopping ${SCENARIO_NAME}...${NC}" >&2
        vrooli scenario stop "${SCENARIO_NAME}" >/dev/null 2>&1 || true
        AUDITOR_STARTED_BY_CLI=0
    fi
}

trap cleanup_auditor EXIT

################################################################################
# Helper Functions
################################################################################
show_help() {
    echo -e "${CYAN}üîç Scenario Auditor CLI${NC}"
    echo "Standards enforcement for Vrooli scenarios"
    echo ""
    echo "Usage: scenario-auditor [command] [options]"
    echo ""
    echo "Commands:"
    echo "  scan [scenario]        Scan scenario for standards violations"
    echo "  audit [scenario] [--timeout SECONDS]"
    echo "                        Run security + standards scans and wait for results"
    echo "  rules [--category]     List available rules"
    echo "  fix [scenario] [--auto] Generate fixes for violations"
    echo "  test <rule-id>         Run tests for a specific rule"
    echo "  validate <rule-id>     Validate custom code against a rule (reads stdin)"
    echo "  test-coverage          Show test coverage metrics"
    echo "  test-cache clear [rule] Clear test cache"
    echo "  health                 Check API health"
    echo "  version                Show version"
    echo "  help                   Show this help"
    echo ""
    echo "Examples:"
    echo "  scenario-auditor scan ecosystem-manager"
    echo "  scenario-auditor audit ecosystem-manager --timeout 240"
    echo "  scenario-auditor rules --category config"
    echo "  scenario-auditor test content_type_headers"
    echo "  echo 'func handler(w http.ResponseWriter, r *http.Request) {...}' | scenario-auditor validate security_headers"
    echo "  scenario-auditor test-cache clear content_type_headers"
}

show_version() {
    local api_url
    api_url=$(get_api_url 2>/dev/null || echo "API not running")
    echo "scenario-auditor CLI v1.0.0"
    echo "API: ${api_url}"
}

# Format JSON output if jq is available
format_json() {
    if command -v jq >/dev/null 2>&1; then
        jq .
    else
        cat
    fi
}

# Make API request
api_request() {
    local method="$1"
    local endpoint="$2"
    local data="${3:-}"
    local api_url
    
    # Get the current API URL
    api_url=$(get_api_url)
    
    local curl_args=(-sS)
    
    if [[ "$method" != "GET" ]]; then
        curl_args+=(-X "$method")
    fi
    
    if [[ -n "$data" ]]; then
        curl_args+=(-H "Content-Type: application/json" -d "$data")
    fi

    local tmp_body
    tmp_body=$(mktemp)
    local http_code
    
    # Make request and capture both body and status code
    if ! http_code=$(curl "${curl_args[@]}" -w "%{http_code}" -o "$tmp_body" "${api_url}${endpoint}"); then
        echo -e "${RED}‚ùå Error: Failed to connect to API${NC}" >&2
        rm -f "$tmp_body"
        exit 1
    fi
    
    # Check status code
    if [[ "$http_code" -ge 400 ]]; then
        echo -e "${RED}‚ùå Error: HTTP $http_code${NC}" >&2
        cat "$tmp_body" >&2
        rm -f "$tmp_body"
        exit 1
    fi
    
    # Output response body
    cat "$tmp_body"
    rm -f "$tmp_body"
}

wait_for_job() {
    local endpoint="$1"
    local timeout="${2:-300}"
    local poll_interval="${3:-3}"
    local start_ts
    start_ts=$(date +%s)
    local last_state=""
    local last_message=""
    local response=""

    while true; do
        response=$(api_request "GET" "$endpoint")

        IFS=$'\t' read -r state message < <(printf '%s' "$response" | jq -r '[.status // .Status // .result.status // "unknown", .message // .result.message // ""] | @tsv')
        state=${state,,}

        if [[ "$state" != "$last_state" || "$message" != "$last_message" ]]; then
            local display="$state"
            if [[ -n "$message" && "$message" != "null" ]]; then
                display+=" - $message"
            fi
            echo -e "${BLUE}   ‚Ü≥ status: ${display}${NC}" >&2
            last_state="$state"
            last_message="$message"
        fi

        case "$state" in
            completed)
                echo "$response"
                return 0
                ;;
            failed|error|errored|cancelled|canceled)
                echo "$response"
                return 1
                ;;
        esac

        if [[ "$timeout" =~ ^[0-9]+$ ]]; then
            local now
            now=$(date +%s)
            if (( now - start_ts >= timeout )); then
                echo "$response"
                return 2
            fi
        fi

        sleep "$poll_interval"
    done
}

################################################################################
# Command Handlers
################################################################################

cmd_scan() {
    local scenario="${1:-current}"
    api_request "POST" "/api/v1/scenarios/$scenario/scan" "{}"
}

cmd_rules() {
    local endpoint="/api/v1/rules"
    if [[ "$1" == "--category" && -n "$2" ]]; then
        endpoint="/api/v1/rules?category=$2"
    fi
    api_request "GET" "$endpoint"
}

cmd_fix() {
    local scenario="${1:-current}"
    local auto_apply="false"
    if [[ "$2" == "--auto" ]]; then
        auto_apply="true"
    fi
    api_request "POST" "/api/v1/ai/fix/$scenario" "{\"auto_apply\": $auto_apply}"
}

cmd_test() {
    local rule_id="$1"
    if [[ -z "$rule_id" ]]; then
        echo -e "${RED}‚ùå Error: Rule ID is required${NC}" >&2
        echo "Usage: scenario-auditor test <rule-id>" >&2
        exit 1
    fi
    api_request "POST" "/api/v1/rules/$rule_id/test" "{}"
}

cmd_validate() {
    local rule_id="$1"
    if [[ -z "$rule_id" ]]; then
        echo -e "${RED}‚ùå Error: Rule ID is required${NC}" >&2
        echo "Usage: scenario-auditor validate <rule-id>" >&2
        echo "Note: Code input will be read from stdin" >&2
        exit 1
    fi
    
    # Read code from stdin
    local code
    code=$(cat)
    if [[ -z "$code" ]]; then
        echo -e "${RED}‚ùå Error: No code provided via stdin${NC}" >&2
        exit 1
    fi
    
    # Prepare JSON request
    local json_data
    json_data=$(jq -n --arg code "$code" --arg language "go" '{code: $code, language: $language}')
    
    api_request "POST" "/api/v1/rules/$rule_id/validate" "$json_data"
}

cmd_test_coverage() {
    api_request "GET" "/api/v1/rules/test-coverage"
}

cmd_test_cache() {
    if [[ "$1" != "clear" ]]; then
        echo -e "${RED}‚ùå Error: Invalid test-cache command${NC}" >&2
        echo "Usage: scenario-auditor test-cache clear [rule-id]" >&2
        exit 1
    fi
    
    local endpoint="/api/v1/rules/test-cache"
    if [[ -n "$2" ]]; then
        endpoint="/api/v1/rules/$2/test-cache"
    fi
    
    api_request "DELETE" "$endpoint"
}

cmd_health() {
    api_request "GET" "/api/v1/health"
}

cmd_audit() {
    local scenario="current"
    local timeout=300
    local run_security=1
    local run_standards=1

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --timeout)
                if [[ -z "$2" ]]; then
                    echo -e "${RED}‚ùå Error: --timeout requires a value${NC}" >&2
                    exit 1
                fi
                if ! [[ "$2" =~ ^[0-9]+$ ]]; then
                    echo -e "${RED}‚ùå Error: timeout must be a non-negative integer${NC}" >&2
                    exit 1
                fi
                timeout="$2"
                shift 2
                ;;
            --security-only)
                run_standards=0
                shift
                ;;
            --standards-only)
                run_security=0
                shift
                ;;
            --help|-h)
                echo "Usage: scenario-auditor audit [scenario] [--timeout SECONDS] [--security-only|--standards-only]" >&2
                return 0
                ;;
            --*)
                echo -e "${RED}‚ùå Error: Unknown option $1${NC}" >&2
                exit 1
                ;;
            *)
                scenario="$1"
                shift
                ;;
        esac
    done

    if (( run_security == 0 && run_standards == 0 )); then
        echo -e "${RED}‚ùå Error: Both security and standards scans disabled${NC}" >&2
        exit 1
    fi

    local api_url
    api_url=$(ensure_auditor_running)
    echo -e "${BLUE}‚ÑπÔ∏è  Scenario Auditor API: ${api_url}${NC}" >&2

    local security_job=""
    local security_status=""
    local security_rc=0
    local security_outcome="skipped"

    local standards_job=""
    local standards_status=""
    local standards_rc=0
    local standards_outcome="skipped"

    if (( run_security == 1 )); then
        echo -e "${CYAN}üîê Starting security scan for ${scenario}...${NC}" >&2
        local security_start
        security_start=$(api_request "POST" "/api/v1/scenarios/${scenario}/scan" "{}")
        security_job=$(echo "$security_start" | jq -r '.job_id // .status.id // empty')
        if [[ -z "$security_job" || "$security_job" == "null" ]]; then
            echo -e "${RED}‚ùå Error: Failed to obtain security scan job id${NC}" >&2
            echo "$security_start" | format_json >&2
            exit 1
        fi

        echo -e "${BLUE}   ‚Ü≥ job id: ${security_job}${NC}" >&2
        local security_endpoint="/api/v1/scenarios/scan/jobs/${security_job}"

        set +e
        security_status=$(wait_for_job "$security_endpoint" "$timeout")
        security_rc=$?
        set -e

        case "$security_rc" in
            0)
                security_outcome="completed"
                echo -e "${GREEN}‚úÖ Security scan completed${NC}" >&2
                ;;
            1)
                security_outcome="failed"
                echo -e "${RED}‚ùå Security scan failed${NC}" >&2
                ;;
            2)
                security_outcome="timeout"
                echo -e "${YELLOW}‚è≥ Security scan timed out after ${timeout}s${NC}" >&2
                ;;
            *)
                security_outcome="unknown"
                echo -e "${YELLOW}‚ö†Ô∏è  Security scan finished with unexpected status (${security_rc})${NC}" >&2
                ;;
        esac
    fi

    if (( run_standards == 1 )); then
        echo -e "${CYAN}üìè Starting standards scan for ${scenario}...${NC}" >&2
        local standards_start
        standards_start=$(api_request "POST" "/api/v1/standards/check/${scenario}" '{"type":"full"}')
        standards_job=$(echo "$standards_start" | jq -r '.job_id // .status.id // empty')
        if [[ -z "$standards_job" || "$standards_job" == "null" ]]; then
            echo -e "${RED}‚ùå Error: Failed to obtain standards scan job id${NC}" >&2
            echo "$standards_start" | format_json >&2
            exit 1
        fi

        echo -e "${BLUE}   ‚Ü≥ job id: ${standards_job}${NC}" >&2
        local standards_endpoint="/api/v1/standards/check/jobs/${standards_job}"

        set +e
        standards_status=$(wait_for_job "$standards_endpoint" "$timeout")
        standards_rc=$?
        set -e

        case "$standards_rc" in
            0)
                standards_outcome="completed"
                echo -e "${GREEN}‚úÖ Standards scan completed${NC}" >&2
                ;;
            1)
                standards_outcome="failed"
                echo -e "${RED}‚ùå Standards scan failed${NC}" >&2
                ;;
            2)
                standards_outcome="timeout"
                echo -e "${YELLOW}‚è≥ Standards scan timed out after ${timeout}s${NC}" >&2
                ;;
            *)
                standards_outcome="unknown"
                echo -e "${YELLOW}‚ö†Ô∏è  Standards scan finished with unexpected status (${standards_rc})${NC}" >&2
                ;;
        esac
    fi

    local combined
    combined=$(jq -n \
        --arg scenario "$scenario" \
        --argjson timeout "$timeout" \
        '{scenario: $scenario, timeout_seconds: ($timeout|tonumber), security: null, standards: null}')

    if (( run_security == 1 )); then
        local security_status_json
        if [[ -z "$security_status" ]]; then
            security_status_json="null"
        else
            security_status_json="$security_status"
        fi
        combined=$(echo "$combined" | jq \
            --arg outcome "$security_outcome" \
            --arg job "$security_job" \
            --arg endpoint "/api/v1/scenarios/scan/jobs/${security_job}" \
            --argjson status "$security_status_json" \
            '.security = {
                job_id: $job,
                poll_endpoint: $endpoint,
                outcome: $outcome,
                status: $status
            }')
    else
        combined=$(echo "$combined" | jq --arg outcome "$security_outcome" '.security = {outcome: $outcome}')
    fi

    if (( run_standards == 1 )); then
        local standards_status_json
        if [[ -z "$standards_status" ]]; then
            standards_status_json="null"
        else
            standards_status_json="$standards_status"
        fi
        combined=$(echo "$combined" | jq \
            --arg outcome "$standards_outcome" \
            --arg job "$standards_job" \
            --arg endpoint "/api/v1/standards/check/jobs/${standards_job}" \
            --argjson status "$standards_status_json" \
            '.standards = {
                job_id: $job,
                poll_endpoint: $endpoint,
                outcome: $outcome,
                status: $status
            }')
    else
        combined=$(echo "$combined" | jq --arg outcome "$standards_outcome" '.standards = {outcome: $outcome}')
    fi

    echo "$combined" | format_json

    # If we started the scenario for this run, stop it now (trap will be a safety net)
    cleanup_auditor
}

################################################################################
# Main
################################################################################

main() {
    if [[ $# -eq 0 ]]; then
        show_help
        exit 1
    fi

    local command="$1"
    shift

    case "$command" in
        scan)
            cmd_scan "$@"
            ;;
        audit)
            cmd_audit "$@"
            ;;
        rules)
            cmd_rules "$@"
            ;;
        fix)
            cmd_fix "$@"
            ;;
        test)
            cmd_test "$@"
            ;;
        validate)
            cmd_validate "$@"
            ;;
        test-coverage)
            cmd_test_coverage
            ;;
        test-cache)
            cmd_test_cache "$@"
            ;;
        health)
            cmd_health
            ;;
        version)
            show_version
            ;;
        help|--help|-h)
            show_help
            ;;
        *)
            echo -e "${RED}‚ùå Error: Unknown command: $command${NC}" >&2
            echo ""
            show_help
            exit 1
            ;;
    esac
}

main "$@"
