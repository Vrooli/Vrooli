<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Scenario Dependency Analyzer - Vrooli Intelligence System</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        /* Technical NASA mission control aesthetic */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: linear-gradient(135deg, #0f0f23 0%, #1a1a2e 50%, #16213e 100%);
            color: #00ff00;
            font-family: 'Courier New', monospace;
            overflow-x: hidden;
            min-height: 100vh;
        }

        .header {
            background: rgba(0, 0, 0, 0.8);
            border-bottom: 2px solid #00ff00;
            padding: 1rem;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            z-index: 1000;
            backdrop-filter: blur(10px);
        }

        .header h1 {
            color: #00ff00;
            text-align: center;
            text-shadow: 0 0 10px #00ff00;
            font-size: 1.5rem;
            letter-spacing: 2px;
        }

        .header .subtitle {
            text-align: center;
            color: #00cccc;
            font-size: 0.8rem;
            margin-top: 0.5rem;
            opacity: 0.8;
        }

        .controls {
            position: fixed;
            top: 80px;
            left: 20px;
            background: rgba(0, 0, 0, 0.9);
            border: 1px solid #00ff00;
            border-radius: 5px;
            padding: 1rem;
            max-width: 300px;
            backdrop-filter: blur(5px);
            box-shadow: 0 0 20px rgba(0, 255, 0, 0.3);
        }

        .controls h3 {
            color: #00cccc;
            margin-bottom: 1rem;
            text-shadow: 0 0 5px #00cccc;
        }

        .control-group {
            margin-bottom: 1rem;
        }

        .control-group label {
            display: block;
            color: #ffffff;
            margin-bottom: 0.5rem;
            font-size: 0.9rem;
        }

        .control-group select,
        .control-group input,
        .control-group button {
            width: 100%;
            padding: 0.5rem;
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid #00ff00;
            color: #00ff00;
            border-radius: 3px;
            font-family: inherit;
        }

        .control-group button {
            background: rgba(0, 255, 0, 0.1);
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .control-group button:hover {
            background: rgba(0, 255, 0, 0.2);
            box-shadow: 0 0 10px rgba(0, 255, 0, 0.5);
        }

        .stats {
            position: fixed;
            top: 80px;
            right: 20px;
            background: rgba(0, 0, 0, 0.9);
            border: 1px solid #00ff00;
            border-radius: 5px;
            padding: 1rem;
            backdrop-filter: blur(5px);
            box-shadow: 0 0 20px rgba(0, 255, 0, 0.3);
        }

        .stats h3 {
            color: #00cccc;
            margin-bottom: 1rem;
            text-shadow: 0 0 5px #00cccc;
        }

        .stat-item {
            display: flex;
            justify-content: space-between;
            margin-bottom: 0.5rem;
            font-size: 0.9rem;
        }

        .stat-label {
            color: #ffffff;
        }

        .stat-value {
            color: #00ff00;
            font-weight: bold;
        }

        #graph-container {
            position: fixed;
            top: 80px;
            left: 0;
            right: 0;
            bottom: 0;
            background: radial-gradient(circle at center, rgba(0, 50, 0, 0.1) 0%, rgba(0, 0, 0, 0.9) 100%);
        }

        #graph-svg {
            width: 100%;
            height: 100%;
            cursor: grab;
        }

        #graph-svg:active {
            cursor: grabbing;
        }

        /* Node and edge styles */
        .node {
            stroke-width: 2;
            cursor: pointer;
        }

        .node.scenario {
            fill: #0066cc;
            stroke: #00ccff;
        }

        .node.resource {
            fill: #cc6600;
            stroke: #ffcc00;
        }

        .node.workflow {
            fill: #cc0066;
            stroke: #ff00cc;
        }

        .node:hover {
            stroke-width: 4;
            filter: brightness(1.5);
        }

        .node.selected {
            stroke-width: 3;
            stroke: #ffffff;
            filter: brightness(1.2);
        }

        .link {
            stroke-width: 2;
            stroke-opacity: 0.6;
        }

        .link.required {
            stroke: #ff0000;
            stroke-width: 3;
        }

        .link.optional {
            stroke: #00ff00;
            stroke-dasharray: 5,5;
        }

        .node-label {
            fill: #ffffff;
            text-anchor: middle;
            font-size: 12px;
            font-family: 'Courier New', monospace;
            pointer-events: none;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
        }

        .tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.95);
            border: 1px solid #00ff00;
            border-radius: 5px;
            padding: 1rem;
            color: #ffffff;
            font-size: 0.9rem;
            pointer-events: none;
            z-index: 1001;
            max-width: 300px;
            box-shadow: 0 0 20px rgba(0, 255, 0, 0.5);
        }

        .tooltip h4 {
            color: #00ccff;
            margin-bottom: 0.5rem;
            text-shadow: 0 0 5px #00ccff;
        }

        .tooltip .meta {
            color: #00ff00;
            font-size: 0.8rem;
            margin-top: 0.5rem;
        }

        .loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #00ff00;
            font-size: 1.2rem;
            text-align: center;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .error {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #ff0000;
            background: rgba(0, 0, 0, 0.9);
            border: 2px solid #ff0000;
            border-radius: 10px;
            padding: 2rem;
            text-align: center;
            box-shadow: 0 0 20px rgba(255, 0, 0, 0.5);
        }

        /* Responsive design */
        @media (max-width: 768px) {
            .controls, .stats {
                position: static;
                max-width: none;
                margin: 1rem;
            }
            
            #graph-container {
                top: auto;
                position: static;
                height: 400px;
            }
        }

        /* Matrix-style background animation */
        .matrix-bg {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: -1;
            opacity: 0.1;
        }
    </style>
</head>
<body>
    <!-- Matrix-style background -->
    <canvas class="matrix-bg" id="matrix-canvas"></canvas>

    <!-- Header -->
    <div class="header">
        <h1>VROOLI DEPENDENCY INTELLIGENCE SYSTEM</h1>
        <div class="subtitle">Meta-Intelligence for Deployment Optimization and Capability Planning</div>
    </div>

    <!-- Controls -->
    <div class="controls">
        <h3>CONTROL PANEL</h3>
        
        <div class="control-group">
            <label for="graph-type">Graph Type:</label>
            <select id="graph-type">
                <option value="combined">Combined Dependencies</option>
                <option value="resources">Resource Dependencies</option>
                <option value="scenarios">Scenario Dependencies</option>
            </select>
        </div>

        <div class="control-group">
            <label for="layout-type">Layout Algorithm:</label>
            <select id="layout-type">
                <option value="force">Force Directed</option>
                <option value="circular">Circular</option>
                <option value="tree">Hierarchical Tree</option>
            </select>
        </div>

        <div class="control-group">
            <label for="filter-input">Filter Nodes:</label>
            <input type="text" id="filter-input" placeholder="Enter scenario name...">
        </div>

        <div class="control-group">
            <button id="refresh-btn">REFRESH DATA</button>
        </div>

        <div class="control-group">
            <button id="analyze-all-btn">ANALYZE ALL SCENARIOS</button>
        </div>

        <div class="control-group">
            <button id="export-btn">EXPORT GRAPH</button>
        </div>
    </div>

    <!-- Statistics -->
    <div class="stats">
        <h3>SYSTEM STATUS</h3>
        <div class="stat-item">
            <span class="stat-label">Total Nodes:</span>
            <span class="stat-value" id="total-nodes">0</span>
        </div>
        <div class="stat-item">
            <span class="stat-label">Total Edges:</span>
            <span class="stat-value" id="total-edges">0</span>
        </div>
        <div class="stat-item">
            <span class="stat-label">Scenarios:</span>
            <span class="stat-value" id="scenario-count">0</span>
        </div>
        <div class="stat-item">
            <span class="stat-label">Resources:</span>
            <span class="stat-value" id="resource-count">0</span>
        </div>
        <div class="stat-item">
            <span class="stat-label">Complexity:</span>
            <span class="stat-value" id="complexity-score">0.0</span>
        </div>
        <div class="stat-item">
            <span class="stat-label">API Status:</span>
            <span class="stat-value" id="api-status">UNKNOWN</span>
        </div>
    </div>

    <!-- Graph Container -->
    <div id="graph-container">
        <svg id="graph-svg"></svg>
    </div>

    <!-- Tooltip -->
    <div id="tooltip" class="tooltip" style="display: none;"></div>

    <!-- Loading indicator -->
    <div id="loading" class="loading" style="display: none;">
        ANALYZING DEPENDENCIES...<br>
        <small>Scanning Vrooli intelligence system...</small>
    </div>

    <!-- Error display -->
    <div id="error" class="error" style="display: none;"></div>

    <script>
        // Configuration
        const API_BASE_URL = `http://localhost:${window.location.hostname === 'localhost' ? '20400' : location.port}`;
        
        // Global state
        let currentGraph = null;
        let selectedNode = null;
        let simulation = null;

        // DOM elements
        const graphSvg = d3.select('#graph-svg');
        const tooltip = d3.select('#tooltip');
        const loading = d3.select('#loading');
        const error = d3.select('#error');

        // Initialize matrix background
        function initMatrixBackground() {
            const canvas = document.getElementById('matrix-canvas');
            const ctx = canvas.getContext('2d');
            
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            
            const chars = '0123456789ABCDEF';
            const drops = [];
            
            for (let i = 0; i < canvas.width / 10; i++) {
                drops[i] = 1;
            }
            
            function drawMatrix() {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.05)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                ctx.fillStyle = '#00ff00';
                ctx.font = '10px monospace';
                
                for (let i = 0; i < drops.length; i++) {
                    const text = chars[Math.floor(Math.random() * chars.length)];
                    ctx.fillText(text, i * 10, drops[i] * 10);
                    
                    if (drops[i] * 10 > canvas.height && Math.random() > 0.975) {
                        drops[i] = 0;
                    }
                    drops[i]++;
                }
            }
            
            setInterval(drawMatrix, 100);
        }

        // API functions
        async function checkAPIHealth() {
            try {
                const response = await fetch(`${API_BASE_URL}/health`);
                const data = await response.json();
                document.getElementById('api-status').textContent = data.status.toUpperCase();
                return response.ok;
            } catch (e) {
                document.getElementById('api-status').textContent = 'OFFLINE';
                return false;
            }
        }

        async function loadGraphData(type = 'combined') {
            try {
                showLoading(true);
                
                const response = await fetch(`${API_BASE_URL}/api/v1/graph/${type}`);
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                const data = await response.json();
                currentGraph = data;
                
                updateStats(data);
                renderGraph(data);
                
                showLoading(false);
                return data;
            } catch (e) {
                showError(`Failed to load graph data: ${e.message}`);
                showLoading(false);
                throw e;
            }
        }

        async function analyzeAllScenarios() {
            try {
                showLoading(true, 'ANALYZING ALL SCENARIOS...\nThis may take a few minutes...');
                
                const response = await fetch(`${API_BASE_URL}/api/v1/analyze/all`);
                if (!response.ok) {
                    throw new Error(`Analysis failed: ${response.status}`);
                }
                
                const data = await response.json();
                
                // Refresh the graph after analysis
                await loadGraphData(document.getElementById('graph-type').value);
                
                showLoading(false);
                showSuccess('All scenarios analyzed successfully');
            } catch (e) {
                showError(`Analysis failed: ${e.message}`);
                showLoading(false);
            }
        }

        // UI helper functions
        function showLoading(show, message = 'ANALYZING DEPENDENCIES...') {
            if (show) {
                loading.style('display', 'block');
                loading.html(message + '<br><small>Scanning Vrooli intelligence system...</small>');
            } else {
                loading.style('display', 'none');
            }
        }

        function showError(message) {
            error.style('display', 'block');
            error.html(`<h3>SYSTEM ERROR</h3><p>${message}</p><button onclick="hideError()">ACKNOWLEDGE</button>`);
        }

        function hideError() {
            error.style('display', 'none');
        }

        function showSuccess(message) {
            // Create temporary success notification
            const success = d3.select('body')
                .append('div')
                .attr('class', 'success')
                .style('position', 'fixed')
                .style('top', '100px')
                .style('right', '20px')
                .style('background', 'rgba(0, 255, 0, 0.2)')
                .style('border', '1px solid #00ff00')
                .style('border-radius', '5px')
                .style('padding', '1rem')
                .style('color', '#00ff00')
                .style('z-index', '1002')
                .text(message);
            
            setTimeout(() => success.remove(), 3000);
        }

        function updateStats(data) {
            document.getElementById('total-nodes').textContent = data.nodes.length;
            document.getElementById('total-edges').textContent = data.edges.length;
            
            const scenarioCount = data.nodes.filter(n => n.type === 'scenario').length;
            const resourceCount = data.nodes.filter(n => n.type === 'resource').length;
            
            document.getElementById('scenario-count').textContent = scenarioCount;
            document.getElementById('resource-count').textContent = resourceCount;
            document.getElementById('complexity-score').textContent = 
                (data.metadata && data.metadata.complexity_score) ? 
                data.metadata.complexity_score.toFixed(2) : '0.00';
        }

        // Graph rendering
        function renderGraph(data) {
            // Clear previous graph
            graphSvg.selectAll('*').remove();
            
            const width = window.innerWidth;
            const height = window.innerHeight - 80;
            
            graphSvg.attr('width', width).attr('height', height);
            
            // Create zoom behavior
            const zoom = d3.zoom()
                .scaleExtent([0.1, 4])
                .on('zoom', (event) => {
                    container.attr('transform', event.transform);
                });
            
            graphSvg.call(zoom);
            
            const container = graphSvg.append('g');
            
            // Create simulation
            simulation = d3.forceSimulation(data.nodes)
                .force('link', d3.forceLink(data.edges).id(d => d.id).distance(100))
                .force('charge', d3.forceManyBody().strength(-300))
                .force('center', d3.forceCenter(width / 2, height / 2));
            
            // Create links
            const link = container.append('g')
                .selectAll('line')
                .data(data.edges)
                .enter().append('line')
                .attr('class', d => `link ${d.required ? 'required' : 'optional'}`)
                .attr('stroke', d => d.required ? '#ff4444' : '#44ff44');
            
            // Create nodes
            const node = container.append('g')
                .selectAll('circle')
                .data(data.nodes)
                .enter().append('circle')
                .attr('class', d => `node ${d.type}`)
                .attr('r', d => {
                    const baseSize = 12;
                    const connections = data.edges.filter(e => e.source.id === d.id || e.target.id === d.id).length;
                    return baseSize + Math.min(connections * 2, 20);
                })
                .call(d3.drag()
                    .on('start', dragStarted)
                    .on('drag', dragged)
                    .on('end', dragEnded));
            
            // Add labels
            const label = container.append('g')
                .selectAll('text')
                .data(data.nodes)
                .enter().append('text')
                .attr('class', 'node-label')
                .text(d => d.label)
                .attr('dy', -15);
            
            // Add event handlers
            node
                .on('mouseover', (event, d) => showTooltip(event, d))
                .on('mouseout', hideTooltip)
                .on('click', (event, d) => selectNode(d));
            
            // Update positions on simulation tick
            simulation.on('tick', () => {
                link
                    .attr('x1', d => d.source.x)
                    .attr('y1', d => d.source.y)
                    .attr('x2', d => d.target.x)
                    .attr('y2', d => d.target.y);
                
                node
                    .attr('cx', d => d.x)
                    .attr('cy', d => d.y);
                
                label
                    .attr('x', d => d.x)
                    .attr('y', d => d.y);
            });
        }

        // Node interaction functions
        function dragStarted(event, d) {
            if (!event.active) simulation.alphaTarget(0.3).restart();
            d.fx = d.x;
            d.fy = d.y;
        }

        function dragged(event, d) {
            d.fx = event.x;
            d.fy = event.y;
        }

        function dragEnded(event, d) {
            if (!event.active) simulation.alphaTarget(0);
            d.fx = null;
            d.fy = null;
        }

        function showTooltip(event, d) {
            const tooltipContent = `
                <h4>${d.label}</h4>
                <div><strong>Type:</strong> ${d.type}</div>
                <div><strong>Group:</strong> ${d.group}</div>
                ${d.metadata && d.metadata.purpose ? `<div><strong>Purpose:</strong> ${d.metadata.purpose}</div>` : ''}
                <div class="meta">Click to select and highlight connections</div>
            `;
            
            tooltip
                .style('display', 'block')
                .html(tooltipContent)
                .style('left', (event.pageX + 10) + 'px')
                .style('top', (event.pageY - 10) + 'px');
        }

        function hideTooltip() {
            tooltip.style('display', 'none');
        }

        function selectNode(node) {
            selectedNode = node;
            
            // Update visual selection
            d3.selectAll('.node').classed('selected', false);
            d3.selectAll('.node').filter(d => d.id === node.id).classed('selected', true);
            
            // Highlight connected edges
            d3.selectAll('.link')
                .style('opacity', d => 
                    (d.source.id === node.id || d.target.id === node.id) ? 1 : 0.2
                );
        }

        // Event handlers
        document.getElementById('graph-type').addEventListener('change', (e) => {
            loadGraphData(e.target.value);
        });

        document.getElementById('refresh-btn').addEventListener('click', () => {
            const graphType = document.getElementById('graph-type').value;
            loadGraphData(graphType);
        });

        document.getElementById('analyze-all-btn').addEventListener('click', () => {
            analyzeAllScenarios();
        });

        document.getElementById('export-btn').addEventListener('click', () => {
            if (currentGraph) {
                const dataStr = JSON.stringify(currentGraph, null, 2);
                const dataBlob = new Blob([dataStr], {type: 'application/json'});
                const url = URL.createObjectURL(dataBlob);
                const link = document.createElement('a');
                link.href = url;
                link.download = `dependency-graph-${new Date().toISOString().split('T')[0]}.json`;
                link.click();
                URL.revokeObjectURL(url);
            }
        });

        // Filter functionality
        document.getElementById('filter-input').addEventListener('input', (e) => {
            const filterValue = e.target.value.toLowerCase();
            
            if (currentGraph) {
                d3.selectAll('.node')
                    .style('opacity', d => 
                        filterValue === '' || d.label.toLowerCase().includes(filterValue) ? 1 : 0.3
                    );
                
                d3.selectAll('.node-label')
                    .style('opacity', d => 
                        filterValue === '' || d.label.toLowerCase().includes(filterValue) ? 1 : 0.3
                    );
            }
        });

        // Initialize application
        async function init() {
            initMatrixBackground();
            
            const isHealthy = await checkAPIHealth();
            
            if (isHealthy) {
                await loadGraphData('combined');
            } else {
                showError('API server is not available. Please ensure the scenario is running.');
            }
            
            // Refresh API status every 30 seconds
            setInterval(checkAPIHealth, 30000);
        }

        // Handle window resize
        window.addEventListener('resize', () => {
            if (currentGraph) {
                renderGraph(currentGraph);
            }
        });

        // Start the application
        init();
    </script>
</body>
</html>