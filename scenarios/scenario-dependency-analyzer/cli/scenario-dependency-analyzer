#!/bin/bash

# Scenario Dependency Analyzer CLI
# Provides command-line interface for dependency analysis and graph generation

set -euo pipefail

# Configuration
API_PORT="${DEPENDENCY_ANALYZER_API_PORT:-20400}"
API_BASE_URL="http://localhost:${API_PORT}"
CLI_VERSION="1.0.0"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
PURPLE='\033[0;35m'
CYAN='\033[0;36m'
NC='\033[0m' # No Color

# Utility functions
log_info() {
    echo -e "${BLUE}[INFO]${NC} $1" >&2
}

log_success() {
    echo -e "${GREEN}[SUCCESS]${NC} $1" >&2
}

log_warning() {
    echo -e "${YELLOW}[WARNING]${NC} $1" >&2
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $1" >&2
}

# Check if API is available
check_api_health() {
    if curl -sf "$API_BASE_URL/health" >/dev/null 2>&1; then
        return 0
    else
        return 1
    fi
}

# Format JSON output for human readability
format_json() {
    if command -v jq >/dev/null 2>&1; then
        jq '.' 
    else
        cat
    fi
}

# Format table output
format_table() {
    local data="$1"
    local format="${2:-table}"
    
    if [[ "$format" == "json" ]]; then
        echo "$data" | format_json
        return
    fi
    
    # Simple table formatting using jq if available
    if command -v jq >/dev/null 2>&1; then
        echo "$data" | jq -r '
            if type == "array" then
                .[] | [.scenario_name // .dependency_name, .dependency_type // .type, .required // true, .purpose // .description] | @tsv
            elif type == "object" and has("resources") then
                .resources[]? | [.scenario_name, .dependency_type, .dependency_name, .required, .purpose] | @tsv
            else
                . | to_entries | .[] | [.key, .value] | @tsv
            end' | column -t -s $'\t' 2>/dev/null || echo "$data"
    else
        echo "$data"
    fi
}

# Main command functions
cmd_help() {
    cat << 'EOF'
Scenario Dependency Analyzer CLI v1.0.0

USAGE:
    scenario-dependency-analyzer <COMMAND> [OPTIONS]

COMMANDS:
    analyze <scenario>     Analyze dependencies for a specific scenario or 'all'
    graph <type>          Generate dependency graph (resources|scenarios|combined)
    optimize <scenario>    Get optimization recommendations (future)
    propose <description>  Analyze dependencies for proposed scenario
    status                Show system status and health
    help                  Show this help message
    version               Show version information

GLOBAL OPTIONS:
    --json                Output in JSON format
    --verbose             Enable verbose output
    --output <format>     Output format (table|json|graph)
    --filter <pattern>    Filter results by pattern

EXAMPLES:
    # Analyze a specific scenario
    scenario-dependency-analyzer analyze chart-generator

    # Analyze all scenarios
    scenario-dependency-analyzer analyze all --output json

    # Generate combined dependency graph
    scenario-dependency-analyzer graph combined --output json

    # Generate graph and save to file
    scenario-dependency-analyzer graph resources --format png --output-file deps.png

    # Analyze proposed scenario
    scenario-dependency-analyzer propose "AI-powered task scheduler with PostgreSQL"

    # Check system status
    scenario-dependency-analyzer status --json

For more information, visit: https://github.com/Vrooli/Vrooli
EOF
}

cmd_version() {
    echo "scenario-dependency-analyzer v${CLI_VERSION}"
    if [[ "${1:-}" == "--json" ]]; then
        echo "{\"version\": \"$CLI_VERSION\", \"api_url\": \"$API_BASE_URL\"}"
    fi
}

cmd_status() {
    local output_format="${1:-table}"
    
    log_info "Checking system status..."
    
    if check_api_health; then
        health_response=$(curl -s "$API_BASE_URL/health" 2>/dev/null || echo '{"status": "unknown"}')
        
        if [[ "$output_format" == "json" ]]; then
            echo "$health_response" | format_json
        else
            log_success "API is healthy"
            echo "$health_response" | format_table
        fi
    else
        if [[ "$output_format" == "json" ]]; then
            echo '{"status": "unhealthy", "error": "API not reachable"}'
        else
            log_error "API is not reachable at $API_BASE_URL"
            log_info "Make sure the scenario is running with: vrooli scenario run scenario-dependency-analyzer"
        fi
        exit 1
    fi
}

cmd_analyze() {
    local scenario="${1:-}"
    local output_format="${2:-table}"
    local include_transitive="${3:-false}"
    
    if [[ -z "$scenario" ]]; then
        log_error "Scenario name is required"
        echo "Usage: scenario-dependency-analyzer analyze <scenario> [--output format]"
        exit 1
    fi
    
    if ! check_api_health; then
        log_error "API not available. Make sure scenario is running."
        exit 1
    fi
    
    log_info "Analyzing dependencies for scenario: $scenario"
    
    local url="$API_BASE_URL/api/v1/analyze/$scenario"
    if [[ "$include_transitive" == "true" ]]; then
        url="${url}?include_transitive=true"
    fi
    
    response=$(curl -sf "$url" 2>/dev/null)
    if [[ $? -ne 0 ]]; then
        log_error "Failed to analyze scenario: $scenario"
        exit 1
    fi
    
    if [[ "$output_format" == "json" ]]; then
        echo "$response" | format_json
    else
        log_success "Analysis completed"
        echo
        echo -e "${CYAN}Dependencies for $scenario:${NC}"
        echo "$response" | format_table
    fi
}

cmd_graph() {
    local graph_type="${1:-combined}"
    local output_format="${2:-json}"
    local output_file="${3:-}"
    local filter_pattern="${4:-}"
    
    if ! check_api_health; then
        log_error "API not available. Make sure scenario is running."
        exit 1
    fi
    
    if [[ ! "$graph_type" =~ ^(resources|scenarios|combined)$ ]]; then
        log_error "Invalid graph type: $graph_type. Must be one of: resources, scenarios, combined"
        exit 1
    fi
    
    log_info "Generating $graph_type dependency graph..."
    
    local url="$API_BASE_URL/api/v1/graph/$graph_type"
    if [[ -n "$filter_pattern" ]]; then
        url="${url}?filter=$filter_pattern"
    fi
    
    response=$(curl -sf "$url" 2>/dev/null)
    if [[ $? -ne 0 ]]; then
        log_error "Failed to generate dependency graph"
        exit 1
    fi
    
    if [[ -n "$output_file" ]]; then
        echo "$response" > "$output_file"
        log_success "Graph saved to: $output_file"
    else
        if [[ "$output_format" == "json" ]]; then
            echo "$response" | format_json
        else
            log_success "Graph generated"
            # Extract summary info for table format
            echo "$response" | jq -r '.metadata | to_entries[] | "\(.key): \(.value)"' 2>/dev/null || echo "$response"
        fi
    fi
}

cmd_optimize() {
    local scenario="${1:-all}"
    local optimization_type="${2:-all}"
    local apply_safe="${3:-false}"
    
    log_warning "Optimization feature is not yet implemented"
    log_info "This feature will provide recommendations for:"
    echo "  - Resource optimization (e.g., ollama â†’ openrouter for lightweight deployments)"
    echo "  - Dependency reduction opportunities"  
    echo "  - Shared workflow adoption suggestions"
    echo "  - Performance improvements"
    
    if [[ "$scenario" == "all" ]]; then
        echo
        echo "Would analyze optimization opportunities for all scenarios."
    else
        echo
        echo "Would analyze optimization opportunities for: $scenario"
    fi
}

cmd_propose() {
    local description="${1:-}"
    local similar_count="${2:-5}"
    local resources_only="${3:-false}"
    
    if [[ -z "$description" ]]; then
        log_error "Scenario description is required"
        echo "Usage: scenario-dependency-analyzer propose \"<description>\" [--similar N] [--resources-only]"
        exit 1
    fi
    
    if ! check_api_health; then
        log_error "API not available. Make sure scenario is running."
        exit 1
    fi
    
    log_info "Analyzing proposed scenario dependencies..."
    
    # Create JSON payload
    payload=$(cat <<EOF
{
    "name": "proposed-scenario",
    "description": "$description",
    "requirements": []
}
EOF
)
    
    response=$(curl -sf -X POST "$API_BASE_URL/api/v1/analyze/proposed" \
        -H "Content-Type: application/json" \
        -d "$payload" 2>/dev/null)
    
    if [[ $? -ne 0 ]]; then
        log_error "Failed to analyze proposed scenario"
        exit 1
    fi
    
    log_success "Analysis completed"
    echo
    echo -e "${CYAN}Predicted dependencies:${NC}"
    echo "$response" | format_json
}

# Parse command line arguments
parse_args() {
    local command=""
    local args=()
    local output_format="table"
    local verbose=false
    local filter=""
    local output_file=""
    local include_transitive=false
    
    while [[ $# -gt 0 ]]; do
        case $1 in
            --json)
                output_format="json"
                shift
                ;;
            --verbose)
                verbose=true
                shift
                ;;
            --output)
                output_format="$2"
                shift 2
                ;;
            --filter)
                filter="$2"
                shift 2
                ;;
            --output-file)
                output_file="$2"
                shift 2
                ;;
            --include-transitive)
                include_transitive=true
                shift
                ;;
            --similar)
                similar_count="$2"
                shift 2
                ;;
            --resources-only)
                resources_only=true
                shift
                ;;
            --format)
                # For graph command
                output_format="$2"
                shift 2
                ;;
            -h|--help|help)
                cmd_help
                exit 0
                ;;
            -v|--version|version)
                cmd_version "$output_format"
                exit 0
                ;;
            analyze|graph|optimize|propose|status)
                command="$1"
                shift
                ;;
            *)
                args+=("$1")
                shift
                ;;
        esac
    done
    
    if [[ -z "$command" ]]; then
        echo "Error: No command specified"
        echo
        cmd_help
        exit 1
    fi
    
    # Execute the command
    case $command in
        analyze)
            cmd_analyze "${args[0]:-}" "$output_format" "$include_transitive"
            ;;
        graph)
            cmd_graph "${args[0]:-combined}" "$output_format" "$output_file" "$filter"
            ;;
        optimize)
            cmd_optimize "${args[0]:-all}" "${args[1]:-all}" "${args[2]:-false}"
            ;;
        propose)
            cmd_propose "${args[0]:-}" "$similar_count" "$resources_only"
            ;;
        status)
            cmd_status "$output_format"
            ;;
        *)
            echo "Error: Unknown command: $command"
            cmd_help
            exit 1
            ;;
    esac
}

# Main execution
main() {
    if [[ $# -eq 0 ]]; then
        cmd_help
        exit 0
    fi
    
    parse_args "$@"
}

main "$@"