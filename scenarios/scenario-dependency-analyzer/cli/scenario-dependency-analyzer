#!/bin/bash
################################################################################
# Scenario Dependency Analyzer CLI - Thin Wrapper Version
# 
# A lightweight CLI that delegates all logic to the scenario's API.
# Port discovery uses ultra-fast file-based lookup.
################################################################################

set -e

# Configuration
SCENARIO_NAME="scenario-dependency-analyzer"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
PURPLE='\033[0;35m'
NC='\033[0m' # No Color

################################################################################
# Port Discovery - Ultra-fast file-based lookup
################################################################################
get_api_url() {
    # Use the ultra-fast port command
    local api_port
    api_port=$(vrooli scenario port "${SCENARIO_NAME}" API_PORT 2>/dev/null)
    
    if [[ -z "$api_port" ]]; then
        echo -e "${RED}‚ùå Error: ${SCENARIO_NAME} is not running${NC}" >&2
        echo "   Start it with: vrooli scenario run ${SCENARIO_NAME}" >&2
        exit 1
    fi
    
    echo "http://localhost:${api_port}"
}

bool_to_json() {
    if [[ "$1" == "true" ]]; then
        printf 'true'
    else
        printf 'false'
    fi
}

################################################################################
# Helper Functions
################################################################################
usage() {
    echo -e "${CYAN}Scenario Dependency Analyzer CLI${NC}"
    echo "Analyze and visualize dependencies between scenarios and resources"
    echo ""
    echo "Usage: scenario-dependency-analyzer [COMMAND] [OPTIONS]"
    echo ""
    echo "Commands:"
    echo -e "  ${GREEN}analyze${NC}     Analyze dependencies for a scenario"
    echo -e "  ${GREEN}scan${NC}        Scan + optionally apply dependencies"
    echo -e "  ${GREEN}dag${NC}         Export recursive dependency DAG"
    echo -e "  ${GREEN}graph${NC}       Generate dependency graph visualization"
    echo -e "  ${GREEN}cycles${NC}      Detect circular dependencies in graph"
    echo -e "  ${GREEN}impact${NC}      Analyze impact of removing a dependency"
    echo -e "  ${GREEN}propose${NC}     Analyze dependencies for a proposed scenario"
    echo -e "  ${GREEN}optimize${NC}    Get optimization recommendations"
    echo -e "  ${GREEN}list${NC}        List dependencies for a scenario"
    echo -e "  ${GREEN}deployment${NC}  Show deployment readiness + tier data"
    echo -e "  ${GREEN}health${NC}      Check service health and analysis capabilities"
    echo -e "  ${GREEN}status${NC}      Show analysis system status"
    echo ""
    echo "Examples:"
    echo "  scenario-dependency-analyzer analyze ecosystem-manager"
    echo "  scenario-dependency-analyzer dag export ecosystem-manager --recursive"
    echo "  scenario-dependency-analyzer graph --type combined --format dot"
    echo "  scenario-dependency-analyzer cycles --type combined"
    echo "  scenario-dependency-analyzer impact postgres"
    echo "  scenario-dependency-analyzer propose --name 'ai-chatbot' --requirements 'nlp,database'"
    echo "  scenario-dependency-analyzer optimize ecosystem-manager --type resource"
    echo "  scenario-dependency-analyzer list ecosystem-manager --type resources"
    echo ""
    echo "Options:"
    echo "  --help, -h       Show help for any command"
    echo "  --json           Output in JSON format (most commands)"
    echo "  --output <fmt>   Alias for --json when fmt=json"
    echo "  --verbose        Show detailed output"
    echo ""
    echo "For more information: scenario-dependency-analyzer <command> --help"
}

# Deployment readiness command
cmd_deployment() {
    local scenario=""
    local json_output=false

    if [[ $# -eq 0 ]]; then
        echo "Usage: scenario-dependency-analyzer deployment <scenario> [--json]" >&2
        return 1
    fi

    while [[ $# -gt 0 ]]; do
        case $1 in
            --json)
                json_output=true
                shift
                ;;
            --help|-h)
                echo "Usage: scenario-dependency-analyzer deployment <scenario> [--json]"
                echo ""
                echo "Show deployment readiness, tier fitness, and bundle metadata for a scenario"
                echo ""
                echo "Options:"
                echo "  --json   Raw JSON output"
                return 0
                ;;
            -*)
                echo -e "${RED}‚ùå Unknown option: $1${NC}" >&2
                return 1
                ;;
            *)
                if [[ -z "$scenario" ]]; then
                    scenario="$1"
                fi
                shift
                ;;
        esac
    done

    if [[ -z "$scenario" ]]; then
        echo -e "${RED}‚ùå Scenario name required${NC}" >&2
        return 1
    fi

    echo -e "${BLUE}üõ∞Ô∏è  Loading deployment report for: $scenario${NC}"
    local response
    response=$(api_request "GET" "/api/v1/scenarios/${scenario}/deployment")

    if [[ $json_output == true ]]; then
        echo "$response" | format_json
        return 0
    fi

    if ! command -v jq >/dev/null 2>&1; then
        echo "$response"
        return 0
    fi

    local title
    title=$(echo "$response" | jq -r '"Scenario: \(.scenario // "unknown" )"')
    local generated
    generated=$(echo "$response" | jq -r 'if .generated_at then "Generated: " + .generated_at else "Generated: unknown" end')

    echo -e "${CYAN}${title}${NC}"
    echo "$generated"

    echo ""
    echo -e "${CYAN}Tier readiness:${NC}"
    local tiers
    tiers=$(echo "$response" | jq -r '
        if (.aggregates // {}) == {} then "  (no tier metadata)"
        else
            (.aggregates | to_entries[] |
                "  - " + .key + ": fitness " +
                (if (.value.fitness_score // null) then ((.value.fitness_score * 100) | round | tostring) + "%" else "n/a" end) +
                ", dependencies: " + ((.value.dependency_count // 0) | tostring) +
                (if (.value.blocking_dependencies and (.value.blocking_dependencies | length > 0)) then
                    ", blockers: " + (.value.blocking_dependencies | join(", "))
                 else ", blockers: none" end)
            )
        end')
    echo "$tiers"

    echo ""
    echo -e "${CYAN}Bundle dependencies:${NC}"
    local bundle
    bundle=$(echo "$response" | jq -r '
        if (.bundle_manifest.dependencies // []) == [] then "  (none)"
        else
            (.bundle_manifest.dependencies | .[:6] | map("  - " + (.type // "unknown") + " :: " + (.name // "") +
                (if (.tier_support // {} | length) > 0 then
                    " (tiers: " + ((.tier_support | keys | join(", "))) + ")"
                else "" end)) | .[])
        end')
    echo "$bundle"

    echo ""
    echo -e "${CYAN}Bundle files:${NC}"
    local files
    files=$(echo "$response" | jq -r '
        if (.bundle_manifest.files // []) == [] then "  (none)"
        else
            (.bundle_manifest.files | .[:5] | map("  - " + (.type // "file") + ": " + (.path // "") +
                (if .exists then " (present)" else " (missing)" end)) | .[])
        end')
    echo "$files"
}

# Format JSON output if jq is available
format_json() {
    if command -v jq >/dev/null 2>&1; then
        jq .
    else
        cat
    fi
}

# Make API request
api_request() {
    local method="$1"
    local endpoint="$2"
    local data="${3:-}"
    local api_url
    
    # Get the current API URL
    api_url=$(get_api_url)
    
    local curl_args=(-s)
    
    if [[ "$method" != "GET" ]]; then
        curl_args+=(-X "$method")
    fi
    
    if [[ -n "$data" ]]; then
        curl_args+=(-H "Content-Type: application/json" -d "$data")
    fi
    
    curl "${curl_args[@]}" "${api_url}${endpoint}"
}

################################################################################
# Command Implementations - All delegated to API
################################################################################

# DAG export command
cmd_dag() {
    local subcommand="${1:-}"
    shift || true

    case "$subcommand" in
        export)
            cmd_dag_export "$@"
            ;;
        --help|-h|help|"")
            echo "Usage: scenario-dependency-analyzer dag <subcommand> [OPTIONS]"
            echo ""
            echo "Subcommands:"
            echo "  export     Export recursive dependency DAG for a scenario"
            echo ""
            echo "Examples:"
            echo "  scenario-dependency-analyzer dag export ecosystem-manager"
            echo "  scenario-dependency-analyzer dag export api-manager --recursive=false"
            echo "  scenario-dependency-analyzer dag export my-scenario --json"
            ;;
        *)
            echo -e "${RED}‚ùå Unknown dag subcommand: $subcommand${NC}" >&2
            echo "   Run: scenario-dependency-analyzer dag --help" >&2
            return 1
            ;;
    esac
}

cmd_dag_export() {
    local scenario=""
    local recursive=true
    local json_output=false
    local output_file=""

    while [[ $# -gt 0 ]]; do
        case $1 in
            --recursive)
                recursive=true
                shift
                ;;
            --recursive=*)
                recursive="${1#*=}"
                shift
                ;;
            --no-recursive)
                recursive=false
                shift
                ;;
            --json)
                json_output=true
                shift
                ;;
            --output|-o)
                output_file="$2"
                shift 2
                ;;
            --help|-h)
                echo "Usage: scenario-dependency-analyzer dag export <scenario> [OPTIONS]"
                echo ""
                echo "Export the full recursive dependency DAG for a scenario"
                echo ""
                echo "Options:"
                echo "  --recursive         Include full recursive tree (default: true)"
                echo "  --no-recursive      Only top-level dependencies"
                echo "  --json              Output raw JSON"
                echo "  --output <file>     Save to file"
                echo ""
                echo "Examples:"
                echo "  scenario-dependency-analyzer dag export ecosystem-manager"
                echo "  scenario-dependency-analyzer dag export api-manager --no-recursive"
                echo "  scenario-dependency-analyzer dag export my-app --output deps.json"
                return 0
                ;;
            -*)
                echo -e "${RED}‚ùå Unknown option: $1${NC}" >&2
                return 1
                ;;
            *)
                if [[ -z "$scenario" ]]; then
                    scenario="$1"
                fi
                shift
                ;;
        esac
    done

    if [[ -z "$scenario" ]]; then
        echo -e "${RED}‚ùå Scenario name required${NC}" >&2
        echo "   Usage: scenario-dependency-analyzer dag export <scenario>" >&2
        return 1
    fi

    echo -e "${BLUE}üìä Exporting DAG for: $scenario (recursive=${recursive})${NC}"

    local response
    response=$(api_request "GET" "/api/v1/scenarios/${scenario}/dag/export?recursive=${recursive}&format=json")

    if [[ -n "$output_file" ]]; then
        echo "$response" | format_json > "$output_file"
        echo -e "${GREEN}‚úÖ DAG exported to: $output_file${NC}"

        # Show summary
        if command -v jq >/dev/null 2>&1; then
            local dep_count=$(echo "$response" | jq -r '.dag | length')
            local gaps=$(echo "$response" | jq -r '.metadata_gaps.total_gaps // 0')
            echo "   Dependencies: $dep_count"
            if [[ "$gaps" -gt 0 ]]; then
                echo -e "   ${YELLOW}‚ö†Ô∏è  Metadata gaps: $gaps${NC}"
            fi
        fi
        return 0
    fi

    if [[ $json_output == true ]]; then
        echo "$response" | format_json
        return 0
    fi

    # Pretty print the DAG
    if ! command -v jq >/dev/null 2>&1; then
        echo "$response"
        return 0
    fi

    echo -e "${GREEN}‚úÖ DAG exported${NC}"
    echo ""

    # Show tree structure
    echo -e "${CYAN}Dependency Tree:${NC}"
    echo "$response" | jq -r '
        .dag[] |
        "  - \(.type): \(.name)" +
        (if .children and (.children | length) > 0 then
            " (\(.children | length) children)"
         else "" end)
    '

    # Show metadata gaps if present
    local gaps=$(echo "$response" | jq -r '.metadata_gaps.total_gaps // 0')
    if [[ "$gaps" -gt 0 ]]; then
        echo ""
        echo -e "${YELLOW}‚ö†Ô∏è  Metadata Gaps Detected:${NC}"
        echo "$response" | jq -r '
            .metadata_gaps.recommendations[]? | "  ‚Ä¢ " + .
        '
    fi
}

# Analyze scenario command
cmd_analyze() {
    local scenario=""
    local include_transitive=false
    local json_output=false
    local verbose=false
    local output_format=""
    
    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case $1 in
            --transitive)
                include_transitive=true
                shift
                ;;
            --json)
                json_output=true
                shift
                ;;
            --output)
                if [[ -z "${2:-}" ]]; then
                    echo -e "${RED}‚ùå Option --output requires a value${NC}" >&2
                    return 1
                fi
                output_format="$2"
                shift 2
                ;;
            --output=*)
                output_format="${1#*=}"
                shift
                ;;
            --verbose)
                verbose=true
                shift
                ;;
            --help|-h)
                echo "Usage: scenario-dependency-analyzer analyze <scenario> [OPTIONS]"
                echo ""
                echo "Analyze dependencies for a scenario"
                echo ""
                echo "Options:"
                echo "  --transitive      Include transitive dependencies"
                echo "  --json            Output in JSON format"
                echo "  --output <fmt>    Alias for format selection (supports: json)"
                echo "  --verbose         Show detailed analysis"
                echo ""
                echo "Examples:"
                echo "  scenario-dependency-analyzer analyze ecosystem-manager"
                echo "  scenario-dependency-analyzer analyze api-manager --transitive"
                return 0
                ;;
            -o)
                if [[ -z "${2:-}" ]]; then
                    echo -e "${RED}‚ùå Option -o requires a value${NC}" >&2
                    return 1
                fi
                output_format="$2"
                shift 2
                ;;
            -*)
                echo -e "${RED}‚ùå Unknown option: $1${NC}" >&2
                return 1
                ;;
            *)
                if [[ -z "$scenario" ]]; then
                    scenario="$1"
                fi
                shift
                ;;
        esac
    done
    
    if [[ -z "$scenario" ]]; then
        echo -e "${RED}‚ùå Error: Scenario name required${NC}" >&2
        echo "   Usage: scenario-dependency-analyzer analyze <scenario>" >&2
        return 1
    fi

    if [[ -n "$output_format" ]]; then
        case "$output_format" in
            json)
                json_output=true
                ;;
            pretty|text|human)
                json_output=false
                ;;
            *)
                echo -e "${RED}‚ùå Unsupported output format: $output_format${NC}" >&2
                echo "   Supported formats: json" >&2
                return 1
                ;;
        esac
    fi
    
    echo -e "${BLUE}üîç Analyzing dependencies for: $scenario${NC}"
    
    local response
    response=$(api_request "GET" "/api/v1/analyze/${scenario}?include_transitive=${include_transitive}")
    
    if [[ $json_output == true ]]; then
        echo "$response" | format_json
    else
        # Pretty print analysis results
        local resources=$(echo "$response" | jq -r '.resources | length' 2>/dev/null || echo "0")
        local scenarios=$(echo "$response" | jq -r '.scenarios | length' 2>/dev/null || echo "0")
        local workflows=$(echo "$response" | jq -r '.shared_workflows | length' 2>/dev/null || echo "0")
        
        echo -e "${GREEN}‚úÖ Analysis complete${NC}"
        echo ""
        echo -e "${CYAN}üìä Dependency Summary:${NC}"
        echo "   Resources: $resources"
        echo "   Scenarios: $scenarios"
        echo "   Shared Workflows: $workflows"
        
        if [[ "$verbose" == true ]]; then
            echo ""
            echo -e "${CYAN}Resources:${NC}"
            echo "$response" | jq -r '.resources[]? | "  - \(.dependency_name) (\(.dependency_type))"' 2>/dev/null
            
            echo ""
            echo -e "${CYAN}Dependent Scenarios:${NC}"
            echo "$response" | jq -r '.scenarios[]? | "  - \(.dependency_name)"' 2>/dev/null
        fi
    fi
}

cmd_scan() {
    local scenario=""
    local apply=false
    local apply_resources=false
    local apply_scenarios=false
    local json_output=false

    while [[ $# -gt 0 ]]; do
        case $1 in
            --apply)
                apply=true
                shift
                ;;
            --apply-resources)
                apply_resources=true
                shift
                ;;
            --apply-scenarios)
                apply_scenarios=true
                shift
                ;;
            --json)
                json_output=true
                shift
                ;;
            --help|-h)
                echo "Usage: scenario-dependency-analyzer scan <scenario> [OPTIONS]"
                echo ""
                echo "Run dependency scan and optionally apply updates"
                echo ""
                echo "Options:"
                echo "  --apply             Apply inferred resources and scenarios"
                echo "  --apply-resources   Apply only inferred resources"
                echo "  --apply-scenarios   Apply only inferred scenarios"
                echo "  --json              Raw JSON output"
                echo ""
                echo "Examples:"
                echo "  scenario-dependency-analyzer scan ecosystem-manager"
                echo "  scenario-dependency-analyzer scan api-tools --apply"
                return 0
                ;;
            -*)
                echo -e "${RED}‚ùå Unknown option: $1${NC}" >&2
                return 1
                ;;
            *)
                scenario="$1"
                shift
                ;;
        esac
    done

    if [[ -z "$scenario" ]]; then
        echo -e "${RED}‚ùå Scenario name required${NC}" >&2
        return 1
    fi

    local payload
    payload=$(printf '{"apply":%s,"apply_resources":%s,"apply_scenarios":%s}' \
        "$(bool_to_json "$apply")" \
        "$(bool_to_json "$apply_resources")" \
        "$(bool_to_json "$apply_scenarios")")

    echo -e "${BLUE}üõ∞Ô∏è  Scanning scenario: $scenario${NC}"
    local response
    response=$(api_request "POST" "/api/v1/scenarios/${scenario}/scan" "$payload")

    if [[ $json_output == true ]]; then
        echo "$response" | format_json
        return 0
    fi

    local applied=$(echo "$response" | jq -r '.applied' 2>/dev/null || echo "false")
    local resources_added=$(echo "$response" | jq -r '.apply_summary.resources_added | length' 2>/dev/null || echo "0")
    local scenarios_added=$(echo "$response" | jq -r '.apply_summary.scenarios_added | length' 2>/dev/null || echo "0")

    echo -e "${GREEN}‚úÖ Scan complete${NC}"
    echo "  Applied changes: $applied"
    echo "  Resources added: $resources_added"
    echo "  Scenarios added: $scenarios_added"

    if [[ "$applied" == "true" ]]; then
        echo "  Tip: run 'git diff scenarios/${scenario}/.vrooli/service.json' to review"
    fi
}

# Generate graph command
cmd_graph() {
    local graph_type="combined"
    local graph_type_set=false
    local format="json"
    local output_file=""
    local json_output=false
    
    while [[ $# -gt 0 ]]; do
        case $1 in
            --type)
                graph_type="$2"
                shift 2
                ;;
            --format)
                format="$2"
                shift 2
                ;;
            --output|-o)
                output_file="$2"
                shift 2
                ;;
            --json)
                json_output=true
                shift
                ;;
            --help|-h)
                echo "Usage: scenario-dependency-analyzer graph [OPTIONS]"
                echo ""
                echo "Generate dependency graph visualization"
                echo ""
                echo "Options:"
                echo "  [type]             Optional positional graph type (resource, scenario, combined)"
                echo "  --type <type>      Graph type (resource, scenario, combined)"
                echo "  --format <fmt>     Output format (json, dot, mermaid)"
                echo "  --output <file>    Save output to file"
                echo "  --json             Force JSON output"
                echo ""
                echo "Examples:"
                echo "  scenario-dependency-analyzer graph --type combined"
                echo "  scenario-dependency-analyzer graph --format dot --output deps.dot"
                echo "  scenario-dependency-analyzer graph --type resource --format mermaid"
                return 0
                ;;
            *)
                if [[ "$graph_type_set" == false && "$1" != "" ]]; then
                    graph_type="$1"
                    graph_type_set=true
                    shift
                else
                    echo -e "${RED}‚ùå Unknown option: $1${NC}" >&2
                    return 1
                fi
                ;;
        esac
    done
    
    # Map user-friendly names to API types if needed
    local api_type="$graph_type"
    case "$graph_type" in
        resources) api_type="resource" ;;
        scenarios) api_type="scenario" ;;
        all|combined) api_type="combined" ;;
        resource|scenario) api_type="$graph_type" ;;
        *)
            echo -e "${RED}‚ùå Invalid graph type: $graph_type${NC}" >&2
            echo "   Valid types: resource, scenario, combined" >&2
            return 1
            ;;
    esac
    
    echo -e "${BLUE}üìä Generating ${graph_type} dependency graph...${NC}"
    
    local response
    response=$(api_request "GET" "/api/v1/graph/${api_type}")
    
    # Handle different output formats
    case "$format" in
        dot)
            # Convert JSON graph to DOT format
            local dot_output=$(echo "$response" | jq -r '
                "digraph Dependencies {",
                "  rankdir=LR;",
                "  node [shape=box];",
                (.nodes[]? | "  \(.id) [label=\"\(.label)\"];"),
                (.edges[]? | "  \(.source) -> \(.target) [label=\"\(.label)\"];"),
                "}"
            ' 2>/dev/null | tr '\n' '\n')
            
            if [[ -n "$output_file" ]]; then
                echo "$dot_output" > "$output_file"
                echo -e "${GREEN}‚úÖ Graph saved to: $output_file${NC}"
                echo "   Visualize with: dot -Tpng $output_file -o graph.png"
            else
                echo "$dot_output"
            fi
            ;;
            
        mermaid)
            # Convert JSON graph to Mermaid format
            local mermaid_output=$(echo "$response" | jq -r '
                "graph TD",
                (.edges[]? | "  \(.source)[\(.source)] --> \(.target)[\(.target)]")
            ' 2>/dev/null | tr '\n' '\n')
            
            if [[ -n "$output_file" ]]; then
                echo "$mermaid_output" > "$output_file"
                echo -e "${GREEN}‚úÖ Graph saved to: $output_file${NC}"
            else
                echo "$mermaid_output"
            fi
            ;;
            
        json|*)
            if [[ -n "$output_file" ]]; then
                echo "$response" | format_json > "$output_file"
                echo -e "${GREEN}‚úÖ Graph saved to: $output_file${NC}"
            else
                echo "$response" | format_json
            fi
            ;;
    esac
}

# Propose scenario command
cmd_propose() {
    local name=""
    local description=""
    local requirements=""
    local similar=""
    local json_output=false
    
    while [[ $# -gt 0 ]]; do
        case $1 in
            --name)
                name="$2"
                shift 2
                ;;
            --description)
                description="$2"
                shift 2
                ;;
            --requirements)
                requirements="$2"
                shift 2
                ;;
            --similar)
                similar="$2"
                shift 2
                ;;
            --json)
                json_output=true
                shift
                ;;
            --help|-h)
                echo "Usage: scenario-dependency-analyzer propose [OPTIONS]"
                echo ""
                echo "Analyze dependencies for a proposed scenario"
                echo ""
                echo "Options:"
                echo "  --name <name>              Proposed scenario name"
                echo "  --description <desc>       Scenario description"
                echo "  --requirements <list>      Comma-separated requirements"
                echo "  --similar <scenarios>      Similar existing scenarios"
                echo "  --json                     Output in JSON format"
                echo ""
                echo "Examples:"
                echo "  scenario-dependency-analyzer propose --name 'ai-chatbot' \\"
                echo "    --requirements 'nlp,database,api' --description 'AI-powered chat'"
                return 0
                ;;
            *)
                echo -e "${RED}‚ùå Unknown option: $1${NC}" >&2
                return 1
                ;;
        esac
    done
    
    if [[ -z "$name" || -z "$requirements" ]]; then
        echo -e "${RED}‚ùå Error: --name and --requirements are required${NC}" >&2
        return 1
    fi
    
    # Build request JSON
    local req_array=$(echo "$requirements" | jq -R 'split(",") | map(gsub("^\\s+|\\s+$";""))')
    local sim_array="[]"
    if [[ -n "$similar" ]]; then
        sim_array=$(echo "$similar" | jq -R 'split(",") | map(gsub("^\\s+|\\s+$";""))')
    fi
    
    local request_body=$(jq -n \
        --arg name "$name" \
        --arg desc "${description:-}" \
        --argjson reqs "$req_array" \
        --argjson sims "$sim_array" \
        '{
            name: $name,
            description: $desc,
            requirements: $reqs,
            similar_scenarios: $sims
        }')
    
    echo -e "${BLUE}üîÆ Analyzing proposed scenario: $name${NC}"
    
    local response
    response=$(api_request "POST" "/api/v1/analyze/proposed" "$request_body")
    
    if [[ $json_output == true ]]; then
        echo "$response" | format_json
    else
        echo -e "${GREEN}‚úÖ Analysis complete${NC}"
        echo ""
        echo -e "${CYAN}üìã Recommended Dependencies:${NC}"
        echo "$response" | jq -r '
            if .recommended_resources then
                "Resources:",
                (.recommended_resources[]? | "  - \(.)")
            else empty end,
            if .recommended_scenarios then
                "\nRelated Scenarios:",
                (.recommended_scenarios[]? | "  - \(.)")
            else empty end
        ' 2>/dev/null || echo "$response" | format_json
    fi
}

# List dependencies command
cmd_list() {
    local scenario="$1"
    local dep_type=""
    local json_output=false
    
    if [[ -z "$scenario" || "$scenario" == "--help" || "$scenario" == "-h" ]]; then
        echo "Usage: scenario-dependency-analyzer list <scenario> [OPTIONS]"
        echo ""
        echo "List dependencies for a scenario"
        echo ""
        echo "Options:"
        echo "  --type <type>    Filter by type (resources, scenarios, workflows)"
        echo "  --json           Output in JSON format"
        echo ""
        echo "Examples:"
        echo "  scenario-dependency-analyzer list ecosystem-manager"
        echo "  scenario-dependency-analyzer list api-manager --type resources"
        return 0
    fi
    
    shift
    while [[ $# -gt 0 ]]; do
        case $1 in
            --type)
                dep_type="$2"
                shift 2
                ;;
            --json)
                json_output=true
                shift
                ;;
            *)
                shift
                ;;
        esac
    done
    
    echo -e "${BLUE}üìã Fetching dependencies for: $scenario${NC}"
    
    local endpoint="/api/v1/scenarios/${scenario}/dependencies"
    [[ -n "$dep_type" ]] && endpoint="${endpoint}?type=${dep_type}"
    
    local response
    response=$(api_request "GET" "$endpoint")
    
    if [[ $json_output == true ]]; then
        echo "$response" | format_json
    else
        # Pretty print dependencies
        echo -e "${GREEN}‚úÖ Dependencies for $scenario:${NC}"
        echo ""
        
        # Parse and display by type
        echo "$response" | jq -r '
            group_by(.dependency_type) | 
            .[] | 
            "\(.[]?.dependency_type // "Unknown"):",
            (.[] | "  - \(.dependency_name)\(if .required then " (required)" else "" end)")
        ' 2>/dev/null || echo "$response" | format_json
    fi
}

# Health check command
cmd_health() {
    local json_output=false
    local detailed=false
    
    while [[ $# -gt 0 ]]; do
        case $1 in
            --json)
                json_output=true
                shift
                ;;
            --detailed)
                detailed=true
                shift
                ;;
            *)
                shift
                ;;
        esac
    done
    
    echo -e "${BLUE}üè• Checking health...${NC}"
    
    # Basic health check
    local api_url
    api_url=$(get_api_url)
    
    local health_response
    health_response=$(curl -s "${api_url}/health")
    
    if [[ "$detailed" == true ]]; then
        # Also check analysis health
        local analysis_response
        analysis_response=$(curl -s "${api_url}/api/v1/health/analysis")
        
        if [[ $json_output == true ]]; then
            echo "{\"basic\": $health_response, \"analysis\": $analysis_response}" | format_json
        else
            echo -e "${GREEN}‚úÖ Service Health:${NC}"
            echo "$health_response" | jq -r '"  Status: \(.status)"' 2>/dev/null
            echo ""
            echo -e "${CYAN}üìä Analysis Capabilities:${NC}"
            echo "$analysis_response" | jq -r '
                "  Scenarios Found: \(.scenarios_found)",
                "  Resources Available: \(.resources_available)",
                "  Database: \(.database_status)"
            ' 2>/dev/null || echo "  Unable to retrieve analysis status"
        fi
    else
        if echo "$health_response" | grep -q "ok\|healthy"; then
            echo -e "${GREEN}‚úÖ Scenario Dependency Analyzer is healthy${NC}"
            echo "   API: ${api_url}"
        else
            echo -e "${RED}‚ùå Health check failed${NC}"
            echo "   Response: $health_response"
            return 1
        fi
    fi
}

# Status command (system overview)
cmd_status() {
    echo -e "${CYAN}üìä Scenario Dependency Analyzer Status${NC}"
    echo ""
    
    # Get API URL and check if running
    local api_url
    if api_url=$(get_api_url 2>/dev/null); then
        echo -e "${GREEN}‚úÖ Service: Running${NC}"
        echo "   API: $api_url"
        
        # Get analysis health for more details
        local analysis_response
        analysis_response=$(curl -s "${api_url}/api/v1/health/analysis" 2>/dev/null)
        
        if [[ -n "$analysis_response" ]]; then
            echo ""
            echo -e "${CYAN}Analysis System:${NC}"
            echo "$analysis_response" | jq -r '
                "  Scenarios: \(.scenarios_found // 0)",
                "  Resources: \(.resources_available // 0)",
                "  Database: \(.database_status // "unknown")",
                "  Last Analysis: \(.last_analysis // "never")"
            ' 2>/dev/null || echo "  Status information unavailable"
        fi
    else
        echo -e "${RED}‚ùå Service: Not Running${NC}"
        echo "   Start with: vrooli scenario run scenario-dependency-analyzer"
    fi
}

# Impact command (analyze dependency removal impact)
cmd_impact() {
    local dependency=""
    local json_output=false

    if [[ $# -eq 0 ]]; then
        echo "Usage: scenario-dependency-analyzer impact <dependency> [--json]" >&2
        return 1
    fi

    while [[ $# -gt 0 ]]; do
        case $1 in
            --json)
                json_output=true
                shift
                ;;
            --help|-h)
                echo "Usage: scenario-dependency-analyzer impact <dependency> [--json]"
                echo ""
                echo "Analyze the impact of removing a dependency"
                echo ""
                echo "Options:"
                echo "  --json   Raw JSON output"
                echo ""
                echo "Examples:"
                echo "  scenario-dependency-analyzer impact postgres"
                echo "  scenario-dependency-analyzer impact ecosystem-manager --json"
                return 0
                ;;
            -*)
                echo -e "${RED}‚ùå Unknown option: $1${NC}" >&2
                return 1
                ;;
            *)
                if [[ -z "$dependency" ]]; then
                    dependency="$1"
                fi
                shift
                ;;
        esac
    done

    if [[ -z "$dependency" ]]; then
        echo -e "${RED}‚ùå Dependency name required${NC}" >&2
        return 1
    fi

    echo -e "${BLUE}üîç Analyzing impact of removing: $dependency${NC}"
    local response
    response=$(api_request "GET" "/api/v1/dependencies/${dependency}/impact")

    if [[ $json_output == true ]]; then
        echo "$response" | format_json
        return 0
    fi

    if ! command -v jq >/dev/null 2>&1; then
        echo "$response"
        return 0
    fi

    local severity=$(echo "$response" | jq -r '.severity')
    local summary=$(echo "$response" | jq -r '.impact_summary')
    local total_affected=$(echo "$response" | jq -r '.total_affected')

    # Color-code by severity
    case "$severity" in
        critical)
            echo -e "${RED}üî¥ CRITICAL IMPACT${NC}"
            ;;
        high)
            echo -e "${RED}‚ö†Ô∏è  HIGH IMPACT${NC}"
            ;;
        medium)
            echo -e "${YELLOW}‚ö†Ô∏è  MEDIUM IMPACT${NC}"
            ;;
        low)
            echo -e "${YELLOW}‚ÑπÔ∏è  LOW IMPACT${NC}"
            ;;
        *)
            echo -e "${GREEN}‚úÖ MINIMAL IMPACT${NC}"
            ;;
    esac

    echo ""
    echo "$summary"

    if [[ "$total_affected" -gt 0 ]]; then
        echo ""
        echo -e "${CYAN}Direct Dependents:${NC}"
        echo "$response" | jq -r '.direct_dependents[] |
            "  - " + .scenario_name +
            (if .required then " (REQUIRED)" else "" end) +
            "\n    Purpose: " + (.purpose // "n/a")'

        local indirect_count=$(echo "$response" | jq -r '.indirect_dependents | length')
        if [[ "$indirect_count" -gt 0 ]]; then
            echo ""
            echo -e "${CYAN}Indirect Dependents (${indirect_count}):${NC}"
            echo "$response" | jq -r '.indirect_dependents[] | "  - " + .scenario_name'
        fi

        echo ""
        echo -e "${CYAN}Recommendations:${NC}"
        echo "$response" | jq -r '.recommendations[] | "  ‚Ä¢ " + .'
    fi
}

# Cycles command (detect circular dependencies)
cmd_cycles() {
    local graph_type="combined"
    local json_output=false

    while [[ $# -gt 0 ]]; do
        case $1 in
            --type)
                graph_type="$2"
                shift 2
                ;;
            --json)
                json_output=true
                shift
                ;;
            --help|-h)
                echo "Usage: scenario-dependency-analyzer cycles [OPTIONS]"
                echo ""
                echo "Detect circular dependencies in the dependency graph"
                echo ""
                echo "Options:"
                echo "  --type <type>    Graph type (resource, scenario, combined) [default: combined]"
                echo "  --json           Output in JSON format"
                echo ""
                echo "Examples:"
                echo "  scenario-dependency-analyzer cycles --type combined"
                echo "  scenario-dependency-analyzer cycles --type scenario --json"
                return 0
                ;;
            -*)
                echo -e "${RED}‚ùå Unknown option: $1${NC}" >&2
                return 1
                ;;
            *)
                if [[ -z "$graph_type" || "$graph_type" == "combined" ]]; then
                    graph_type="$1"
                fi
                shift
                ;;
        esac
    done

    # Map user-friendly names to API types if needed
    local api_type="$graph_type"
    case "$graph_type" in
        resources) api_type="resource" ;;
        scenarios) api_type="scenario" ;;
        all|combined) api_type="combined" ;;
        resource|scenario) api_type="$graph_type" ;;
        *)
            echo -e "${RED}‚ùå Invalid graph type: $graph_type${NC}" >&2
            echo "   Valid types: resource, scenario, combined" >&2
            return 1
            ;;
    esac

    echo -e "${BLUE}üîç Detecting circular dependencies in ${graph_type} graph...${NC}"

    local response
    response=$(api_request "GET" "/api/v1/graph/${api_type}/cycles")

    if [[ $json_output == true ]]; then
        echo "$response" | format_json
        return 0
    fi

    # Pretty print cycle detection results
    if ! command -v jq >/dev/null 2>&1; then
        echo "$response"
        return 0
    fi

    local has_cycles=$(echo "$response" | jq -r '.has_cycles')
    local severity=$(echo "$response" | jq -r '.severity')
    local message=$(echo "$response" | jq -r '.message')

    if [[ "$has_cycles" == "false" ]]; then
        echo -e "${GREEN}‚úÖ ${message}${NC}"
        return 0
    fi

    # Cycles detected - show details
    if [[ "$severity" == "critical" ]]; then
        echo -e "${RED}üî¥ ${message}${NC}"
    else
        echo -e "${YELLOW}‚ö†Ô∏è  ${message}${NC}"
    fi

    echo ""
    echo -e "${CYAN}Detected Cycles:${NC}"
    echo "$response" | jq -r '.cycles[] |
        "  ‚Ä¢ " + .description +
        "\n    Type: " + .cycle_type +
        " | Length: " + (.length | tostring) + " hops" +
        (if .required then " | ‚ö†Ô∏è  ALL REQUIRED" else "" end)'

    echo ""
    echo -e "${CYAN}Affected Dependencies:${NC}"
    echo "$response" | jq -r '.affected_dependencies[] | "  - " + .'

    # Return non-zero if critical
    if [[ "$severity" == "critical" ]]; then
        return 1
    fi
}

# Optimize command (get optimization recommendations)
cmd_optimize() {
    local scenario=""
    local opt_type="all"
    local apply_safe=false
    local json_output=false
    
    while [[ $# -gt 0 ]]; do
        case $1 in
            --type)
                opt_type="$2"
                shift 2
                ;;
            --apply)
                apply_safe=true
                shift
                ;;
            --json)
                json_output=true
                shift
                ;;
            --help|-h)
                echo "Usage: scenario-dependency-analyzer optimize [scenario] [OPTIONS]"
                echo ""
                echo "Get optimization recommendations for scenarios"
                echo ""
                echo "Options:"
                echo "  --type <type>      Optimization type (resource, deployment, cost, all)"
                echo "  --apply            Apply safe optimizations automatically"
                echo "  --json             Output in JSON format"
                echo ""
                echo "Examples:"
                echo "  scenario-dependency-analyzer optimize ecosystem-manager"
                echo "  scenario-dependency-analyzer optimize all --type resource"
                echo "  scenario-dependency-analyzer optimize --apply"
                return 0
                ;;
            -*)
                echo -e "${RED}‚ùå Unknown option: $1${NC}" >&2
                return 1
                ;;
            *)
                if [[ -z "$scenario" ]]; then
                    scenario="$1"
                fi
                shift
                ;;
        esac
    done
    
    # Default to 'all' if no scenario specified
    if [[ -z "$scenario" ]]; then
        scenario="all"
    fi
    
    echo -e "${BLUE}üîß Getting optimization recommendations for: $scenario${NC}"

    local apply_flag
    apply_flag=$(bool_to_json "$apply_safe")
    local payload
    payload=$(cat <<EOF
{
  "scenario": "${scenario}",
  "type": "${opt_type}",
  "apply": ${apply_flag}
}
EOF
)

    local response
    response=$(api_request "POST" "/api/v1/optimize" "$payload")

    if [[ $json_output == true ]]; then
        echo "$response" | format_json
        return
    fi

    if command -v jq >/dev/null 2>&1; then
        echo "$response" | jq -r '
            .results | to_entries[] |
            "Scenario: \(.key)",
            (if (.value.error // "") != "" then
                "  Error: \(.value.error)"
             else
                "  Recommendations: \(.value.summary.recommendation_count)",
                "  High priority: \(.value.summary.high_priority // 0)",
                (if (.value.recommendations | length) == 0 then
                    "  No recommendations generated"
                else
                    (.value.recommendations[] | 
                        "    - [\(.recommendation_type)] \(.title)",
                        ("      Description: " + (.description // "n/a")),
                        ("      Confidence: " + ((.confidence_score // 0) | tostring)),
                        ("      Suggested action: " + (.recommended_state.action // "review"))
                    )
                end)
             end),
            ""
        '
    else
        echo "$response" | format_json
    fi
}

################################################################################
# Main Command Router
################################################################################
main() {
    local command="${1:-}"
    
    if [[ -z "$command" ]]; then
        usage
        exit 0
    fi
    
    shift
    
    case "$command" in
        analyze)
            cmd_analyze "$@"
            ;;
        scan)
            cmd_scan "$@"
            ;;
        dag)
            cmd_dag "$@"
            ;;
        graph)
            cmd_graph "$@"
            ;;
        cycles)
            cmd_cycles "$@"
            ;;
        impact)
            cmd_impact "$@"
            ;;
        propose)
            cmd_propose "$@"
            ;;
        optimize)
            cmd_optimize "$@"
            ;;
        list)
            cmd_list "$@"
            ;;
        deployment)
            cmd_deployment "$@"
            ;;
        health)
            cmd_health "$@"
            ;;
        status)
            cmd_status "$@"
            ;;
        --help|-h|help)
            usage
            ;;
        --version|-v|version)
            echo "Scenario Dependency Analyzer CLI v2.0.0 (thin wrapper)"
            ;;
        *)
            echo -e "${RED}‚ùå Unknown command: $command${NC}" >&2
            usage
            exit 1
            ;;
    esac
}

# Run main function
main "$@"
