/**
 * MCP Code Generator
 * Generates MCP server implementations for Vrooli scenarios
 */

const fs = require('fs').promises;
const path = require('path');

class MCPCodeGenerator {
    constructor() {
        this.templatesPath = path.join(__dirname, '..', 'templates');
    }

    /**
     * Generate MCP implementation for a scenario
     * @param {Object} scenarioInfo - Information about the scenario
     * @param {Object} options - Generation options
     * @returns {Promise<Object>} Generated files and metadata
     */
    async generateMCPImplementation(scenarioInfo, options = {}) {
        const {
            scenarioName,
            scenarioPath,
            apiEndpoints = [],
            cliCommands = [],
            template = 'basic-api'
        } = scenarioInfo;

        const generated = {
            files: [],
            manifest: null,
            port: this.allocatePort(scenarioName),
            success: false,
            error: null
        };

        try {
            // Generate manifest
            generated.manifest = this.generateManifest(scenarioName, apiEndpoints, cliCommands);
            
            // Generate server file
            const serverCode = await this.generateServerCode(scenarioName, generated.manifest, template);
            
            // Generate handler files
            const handlers = this.generateHandlers(apiEndpoints, cliCommands);
            
            // Package.json for MCP dependencies
            const packageJson = this.generatePackageJson(scenarioName);
            
            // README for MCP usage
            const readme = this.generateReadme(scenarioName, generated.manifest);
            
            // Collect all generated files
            generated.files = [
                { path: 'mcp/manifest.json', content: JSON.stringify(generated.manifest, null, 2) },
                { path: 'mcp/server.js', content: serverCode },
                { path: 'mcp/package.json', content: JSON.stringify(packageJson, null, 2) },
                { path: 'mcp/README.md', content: readme },
                ...handlers.map(h => ({ path: `mcp/handlers/${h.name}`, content: h.content }))
            ];
            
            generated.success = true;
        } catch (error) {
            generated.error = error.message;
        }

        return generated;
    }

    /**
     * Generate MCP manifest from scenario information
     * @param {string} scenarioName - Name of the scenario
     * @param {Array} apiEndpoints - API endpoints to expose
     * @param {Array} cliCommands - CLI commands to expose
     * @returns {Object} MCP manifest
     */
    generateManifest(scenarioName, apiEndpoints, cliCommands) {
        const tools = [];
        
        // Convert API endpoints to tools
        apiEndpoints.forEach(endpoint => {
            tools.push({
                name: this.apiEndpointToToolName(endpoint),
                description: endpoint.description || `Call ${endpoint.method} ${endpoint.path}`,
                inputSchema: {
                    type: 'object',
                    properties: endpoint.parameters || {},
                    required: endpoint.required || []
                }
            });
        });
        
        // Convert CLI commands to tools
        cliCommands.forEach(command => {
            tools.push({
                name: `cli_${command.name.replace(/-/g, '_')}`,
                description: command.description || `Execute ${command.name} command`,
                inputSchema: {
                    type: 'object',
                    properties: this.cliArgsToSchema(command.arguments || []),
                    required: command.required || []
                }
            });
        });
        
        return {
            name: scenarioName,
            version: '1.0.0',
            description: `MCP interface for ${scenarioName} scenario`,
            capabilities: {
                tools: tools
            },
            server: {
                command: 'node',
                args: ['mcp/server.js'],
                env: {
                    MCP_PORT: `${this.allocatePort(scenarioName)}`
                }
            }
        };
    }

    /**
     * Generate MCP server code
     * @param {string} scenarioName - Name of the scenario
     * @param {Object} manifest - MCP manifest
     * @param {string} template - Template to use
     * @returns {Promise<string>} Server code
     */
    async generateServerCode(scenarioName, manifest, template) {
        const serverTemplate = `#!/usr/bin/env node
/**
 * MCP Server for ${scenarioName}
 * Auto-generated by scenario-to-mcp
 */

const { Server } = require('@modelcontextprotocol/sdk/server/stdio');
const { exec } = require('child_process');
const { promisify } = require('util');
const axios = require('axios');
const path = require('path');

const execAsync = promisify(exec);

// Initialize MCP server
const server = new Server({
    name: '${scenarioName}',
    version: '1.0.0'
});

// Import handlers
const handlers = require('./handlers');

// Register tool list handler
server.setRequestHandler('tools/list', async () => ({
    tools: ${JSON.stringify(manifest.capabilities.tools, null, 8)}
}));

// Register tool call handler
server.setRequestHandler('tools/call', async (request) => {
    const { name, arguments: args } = request.params;
    
    try {
        // Route to appropriate handler
        if (handlers[name]) {
            const result = await handlers[name](args);
            return {
                content: [
                    {
                        type: 'text',
                        text: JSON.stringify(result, null, 2)
                    }
                ]
            };
        } else {
            throw new Error(\`Unknown tool: \${name}\`);
        }
    } catch (error) {
        return {
            content: [
                {
                    type: 'text',
                    text: \`Error: \${error.message}\`
                }
            ],
            isError: true
        };
    }
});

// Health check endpoint
server.setRequestHandler('health', async () => ({
    status: 'healthy',
    scenario: '${scenarioName}',
    timestamp: new Date().toISOString()
}));

// Start the server
async function main() {
    try {
        const port = process.env.MCP_PORT || ${this.allocatePort(scenarioName)};
        console.log(\`Starting MCP server for ${scenarioName} on port \${port}\`);
        
        await server.start();
        console.log('MCP server started successfully');
    } catch (error) {
        console.error('Failed to start MCP server:', error);
        process.exit(1);
    }
}

// Handle shutdown gracefully
process.on('SIGINT', async () => {
    console.log('Shutting down MCP server...');
    await server.stop();
    process.exit(0);
});

process.on('SIGTERM', async () => {
    console.log('Shutting down MCP server...');
    await server.stop();
    process.exit(0);
});

// Start the server
main();
`;
        
        return serverTemplate;
    }

    /**
     * Generate handler modules for tools
     * @param {Array} apiEndpoints - API endpoints
     * @param {Array} cliCommands - CLI commands
     * @returns {Array} Handler files
     */
    generateHandlers(apiEndpoints, cliCommands) {
        const handlers = [];
        
        // Generate index.js that exports all handlers
        const indexContent = `/**
 * MCP Tool Handlers
 * Auto-generated by scenario-to-mcp
 */

const axios = require('axios');
const { exec } = require('child_process');
const { promisify } = require('util');

const execAsync = promisify(exec);
const API_BASE = process.env.API_BASE || 'http://localhost:' + (process.env.API_PORT || 3000);

const handlers = {};

${apiEndpoints.map(endpoint => this.generateAPIHandler(endpoint)).join('\n\n')}

${cliCommands.map(command => this.generateCLIHandler(command)).join('\n\n')}

module.exports = handlers;
`;
        
        handlers.push({
            name: 'index.js',
            content: indexContent
        });
        
        return handlers;
    }

    /**
     * Generate handler for API endpoint
     * @param {Object} endpoint - API endpoint definition
     * @returns {string} Handler code
     */
    generateAPIHandler(endpoint) {
        const toolName = this.apiEndpointToToolName(endpoint);
        return `// Handler for ${endpoint.method} ${endpoint.path}
handlers['${toolName}'] = async (args) => {
    try {
        const response = await axios({
            method: '${endpoint.method.toLowerCase()}',
            url: \`\${API_BASE}${endpoint.path}\`,
            ${endpoint.method === 'GET' ? 'params: args,' : 'data: args,'}
            headers: {
                'Content-Type': 'application/json'
            }
        });
        return response.data;
    } catch (error) {
        throw new Error(\`API call failed: \${error.message}\`);
    }
};`;
    }

    /**
     * Generate handler for CLI command
     * @param {Object} command - CLI command definition
     * @returns {string} Handler code
     */
    generateCLIHandler(command) {
        const toolName = `cli_${command.name.replace(/-/g, '_')}`;
        return `// Handler for CLI command: ${command.name}
handlers['${toolName}'] = async (args) => {
    try {
        // Build command string
        const argString = Object.entries(args)
            .map(([key, value]) => \`--\${key} "\${value}"\`)
            .join(' ');
        
        const { stdout, stderr } = await execAsync(
            \`${command.binary || command.name} \${argString}\`
        );
        
        if (stderr) {
            console.error('Command stderr:', stderr);
        }
        
        return {
            success: true,
            output: stdout,
            error: stderr || null
        };
    } catch (error) {
        throw new Error(\`CLI command failed: \${error.message}\`);
    }
};`;
    }

    /**
     * Generate package.json for MCP dependencies
     * @param {string} scenarioName - Name of the scenario
     * @returns {Object} package.json content
     */
    generatePackageJson(scenarioName) {
        return {
            name: `${scenarioName}-mcp`,
            version: '1.0.0',
            description: `MCP server for ${scenarioName} scenario`,
            main: 'server.js',
            scripts: {
                start: 'node server.js',
                install: 'npm install'
            },
            dependencies: {
                '@modelcontextprotocol/sdk': '^0.5.0',
                'axios': '^1.6.0'
            },
            engines: {
                node: '>=18.0.0'
            }
        };
    }

    /**
     * Generate README for MCP usage
     * @param {string} scenarioName - Name of the scenario
     * @param {Object} manifest - MCP manifest
     * @returns {string} README content
     */
    generateReadme(scenarioName, manifest) {
        const tools = manifest.capabilities.tools;
        
        return `# MCP Interface for ${scenarioName}

This directory contains the Model Context Protocol (MCP) server implementation for the ${scenarioName} scenario.

## Available Tools

${tools.map(tool => `### ${tool.name}
${tool.description}

**Input Schema:**
\`\`\`json
${JSON.stringify(tool.inputSchema, null, 2)}
\`\`\`
`).join('\n')}

## Usage

### Starting the MCP Server

\`\`\`bash
cd mcp
npm install
npm start
\`\`\`

### Connecting from Claude

Add this to your Claude MCP configuration:

\`\`\`json
{
  "mcpServers": {
    "${scenarioName}": {
      "command": "node",
      "args": ["${path.resolve(`/scenarios/${scenarioName}/mcp/server.js`)}"],
      "env": {
        "MCP_PORT": "${this.allocatePort(scenarioName)}"
      }
    }
  }
}
\`\`\`

### Testing Tools

You can test individual tools using the MCP client:

\`\`\`bash
scenario-to-mcp test ${scenarioName} --tool <tool-name> --args '{"param": "value"}'
\`\`\`

## Development

To modify the MCP interface:

1. Edit the handlers in \`handlers/index.js\`
2. Update the manifest in \`manifest.json\`
3. Restart the MCP server

## Port Configuration

Default MCP port: ${this.allocatePort(scenarioName)}

You can override this by setting the \`MCP_PORT\` environment variable.

---
*Generated by scenario-to-mcp*
`;
    }

    /**
     * Convert API endpoint to tool name
     * @param {Object} endpoint - API endpoint
     * @returns {string} Tool name
     */
    apiEndpointToToolName(endpoint) {
        const path = endpoint.path
            .replace(/^\/api\/v\d+\//, '')
            .replace(/\//g, '_')
            .replace(/[{}]/g, '')
            .replace(/:/g, '');
        
        return `api_${endpoint.method.toLowerCase()}_${path}`;
    }

    /**
     * Convert CLI arguments to JSON schema
     * @param {Array} args - CLI arguments
     * @returns {Object} Properties schema
     */
    cliArgsToSchema(args) {
        const properties = {};
        
        args.forEach(arg => {
            properties[arg.name] = {
                type: arg.type || 'string',
                description: arg.description || `${arg.name} parameter`
            };
        });
        
        return properties;
    }

    /**
     * Allocate MCP port for scenario
     * @param {string} scenarioName - Name of the scenario
     * @returns {number} Allocated port
     */
    allocatePort(scenarioName) {
        // Simple hash-based port allocation
        let hash = 0;
        for (let i = 0; i < scenarioName.length; i++) {
            hash = ((hash << 5) - hash) + scenarioName.charCodeAt(i);
            hash = hash & hash;
        }
        
        // Map to port range 4000-5000
        return 4000 + Math.abs(hash) % 1000;
    }

    /**
     * Analyze scenario to extract API and CLI information
     * @param {string} scenarioPath - Path to scenario
     * @returns {Promise<Object>} Extracted information
     */
    async analyzeScenario(scenarioPath) {
        const info = {
            apiEndpoints: [],
            cliCommands: [],
            hasAPI: false,
            hasCLI: false
        };
        
        try {
            // Check for API implementation
            const apiPath = path.join(scenarioPath, 'api');
            if (await this.pathExists(apiPath)) {
                info.hasAPI = true;
                
                // Try to extract API endpoints from main.go or similar
                const mainFile = await this.findMainFile(apiPath);
                if (mainFile) {
                    info.apiEndpoints = await this.extractAPIEndpoints(mainFile);
                }
            }
            
            // Check for CLI implementation
            const cliPath = path.join(scenarioPath, 'cli');
            if (await this.pathExists(cliPath)) {
                info.hasCLI = true;
                
                // Try to extract CLI commands
                const cliFile = await this.findCLIFile(cliPath);
                if (cliFile) {
                    info.cliCommands = await this.extractCLICommands(cliFile);
                }
            }
        } catch (error) {
            console.error('Error analyzing scenario:', error);
        }
        
        return info;
    }

    /**
     * Extract API endpoints from source file
     * @param {string} filePath - Path to source file
     * @returns {Promise<Array>} Extracted endpoints
     */
    async extractAPIEndpoints(filePath) {
        const endpoints = [];
        
        try {
            const content = await fs.readFile(filePath, 'utf-8');
            
            // Pattern matching for common API frameworks
            const patterns = [
                // Go Gin/Echo patterns
                /router\.(GET|POST|PUT|DELETE|PATCH)\("([^"]+)",/g,
                /r\.(GET|POST|PUT|DELETE|PATCH)\("([^"]+)",/g,
                
                // Express patterns
                /app\.(get|post|put|delete|patch)\(['"]([^'"]+)['"]/g,
                /router\.(get|post|put|delete|patch)\(['"]([^'"]+)['"]/g
            ];
            
            for (const pattern of patterns) {
                let match;
                while ((match = pattern.exec(content)) !== null) {
                    endpoints.push({
                        method: match[1].toUpperCase(),
                        path: match[2],
                        description: `${match[1].toUpperCase()} ${match[2]}`
                    });
                }
            }
        } catch (error) {
            console.error('Error extracting API endpoints:', error);
        }
        
        return endpoints;
    }

    /**
     * Extract CLI commands from source file
     * @param {string} filePath - Path to source file
     * @returns {Promise<Array>} Extracted commands
     */
    async extractCLICommands(filePath) {
        const commands = [];
        
        try {
            const content = await fs.readFile(filePath, 'utf-8');
            
            // Pattern matching for common CLI patterns
            const patterns = [
                // Bash case statements
                /case\s+["']?(\w+)["']?\s+in/g,
                /"(\w+)"\)\s*$/gm,
                
                // Help text patterns
                /echo\s+["'](\w+)\s+-\s+([^"']+)["']/g
            ];
            
            for (const pattern of patterns) {
                let match;
                while ((match = pattern.exec(content)) !== null) {
                    const name = match[1];
                    if (name && !['in', 'esac', 'echo'].includes(name)) {
                        commands.push({
                            name: name,
                            description: match[2] || `Execute ${name} command`
                        });
                    }
                }
            }
        } catch (error) {
            console.error('Error extracting CLI commands:', error);
        }
        
        return [...new Map(commands.map(c => [c.name, c])).values()];
    }

    /**
     * Find main API file
     * @param {string} apiPath - Path to API directory
     * @returns {Promise<string|null>} Path to main file
     */
    async findMainFile(apiPath) {
        const candidates = ['main.go', 'server.js', 'index.js', 'app.js'];
        
        for (const candidate of candidates) {
            const filePath = path.join(apiPath, candidate);
            if (await this.pathExists(filePath)) {
                return filePath;
            }
        }
        
        return null;
    }

    /**
     * Find main CLI file
     * @param {string} cliPath - Path to CLI directory
     * @returns {Promise<string|null>} Path to CLI file
     */
    async findCLIFile(cliPath) {
        try {
            const files = await fs.readdir(cliPath);
            
            // Look for main CLI script
            for (const file of files) {
                if (!file.endsWith('.bats') && !file.endsWith('.md')) {
                    const filePath = path.join(cliPath, file);
                    const stats = await fs.stat(filePath);
                    if (stats.isFile()) {
                        return filePath;
                    }
                }
            }
        } catch (error) {
            console.error('Error finding CLI file:', error);
        }
        
        return null;
    }

    /**
     * Check if path exists
     * @param {string} pathToCheck - Path to check
     * @returns {Promise<boolean>} True if exists
     */
    async pathExists(pathToCheck) {
        try {
            await fs.access(pathToCheck);
            return true;
        } catch {
            return false;
        }
    }
}

// Export for use in other modules
module.exports = MCPCodeGenerator;

// CLI interface if run directly
if (require.main === module) {
    const generator = new MCPCodeGenerator();
    
    async function main() {
        const command = process.argv[2];
        const scenarioName = process.argv[3];
        
        if (!command || !scenarioName) {
            console.log('Usage:');
            console.log('  node code-generator.js generate <scenario-name>');
            console.log('  node code-generator.js analyze <scenario-path>');
            return;
        }
        
        switch (command) {
            case 'generate':
                const scenarioPath = path.join(__dirname, '..', '..', '..', 'scenarios', scenarioName);
                const info = await generator.analyzeScenario(scenarioPath);
                const result = await generator.generateMCPImplementation({
                    scenarioName,
                    scenarioPath,
                    ...info
                });
                console.log(JSON.stringify(result, null, 2));
                break;
                
            case 'analyze':
                const analysis = await generator.analyzeScenario(scenarioName);
                console.log(JSON.stringify(analysis, null, 2));
                break;
        }
    }
    
    main().catch(console.error);
}