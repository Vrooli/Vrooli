<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>Open MCT - Mission Control</title>
    <script src="openmct.js"></script>
    <style>
        html, body {
            height: 100%;
            margin: 0;
            padding: 0;
            overflow: hidden;
        }
        #openmct {
            height: 100%;
        }
    </style>
</head>
<body>
    <div id="openmct"></div>
    <script>
        openmct.setAssetPath('/');

        openmct.install(openmct.plugins.LocalStorage());
        openmct.install(openmct.plugins.MyItems());
        openmct.install(openmct.plugins.UTCTimeSystem());

        // Install telemetry provider
        openmct.install(function TelemetryPlugin() {
            return function install(openmct) {
                const provider = {
                    supportsRequest: function(domainObject) {
                        return domainObject.type === 'telemetry.point';
                    },
                    request: function(domainObject, options) {
                        const url = `/api/telemetry/history?stream=${domainObject.identifier.key}`;
                        return fetch(url)
                            .then(response => response.json())
                            .then(data => data.map(item => ({
                                timestamp: item.timestamp,
                                value: item.value,
                                ...JSON.parse(item.data || '{}')
                            })));
                    },
                    supportsSubscribe: function(domainObject) {
                        return domainObject.type === 'telemetry.point';
                    },
                    subscribe: function(domainObject, callback) {
                        const ws = new WebSocket(`ws://${window.location.hostname}:8198`);
                        
                        ws.onmessage = function(event) {
                            const data = JSON.parse(event.data);
                            if (data.stream === domainObject.identifier.key) {
                                callback({
                                    timestamp: data.timestamp,
                                    value: data.value,
                                    ...data.data
                                });
                            }
                        };

                        return function unsubscribe() {
                            ws.close();
                        };
                    }
                };

                openmct.telemetry.addProvider(provider);
            };
        });

        // Install object provider for telemetry points
        openmct.install(function ObjectPlugin() {
            return function install(openmct) {
                // Root folder
                openmct.objects.addRoot({
                    namespace: 'telemetry',
                    key: 'root'
                });

                const objectProvider = {
                    get: function(identifier) {
                        if (identifier.key === 'root') {
                            return Promise.resolve({
                                identifier: identifier,
                                name: 'Telemetry Streams',
                                type: 'folder',
                                location: 'ROOT'
                            });
                        }

                        // Return telemetry point definitions
                        const telemetryPoints = {
                            'satellite_position': {
                                name: 'Satellite Position',
                                telemetry: {
                                    values: [
                                        { key: 'timestamp', name: 'Time', format: 'utc', hints: { domain: 1 } },
                                        { key: 'value', name: 'Latitude', unit: 'deg', hints: { range: 1 } },
                                        { key: 'longitude', name: 'Longitude', unit: 'deg' },
                                        { key: 'altitude', name: 'Altitude', unit: 'km' },
                                        { key: 'velocity', name: 'Velocity', unit: 'km/s' }
                                    ]
                                }
                            },
                            'sensor_network': {
                                name: 'Sensor Network',
                                telemetry: {
                                    values: [
                                        { key: 'timestamp', name: 'Time', format: 'utc', hints: { domain: 1 } },
                                        { key: 'value', name: 'Temperature', unit: 'Â°C', hints: { range: 1 } },
                                        { key: 'humidity', name: 'Humidity', unit: '%' },
                                        { key: 'pressure', name: 'Pressure', unit: 'hPa' }
                                    ]
                                }
                            },
                            'system_metrics': {
                                name: 'System Metrics',
                                telemetry: {
                                    values: [
                                        { key: 'timestamp', name: 'Time', format: 'utc', hints: { domain: 1 } },
                                        { key: 'value', name: 'CPU Usage', unit: '%', hints: { range: 1 } },
                                        { key: 'memory', name: 'Memory', unit: '%' },
                                        { key: 'disk', name: 'Disk', unit: '%' },
                                        { key: 'network', name: 'Network', unit: 'Mbps' }
                                    ]
                                }
                            }
                        };

                        if (telemetryPoints[identifier.key]) {
                            return Promise.resolve({
                                identifier: identifier,
                                name: telemetryPoints[identifier.key].name,
                                type: 'telemetry.point',
                                telemetry: telemetryPoints[identifier.key].telemetry,
                                location: 'telemetry:root'
                            });
                        }

                        return Promise.reject(new Error('Not found'));
                    }
                };

                openmct.objects.addProvider('telemetry', objectProvider);

                // Add telemetry points as composition of root
                openmct.composition.addProvider({
                    appliesTo: function(domainObject) {
                        return domainObject.identifier.namespace === 'telemetry' 
                            && domainObject.identifier.key === 'root';
                    },
                    load: function() {
                        return Promise.resolve([
                            { namespace: 'telemetry', key: 'satellite_position' },
                            { namespace: 'telemetry', key: 'sensor_network' },
                            { namespace: 'telemetry', key: 'system_metrics' }
                        ]);
                    }
                });

                // Register telemetry point type
                openmct.types.addType('telemetry.point', {
                    name: 'Telemetry Point',
                    description: 'A telemetry data stream',
                    cssClass: 'icon-telemetry'
                });
            };
        });

        // Time conductor configuration
        const ONE_MINUTE = 60 * 1000;
        const ONE_HOUR = 60 * ONE_MINUTE;
        const bounds = {
            start: Date.now() - ONE_HOUR,
            end: Date.now()
        };
        
        openmct.time.clock('local', {
            start: -ONE_HOUR,
            end: 0
        });
        openmct.time.timeSystem('utc');
        openmct.time.bounds(bounds);

        openmct.start();
    </script>
</body>
</html>