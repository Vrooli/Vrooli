#!/bin/bash

# Core functions for Mail-in-a-Box resource

APP_ROOT="${APP_ROOT:-$(builtin cd "${BASH_SOURCE[0]%/*}/../../.." && builtin pwd)}"
MAILINABOX_LIB_DIR="${APP_ROOT}/resources/mail-in-a-box/lib"
MAILINABOX_CONFIG_DIR="${APP_ROOT}/resources/mail-in-a-box/config"

# Source dependencies
source "$MAILINABOX_CONFIG_DIR/defaults.sh"
source "${APP_ROOT}/scripts/lib/utils/format.sh"
source "${APP_ROOT}/scripts/lib/utils/log.sh" 2>/dev/null || true

# Cache flag so we do not repeatedly call Vault export
MAILINABOX_SECRETS_LOADED=${MAILINABOX_SECRETS_LOADED:-0}

# Load secrets from Vault (if available) or environment
mailinabox_load_secrets() {
    if [[ "$MAILINABOX_SECRETS_LOADED" -eq 1 ]]; then
        return 0
    fi

    local export_cmd
    if command -v resource-vault &>/dev/null; then
        if export_cmd=$(resource-vault secrets export mail-in-a-box 2>/dev/null); then
            if [[ -n "$export_cmd" ]]; then
                eval "$export_cmd"
            fi
        fi
    fi

    # Fall back to ~/.vrooli/secrets.json if Vault export is unavailable
    if command -v jq &>/dev/null; then
        local vrooli_root="${VROOLI_ROOT:-"$HOME/Vrooli"}"
        local secrets_file="${vrooli_root}/.vrooli/secrets.json"
        if [[ -f "$secrets_file" ]]; then
            local vars=(
                MAILINABOX_ADMIN_EMAIL
                MAILINABOX_ADMIN_PASSWORD
                MAILINABOX_PRIMARY_HOSTNAME
                MAILINABOX_POSTMASTER_ALIAS
                MAILINABOX_DEFAULT_MAILBOX
                MAILINABOX_DEFAULT_MAILBOX_PASSWORD
                MAILINABOX_SSL_CERT
                MAILINABOX_SSL_KEY
                MAILINABOX_SSL_CHAIN
                MAILINABOX_SSL_CERT_BUNDLE
                MAILINABOX_DKIM_PRIVATE_KEY
            )

            for var_name in "${vars[@]}"; do
                local current="${!var_name:-}"
                local is_default="false"
                case "$var_name" in
                    MAILINABOX_ADMIN_EMAIL)
                        [[ "$current" == "admin@mail.local" ]] && is_default="true"
                        ;;
                    MAILINABOX_ADMIN_PASSWORD)
                        [[ "$current" == "ChangeMe123!" ]] && is_default="true"
                        ;;
                    MAILINABOX_PRIMARY_HOSTNAME)
                        [[ "$current" == "mail.local" ]] && is_default="true"
                        ;;
                    MAILINABOX_POSTMASTER_ALIAS)
                        [[ "$current" == "" || "$current" == "postmaster@mail.local" ]] && is_default="true"
                        ;;
                    MAILINABOX_DEFAULT_MAILBOX)
                        [[ -z "$current" ]] && is_default="true"
                        ;;
                    MAILINABOX_DEFAULT_MAILBOX_PASSWORD)
                        [[ -z "$current" ]] && is_default="true"
                        ;;
                    MAILINABOX_SSL_CERT|MAILINABOX_SSL_KEY|MAILINABOX_SSL_CHAIN|MAILINABOX_SSL_CERT_BUNDLE|MAILINABOX_DKIM_PRIVATE_KEY)
                        [[ -z "$current" ]] && is_default="true"
                        ;;
                esac

                if [[ -z "$current" || "$is_default" == "true" ]]; then
                    local value
                    value=$(jq -r --arg key "$var_name" '.[$key] // empty' "$secrets_file" 2>/dev/null)
                    if [[ -n "$value" && "$value" != "null" ]]; then
                        export "$var_name"="$value"
                    fi
                fi
            done
        fi
    fi

    MAILINABOX_SECRETS_LOADED=1
    return 0
}

# Check that required secrets are present and not using insecure defaults
mailinabox_required_secrets_configured() {
    mailinabox_load_secrets || true

    local missing=false

    # Treat factory defaults as missing configuration
    local default_admin_email="admin@mail.local"
    local default_admin_password="ChangeMe123!"
    local default_hostname="mail.local"

    if [[ -z "${MAILINABOX_ADMIN_EMAIL:-}" || "${MAILINABOX_ADMIN_EMAIL}" == "$default_admin_email" ]]; then
        missing=true
    fi

    if [[ -z "${MAILINABOX_ADMIN_PASSWORD:-}" || "${MAILINABOX_ADMIN_PASSWORD}" == "$default_admin_password" ]]; then
        missing=true
    fi

    if [[ -z "${MAILINABOX_PRIMARY_HOSTNAME:-}" || "${MAILINABOX_PRIMARY_HOSTNAME}" == "$default_hostname" ]]; then
        missing=true
    fi

    $missing && return 1 || return 0
}

# Write the docker-mailserver environment file using configured values
mailinabox_write_env_file() {
    mailinabox_load_secrets || true

    mkdir -p "$MAILINABOX_CONFIG_DIR"

    local postmaster="${MAILINABOX_POSTMASTER_ALIAS:-${MAILINABOX_ADMIN_EMAIL}}"

    cat >"$MAILINABOX_CONFIG_DIR/mailserver.env" <<EOF
# Generated by Vrooli Mail-in-a-Box resource
OVERRIDE_HOSTNAME=${MAILINABOX_PRIMARY_HOSTNAME}
POSTMASTER_ADDRESS=${postmaster}
PERMIT_DOCKER=connected-networks
ENABLE_FAIL2BAN=1
ENABLE_SPAMASSASSIN=1
ENABLE_CLAMAV=0
SPAMASSASSIN_SPAM_TO_INBOX=1
MOVE_SPAM_TO_JUNK=1
VIRUSMAILS_DELETE_DELAY=7
ONE_DIR=0
DMS_DEBUG=0
EOF
}

# Run helper that returns 0 when an email exists inside the container
mailinabox_mailbox_exists() {
    local email="$1"
    [[ -z "$email" ]] && return 1

    docker exec "$MAILINABOX_CONTAINER_NAME" setup email list 2>/dev/null | grep -Fq "$email"
}

# Ensure a mailbox exists with provided credentials
mailinabox_ensure_mailbox() {
    local email="$1"
    local password="$2"

    if [[ -z "$email" || -z "$password" ]]; then
        return 1
    fi

    if mailinabox_mailbox_exists "$email"; then
        docker exec "$MAILINABOX_CONTAINER_NAME" setup email update "$email" "$password" >/dev/null 2>&1 || true
        return 0
    fi

    docker exec "$MAILINABOX_CONTAINER_NAME" setup email add "$email" "$password" >/dev/null 2>&1
}

# Ensure a forwarding alias exists (idempotent)
mailinabox_ensure_alias() {
    local alias="$1"
    local target="$2"

    if [[ -z "$alias" || -z "$target" ]]; then
        return 1
    fi

    if docker exec "$MAILINABOX_CONTAINER_NAME" setup alias list 2>/dev/null | grep -Fq "$alias"; then
        docker exec "$MAILINABOX_CONTAINER_NAME" setup alias update "$alias" "$target" >/dev/null 2>&1 || true
        return 0
    fi

    docker exec "$MAILINABOX_CONTAINER_NAME" setup alias add "$alias" "$target" >/dev/null 2>&1
}

# Extract domain portion from an email address
mailinabox_get_domain_from_email() {
    local email="$1"
    [[ "$email" == *"@"* ]] || return 1
    echo "${email##*@}"
}

# Configure base mailboxes and aliases based on secrets
mailinabox_bootstrap_accounts() {
    if ! mailinabox_is_running; then
        return 1
    fi

    mailinabox_load_secrets || true

    local admin_email="${MAILINABOX_ADMIN_EMAIL:-}"
    local admin_password="${MAILINABOX_ADMIN_PASSWORD:-}"

    if [[ -n "$admin_email" && -n "$admin_password" ]]; then
        mailinabox_ensure_mailbox "$admin_email" "$admin_password" || true
    fi

    # Optional default mailbox
    if [[ -n "${MAILINABOX_DEFAULT_MAILBOX:-}" && -n "${MAILINABOX_DEFAULT_MAILBOX_PASSWORD:-}" ]]; then
        if [[ "${MAILINABOX_DEFAULT_MAILBOX}" != "$admin_email" ]]; then
            mailinabox_ensure_mailbox "${MAILINABOX_DEFAULT_MAILBOX}" "${MAILINABOX_DEFAULT_MAILBOX_PASSWORD}" || true
        fi
    fi

    # Postmaster / abuse aliases
    if [[ -n "$admin_email" ]]; then
        local admin_domain
        admin_domain=$(mailinabox_get_domain_from_email "$admin_email" || true)
        if [[ -n "$admin_domain" ]]; then
            local alias_target="${MAILINABOX_POSTMASTER_ALIAS:-$admin_email}"
            mailinabox_ensure_alias "postmaster@${admin_domain}" "$alias_target" || true
            mailinabox_ensure_alias "abuse@${admin_domain}" "$alias_target" || true
        fi
    fi

    return 0
}

# Check if Mail-in-a-Box is installed
mailinabox_is_installed() {
    if [[ -d "$MAILINABOX_DATA_DIR" ]] && docker inspect "$MAILINABOX_CONTAINER_NAME" >/dev/null 2>&1; then
        return 0
    else
        return 1
    fi
}

# Check if Mail-in-a-Box is running
mailinabox_is_running() {
    local status=$(docker inspect -f '{{.State.Running}}' "$MAILINABOX_CONTAINER_NAME" 2>/dev/null)
    [[ "$status" == "true" ]]
}

# Get Mail-in-a-Box health status
mailinabox_get_health() {
    if ! mailinabox_required_secrets_configured; then
        echo "unhealthy"
        return 1
    fi

    if ! mailinabox_is_running; then
        echo "unhealthy"
        return 1
    fi
    
    # Check SMTP availability (docker-mailserver doesn't have an admin panel)
    if echo "QUIT" | timeout 5 nc "${MAILINABOX_BIND_ADDRESS}" "${MAILINABOX_PORT_SMTP}" 2>/dev/null | grep -q "220"; then
        echo "healthy"
        return 0
    else
        echo "unhealthy"
        return 1
    fi
}

# Get Mail-in-a-Box version
mailinabox_get_version() {
    if mailinabox_is_installed; then
        docker inspect -f '{{.Config.Image}}' "$MAILINABOX_CONTAINER_NAME" 2>/dev/null | cut -d: -f2 || echo "unknown"
    else
        echo "not_installed"
    fi
}

# Get Mail-in-a-Box status details
mailinabox_get_status_details() {
    local details=""
    local secrets_ready=true

    if ! mailinabox_required_secrets_configured; then
        secrets_ready=false
        details="Missing required credentials"
    fi

    if mailinabox_is_running; then
        local account_output
        account_output=$(docker exec "$MAILINABOX_CONTAINER_NAME" bash -c "if [ -f /tmp/docker-mailserver/postfix-accounts.cf ]; then cut -d'|' -f1 /tmp/docker-mailserver/postfix-accounts.cf; fi" 2>/dev/null || true)

        local mailbox_count=0
        local domain_count=0

        if [[ -n "$account_output" ]]; then
            mailbox_count=$(echo "$account_output" | sed '/^\s*$/d' | wc -l | tr -d ' ')
            domain_count=$(echo "$account_output" | awk -F'@' 'NF==2 {gsub(/\s+$/, "", $2); print $2}' | sort -u | sed '/^$/d' | wc -l | tr -d ' ')
        fi

        local running_summary="Mailboxes: ${mailbox_count}, Domains: ${domain_count}"

        if [[ "$secrets_ready" == false ]]; then
            details="${running_summary} - Missing required credentials"
        else
            details="${running_summary}"
        fi
    else
        if [[ "$secrets_ready" == false ]]; then
            details="${details:-Missing required credentials}"
        else
            details="Service not running"
        fi
    fi

    echo "$details"
}

# Get resource URLs
mailinabox_get_urls() {
    local urls=""
    
    # Check if Roundcube webmail is running
    if docker inspect mailinabox-webmail &>/dev/null && [[ "$(docker inspect -f '{{.State.Running}}' mailinabox-webmail 2>/dev/null)" == "true" ]]; then
        urls="Webmail: http://${MAILINABOX_BIND_ADDRESS}:8080"
    else
        urls="Webmail: Not available (install with docker-compose)"
    fi
    
    urls="${urls}, SMTP: ${MAILINABOX_BIND_ADDRESS}:${MAILINABOX_PORT_SMTP}"
    urls="${urls}, IMAP: ${MAILINABOX_BIND_ADDRESS}:${MAILINABOX_PORT_IMAPS}"
    echo "$urls"
}

# Validation functions for tests

# Validate email address format
validate_email() {
    local email="$1"
    # Updated regex to reject consecutive dots in local part
    local regex="^[a-zA-Z0-9]+([._%-][a-zA-Z0-9]+)*@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$"
    
    # Additional check for consecutive dots
    if [[ "$email" == *".."* ]]; then
        echo "Invalid email format: $email (consecutive dots not allowed)" >&2
        return 1
    fi
    
    if [[ "$email" =~ $regex ]]; then
        return 0
    else
        echo "Invalid email format: $email" >&2
        return 1
    fi
}

# Validate password strength
validate_password() {
    local password="$1"
    
    if [[ ${#password} -lt 8 ]]; then
        echo "Password must be at least 8 characters" >&2
        return 1
    fi
    
    return 0
}

# Check if Docker is available
check_docker() {
    if command -v docker &>/dev/null && docker info &>/dev/null; then
        return 0
    else
        echo "Docker is not available or not running" >&2
        return 1
    fi
}

# Get container name
get_container_name() {
    echo "${MAILINABOX_CONTAINER_NAME:-mailinabox}"
}
