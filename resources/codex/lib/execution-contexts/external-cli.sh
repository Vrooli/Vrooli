#!/usr/bin/env bash
################################################################################
# External CLI Execution Context
# 
# Interfaces with OpenAI's Codex CLI for full agent capabilities
# This is Tier 1 - the most powerful execution context
################################################################################

# Setup paths
APP_ROOT="${APP_ROOT:-$(builtin cd "${BASH_SOURCE[0]%/*}/../../../.." && builtin pwd)}"
source "${APP_ROOT}/scripts/lib/utils/log.sh"
source "${APP_ROOT}/resources/codex/lib/common.sh"

################################################################################
# CLI Context Interface
################################################################################

#######################################
# Check if CLI context is available
# Returns:
#   0 if available, 1 if not
#######################################
cli_context::is_available() {
    command -v codex &>/dev/null
}

#######################################
# Get CLI context status
# Returns:
#   JSON status object
#######################################
cli_context::status() {
    local installed="false"
    local version="not installed"
    local configured="false"
    local workspace_exists="false"
    
    if cli_context::is_available; then
        installed="true"
        version=$(codex --version 2>/dev/null | grep -oE '[0-9]+\.[0-9]+\.[0-9]+' || echo "unknown")
        
        # Check configuration
        if [[ -f "$HOME/.codex/config.toml" ]]; then
            configured="true"
        fi
        
        # Check workspace
        local workspace="${CODEX_WORKSPACE:-/tmp/codex-workspace}"
        if [[ -d "$workspace" ]]; then
            workspace_exists="true"
        fi
    fi
    
    cat << EOF
{
  "context": "external-cli",
  "tier": 1,
  "installed": $installed,
  "version": "$version",
  "configured": $configured,
  "workspace_exists": $workspace_exists,
  "capabilities": ["function-calling", "text-generation", "reasoning"]
}
EOF
}

#######################################
# Install CLI context (Codex CLI)
# Returns:
#   0 on success, 1 on failure
#######################################
cli_context::install() {
    if cli_context::is_available; then
        log::info "Codex CLI already installed (version: $(codex --version 2>/dev/null | head -n1))"
        return 0
    fi
    
    if ! command -v npm &>/dev/null; then
        log::error "npm is required to install Codex CLI"
        log::info "Install Node.js/npm first: https://nodejs.org"
        return 1
    fi
    
    log::info "Installing OpenAI Codex CLI..."
    
    if npm install -g @openai/codex; then
        log::success "Codex CLI installed successfully"
        cli_context::configure
        return 0
    else
        log::error "Failed to install Codex CLI"
        return 1
    fi
}

#######################################
# Configure CLI context
# Returns:
#   0 on success, 1 on failure
#######################################
cli_context::configure() {
    local config_dir="$HOME/.codex"
    local config_file="$config_dir/config.toml"
    
    # Get API key
    local api_key
    api_key=$(codex::get_api_key)
    
    if [[ -z "$api_key" ]]; then
        log::warn "No API key found for Codex CLI configuration"
        return 1
    fi
    
    # Create config directory
    mkdir -p "$config_dir"
    
    # Check if config exists
    if [[ -f "$config_file" ]]; then
        log::info "Codex CLI config already exists"
        return 0
    fi
    
    log::info "Configuring Codex CLI..."
    
    # Create config file
    cat > "$config_file" << EOF
# Codex CLI Configuration - Generated by resource-codex

# Model settings
model = "codex-mini-latest"
model_provider = "openai"

# Authentication
preferred_auth_method = "apikey"

# Behavior settings
auto_approve = false
verbose = false
max_file_size = 1000000

# Workspace
default_workspace = "${CODEX_WORKSPACE:-/tmp/codex-workspace}"

# MCP servers (optional)
# [mcp_servers.example]
# command = ["node", "/path/to/server.js"]
# args = []
EOF
    
    # Set API key as environment variable
    export OPENAI_API_KEY="$api_key"
    
    log::success "Codex CLI configured"
    return 0
}

################################################################################
# Execution Interface
################################################################################

#######################################
# Execute request through CLI context
# Arguments:
#   $1 - Capability type (function-calling, text-generation, reasoning)
#   $2 - Model config (JSON)
#   $3 - User request
# Returns:
#   0 on success, 1 on failure
#######################################
cli_context::execute() {
    local capability="$1"
    local model_config="$2"
    local request="$3"
    
    if ! cli_context::is_available; then
        log::error "Codex CLI not available. Install with: resource-codex manage install-cli"
        return 1
    fi
    
    # Ensure API key is set
    local api_key
    api_key=$(codex::get_api_key)
    if [[ -n "$api_key" ]]; then
        export OPENAI_API_KEY="$api_key"
    fi
    
    # Create workspace directory
    local workspace="${CODEX_WORKSPACE:-/tmp/codex-workspace}"
    mkdir -p "$workspace"
    
    log::info "Executing via Codex CLI agent..."
    log::debug "Capability: $capability"
    log::debug "Workspace: $workspace"
    
    # Get execution mode
    local mode="${CODEX_CLI_MODE:-auto}"
    
    # Extract model from config if provided
    local model
    if [[ -n "$model_config" ]]; then
        model=$(echo "$model_config" | jq -r '.model_name // "codex-mini-latest"' 2>/dev/null || echo "codex-mini-latest")
    else
        model="codex-mini-latest"
    fi
    
    # Save request to file for complex inputs
    local prompt_file="$workspace/prompt-$$.txt"
    echo "$request" > "$prompt_file"
    
    # Execute with Codex CLI
    cd "$workspace" || return 1
    
    local exit_code
    
    # Add capability-specific context to the request
    case "$capability" in
        function-calling)
            echo "Use tools to complete this task. Create files, run commands, and test as needed." >> "$prompt_file"
            ;;
        reasoning)
            echo "Think step by step and show your reasoning process." >> "$prompt_file"
            ;;
        text-generation)
            echo "Generate the requested code or content." >> "$prompt_file"
            ;;
    esac
    
    # Run Codex with appropriate flags
    codex \
        --mode "$mode" \
        --model "$model" \
        --file "$prompt_file"
    exit_code=$?
    
    # Cleanup
    rm -f "$prompt_file"
    
    if [[ $exit_code -eq 0 ]]; then
        log::success "Codex CLI execution completed successfully"
        
        # Show created/modified files
        local files_created=$(find "$workspace" -type f -newer "$prompt_file" 2>/dev/null | wc -l)
        if [[ $files_created -gt 0 ]]; then
            log::info "Files created/modified in workspace:"
            find "$workspace" -type f -newer "$prompt_file" 2>/dev/null | head -10
        fi
    else
        log::error "Codex CLI execution failed with exit code: $exit_code"
    fi
    
    return $exit_code
}

################################################################################
# Management Functions
################################################################################

#######################################
# Update CLI context to latest version
# Returns:
#   0 on success, 1 on failure
#######################################
cli_context::update() {
    if ! cli_context::is_available; then
        log::info "Codex CLI not installed, installing..."
        return cli_context::install
    fi
    
    log::info "Updating Codex CLI..."
    
    # Use built-in upgrade command
    if codex --upgrade; then
        log::success "Codex CLI updated to $(codex --version 2>/dev/null | head -n1)"
        return 0
    else
        # Fallback to npm
        npm update -g @openai/codex
        return $?
    fi
}

#######################################
# Clean CLI workspace
# Returns:
#   0 on success
#######################################
cli_context::clean() {
    local workspace="${CODEX_WORKSPACE:-/tmp/codex-workspace}"
    
    if [[ -d "$workspace" ]]; then
        log::info "Cleaning CLI workspace: $workspace"
        rm -rf "$workspace"/*
        log::success "Workspace cleaned"
    else
        log::info "Workspace doesn't exist: $workspace"
    fi
    
    return 0
}

################################################################################
# Task-Specific Functions
################################################################################

#######################################
# Fix code issues using CLI
# Arguments:
#   $1 - File or directory to fix
#   $2 - Issue description
# Returns:
#   0 on success, 1 on failure
#######################################
cli_context::fix() {
    local target="$1"
    local issue="${2:-}"
    
    local prompt="Fix the code in $target"
    if [[ -n "$issue" ]]; then
        prompt="$prompt. Issue: $issue"
    fi
    
    cli_context::execute "function-calling" "" "$prompt"
}

#######################################
# Generate tests using CLI
# Arguments:
#   $1 - File or code to test
# Returns:
#   0 on success, 1 on failure
#######################################
cli_context::generate_tests() {
    local target="$1"
    
    local prompt="Generate comprehensive tests for: $target. Use appropriate testing framework and run the tests to verify they work."
    cli_context::execute "function-calling" "" "$prompt"
}

#######################################
# Refactor code using CLI
# Arguments:
#   $1 - File or directory to refactor  
#   $2 - Refactoring goals
# Returns:
#   0 on success, 1 on failure
#######################################
cli_context::refactor() {
    local target="$1"
    local goals="${2:-improve readability and performance}"
    
    local prompt="Refactor the code in $target to $goals. Maintain functionality while improving code quality."
    cli_context::execute "function-calling" "" "$prompt"
}

# Export functions for external use
export -f cli_context::is_available
export -f cli_context::execute
export -f cli_context::install
export -f cli_context::configure