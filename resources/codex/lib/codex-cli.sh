#!/usr/bin/env bash
################################################################################
# Codex CLI Integration - Bridge to OpenAI's 2025 Codex Agent
# 
# This module integrates the official OpenAI Codex CLI tool
# providing full agent capabilities with tool execution
################################################################################

# Setup paths
APP_ROOT="${APP_ROOT:-$(builtin cd "${BASH_SOURCE[0]%/*}/../../.." && builtin pwd)}"
source "${APP_ROOT}/scripts/lib/utils/log.sh"
source "${APP_ROOT}/resources/codex/lib/common.sh"

################################################################################
# Codex CLI Detection and Installation
################################################################################

#######################################
# Check if Codex CLI is installed
# Returns:
#   0 if installed, 1 if not
#######################################
codex::cli::is_installed() {
    command -v codex &>/dev/null
}

#######################################
# Get Codex CLI version
# Returns:
#   Version string or "not installed"
#######################################
codex::cli::version() {
    if codex::cli::is_installed; then
        codex --version 2>/dev/null | grep -oE '[0-9]+\.[0-9]+\.[0-9]+' || echo "unknown"
    else
        echo "not installed"
    fi
}

#######################################
# Install Codex CLI via npm
# Returns:
#   0 on success, 1 on failure
#######################################
codex::cli::install() {
    if codex::cli::is_installed; then
        log::info "Codex CLI already installed (version: $(codex::cli::version))"
        return 0
    fi
    
    if ! command -v npm &>/dev/null; then
        log::error "npm is required to install Codex CLI"
        log::info "Install Node.js/npm first: https://nodejs.org"
        return 1
    fi
    
    log::info "Installing OpenAI Codex CLI..."
    
    # Install globally
    if npm install -g @openai/codex; then
        log::success "Codex CLI installed successfully"
        
        # Configure if we have an API key
        codex::cli::configure
        
        return 0
    else
        log::error "Failed to install Codex CLI"
        return 1
    fi
}

#######################################
# Update Codex CLI to latest version
# Returns:
#   0 on success, 1 on failure
#######################################
codex::cli::update() {
    if ! codex::cli::is_installed; then
        log::info "Codex CLI not installed, installing..."
        return codex::cli::install
    fi
    
    log::info "Updating Codex CLI..."
    
    # Use built-in upgrade command
    if codex --upgrade; then
        log::success "Codex CLI updated to $(codex::cli::version)"
        return 0
    else
        # Fallback to npm
        npm update -g @openai/codex
        return $?
    fi
}

################################################################################
# Codex CLI Configuration
################################################################################

#######################################
# Configure Codex CLI with API key
# Returns:
#   0 on success, 1 on failure
#######################################
codex::cli::configure() {
    local config_dir
    config_dir=$(codex::ensure_home | tail -n1)
    local config_file="$config_dir/config.toml"
    
    # Get API key
    local api_key
    api_key=$(codex::get_api_key)
    
    if [[ -z "$api_key" ]]; then
        log::warn "No API key found for Codex CLI configuration"
        return 1
    fi
    
    # Create config directory
    mkdir -p "$config_dir"
    
    # Check if config exists
    if [[ -f "$config_file" ]]; then
        log::info "Codex CLI config already exists"
        return 0
    fi
    
    log::info "Configuring Codex CLI..."
    
    # Create config file
    cat > "$config_file" <<EOF
# Codex CLI Configuration
# Generated by resource-codex

# Model settings
model = "${CODEX_DEFAULT_MODEL:-codex-mini-latest}"
model_provider = "openai"

# Authentication
preferred_auth_method = "apikey"

# Behavior settings
auto_approve = false
verbose = false
max_file_size = 1000000

# Workspace
default_workspace = "${CODEX_WORKSPACE:-/tmp/codex-workspace}"

# MCP servers (optional)
# [mcp_servers.example]
# command = ["node", "/path/to/server.js"]
# args = []
EOF
    
    # Set API key as environment variable for current session
    export OPENAI_API_KEY="$api_key"
    
    log::success "Codex CLI configured"
    return 0
}

################################################################################
# Codex CLI Execution
################################################################################

#######################################
# Execute a prompt using Codex CLI
# Arguments:
#   $1 - Prompt or task description
#   $2 - Optional: Mode (auto|approve|always)
# Returns:
#   0 on success, 1 on failure
#######################################
codex::cli::execute() {
    local prompt="$1"
    local mode="${2:-${CODEX_CLI_MODE:-auto}}"
    
    if ! codex::cli::is_installed; then
        log::error "Codex CLI not installed. Run: resource-codex manage install-cli"
        return 1
    fi
    
    # Ensure API key is set
    local api_key
    api_key=$(codex::get_api_key)
    if [[ -n "$api_key" ]]; then
        export OPENAI_API_KEY="$api_key"
    fi
    
    # Create workspace directory
    local workspace="${CODEX_WORKSPACE:-/tmp/codex-workspace}"
    mkdir -p "$workspace"
    
    log::info "Executing with Codex agent (mode: $mode)..."
    log::info "Workspace: $workspace"
    
    # Save prompt to file for complex inputs
    mkdir -p "$workspace"

    local codex_home
    codex_home=$(codex::ensure_home | tail -n1)

    local original_home="$HOME"
    local home_overridden=false
    if [[ "${CODEX_HOME_OVERRIDE_REQUIRED:-false}" == "true" ]]; then
        export HOME="$codex_home"
        home_overridden=true
    fi

    local prompt_file="$workspace/codex-prompt-$$.txt"
    printf '%s\n' "$prompt" > "$prompt_file"

    local marker_file="$workspace/.codex-run-$$.marker"
    : > "$marker_file"
    trap "rm -f '$prompt_file' '$marker_file'" RETURN

    local model="${CODEX_DEFAULT_MODEL:-codex-mini-latest}"
    local sandbox="${CODEX_CLI_SANDBOX:-workspace-write}"
    local approval_policy="${mode:-auto}"
    local codex_args=("codex" "exec" "-m" "$model" "-C" "$workspace" "--skip-git-repo-check")

    case "$approval_policy" in
        ""|auto)
            codex_args+=("--full-auto")
            ;;
        approve|on-request)
            codex_args+=("-s" "$sandbox" "-a" "on-request")
            ;;
        never|always)
            codex_args+=("-s" "$sandbox" "-a" "never")
            ;;
        yolo)
            codex_args+=("--dangerously-bypass-approvals-and-sandbox")
            ;;
        on-failure|untrusted)
            codex_args+=("-s" "$sandbox" "-a" "$approval_policy")
            ;;
        *)
            codex_args+=("-s" "$sandbox" "-a" "$approval_policy")
            ;;
    esac

    if [[ "$sandbox" == "workspace-write" && "$approval_policy" != "yolo" ]]; then
        codex_args+=("-c" "sandbox_workspace_write.network_access=true")
    fi

    if [[ -n "${CODEX_MAX_TURNS:-}" ]]; then
        codex_args+=("-c" "conversation.max_turns=${CODEX_MAX_TURNS}")
    fi

    if [[ -n "${CODEX_CLI_EXTRA_ARGS:-}" ]]; then
        # shellcheck disable=SC2206
        codex_args+=(${CODEX_CLI_EXTRA_ARGS})
    fi

    # Ensure API key available for CLI
    local api_key
    api_key=$(codex::get_api_key)
    if [[ -n "$api_key" ]]; then
        export OPENAI_API_KEY="$api_key"
    fi

    export CODEX_HOME="$codex_home"

    local exit_code
    local task_timeout="${CODEX_TIMEOUT:-}"
    if [[ -n "$task_timeout" && "$task_timeout" =~ ^[0-9]+$ && "$task_timeout" -gt 0 ]]; then
        timeout "$task_timeout" "${codex_args[@]}" < "$prompt_file"
        exit_code=$?
    else
        "${codex_args[@]}" < "$prompt_file"
        exit_code=$?
    fi

    if [[ $exit_code -eq 124 ]]; then
        log::error "Codex agent timed out after ${task_timeout}s"
    elif [[ $exit_code -eq 0 ]]; then
        log::success "Codex agent completed successfully"

        local new_files
        new_files=$(find "$workspace" -type f -newer "$marker_file" ! -samefile "$prompt_file" 2>/dev/null || true)
        if [[ -n "$new_files" ]]; then
            log::info "Files created/modified in workspace:"
            echo "$new_files"
        fi
    else
        log::error "Codex agent failed with exit code: $exit_code"
    fi

    rm -f "$prompt_file" "$marker_file"

    if [[ "$home_overridden" == true ]]; then
        export HOME="$original_home"
    fi

    return $exit_code
}

#######################################
# Execute with specific Codex model
# Arguments:
#   $1 - Model name
#   $2 - Prompt
# Returns:
#   0 on success, 1 on failure
#######################################
codex::cli::execute_with_model() {
    local model="$1"
    local prompt="$2"
    local exec_mode="${3:-}" 

    # Temporarily override model
    local old_model="$CODEX_DEFAULT_MODEL"
    export CODEX_DEFAULT_MODEL="$model"

    local result
    if [[ -n "$exec_mode" ]]; then
        codex::cli::execute "$prompt" "$exec_mode"
        result=$?
    else
        codex::cli::execute "$prompt"
        result=$?
    fi

    # Restore old model
    export CODEX_DEFAULT_MODEL="$old_model"

    return $result
}

################################################################################
# High-Level Task Functions
################################################################################

#######################################
# Generate code using Codex agent
# Arguments:
#   $1 - Code generation prompt
# Returns:
#   0 on success, 1 on failure
#######################################
codex::cli::generate() {
    local prompt="Generate the following code: $1"
    codex::cli::execute "$prompt" "auto"
}

#######################################
# Fix code issues using Codex agent
# Arguments:
#   $1 - File or directory to fix
#   $2 - Optional: Issue description
# Returns:
#   0 on success, 1 on failure
#######################################
codex::cli::fix() {
    local target="$1"
    local issue="${2:-}"
    
    local prompt="Fix the code in $target"
    if [[ -n "$issue" ]]; then
        prompt="$prompt. Issue: $issue"
    fi
    
    codex::cli::execute "$prompt" "approve"
}

#######################################
# Generate tests using Codex agent
# Arguments:
#   $1 - File or code to test
# Returns:
#   0 on success, 1 on failure
#######################################
codex::cli::test() {
    local target="$1"
    
    local prompt="Generate comprehensive tests for: $target. Use appropriate testing framework and run the tests."
    codex::cli::execute "$prompt" "auto"
}

#######################################
# Refactor code using Codex agent
# Arguments:
#   $1 - File or directory to refactor
#   $2 - Optional: Refactoring goals
# Returns:
#   0 on success, 1 on failure
#######################################
codex::cli::refactor() {
    local target="$1"
    local goals="${2:-improve readability and performance}"
    
    local prompt="Refactor the code in $target to $goals"
    codex::cli::execute "$prompt" "approve"
}

################################################################################
# Status and Information
################################################################################

#######################################
# Show Codex CLI status
# Returns:
#   0 if healthy, 1 if issues
#######################################
codex::cli::status() {
    echo "Codex CLI Status:"
    echo "----------------"
    
    local codex_home
    codex_home=$(codex::ensure_home | tail -n1)
    local config_file="${codex_home}/config.toml"
    
    # Check installation
    if codex::cli::is_installed; then
        echo "✅ Installed: $(codex::cli::version)"
    else
        echo "❌ Not installed"
        echo "   Run: resource-codex manage install-cli"
        return 1
    fi
    
    # Check configuration
    if [[ -f "$config_file" ]]; then
        echo "✅ Configured"
        
        # Show current model
        local model=$(grep "^model = " "$config_file" 2>/dev/null | cut -d'"' -f2)
        echo "   Model: ${model:-unknown}"
    else
        echo "⚠️  Not configured"
        echo "   Run: resource-codex manage configure-cli"
    fi
    
    # Check API key
    local api_key
    api_key=$(codex::get_api_key)
    if [[ -n "$api_key" ]]; then
        echo "✅ API key available"
    else
        echo "❌ No API key found"
    fi
    
    # Check workspace
    local workspace="${CODEX_WORKSPACE:-/tmp/codex-workspace}"
    if [[ -d "$workspace" ]]; then
        local file_count=$(find "$workspace" -type f 2>/dev/null | wc -l)
        echo "✅ Workspace: $workspace ($file_count files)"
    else
        echo "   Workspace: $workspace (not created yet)"
    fi

    echo "   Codex home: $codex_home"
    echo "   Max turns: ${CODEX_MAX_TURNS:-auto}"
    echo "   Timeout: ${CODEX_TIMEOUT:-auto}"

    return 0
}

################################################################################
# Smart Routing Function
################################################################################

#######################################
# Smart execution routing
# Routes to Codex CLI if available, else API
# Arguments:
#   $1 - Prompt
# Returns:
#   0 on success, 1 on failure
#######################################
codex::smart_execute() {
    local prompt="$1"
    
    # Priority 1: Codex CLI (full agent)
    if codex::cli::is_installed; then
        log::info "Using Codex CLI agent..."
        return codex::cli::execute "$prompt"
    fi
    
    # Priority 2: codex-mini-latest model via API
    # Note: codex-mini-latest only works with /responses endpoint, not /chat/completions
    # Skip API usage of codex-mini-latest for now - it requires different endpoint
    if [[ "${CODEX_PREFER_MODEL:-true}" == "true" && "${CODEX_USE_RESPONSES_API:-false}" == "true" ]]; then
        log::info "Using codex-mini-latest model via Responses API..."
        
        # TODO: Implement /responses endpoint support
        # For now, fall through to GPT models
        log::info "Responses API not yet implemented, falling back to GPT models..."
    fi
    
    # Priority 3: Fallback to GPT models
    log::info "Using GPT model via API..."
    if type -t codex::generate_code &>/dev/null; then
        codex::generate_code "$prompt"
    else
        log::error "No execution backend available"
        return 1
    fi
}

# Export functions for use in other scripts
export -f codex::cli::is_installed
export -f codex::cli::execute
export -f codex::smart_execute
