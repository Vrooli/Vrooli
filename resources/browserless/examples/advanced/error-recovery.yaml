workflow:
  name: "error-recovery"
  description: "Demonstrate error detection and recovery using conditional branching"
  version: "2.0.0"
  
  parameters:
    target_url:
      type: string
      required: true
      description: "URL to test"
      default: "http://localhost:3000"
    max_retries:
      type: integer
      required: false
      description: "Maximum retry attempts"
      default: 3
    output_dir:
      type: string
      required: false
      description: "Directory for outputs"
      default: "./error-recovery-output"
  
  # Define error recovery strategies
  sub_workflows:
    handle_network_error:
      steps:
        - name: "wait-before-retry"
          action: "wait"
          duration: 5000
          
        - name: "log-retry"
          action: "log"
          message: "Network error detected, retrying..."
          
        - name: "retry-navigation"
          action: "navigate"
          url: "${params.target_url}"
    
    handle_form_error:
      steps:
        - name: "clear-form"
          action: "evaluate"
          script: |
            // Clear all form inputs
            document.querySelectorAll('input[type="text"], input[type="email"], textarea').forEach(input => {
              input.value = '';
            });
            return true;
          
        - name: "highlight-errors"
          action: "evaluate"
          script: |
            // Find and return error fields
            const errors = [];
            document.querySelectorAll('.error, .invalid, [aria-invalid="true"]').forEach(el => {
              errors.push({
                field: el.getAttribute('name') || el.id || 'unknown',
                message: el.getAttribute('aria-describedby') || 
                        document.querySelector(`[id="${el.getAttribute('aria-describedby')}"]`)?.textContent ||
                        'Field has error'
              });
            });
            return errors;
          output: "${params.output_dir}/form-errors.json"
  
  steps:
    # Step 1: Initial navigation with error detection
    - name: "navigate-with-check"
      action: "navigate"
      url: "${params.target_url}"
      label: "navigation_start"
      
    - name: "wait-for-initial-load"
      action: "wait"
      duration: 2000
      
    # Step 2: Check for various error conditions
    - name: "check-404-error"
      action: "condition"
      condition_type: "element_text"
      selector: "body"
      text: "404"
      match_type: "contains"
      then_steps:
        - name: "capture-404"
          action: "screenshot"
          path: "${params.output_dir}/404-error.png"
          
        - name: "log-404"
          action: "log"
          message: "404 Page Not Found error detected"
          
        - name: "extract-404-details"
          action: "evaluate"
          script: |
            return {
              error: '404',
              url: window.location.href,
              title: document.title,
              message: document.body.textContent.substring(0, 500)
            };
          output: "${params.output_dir}/404-details.json"
          
        - name: "fail-404"
          action: "evaluate"
          script: "throw new Error('404 Page Not Found')"
    
    # Step 3: Check for 500 errors
    - name: "check-500-error"
      action: "condition"
      condition_type: "element_text"
      selector: "body"
      text: "500"
      match_type: "contains"
      then_steps:
        - name: "capture-500"
          action: "screenshot"
          path: "${params.output_dir}/500-error.png"
          
        - name: "check-retry-available"
          action: "condition"
          condition_type: "element_visible"
          selector: "button:contains('Retry'), a:contains('Retry')"
          then_steps:
            - name: "click-retry"
              action: "click"
              selector: "button:contains('Retry'), a:contains('Retry')"
              
            - name: "wait-after-retry"
              action: "wait"
              duration: 3000
              
            - name: "jump-to-start"
              action: "jump"
              label: "navigation_start"
          else_steps:
            - name: "log-500-fatal"
              action: "log"
              message: "500 Server Error - No retry option available"
    
    # Step 4: Check for JavaScript errors
    - name: "check-js-errors"
      action: "evaluate"
      script: |
        // Check if there's a React error boundary or Angular error
        const hasReactError = document.querySelector('.error-boundary, #react-error');
        const hasAngularError = document.querySelector('.ng-error, [ng-error]');
        const hasVueError = document.querySelector('.vue-error-page');
        
        return hasReactError || hasAngularError || hasVueError ? true : false;
      variable: "has_js_error"
      
    - name: "handle-js-error"
      action: "condition"
      condition: "{{has_js_error}}"
      condition_type: "javascript"
      then_steps:
        - name: "capture-js-error"
          action: "screenshot"
          path: "${params.output_dir}/js-error.png"
          
        - name: "extract-error-stack"
          action: "evaluate"
          script: |
            const errorElement = document.querySelector('.error-stack, .stack-trace, pre');
            return {
              hasError: true,
              stack: errorElement ? errorElement.textContent : 'No stack trace available',
              url: window.location.href
            };
          output: "${params.output_dir}/js-error-details.json"
    
    # Step 5: Check for form validation errors
    - name: "check-form-present"
      action: "condition"
      condition_type: "element_visible"
      selector: "form"
      then_steps:
        - name: "fill-test-form"
          action: "fill"
          selector: "input[type='email']"
          text: "invalid-email"  # Intentionally invalid
          
        - name: "submit-form"
          action: "click"
          selector: "button[type='submit']"
          
        - name: "wait-for-validation"
          action: "wait"
          duration: 1000
          
        - name: "check-validation-errors"
          action: "condition"
          condition_type: "element_visible"
          selector: ".error-message, .validation-error, [role='alert']"
          then_steps:
            - name: "handle-validation"
              action: "call_sub_workflow"
              sub_workflow: "handle_form_error"
              
            - name: "fix-email"
              action: "fill"
              selector: "input[type='email']"
              text: "valid@example.com"
              
            - name: "resubmit"
              action: "click"
              selector: "button[type='submit']"
    
    # Step 6: Check for toast/snackbar errors
    - name: "monitor-toasts"
      action: "condition"
      condition_type: "element_visible"
      selector: ".toast-error, .snackbar.error, .notification.error"
      then_steps:
        - name: "capture-toast"
          action: "screenshot_element"
          selector: ".toast-error, .snackbar.error, .notification.error"
          path: "${params.output_dir}/toast-error.png"
          
        - name: "extract-toast-message"
          action: "extract_text"
          selector: ".toast-error, .snackbar.error, .notification.error"
          variable: "toast_message"
          
        - name: "log-toast"
          action: "log"
          message: "Toast error: {{toast_message}}"
          
        - name: "dismiss-toast"
          action: "condition"
          condition_type: "element_visible"
          selector: ".toast-close, .snackbar-close, button[aria-label='Close']"
          then_steps:
            - action: "click"
              selector: ".toast-close, .snackbar-close, button[aria-label='Close']"
    
    # Step 7: Check for modal errors
    - name: "check-error-modal"
      action: "condition"
      condition_type: "element_visible"
      selector: ".modal.error, .dialog[role='alertdialog'], .error-modal"
      then_steps:
        - name: "capture-modal"
          action: "screenshot"
          path: "${params.output_dir}/error-modal.png"
          
        - name: "extract-modal-content"
          action: "evaluate"
          script: |
            const modal = document.querySelector('.modal.error, .dialog[role="alertdialog"], .error-modal');
            if (modal) {
              return {
                title: modal.querySelector('.modal-title, h2, h3')?.textContent || 'Error',
                message: modal.querySelector('.modal-body, .content, p')?.textContent || '',
                buttons: Array.from(modal.querySelectorAll('button')).map(b => b.textContent)
              };
            }
            return null;
          output: "${params.output_dir}/modal-error.json"
          
        - name: "close-modal"
          action: "click"
          selector: "button:contains('OK'), button:contains('Close'), button[aria-label='Close']"
    
    # Step 8: Network timeout detection
    - name: "check-timeout"
      action: "condition"
      condition_type: "element_text"
      selector: "body"
      text: "timeout"
      match_type: "contains"
      then_steps:
        - name: "handle-timeout"
          action: "call_sub_workflow"
          sub_workflow: "handle_network_error"
    
    # Step 9: Check page loaded successfully
    - name: "verify-page-loaded"
      action: "evaluate"
      script: |
        // Check various indicators of successful page load
        const hasContent = document.body.textContent.trim().length > 100;
        const hasImages = document.querySelectorAll('img').length > 0;
        const hasLinks = document.querySelectorAll('a').length > 0;
        const hasHeadings = document.querySelectorAll('h1, h2, h3').length > 0;
        
        return {
          success: hasContent && (hasImages || hasLinks || hasHeadings),
          metrics: {
            contentLength: document.body.textContent.trim().length,
            imageCount: document.querySelectorAll('img').length,
            linkCount: document.querySelectorAll('a').length,
            headingCount: document.querySelectorAll('h1, h2, h3').length
          }
        };
      variable: "page_status"
      output: "${params.output_dir}/page-status.json"
      
    - name: "final-success-check"
      action: "condition"
      condition: "{{page_status}}.success"
      condition_type: "javascript"
      then_steps:
        - name: "log-success"
          action: "log"
          message: "Page loaded successfully without errors"
          
        - name: "capture-success"
          action: "screenshot"
          path: "${params.output_dir}/success-page.png"
      else_steps:
        - name: "log-poor-content"
          action: "log"
          message: "Page loaded but appears to have minimal content"
          
        - name: "capture-poor-page"
          action: "screenshot"
          path: "${params.output_dir}/poor-content-page.png"