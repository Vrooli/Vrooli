{
  "id": "7829564732190850259",
  "publicId": "break-scheduler-v1",
  "resourceType": "Routine",
  "isPrivate": false,
  "permissions": "{}",
  "isInternal": false,
  "tags": [],
  "versions": [
    {
      "id": "7829564732190850260",
      "publicId": "break-scheduler-v1-0",
      "versionLabel": "1.0.0",
      "versionNotes": "Initial version - Inserts rest periods and transition time",
      "isComplete": true,
      "isPrivate": false,
      "versionIndex": 0,
      "isAutomatable": true,
      "resourceSubType": "RoutineCode",
      "config": {
        "__version": "1.0",
        "callDataCode": {
          "__version": "1.0",
          "schema": {
            "language": "javascript",
            "logic": "function scheduleBreaksAndTransitions({ optimalSchedule, restRequirements, switchingTime }) {\n  const allocations = Array.isArray(optimalSchedule) ? optimalSchedule : [optimalSchedule].filter(Boolean);\n  const breakPrefs = restRequirements || getDefaultBreakPreferences();\n  const transitionNeeds = switchingTime || getDefaultTransitionNeeds();\n  \n  // Group allocations by date for day-by-day processing\n  const allocationsByDate = {};\n  allocations.forEach(allocation => {\n    if (!allocationsByDate[allocation.date]) {\n      allocationsByDate[allocation.date] = [];\n    }\n    allocationsByDate[allocation.date].push(allocation);\n  });\n  \n  const completeTimeBlocks = [];\n  const restPeriods = [];\n  const switchTime = [];\n  \n  // Process each day\n  Object.keys(allocationsByDate).forEach(date => {\n    const dayAllocations = allocationsByDate[date].sort((a, b) => \n      a.startTime.localeCompare(b.startTime)\n    );\n    \n    const daySchedule = buildDayScheduleWithBreaks(dayAllocations, date, breakPrefs, transitionNeeds);\n    \n    completeTimeBlocks.push(...daySchedule.timeBlocks);\n    restPeriods.push(...daySchedule.breaks);\n    switchTime.push(...daySchedule.transitions);\n  });\n  \n  function getDefaultBreakPreferences() {\n    return {\n      shortBreakDuration: 15,\n      longBreakDuration: 60,\n      shortBreakInterval: 90, // Every 90 minutes\n      longBreakInterval: 240, // Every 4 hours\n      lunchBreakTime: '12:00',\n      lunchBreakDuration: 60,\n      maxContinuousWork: 120, // 2 hours max without break\n      breakTypes: {\n        micro: 5,\n        short: 15,\n        medium: 30,\n        long: 60,\n        lunch: 60\n      }\n    };\n  }\n  \n  function getDefaultTransitionNeeds() {\n    return {\n      sameType: 5,     // 5 minutes between similar tasks\n      differentType: 10, // 10 minutes between different types\n      meeting: 15,     // 15 minutes before/after meetings\n      creative: 10,    // 10 minutes for creative work transitions\n      administrative: 5, // 5 minutes for admin tasks\n      deepWork: 15     // 15 minutes for deep work sessions\n    };\n  }\n  \n  function buildDayScheduleWithBreaks(dayAllocations, date, breakPrefs, transitionNeeds) {\n    const timeBlocks = [];\n    const breaks = [];\n    const transitions = [];\n    \n    let currentTime = dayAllocations[0]?.startTime || '09:00';\n    let cumulativeWorkTime = 0;\n    let lastBreakTime = currentTime;\n    \n    for (let i = 0; i < dayAllocations.length; i++) {\n      const currentAllocation = dayAllocations[i];\n      const nextAllocation = dayAllocations[i + 1];\n      \n      // Add transition time before task if needed\n      if (i > 0) {\n        const prevAllocation = dayAllocations[i - 1];\n        const transitionDuration = calculateTransitionTime(prevAllocation, currentAllocation, transitionNeeds);\n        \n        if (transitionDuration > 0) {\n          const transitionStart = timeBlocks[timeBlocks.length - 1]?.endTime || prevAllocation.endTime;\n          const transitionEnd = addMinutesToTime(transitionStart, transitionDuration);\n          \n          transitions.push({\n            date: date,\n            startTime: transitionStart,\n            endTime: transitionEnd,\n            duration: transitionDuration,\n            type: 'task-transition',\n            fromTask: prevAllocation.taskName,\n            toTask: currentAllocation.taskName,\n            reason: getTransitionReason(prevAllocation, currentAllocation)\n          });\n          \n          currentTime = transitionEnd;\n        }\n      }\n      \n      // Check if we need a break before this task\n      const timeSinceLastBreak = getTimeDifferenceMinutes(lastBreakTime, currentTime);\n      const shouldAddBreak = shouldInsertBreak(cumulativeWorkTime, timeSinceLastBreak, currentAllocation, breakPrefs);\n      \n      if (shouldAddBreak.needed) {\n        const breakInfo = addBreak(currentTime, shouldAddBreak.type, shouldAddBreak.duration, date, breaks);\n        currentTime = breakInfo.endTime;\n        cumulativeWorkTime = 0;\n        lastBreakTime = currentTime;\n      }\n      \n      // Add the actual task allocation\n      const taskBlock = {\n        ...currentAllocation,\n        actualStartTime: currentTime,\n        actualEndTime: addMinutesToTime(currentTime, currentAllocation.duration),\n        breaksBefore: breaks.filter(b => b.endTime === currentTime).length,\n        transitionsBefore: transitions.filter(t => t.endTime === currentTime).length\n      };\n      \n      timeBlocks.push(taskBlock);\n      currentTime = taskBlock.actualEndTime;\n      cumulativeWorkTime += currentAllocation.duration;\n      \n      // Check if we need a break after this task (for long tasks)\n      if (currentAllocation.duration >= breakPrefs.maxContinuousWork) {\n        const postTaskBreak = addBreak(currentTime, 'post-intensive', breakPrefs.shortBreakDuration, date, breaks);\n        currentTime = postTaskBreak.endTime;\n        cumulativeWorkTime = 0;\n        lastBreakTime = currentTime;\n      }\n      \n      // Add lunch break if appropriate\n      if (shouldAddLunchBreak(currentTime, nextAllocation, breakPrefs, breaks)) {\n        const lunchBreak = addBreak(breakPrefs.lunchBreakTime, 'lunch', breakPrefs.lunchBreakDuration, date, breaks);\n        currentTime = lunchBreak.endTime;\n        cumulativeWorkTime = 0;\n        lastBreakTime = currentTime;\n      }\n    }\n    \n    return {\n      timeBlocks: timeBlocks,\n      breaks: breaks,\n      transitions: transitions\n    };\n  }\n  \n  function calculateTransitionTime(prevTask, currentTask, needs) {\n    // Base transition time\n    let transitionTime = needs.sameType;\n    \n    // Different task types need more time\n    if (prevTask.taskType !== currentTask.taskType) {\n      transitionTime = needs.differentType;\n    }\n    \n    // Special cases\n    if (currentTask.taskType === 'meeting' || prevTask.taskType === 'meeting') {\n      transitionTime = Math.max(transitionTime, needs.meeting);\n    }\n    \n    if (currentTask.taskType === 'creative' || prevTask.taskType === 'creative') {\n      transitionTime = Math.max(transitionTime, needs.creative);\n    }\n    \n    if (currentTask.taskType === 'development' || prevTask.taskType === 'development') {\n      transitionTime = Math.max(transitionTime, needs.deepWork);\n    }\n    \n    // High priority tasks get more transition time\n    if (currentTask.priority > 80) {\n      transitionTime += 5;\n    }\n    \n    return transitionTime;\n  }\n  \n  function getTransitionReason(prevTask, currentTask) {\n    if (prevTask.taskType === 'meeting' || currentTask.taskType === 'meeting') {\n      return 'meeting-transition';\n    }\n    if (prevTask.taskType !== currentTask.taskType) {\n      return 'context-switch';\n    }\n    if (currentTask.priority > 80) {\n      return 'high-priority-prep';\n    }\n    return 'standard-transition';\n  }\n  \n  function shouldInsertBreak(cumulativeWork, timeSinceBreak, allocation, prefs) {\n    // Mandatory break for continuous work\n    if (cumulativeWork >= prefs.maxContinuousWork) {\n      return { needed: true, type: 'mandatory', duration: prefs.shortBreakDuration };\n    }\n    \n    // Long interval break\n    if (timeSinceBreak >= prefs.longBreakInterval) {\n      return { needed: true, type: 'long-interval', duration: prefs.longBreakDuration };\n    }\n    \n    // Short interval break\n    if (timeSinceBreak >= prefs.shortBreakInterval) {\n      return { needed: true, type: 'short-interval', duration: prefs.shortBreakDuration };\n    }\n    \n    // Break before intensive tasks\n    if (allocation.duration >= 90 && allocation.taskType === 'creative') {\n      return { needed: true, type: 'pre-intensive', duration: prefs.breakTypes.short };\n    }\n    \n    return { needed: false };\n  }\n  \n  function shouldAddLunchBreak(currentTime, nextAllocation, prefs, existingBreaks) {\n    const lunchTime = prefs.lunchBreakTime;\n    const currentHour = parseInt(currentTime.split(':')[0]);\n    const lunchHour = parseInt(lunchTime.split(':')[0]);\n    \n    // Already had lunch\n    if (existingBreaks.some(b => b.type === 'lunch')) return false;\n    \n    // It's lunch time and we have more work after\n    if (currentHour >= lunchHour && nextAllocation) return true;\n    \n    // It's past lunch time and we haven't had it\n    if (currentHour > lunchHour + 1) return true;\n    \n    return false;\n  }\n  \n  function addBreak(startTime, type, duration, date, breaksArray) {\n    const endTime = addMinutesToTime(startTime, duration);\n    \n    const breakPeriod = {\n      date: date,\n      startTime: startTime,\n      endTime: endTime,\n      duration: duration,\n      type: type,\n      activities: getBreakActivities(type, duration),\n      restorative: isRestorativeBreak(type, duration)\n    };\n    \n    breaksArray.push(breakPeriod);\n    return breakPeriod;\n  }\n  \n  function getBreakActivities(type, duration) {\n    const activities = {\n      'micro': ['stretch', 'hydrate'],\n      'short-interval': ['walk', 'stretch', 'snack', 'bathroom'],\n      'long-interval': ['walk', 'exercise', 'meal', 'relax', 'social'],\n      'lunch': ['meal', 'walk', 'relax', 'social'],\n      'mandatory': ['walk', 'stretch', 'hydrate', 'fresh-air'],\n      'pre-intensive': ['meditate', 'stretch', 'mental-prep'],\n      'post-intensive': ['decompress', 'walk', 'hydrate']\n    };\n    \n    return activities[type] || ['rest', 'hydrate'];\n  }\n  \n  function isRestorativeBreak(type, duration) {\n    return duration >= 15 && ['long-interval', 'lunch', 'mandatory'].includes(type);\n  }\n  \n  function addMinutesToTime(timeString, minutes) {\n    const [hours, mins] = timeString.split(':').map(Number);\n    const totalMinutes = hours * 60 + mins + minutes;\n    const newHours = Math.floor(totalMinutes / 60);\n    const newMins = totalMinutes % 60;\n    \n    return `${newHours.toString().padStart(2, '0')}:${newMins.toString().padStart(2, '0')}`;\n  }\n  \n  function getTimeDifferenceMinutes(startTime, endTime) {\n    const [startHours, startMins] = startTime.split(':').map(Number);\n    const [endHours, endMins] = endTime.split(':').map(Number);\n    \n    const startTotalMins = startHours * 60 + startMins;\n    const endTotalMins = endHours * 60 + endMins;\n    \n    return endTotalMins - startTotalMins;\n  }\n  \n  // Calculate summary statistics\n  const totalWorkTime = completeTimeBlocks.reduce((sum, block) => sum + block.duration, 0);\n  const totalBreakTime = restPeriods.reduce((sum, brk) => sum + brk.duration, 0);\n  const totalTransitionTime = switchTime.reduce((sum, trans) => sum + trans.duration, 0);\n  \n  const summaryStats = {\n    totalWorkMinutes: totalWorkTime,\n    totalBreakMinutes: totalBreakTime,\n    totalTransitionMinutes: totalTransitionTime,\n    totalScheduledMinutes: totalWorkTime + totalBreakTime + totalTransitionTime,\n    workToBreakRatio: totalBreakTime > 0 ? Math.round((totalWorkTime / totalBreakTime) * 100) / 100 : 0,\n    averageWorkBlockDuration: completeTimeBlocks.length > 0 ? Math.round(totalWorkTime / completeTimeBlocks.length) : 0,\n    numberOfBreaks: restPeriods.length,\n    numberOfTransitions: switchTime.length,\n    restorativeBreaks: restPeriods.filter(b => b.restorative).length,\n    scheduleHealthScore: calculateScheduleHealth(totalWorkTime, totalBreakTime, restPeriods)\n  };\n  \n  function calculateScheduleHealth(workTime, breakTime, breaks) {\n    let score = 50; // Base score\n    \n    // Good work-to-break ratio (3:1 to 5:1 is ideal)\n    const ratio = workTime / Math.max(1, breakTime);\n    if (ratio >= 3 && ratio <= 5) score += 20;\n    else if (ratio >= 2 && ratio <= 7) score += 10;\n    else score -= 10;\n    \n    // Regular breaks\n    const restorativeBreaks = breaks.filter(b => b.restorative).length;\n    if (restorativeBreaks >= 2) score += 15;\n    else if (restorativeBreaks >= 1) score += 10;\n    \n    // Not overworked\n    if (workTime <= 8 * 60) score += 10; // 8 hours or less\n    else if (workTime > 10 * 60) score -= 15; // More than 10 hours\n    \n    // Has lunch break\n    if (breaks.some(b => b.type === 'lunch')) score += 15;\n    \n    return Math.max(0, Math.min(100, score));\n  }\n  \n  return {\n    completeTimeBlocks: completeTimeBlocks,\n    restPeriods: restPeriods,\n    switchTime: switchTime.length > 0 ? switchTime : summaryStats\n  };\n}"
          }
        },
        "formInput": {
          "__version": "1.0",
          "schema": {
            "containers": [],
            "elements": [
              {
                "fieldName": "optimalSchedule",
                "id": "optimal_schedule_input",
                "label": "Time Allocations",
                "type": "JSON",
                "isRequired": true,
                "props": {
                  "placeholder": "Optimized time allocations"
                }
              },
              {
                "fieldName": "restRequirements",
                "id": "rest_requirements_input",
                "label": "Break Preferences",
                "type": "JSON",
                "isRequired": false,
                "props": {
                  "placeholder": "Break frequency and duration preferences"
                }
              },
              {
                "fieldName": "switchingTime",
                "id": "switching_time_input",
                "label": "Transition Needs",
                "type": "JSON",
                "isRequired": false,
                "props": {
                  "placeholder": "Time needed between different activities"
                }
              }
            ]
          }
        },
        "formOutput": {
          "__version": "1.0",
          "schema": {
            "containers": [],
            "elements": [
              {
                "fieldName": "completeTimeBlocks",
                "id": "complete_time_blocks_output",
                "label": "Final Schedule",
                "type": "JSON"
              },
              {
                "fieldName": "restPeriods",
                "id": "rest_periods_output",
                "label": "Break Schedule",
                "type": "JSON"
              },
              {
                "fieldName": "switchTime",
                "id": "switch_time_output",
                "label": "Transition Buffers",
                "type": "JSON"
              }
            ]
          }
        },
        "executionStrategy": "deterministic"
      },
      "translations": [
        {
          "id": "7829564732190850261",
          "language": "en",
          "name": "Break Scheduler",
          "description": "Inserts rest periods and transition time into schedule to maintain productivity and prevent burnout.",
          "instructions": "Provide optimal schedule, break preferences, and transition needs. The routine will add appropriate breaks and transitions for sustainable productivity."
        }
      ]
    }
  ]
}