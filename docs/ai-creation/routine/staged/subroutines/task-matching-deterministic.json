{
  "id": "7829564732190850109",
  "publicId": "task-match-det-v1",
  "resourceType": "Routine",
  "isPrivate": false,
  "permissions": "{}",
  "isInternal": false,
  "tags": [],
  "versions": [
    {
      "id": "7829564732190850110",
      "publicId": "task-match-det-v1-0",
      "versionLabel": "1.0.0",
      "versionNotes": "Initial version - Matches tasks to optimal time slots",
      "isComplete": true,
      "isPrivate": false,
      "versionIndex": 0,
      "isAutomatable": true,
      "resourceSubType": "RoutineCode",
      "config": {
        "__version": "1.0",
        "callDataCode": {
          "__version": "1.0",
          "schema": {
            "language": "javascript",
            "logic": "function matchTasksToTimeBlocks({ freeTimeBlocks, rankedActivities, energyPatterns }) {\n  // Default energy patterns if not provided\n  const energy = energyPatterns || {\n    '9-11': 'high',\n    '11-13': 'medium',\n    '13-15': 'low',\n    '15-17': 'medium'\n  };\n  \n  // Helper to get energy level for a time slot\n  const getEnergyForSlot = (slot) => {\n    const startHour = Math.floor(slot.start / 60);\n    for (const [range, level] of Object.entries(energy)) {\n      const [start, end] = range.split('-').map(Number);\n      if (startHour >= start && startHour < end) {\n        return level;\n      }\n    }\n    return 'medium';\n  };\n  \n  // Categorize tasks by energy requirements\n  const tasksByEnergyNeed = {\n    high: [],\n    medium: [],\n    low: []\n  };\n  \n  rankedActivities.forEach(task => {\n    let energyNeed = 'medium';\n    if (task.effort === 'high' || task.duration > 90 || task.requiresFocus) {\n      energyNeed = 'high';\n    } else if (task.effort === 'low' || task.duration < 30 || task.routine) {\n      energyNeed = 'low';\n    }\n    tasksByEnergyNeed[energyNeed].push({\n      ...task,\n      energyNeed: energyNeed\n    });\n  });\n  \n  // Sort time blocks by quality and energy potential\n  const sortedSlots = [...freeTimeBlocks]\n    .filter(slot => slot.duration >= 15) // Only consider usable slots\n    .map(slot => ({\n      ...slot,\n      energyLevel: getEnergyForSlot(slot),\n      utilityScore: calculateSlotUtility(slot)\n    }))\n    .sort((a, b) => b.utilityScore - a.utilityScore);\n  \n  function calculateSlotUtility(slot) {\n    let score = slot.duration; // Base score = duration\n    if (slot.quality === 'deep-work') score += 50;\n    else if (slot.quality === 'focus') score += 30;\n    else if (slot.quality === 'task') score += 10;\n    \n    const energyLevel = getEnergyForSlot(slot);\n    if (energyLevel === 'high') score += 20;\n    else if (energyLevel === 'medium') score += 10;\n    \n    return score;\n  }\n  \n  // Match tasks to slots\n  const taskAssignments = [];\n  const conflictResolution = [];\n  const usedSlots = new Set();\n  \n  // First pass: Match high-energy tasks to high-energy slots\n  ['high', 'medium', 'low'].forEach(energyLevel => {\n    tasksByEnergyNeed[energyLevel].forEach(task => {\n      let bestSlot = null;\n      let bestScore = -1;\n      \n      sortedSlots.forEach((slot, slotIndex) => {\n        if (usedSlots.has(slotIndex)) return;\n        \n        // Check if task fits\n        if (slot.duration < task.duration) return;\n        \n        // Calculate match score\n        let score = 0;\n        \n        // Energy match bonus\n        if (slot.energyLevel === energyLevel) score += 30;\n        else if (energyLevel === 'low' || slot.energyLevel === 'high') score += 10;\n        \n        // Duration efficiency bonus\n        const wastedTime = slot.duration - task.duration;\n        if (wastedTime < 15) score += 20;\n        else if (wastedTime < 30) score += 10;\n        \n        // Quality match bonus\n        const requiredQuality = task.duration >= 120 ? 'deep-work' :\n                               task.duration >= 60 ? 'focus' :\n                               task.duration >= 30 ? 'task' : 'quick';\n        if (slot.quality === requiredQuality) score += 15;\n        \n        // Deadline urgency bonus\n        if (task.scores && task.scores.urgency >= 8) score += 25;\n        \n        if (score > bestScore) {\n          bestScore = score;\n          bestSlot = { slot, slotIndex };\n        }\n      });\n      \n      if (bestSlot) {\n        const assignment = {\n          taskId: task.id,\n          taskName: task.name,\n          slotStart: bestSlot.slot.start,\n          slotEnd: bestSlot.slot.start + task.duration,\n          duration: task.duration,\n          energyMatch: bestSlot.slot.energyLevel === task.energyNeed ? 'perfect' : 'acceptable',\n          timeSlotQuality: bestSlot.slot.quality,\n          matchScore: bestScore,\n          bufferAfter: Math.min(bestSlot.slot.duration - task.duration, 15)\n        };\n        \n        taskAssignments.push(assignment);\n        usedSlots.add(bestSlot.slotIndex);\n      } else {\n        conflictResolution.push({\n          taskId: task.id,\n          taskName: task.name,\n          issue: 'No suitable time slot found',\n          requiredDuration: task.duration,\n          energyRequirement: task.energyNeed,\n          alternatives: findAlternatives(task, sortedSlots, usedSlots)\n        });\n      }\n    });\n  });\n  \n  function findAlternatives(task, slots, used) {\n    return slots\n      .map((slot, index) => ({ slot, index }))\n      .filter(item => !used.has(item.index) && item.slot.duration >= task.duration * 0.8)\n      .slice(0, 3)\n      .map(item => ({\n        startTime: item.slot.startFormatted,\n        duration: item.slot.duration,\n        quality: item.slot.quality,\n        compromise: item.slot.duration < task.duration ? 'Shorter than needed' : 'Acceptable'\n      }));\n  }\n  \n  // Calculate buffer allocations\n  const bufferAllocation = {\n    totalBufferTime: taskAssignments.reduce((sum, assignment) => sum + assignment.bufferAfter, 0),\n    averageBuffer: taskAssignments.length > 0 ? \n      Math.round(taskAssignments.reduce((sum, assignment) => sum + assignment.bufferAfter, 0) / taskAssignments.length) : 0,\n    recommendations: {\n      betweenTasks: 10,\n      afterDeepWork: 15,\n      beforeMeetings: 5,\n      endOfSession: 10\n    }\n  };\n  \n  return {\n    taskAssignments: taskAssignments,\n    conflictResolution: conflictResolution,\n    bufferAllocation: bufferAllocation\n  };\n}"
          }
        },
        "formInput": {
          "__version": "1.0",
          "schema": {
            "containers": [],
            "elements": [
              {
                "fieldName": "freeTimeBlocks",
                "id": "free_time_blocks_input",
                "label": "Available Slots",
                "type": "JSON",
                "isRequired": true,
                "props": {
                  "placeholder": "Available time slots"
                }
              },
              {
                "fieldName": "rankedActivities",
                "id": "ranked_activities_input",
                "label": "Prioritized Tasks",
                "type": "JSON",
                "isRequired": true,
                "props": {
                  "placeholder": "Priority-ranked tasks"
                }
              },
              {
                "fieldName": "energyPatterns",
                "id": "energy_patterns_input",
                "label": "Productivity Curves",
                "type": "JSON",
                "isRequired": false,
                "props": {
                  "placeholder": "Energy levels by time"
                }
              }
            ]
          }
        },
        "formOutput": {
          "__version": "1.0",
          "schema": {
            "containers": [],
            "elements": [
              {
                "fieldName": "taskAssignments",
                "id": "task_assignments_output",
                "label": "Scheduled Blocks",
                "type": "JSON"
              },
              {
                "fieldName": "conflictResolution",
                "id": "conflict_resolution_output",
                "label": "Overlapping Items",
                "type": "JSON"
              },
              {
                "fieldName": "bufferAllocation",
                "id": "buffer_allocation_output",
                "label": "Transition Times",
                "type": "JSON"
              }
            ]
          }
        },
        "executionStrategy": "deterministic"
      },
      "translations": [
        {
          "id": "7829564732190850111",
          "language": "en",
          "name": "Task Matching (Deterministic)",
          "description": "Assigns tasks to optimal time slots based on duration, energy needs, and priority scores.",
          "instructions": "Provide available time blocks, prioritized tasks, and energy patterns. The routine will match tasks to optimal slots."
        }
      ]
    }
  ]
}