{
  "id": "7829564732190850097",
  "publicId": "time-block-det-v1",
  "resourceType": "Routine",
  "isPrivate": false,
  "permissions": "{}",
  "isInternal": false,
  "tags": [],
  "versions": [
    {
      "id": "7829564732190850098",
      "publicId": "time-block-det-v1-0",
      "versionLabel": "1.0.0",
      "versionNotes": "Initial version - Allocates tasks to time slots optimally",
      "isComplete": true,
      "isPrivate": false,
      "versionIndex": 0,
      "isAutomatable": true,
      "resourceSubType": "RoutineCode",
      "config": {
        "__version": "1.0",
        "callDataCode": {
          "__version": "1.0",
          "schema": {
            "language": "javascript",
            "logic": "function generateTimeBlocks({ prioritizedTasks, availableSlots, constraints, energyLevels }) {\n  // Parse energy patterns\n  const energyMap = energyLevels || {\n    morning: 'high',\n    midMorning: 'high',\n    afternoon: 'medium',\n    lateAfternoon: 'low'\n  };\n  \n  // Helper to get energy level for a time\n  const getEnergyLevel = (minutes) => {\n    const hour = Math.floor(minutes / 60);\n    if (hour < 10) return energyMap.morning || 'high';\n    else if (hour < 12) return energyMap.midMorning || 'high';\n    else if (hour < 15) return energyMap.afternoon || 'medium';\n    else return energyMap.lateAfternoon || 'low';\n  };\n  \n  // Categorize tasks by energy requirements\n  const tasksByEnergy = {\n    high: [],\n    medium: [],\n    low: []\n  };\n  \n  prioritizedTasks.forEach(task => {\n    const complexity = task.complexity || 'medium';\n    const energy = complexity === 'complex' || task.requiresFocus ? 'high' :\n                  complexity === 'simple' || task.routine ? 'low' : 'medium';\n    tasksByEnergy[energy].push(task);\n  });\n  \n  // Schedule tasks to slots\n  const schedule = [];\n  const conflicts = [];\n  const workSlots = availableSlots.filter(slot => slot.type === 'work');\n  let slotIndex = 0;\n  let currentSlotTime = 0;\n  \n  // First pass: high-energy tasks in high-energy slots\n  ['high', 'medium', 'low'].forEach(energyLevel => {\n    tasksByEnergy[energyLevel].forEach(task => {\n      const duration = task.estimatedMinutes || 30;\n      let scheduled = false;\n      \n      // Find suitable slot\n      for (let i = slotIndex; i < workSlots.length; i++) {\n        const slot = workSlots[i];\n        const slotEnergy = getEnergyLevel(slot.start);\n        const remainingInSlot = slot.duration - currentSlotTime;\n        \n        // Check if task fits and energy matches\n        if (remainingInSlot >= duration && \n            (energyLevel === 'low' || slotEnergy === energyLevel || \n             (energyLevel === 'medium' && slotEnergy === 'high'))) {\n          \n          schedule.push({\n            taskId: task.id,\n            taskName: task.name,\n            startTime: slot.start + currentSlotTime,\n            endTime: slot.start + currentSlotTime + duration,\n            duration: duration,\n            slotIndex: i,\n            energyMatch: slotEnergy === energyLevel ? 'perfect' : 'acceptable'\n          });\n          \n          currentSlotTime += duration;\n          if (currentSlotTime >= slot.duration) {\n            slotIndex = i + 1;\n            currentSlotTime = 0;\n          }\n          scheduled = true;\n          break;\n        }\n      }\n      \n      if (!scheduled) {\n        conflicts.push({\n          taskId: task.id,\n          taskName: task.name,\n          reason: 'No suitable time slot available',\n          requiredDuration: duration\n        });\n      }\n    });\n  });\n  \n  // Add buffer time recommendations\n  const bufferRecommendations = {\n    betweenTasks: 5,\n    afterComplexTasks: 10,\n    beforeMeetings: 10,\n    endOfDay: 15,\n    totalBufferMinutes: Math.ceil(schedule.length * 5 + 15)\n  };\n  \n  // Format final schedule\n  const timeBlockSchedule = {\n    blocks: schedule.map(block => ({\n      ...block,\n      formattedStart: formatMinutes(block.startTime),\n      formattedEnd: formatMinutes(block.endTime)\n    })),\n    summary: {\n      tasksScheduled: schedule.length,\n      totalTaskTime: schedule.reduce((sum, b) => sum + b.duration, 0),\n      utilizationRate: Math.round((schedule.reduce((sum, b) => sum + b.duration, 0) / constraints.totalAvailableTime) * 100)\n    }\n  };\n  \n  return {\n    timeBlockSchedule: timeBlockSchedule,\n    conflictWarnings: conflicts,\n    bufferRecommendations: bufferRecommendations\n  };\n  \n  function formatMinutes(minutes) {\n    const hours = Math.floor(minutes / 60);\n    const mins = minutes % 60;\n    const period = hours >= 12 ? 'PM' : 'AM';\n    const displayHours = hours > 12 ? hours - 12 : hours === 0 ? 12 : hours;\n    return `${displayHours}:${mins.toString().padStart(2, '0')} ${period}`;\n  }\n}"
          }
        },
        "formInput": {
          "__version": "1.0",
          "schema": {
            "containers": [],
            "elements": [
              {
                "fieldName": "prioritizedTasks",
                "id": "prioritized_tasks_input",
                "label": "Sorted Tasks",
                "type": "JSON",
                "isRequired": true,
                "props": {
                  "placeholder": "Priority-ordered task list"
                }
              },
              {
                "fieldName": "availableSlots",
                "id": "available_slots_input",
                "label": "Free Time Blocks",
                "type": "JSON",
                "isRequired": true,
                "props": {
                  "placeholder": "Available time slots"
                }
              },
              {
                "fieldName": "constraints",
                "id": "constraints_input",
                "label": "Scheduling Constraints",
                "type": "JSON",
                "isRequired": true,
                "props": {
                  "placeholder": "Calendar constraints"
                }
              },
              {
                "fieldName": "energyLevels",
                "id": "energy_levels_input",
                "label": "Energy Patterns",
                "type": "JSON",
                "isRequired": false,
                "props": {
                  "placeholder": "Energy levels by time"
                }
              }
            ]
          }
        },
        "formOutput": {
          "__version": "1.0",
          "schema": {
            "containers": [],
            "elements": [
              {
                "fieldName": "timeBlockSchedule",
                "id": "time_block_schedule_output",
                "label": "Daily Schedule",
                "type": "JSON"
              },
              {
                "fieldName": "conflictWarnings",
                "id": "conflict_warnings_output",
                "label": "Scheduling Conflicts",
                "type": "JSON"
              },
              {
                "fieldName": "bufferRecommendations",
                "id": "buffer_recommendations_output",
                "label": "Buffer Time",
                "type": "JSON"
              }
            ]
          }
        },
        "executionStrategy": "deterministic"
      },
      "translations": [
        {
          "id": "7829564732190850099",
          "language": "en",
          "name": "Time Block Scheduler (Deterministic)",
          "description": "Allocates tasks to available time slots based on priority, energy levels, and constraints.",
          "instructions": "Provide prioritized tasks, available slots, constraints, and energy patterns. The routine will create an optimized schedule."
        }
      ]
    }
  ]
}