{
  "id": "7829564732190850304",
  "publicId": "agent-assessor-v1",
  "resourceType": "Routine",
  "isPrivate": false,
  "permissions": "{}",
  "isInternal": false,
  "tags": [],
  "versions": [
    {
      "id": "7829564732190850305",
      "publicId": "agent-assessor-v1-0",
      "versionLabel": "1.0.0",
      "versionNotes": "Initial version - Evaluates available agents and their current workload",
      "isComplete": true,
      "isPrivate": false,
      "versionIndex": 0,
      "isAutomatable": true,
      "resourceSubType": "RoutineCode",
      "config": {
        "__version": "1.0",
        "callDataCode": {
          "__version": "1.0",
          "schema": {
            "language": "javascript",
            "logic": "function assessAgentCapabilities({ agentProfiles, workloadData, availability }) {\n  const agents = Array.isArray(agentProfiles) ? agentProfiles : [agentProfiles].filter(Boolean);\n  const workloads = workloadData || {};\n  const agentAvailability = availability || {};\n  \n  const agentCapabilities = {};\n  const workloadScores = {};\n  const availableAgents = [];\n  \n  agents.forEach(agent => {\n    const agentId = agent.id || agent.name || agent.agentId;\n    if (!agentId) return;\n    \n    // Analyze agent capabilities\n    const capabilities = analyzeAgentSkills(agent);\n    agentCapabilities[agentId] = capabilities;\n    \n    // Calculate workload scores\n    const workloadMetrics = calculateWorkloadScore(agentId, workloads, agentAvailability);\n    workloadScores[agentId] = workloadMetrics;\n    \n    // Determine if agent is available\n    if (workloadMetrics.isAvailable) {\n      availableAgents.push({\n        agentId: agentId,\n        capabilities: capabilities,\n        workload: workloadMetrics,\n        availabilityScore: workloadMetrics.availabilityScore\n      });\n    }\n  });\n  \n  function analyzeAgentSkills(agent) {\n    const skills = agent.skills || agent.capabilities || [];\n    const experience = agent.experience || agent.experienceLevel || 'intermediate';\n    const specializations = agent.specializations || agent.domains || [];\n    const tools = agent.tools || agent.availableTools || [];\n    \n    // Categorize skills\n    const skillCategories = {\n      technical: [],\n      analytical: [],\n      creative: [],\n      communication: [],\n      domain: [],\n      tools: []\n    };\n    \n    if (Array.isArray(skills)) {\n      skills.forEach(skill => {\n        const skillName = typeof skill === 'string' ? skill : skill.name || skill.skill;\n        const skillLevel = typeof skill === 'object' ? skill.level || 'intermediate' : 'intermediate';\n        \n        const categorizedSkill = {\n          name: skillName,\n          level: skillLevel,\n          proficiency: mapLevelToScore(skillLevel)\n        };\n        \n        // Categorize skill by type\n        if (isTechnicalSkill(skillName)) {\n          skillCategories.technical.push(categorizedSkill);\n        } else if (isAnalyticalSkill(skillName)) {\n          skillCategories.analytical.push(categorizedSkill);\n        } else if (isCreativeSkill(skillName)) {\n          skillCategories.creative.push(categorizedSkill);\n        } else if (isCommunicationSkill(skillName)) {\n          skillCategories.communication.push(categorizedSkill);\n        } else {\n          skillCategories.domain.push(categorizedSkill);\n        }\n      });\n    }\n    \n    // Process tools\n    if (Array.isArray(tools)) {\n      tools.forEach(tool => {\n        skillCategories.tools.push({\n          name: typeof tool === 'string' ? tool : tool.name || tool.tool,\n          proficiency: typeof tool === 'object' ? mapLevelToScore(tool.level || 'intermediate') : 70\n        });\n      });\n    }\n    \n    // Calculate overall capability scores\n    const capabilityScores = {\n      technical: calculateCategoryScore(skillCategories.technical),\n      analytical: calculateCategoryScore(skillCategories.analytical),\n      creative: calculateCategoryScore(skillCategories.creative),\n      communication: calculateCategoryScore(skillCategories.communication),\n      domain: calculateCategoryScore(skillCategories.domain),\n      tools: calculateCategoryScore(skillCategories.tools)\n    };\n    \n    // Calculate experience multiplier\n    const experienceMultiplier = {\n      'beginner': 0.7,\n      'intermediate': 1.0,\n      'advanced': 1.3,\n      'expert': 1.5,\n      'master': 1.8\n    }[experience.toLowerCase()] || 1.0;\n    \n    return {\n      skillCategories: skillCategories,\n      capabilityScores: capabilityScores,\n      experienceLevel: experience,\n      experienceMultiplier: experienceMultiplier,\n      specializations: specializations,\n      overallScore: calculateOverallCapabilityScore(capabilityScores, experienceMultiplier),\n      strengths: identifyStrengths(capabilityScores),\n      recommendedTasks: suggestTaskTypes(capabilityScores, specializations)\n    };\n  }\n  \n  function mapLevelToScore(level) {\n    const levelMap = {\n      'none': 0,\n      'basic': 30,\n      'beginner': 40,\n      'intermediate': 60,\n      'advanced': 80,\n      'expert': 95,\n      'master': 100\n    };\n    return levelMap[level.toLowerCase()] || 60;\n  }\n  \n  function isTechnicalSkill(skill) {\n    const technicalKeywords = ['programming', 'coding', 'development', 'api', 'database', 'system', 'software', 'algorithm'];\n    return technicalKeywords.some(keyword => skill.toLowerCase().includes(keyword));\n  }\n  \n  function isAnalyticalSkill(skill) {\n    const analyticalKeywords = ['analysis', 'research', 'data', 'statistics', 'modeling', 'problem-solving', 'logic'];\n    return analyticalKeywords.some(keyword => skill.toLowerCase().includes(keyword));\n  }\n  \n  function isCreativeSkill(skill) {\n    const creativeKeywords = ['design', 'creative', 'writing', 'innovation', 'brainstorming', 'artistic', 'visualization'];\n    return creativeKeywords.some(keyword => skill.toLowerCase().includes(keyword));\n  }\n  \n  function isCommunicationSkill(skill) {\n    const communicationKeywords = ['communication', 'presentation', 'negotiation', 'collaboration', 'teaching', 'writing', 'documentation'];\n    return communicationKeywords.some(keyword => skill.toLowerCase().includes(keyword));\n  }\n  \n  function calculateCategoryScore(skills) {\n    if (skills.length === 0) return 0;\n    const totalScore = skills.reduce((sum, skill) => sum + skill.proficiency, 0);\n    return Math.round(totalScore / skills.length);\n  }\n  \n  function calculateOverallCapabilityScore(scores, experienceMultiplier) {\n    const weightedScores = {\n      technical: scores.technical * 0.25,\n      analytical: scores.analytical * 0.25,\n      creative: scores.creative * 0.15,\n      communication: scores.communication * 0.15,\n      domain: scores.domain * 0.15,\n      tools: scores.tools * 0.05\n    };\n    \n    const baseScore = Object.values(weightedScores).reduce((sum, score) => sum + score, 0);\n    return Math.round(baseScore * experienceMultiplier);\n  }\n  \n  function identifyStrengths(scores) {\n    const strengths = [];\n    Object.entries(scores).forEach(([category, score]) => {\n      if (score >= 80) strengths.push(category);\n    });\n    return strengths;\n  }\n  \n  function suggestTaskTypes(scores, specializations) {\n    const suggestions = [];\n    \n    if (scores.technical >= 70) suggestions.push('Technical implementation', 'System integration', 'API development');\n    if (scores.analytical >= 70) suggestions.push('Data analysis', 'Research', 'Problem diagnosis');\n    if (scores.creative >= 70) suggestions.push('Content creation', 'Design work', 'Innovation projects');\n    if (scores.communication >= 70) suggestions.push('Documentation', 'Client interaction', 'Team coordination');\n    if (scores.domain >= 70 && specializations.length > 0) {\n      specializations.forEach(spec => suggestions.push(`${spec} specialist tasks`));\n    }\n    \n    return suggestions;\n  }\n  \n  function calculateWorkloadScore(agentId, workloads, availability) {\n    const agentWorkload = workloads[agentId] || { activeTasks: 0, totalCapacity: 100 };\n    const agentAvailability = availability[agentId] || { status: 'available' };\n    \n    // Calculate basic workload metrics\n    const activeTasks = agentWorkload.activeTasks || 0;\n    const totalCapacity = agentWorkload.totalCapacity || 100;\n    const utilizationPercentage = Math.round((activeTasks / Math.max(1, totalCapacity)) * 100);\n    \n    // Factor in availability status\n    const availabilityStatus = agentAvailability.status || 'available';\n    const isAvailable = availabilityStatus === 'available' && utilizationPercentage < 90;\n    \n    // Calculate availability score (higher is better)\n    let availabilityScore = 100 - utilizationPercentage;\n    \n    // Adjust based on status\n    if (availabilityStatus === 'busy') availabilityScore *= 0.5;\n    else if (availabilityStatus === 'offline') availabilityScore = 0;\n    else if (availabilityStatus === 'maintenance') availabilityScore = 0;\n    \n    // Calculate workload level\n    let workloadLevel;\n    if (utilizationPercentage >= 90) workloadLevel = 'overloaded';\n    else if (utilizationPercentage >= 70) workloadLevel = 'heavy';\n    else if (utilizationPercentage >= 40) workloadLevel = 'moderate';\n    else if (utilizationPercentage >= 10) workloadLevel = 'light';\n    else workloadLevel = 'minimal';\n    \n    // Estimate time to availability if currently unavailable\n    let estimatedAvailableTime = null;\n    if (!isAvailable && agentAvailability.nextAvailable) {\n      estimatedAvailableTime = agentAvailability.nextAvailable;\n    } else if (!isAvailable) {\n      // Rough estimate based on current workload\n      const hoursToFreeUp = Math.max(0, (utilizationPercentage - 80) * 0.5);\n      estimatedAvailableTime = new Date(Date.now() + hoursToFreeUp * 60 * 60 * 1000).toISOString();\n    }\n    \n    return {\n      activeTasks: activeTasks,\n      totalCapacity: totalCapacity,\n      utilizationPercentage: utilizationPercentage,\n      availabilityScore: Math.round(availabilityScore),\n      workloadLevel: workloadLevel,\n      isAvailable: isAvailable,\n      availabilityStatus: availabilityStatus,\n      estimatedAvailableTime: estimatedAvailableTime,\n      canTakeUrgentTask: availabilityScore > 20,\n      preferredTaskSize: getPreferredTaskSize(utilizationPercentage)\n    };\n  }\n  \n  function getPreferredTaskSize(utilization) {\n    if (utilization < 30) return 'large';\n    if (utilization < 60) return 'medium';\n    if (utilization < 80) return 'small';\n    return 'micro';\n  }\n  \n  // Sort available agents by availability score\n  availableAgents.sort((a, b) => b.availabilityScore - a.availabilityScore);\n  \n  // Generate summary statistics\n  const summaryStats = {\n    totalAgents: agents.length,\n    availableAgents: availableAgents.length,\n    averageUtilization: agents.length > 0 ? \n      Math.round(Object.values(workloadScores).reduce((sum, w) => sum + w.utilizationPercentage, 0) / agents.length) : 0,\n    overloadedAgents: Object.values(workloadScores).filter(w => w.workloadLevel === 'overloaded').length,\n    skillCoverage: calculateSkillCoverage(agentCapabilities),\n    recommendedActions: generateWorkloadRecommendations(workloadScores, availableAgents.length)\n  };\n  \n  function calculateSkillCoverage(capabilities) {\n    const allSkills = new Set();\n    Object.values(capabilities).forEach(cap => {\n      Object.values(cap.skillCategories).forEach(category => {\n        category.forEach(skill => allSkills.add(skill.name));\n      });\n    });\n    return {\n      totalUniqueSkills: allSkills.size,\n      skillTypes: Object.keys(Object.values(capabilities)[0]?.skillCategories || {})\n    };\n  }\n  \n  function generateWorkloadRecommendations(workloads, availableCount) {\n    const recommendations = [];\n    \n    if (availableCount === 0) {\n      recommendations.push('No agents currently available - consider workload rebalancing');\n    } else if (availableCount < 3) {\n      recommendations.push('Low agent availability - monitor workload distribution');\n    }\n    \n    const overloadedCount = Object.values(workloads).filter(w => w.workloadLevel === 'overloaded').length;\n    if (overloadedCount > 0) {\n      recommendations.push(`${overloadedCount} agents are overloaded - consider task redistribution`);\n    }\n    \n    const underutilizedCount = Object.values(workloads).filter(w => w.utilizationPercentage < 20).length;\n    if (underutilizedCount > 0) {\n      recommendations.push(`${underutilizedCount} agents are underutilized - opportunity for additional tasks`);\n    }\n    \n    return recommendations;\n  }\n  \n  return {\n    skillMatrix: agentCapabilities,\n    utilizationMetrics: {\n      ...workloadScores,\n      summary: summaryStats\n    },\n    eligibleAgents: availableAgents\n  };\n}"
          }
        },
        "formInput": {
          "__version": "1.0",
          "schema": {
            "containers": [],
            "elements": [
              {
                "fieldName": "agentProfiles",
                "id": "agent_profiles_input",
                "label": "Agent Skill Profiles",
                "type": "JSON",
                "isRequired": true,
                "props": {
                  "placeholder": "Agent capabilities and skill information"
                }
              },
              {
                "fieldName": "workloadData",
                "id": "workload_data_input",
                "label": "Current Workloads",
                "type": "JSON",
                "isRequired": true,
                "props": {
                  "placeholder": "Current task assignments and capacity usage"
                }
              },
              {
                "fieldName": "availability",
                "id": "availability_input",
                "label": "Agent Availability",
                "type": "JSON",
                "isRequired": false,
                "props": {
                  "placeholder": "Agent availability status and timing"
                }
              }
            ]
          }
        },
        "formOutput": {
          "__version": "1.0",
          "schema": {
            "containers": [],
            "elements": [
              {
                "fieldName": "skillMatrix",
                "id": "skill_matrix_output",
                "label": "Agent Capabilities",
                "type": "JSON"
              },
              {
                "fieldName": "utilizationMetrics",
                "id": "utilization_metrics_output",
                "label": "Workload Scores",
                "type": "JSON"
              },
              {
                "fieldName": "eligibleAgents",
                "id": "eligible_agents_output",
                "label": "Available Agents",
                "type": "JSON"
              }
            ]
          }
        },
        "executionStrategy": "deterministic"
      },
      "translations": [
        {
          "id": "7829564732190850306",
          "language": "en",
          "name": "Agent Assessor",
          "description": "Evaluates available agents and their current workload using skill analysis, capacity calculations, and availability scoring algorithms.",
          "instructions": "Provide agent profiles, workload data, and availability information. The routine will assess capabilities, calculate utilization metrics, and identify eligible agents."
        }
      ]
    }
  ]
}