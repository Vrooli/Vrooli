{
  "id": "7829564732190850112",
  "publicId": "sched-opt-det-v1",
  "resourceType": "Routine",
  "isPrivate": false,
  "permissions": "{}",
  "isInternal": false,
  "tags": [],
  "versions": [
    {
      "id": "7829564732190850113",
      "publicId": "sched-opt-det-v1-0",
      "versionLabel": "1.0.0",
      "versionNotes": "Initial version - Optimizes schedule flow for efficiency",
      "isComplete": true,
      "isPrivate": false,
      "versionIndex": 0,
      "isAutomatable": true,
      "resourceSubType": "RoutineCode",
      "config": {
        "__version": "1.0",
        "callDataCode": {
          "__version": "1.0",
          "schema": {
            "language": "javascript",
            "logic": "function optimizeScheduleFlow({ scheduledBlocks, transitionTimes, efficiencyRules }) {\n  // Default efficiency rules\n  const rules = efficiencyRules || {\n    minimizeContextSwitching: true,\n    groupSimilarTasks: true,\n    respectEnergyFlow: true,\n    maximizeDeepWork: true,\n    bufferTransitions: true\n  };\n  \n  // Sort blocks by start time\n  const sortedBlocks = [...scheduledBlocks].sort((a, b) => a.slotStart - a.slotStart);\n  \n  // Categorize tasks by type for grouping\n  const taskCategories = {\n    creative: [],\n    analytical: [],\n    administrative: [],\n    communication: [],\n    routine: []\n  };\n  \n  sortedBlocks.forEach(block => {\n    let category = 'administrative'; // default\n    \n    if (block.taskName.toLowerCase().includes('write') || \n        block.taskName.toLowerCase().includes('design') ||\n        block.taskName.toLowerCase().includes('create')) {\n      category = 'creative';\n    } else if (block.taskName.toLowerCase().includes('analyze') ||\n               block.taskName.toLowerCase().includes('review') ||\n               block.taskName.toLowerCase().includes('plan')) {\n      category = 'analytical';\n    } else if (block.taskName.toLowerCase().includes('email') ||\n               block.taskName.toLowerCase().includes('call') ||\n               block.taskName.toLowerCase().includes('meeting')) {\n      category = 'communication';\n    } else if (block.duration <= 30 || \n               block.taskName.toLowerCase().includes('update') ||\n               block.taskName.toLowerCase().includes('check')) {\n      category = 'routine';\n    }\n    \n    taskCategories[category].push({ ...block, category });\n  });\n  \n  // Apply optimization strategies\n  let optimizedBlocks = [...sortedBlocks];\n  \n  // Strategy 1: Group similar tasks to reduce context switching\n  if (rules.groupSimilarTasks) {\n    optimizedBlocks = groupSimilarTasks(optimizedBlocks, taskCategories);\n  }\n  \n  // Strategy 2: Arrange by energy flow (high to low energy tasks)\n  if (rules.respectEnergyFlow) {\n    optimizedBlocks = arrangeByEnergyFlow(optimizedBlocks);\n  }\n  \n  // Strategy 3: Batch administrative and routine tasks\n  const batchedTasks = batchSmallTasks(optimizedBlocks);\n  \n  // Calculate flow improvements\n  const flowImprovements = {\n    contextSwitches: calculateContextSwitches(sortedBlocks, optimizedBlocks),\n    energyAlignment: calculateEnergyAlignment(optimizedBlocks),\n    timeUtilization: calculateTimeUtilization(optimizedBlocks),\n    batchingBenefits: batchedTasks.benefits\n  };\n  \n  function groupSimilarTasks(blocks, categories) {\n    const grouped = [];\n    const used = new Set();\n    \n    // Group by category in order of priority\n    ['creative', 'analytical', 'communication', 'administrative', 'routine'].forEach(category => {\n      const categoryTasks = blocks.filter(block => {\n        if (used.has(block.taskId)) return false;\n        \n        // Determine task category\n        let taskCategory = 'administrative';\n        if (block.taskName.toLowerCase().includes('write') || \n            block.taskName.toLowerCase().includes('design')) taskCategory = 'creative';\n        else if (block.taskName.toLowerCase().includes('analyze')) taskCategory = 'analytical';\n        else if (block.taskName.toLowerCase().includes('email')) taskCategory = 'communication';\n        else if (block.duration <= 30) taskCategory = 'routine';\n        \n        return taskCategory === category;\n      });\n      \n      categoryTasks.forEach(task => {\n        grouped.push(task);\n        used.add(task.taskId);\n      });\n    });\n    \n    return grouped;\n  }\n  \n  function arrangeByEnergyFlow(blocks) {\n    // Sort by energy match quality and duration\n    return blocks.sort((a, b) => {\n      // Prefer perfect energy matches\n      if (a.energyMatch === 'perfect' && b.energyMatch !== 'perfect') return -1;\n      if (b.energyMatch === 'perfect' && a.energyMatch !== 'perfect') return 1;\n      \n      // Then by duration (longer tasks first for high energy periods)\n      return b.duration - a.duration;\n    });\n  }\n  \n  function batchSmallTasks(blocks) {\n    const smallTasks = blocks.filter(block => block.duration <= 30);\n    const largeTasks = blocks.filter(block => block.duration > 30);\n    \n    const batches = [];\n    let currentBatch = [];\n    let batchDuration = 0;\n    \n    smallTasks.forEach(task => {\n      if (batchDuration + task.duration <= 90) {\n        currentBatch.push(task);\n        batchDuration += task.duration;\n      } else {\n        if (currentBatch.length > 1) {\n          batches.push({\n            type: 'batch',\n            tasks: [...currentBatch],\n            totalDuration: batchDuration,\n            category: 'batched-admin'\n          });\n        }\n        currentBatch = [task];\n        batchDuration = task.duration;\n      }\n    });\n    \n    if (currentBatch.length > 1) {\n      batches.push({\n        type: 'batch',\n        tasks: [...currentBatch],\n        totalDuration: batchDuration,\n        category: 'batched-admin'\n      });\n    }\n    \n    return {\n      batches: batches,\n      benefits: {\n        tasksGrouped: batches.reduce((sum, batch) => sum + batch.tasks.length, 0),\        contextSwitchReduction: Math.max(0, smallTasks.length - batches.length),\n        timeEfficiency: batches.length > 0 ? 'Improved' : 'No change'\n      }\n    };\n  }\n  \n  function calculateContextSwitches(original, optimized) {\n    const countSwitches = (blocks) => {\n      let switches = 0;\n      for (let i = 1; i < blocks.length; i++) {\n        const prev = blocks[i-1];\n        const curr = blocks[i];\n        if (prev.category !== curr.category) switches++;\n      }\n      return switches;\n    };\n    \n    const originalSwitches = countSwitches(original.map(b => ({ ...b, category: 'mixed' })));\n    const optimizedSwitches = countSwitches(optimized);\n    \n    return {\n      before: originalSwitches,\n      after: optimizedSwitches,\n      improvement: originalSwitches - optimizedSwitches\n    };\n  }\n  \n  function calculateEnergyAlignment(blocks) {\n    const perfectMatches = blocks.filter(b => b.energyMatch === 'perfect').length;\n    const totalBlocks = blocks.length;\n    \n    return {\n      alignmentRate: totalBlocks > 0 ? Math.round((perfectMatches / totalBlocks) * 100) : 0,\n      perfectMatches: perfectMatches,\n      totalBlocks: totalBlocks\n    };\n  }\n  \n  function calculateTimeUtilization(blocks) {\n    const totalScheduledTime = blocks.reduce((sum, block) => sum + block.duration, 0);\n    const totalBufferTime = blocks.reduce((sum, block) => sum + (block.bufferAfter || 0), 0);\n    \n    return {\n      scheduledTime: totalScheduledTime,\n      bufferTime: totalBufferTime,\n      utilizationRate: totalScheduledTime > 0 ? \n        Math.round((totalScheduledTime / (totalScheduledTime + totalBufferTime)) * 100) : 0\n    };\n  }\n  \n  return {\n    optimizedSchedule: optimizedBlocks,\n    groupedActivities: batchedTasks,\n    flowImprovements: flowImprovements\n  };\n}"
          }
        },
        "formInput": {
          "__version": "1.0",
          "schema": {
            "containers": [],
            "elements": [
              {
                "fieldName": "scheduledBlocks",
                "id": "scheduled_blocks_input",
                "label": "Task Assignments",
                "type": "JSON",
                "isRequired": true,
                "props": {
                  "placeholder": "Assigned task blocks"
                }
              },
              {
                "fieldName": "transitionTimes",
                "id": "transition_times_input",
                "label": "Buffer Allocation",
                "type": "JSON",
                "isRequired": true,
                "props": {
                  "placeholder": "Transition and buffer times"
                }
              },
              {
                "fieldName": "efficiencyRules",
                "id": "efficiency_rules_input",
                "label": "Optimization Criteria",
                "type": "JSON",
                "isRequired": false,
                "props": {
                  "placeholder": "Optimization preferences"
                }
              }
            ]
          }
        },
        "formOutput": {
          "__version": "1.0",
          "schema": {
            "containers": [],
            "elements": [
              {
                "fieldName": "optimizedSchedule",
                "id": "optimized_schedule_output",
                "label": "Efficient Arrangement",
                "type": "JSON"
              },
              {
                "fieldName": "groupedActivities",
                "id": "grouped_activities_output",
                "label": "Batched Tasks",
                "type": "JSON"
              },
              {
                "fieldName": "flowImprovements",
                "id": "flow_improvements_output",
                "label": "Scheduling Enhancements",
                "type": "JSON"
              }
            ]
          }
        },
        "executionStrategy": "deterministic"
      },
      "translations": [
        {
          "id": "7829564732190850114",
          "language": "en",
          "name": "Schedule Optimization (Deterministic)",
          "description": "Arranges time blocks for maximum efficiency and minimal context switching with task batching.",
          "instructions": "Provide scheduled blocks, transition times, and optimization criteria. The routine will optimize the schedule flow."
        }
      ]
    }
  ]
}