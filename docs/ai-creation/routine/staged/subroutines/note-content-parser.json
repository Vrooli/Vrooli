{
  "id": "7829564732190850142",
  "publicId": "note-parser-v1",
  "resourceType": "Routine",
  "isPrivate": false,
  "permissions": "{}",
  "isInternal": false,
  "tags": [],
  "versions": [
    {
      "id": "7829564732190850143",
      "publicId": "note-parser-v1-0",
      "versionLabel": "1.0.0",
      "versionNotes": "Initial version - Parses note content and identifies structure",
      "isComplete": true,
      "isPrivate": false,
      "versionIndex": 0,
      "isAutomatable": true,
      "resourceSubType": "RoutineCode",
      "config": {
        "__version": "1.0",
        "callDataCode": {
          "__version": "1.0",
          "schema": {
            "language": "javascript",
            "logic": "function parseNoteContent({ noteContent, noteType, context }) {\n  // Convert content to text if it's an object\n  const text = typeof noteContent === 'string' ? noteContent : \n               noteContent.content || noteContent.text || \n               JSON.stringify(noteContent);\n  \n  // Basic text cleaning\n  const cleanText = text\n    .replace(/\\r\\n/g, '\\n')\n    .replace(/\\s+/g, ' ')\n    .trim();\n  \n  // Split into lines for analysis\n  const lines = cleanText.split('\\n').map(line => line.trim()).filter(line => line.length > 0);\n  \n  // Identify section patterns based on note type\n  const sectionPatterns = {\n    'meeting-minutes': [\n      /^(agenda|topics?|discussion):/i,\n      /^(action items?|tasks?|follow.?ups?):/i,\n      /^(decisions?|outcomes?):/i,\n      /^(attendees?|participants?):/i,\n      /^(notes?|summary):/i\n    ],\n    'brainstorm': [\n      /^(ideas?|concepts?):/i,\n      /^(solutions?|approaches?):/i,\n      /^(next steps?|actions?):/i,\n      /^(resources?|tools?):/i\n    ],\n    'project-notes': [\n      /^(objectives?|goals?):/i,\n      /^(tasks?|deliverables?):/i,\n      /^(timeline|schedule):/i,\n      /^(resources?|budget):/i,\n      /^(risks?|issues?):/i\n    ],\n    'email-thread': [\n      /^(from|to|subject):/i,\n      /^(requests?|asks?):/i,\n      /^(deadlines?|due dates?):/i\n    ]\n  };\n  \n  const patterns = sectionPatterns[noteType] || [];\n  \n  // Parse sections\n  const sections = [];\n  let currentSection = null;\n  \n  lines.forEach((line, index) => {\n    // Check if line starts a new section\n    const sectionMatch = patterns.find(pattern => pattern.test(line));\n    if (sectionMatch) {\n      if (currentSection) {\n        sections.push(currentSection);\n      }\n      currentSection = {\n        title: line,\n        content: [],\n        startLine: index,\n        type: identifySectionType(line)\n      };\n    } else if (currentSection) {\n      currentSection.content.push(line);\n    } else {\n      // Content before any section headers\n      if (!sections.find(s => s.type === 'general')) {\n        sections.push({\n          title: 'General Notes',\n          content: [],\n          startLine: 0,\n          type: 'general'\n        });\n      }\n      const generalSection = sections.find(s => s.type === 'general');\n      if (generalSection) {\n        generalSection.content.push(line);\n      }\n    }\n  });\n  \n  // Add final section\n  if (currentSection) {\n    sections.push(currentSection);\n  }\n  \n  function identifySectionType(title) {\n    const lower = title.toLowerCase();\n    if (/action|task|follow.?up|todo/.test(lower)) return 'actions';\n    if (/decision|outcome|result/.test(lower)) return 'decisions';\n    if (/agenda|topic|discussion/.test(lower)) return 'discussion';\n    if (/attendee|participant|people/.test(lower)) return 'participants';\n    if (/timeline|schedule|deadline/.test(lower)) return 'timeline';\n    if (/resource|tool|budget/.test(lower)) return 'resources';\n    if (/risk|issue|problem/.test(lower)) return 'risks';\n    return 'general';\n  }\n  \n  // Extract metadata\n  const metadata = {\n    totalLines: lines.length,\n    wordCount: cleanText.split(/\\s+/).length,\n    sectionCount: sections.length,\n    noteType: noteType,\n    hasStructure: sections.length > 1,\n    dominantSections: sections\n      .filter(s => s.content.length > 0)\n      .sort((a, b) => b.content.length - a.content.length)\n      .slice(0, 3)\n      .map(s => s.type),\n    contextInfo: context || {},\n    parsingTimestamp: new Date().toISOString()\n  };\n  \n  // Create section mapping\n  const sectionMapping = sections.map(section => ({\n    id: `section-${sections.indexOf(section)}`,\n    title: section.title,\n    type: section.type,\n    contentLines: section.content.length,\n    startLine: section.startLine,\n    keywords: extractKeywords(section.content.join(' '))\n  }));\n  \n  function extractKeywords(text) {\n    const words = text.toLowerCase()\n      .replace(/[^\\w\\s]/g, ' ')\n      .split(/\\s+/)\n      .filter(word => word.length > 3);\n    \n    const frequency = {};\n    words.forEach(word => {\n      frequency[word] = (frequency[word] || 0) + 1;\n    });\n    \n    return Object.entries(frequency)\n      .sort(([,a], [,b]) => b - a)\n      .slice(0, 5)\n      .map(([word]) => word);\n  }\n  \n  // Structure parsed content\n  const structuredNotes = {\n    originalText: text,\n    cleanText: cleanText,\n    sections: sections,\n    totalSections: sections.length,\n    actionableSections: sections.filter(s => s.type === 'actions').length,\n    decisionSections: sections.filter(s => s.type === 'decisions').length,\n    generalContent: sections.filter(s => s.type === 'general')\n  };\n  \n  return {\n    parsedContent: structuredNotes,\n    sectionMapping: sectionMapping,\n    metadata: metadata\n  };\n}"
          }
        },
        "formInput": {
          "__version": "1.0",
          "schema": {
            "containers": [],
            "elements": [
              {
                "fieldName": "noteContent",
                "id": "note_content_input",
                "label": "Raw Notes",
                "type": "JSON",
                "isRequired": true,
                "props": {
                  "placeholder": "Raw note content to parse"
                }
              },
              {
                "fieldName": "noteType",
                "id": "note_type_input",
                "label": "Content Format",
                "type": "TextInput",
                "isRequired": true,
                "props": {
                  "placeholder": "Type of notes (meeting, brainstorm, etc.)"
                }
              },
              {
                "fieldName": "context",
                "id": "context_input",
                "label": "Meeting Context",
                "type": "JSON",
                "isRequired": false,
                "props": {
                  "placeholder": "Additional context about the notes"
                }
              }
            ]
          }
        },
        "formOutput": {
          "__version": "1.0",
          "schema": {
            "containers": [],
            "elements": [
              {
                "fieldName": "parsedContent",
                "id": "parsed_content_output",
                "label": "Structured Notes",
                "type": "JSON"
              },
              {
                "fieldName": "sectionMapping",
                "id": "section_mapping_output",
                "label": "Note Segments",
                "type": "JSON"
              },
              {
                "fieldName": "metadata",
                "id": "metadata_output",
                "label": "Note Properties",
                "type": "JSON"
              }
            ]
          }
        },
        "executionStrategy": "deterministic"
      },
      "translations": [
        {
          "id": "7829564732190850144",
          "language": "en",
          "name": "Note Content Parser",
          "description": "Analyzes note structure and identifies sections for task extraction processing.",
          "instructions": "Provide raw note content, note type, and optional context. The routine will parse and structure the content."
        }
      ]
    }
  ]
}