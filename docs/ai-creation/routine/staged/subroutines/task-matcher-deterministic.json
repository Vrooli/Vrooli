{
  "id": "7829564732190850307",
  "publicId": "task-matcher-v1",
  "resourceType": "Routine",
  "isPrivate": false,
  "permissions": "{}",
  "isInternal": false,
  "tags": [],
  "versions": [
    {
      "id": "7829564732190850308",
      "publicId": "task-matcher-v1-0",
      "versionLabel": "1.0.0",
      "versionNotes": "Initial version - Finds optimal agent-task matches based on multiple factors",
      "isComplete": true,
      "isPrivate": false,
      "versionIndex": 0,
      "isAutomatable": true,
      "resourceSubType": "RoutineCode",
      "config": {
        "__version": "1.0",
        "callDataCode": {
          "__version": "1.0",
          "schema": {
            "language": "javascript",
            "logic": "function matchTasksToAgents({ requiredSkills, agentCapabilities, workloadScores, taskComplexity }) {\n  const skillRequirements = requiredSkills || {};\n  const agents = agentCapabilities || {};\n  const workloads = workloadScores || {};\n  const complexity = taskComplexity || { overallScore: 50 };\n  \n  const matchScores = {};\n  const topCandidates = [];\n  const matchRationale = {};\n  \n  // Calculate match scores for each agent\n  Object.keys(agents).forEach(agentId => {\n    const agent = agents[agentId];\n    const agentWorkload = workloads[agentId] || { availabilityScore: 50 };\n    \n    const matchResult = calculateAgentTaskMatch(agent, skillRequirements, agentWorkload, complexity);\n    matchScores[agentId] = matchResult.score;\n    matchRationale[agentId] = matchResult.rationale;\n    \n    // Only consider agents that meet minimum requirements\n    if (matchResult.score >= 30 && agentWorkload.isAvailable !== false) {\n      topCandidates.push({\n        agentId: agentId,\n        matchScore: matchResult.score,\n        skillMatch: matchResult.skillMatch,\n        availabilityMatch: matchResult.availabilityMatch,\n        experienceMatch: matchResult.experienceMatch,\n        rationale: matchResult.rationale,\n        confidence: matchResult.confidence\n      });\n    }\n  });\n  \n  function calculateAgentTaskMatch(agent, requirements, workload, complexity) {\n    // Skill matching component (40% weight)\n    const skillMatch = calculateSkillMatch(agent, requirements);\n    \n    // Availability component (30% weight)\n    const availabilityMatch = calculateAvailabilityMatch(workload, complexity);\n    \n    // Experience/complexity fit (20% weight)\n    const experienceMatch = calculateExperienceMatch(agent, complexity);\n    \n    // Specialization bonus (10% weight)\n    const specializationMatch = calculateSpecializationMatch(agent, requirements);\n    \n    // Calculate weighted total score\n    const totalScore = Math.round(\n      (skillMatch.score * 0.4) +\n      (availabilityMatch.score * 0.3) +\n      (experienceMatch.score * 0.2) +\n      (specializationMatch.score * 0.1)\n    );\n    \n    // Calculate confidence based on data quality\n    const confidence = calculateMatchConfidence(skillMatch, availabilityMatch, experienceMatch, agent);\n    \n    // Generate detailed rationale\n    const rationale = generateMatchRationale(skillMatch, availabilityMatch, experienceMatch, specializationMatch, totalScore);\n    \n    return {\n      score: Math.min(100, Math.max(0, totalScore)),\n      skillMatch: skillMatch,\n      availabilityMatch: availabilityMatch,\n      experienceMatch: experienceMatch,\n      specializationMatch: specializationMatch,\n      confidence: confidence,\n      rationale: rationale\n    };\n  }\n  \n  function calculateSkillMatch(agent, requirements) {\n    const agentSkills = agent.skillCategories || {};\n    const requiredSkillCategories = requirements.skillCategories || {};\n    const coreCompetencies = requirements.coreCompetencies || [];\n    \n    let totalRequiredSkills = 0;\n    let matchedSkills = 0;\n    let skillScores = [];\n    \n    // Check core competencies\n    coreCompetencies.forEach(requiredSkill => {\n      totalRequiredSkills++;\n      const matchFound = findSkillMatch(agentSkills, requiredSkill);\n      if (matchFound.found) {\n        matchedSkills++;\n        skillScores.push(matchFound.proficiency);\n      } else {\n        skillScores.push(0);\n      }\n    });\n    \n    // Check technical skills\n    if (requiredSkillCategories.technical) {\n      requiredSkillCategories.technical.forEach(requiredSkill => {\n        totalRequiredSkills++;\n        const matchFound = findSkillInCategory(agentSkills.technical || [], requiredSkill);\n        if (matchFound.found) {\n          matchedSkills++;\n          skillScores.push(matchFound.proficiency);\n        } else {\n          skillScores.push(0);\n        }\n      });\n    }\n    \n    // Calculate skill match percentage and average proficiency\n    const matchPercentage = totalRequiredSkills > 0 ? (matchedSkills / totalRequiredSkills) * 100 : 100;\n    const averageProficiency = skillScores.length > 0 ? skillScores.reduce((sum, score) => sum + score, 0) / skillScores.length : 0;\n    \n    // Combine coverage and proficiency\n    const skillScore = Math.round((matchPercentage * 0.7) + (averageProficiency * 0.3));\n    \n    return {\n      score: skillScore,\n      matchedSkills: matchedSkills,\n      totalRequired: totalRequiredSkills,\n      matchPercentage: Math.round(matchPercentage),\n      averageProficiency: Math.round(averageProficiency),\n      missingSkills: identifyMissingSkills(agentSkills, requirements)\n    };\n  }\n  \n  function findSkillMatch(agentSkills, requiredSkill) {\n    const skillName = typeof requiredSkill === 'string' ? requiredSkill : requiredSkill.name || requiredSkill.skill;\n    \n    // Search across all skill categories\n    for (const category of Object.values(agentSkills)) {\n      if (Array.isArray(category)) {\n        const match = category.find(skill => \n          skill.name && skill.name.toLowerCase().includes(skillName.toLowerCase())\n        );\n        if (match) {\n          return { found: true, proficiency: match.proficiency || 60 };\n        }\n      }\n    }\n    \n    return { found: false, proficiency: 0 };\n  }\n  \n  function findSkillInCategory(categorySkills, requiredSkill) {\n    const skillName = typeof requiredSkill === 'string' ? requiredSkill : requiredSkill.name;\n    const match = categorySkills.find(skill => \n      skill.name && skill.name.toLowerCase().includes(skillName.toLowerCase())\n    );\n    \n    return match ? { found: true, proficiency: match.proficiency || 60 } : { found: false, proficiency: 0 };\n  }\n  \n  function identifyMissingSkills(agentSkills, requirements) {\n    const missing = [];\n    const coreCompetencies = requirements.coreCompetencies || [];\n    \n    coreCompetencies.forEach(requiredSkill => {\n      const skillName = typeof requiredSkill === 'string' ? requiredSkill : requiredSkill.name;\n      const match = findSkillMatch(agentSkills, requiredSkill);\n      if (!match.found) {\n        missing.push(skillName);\n      }\n    });\n    \n    return missing;\n  }\n  \n  function calculateAvailabilityMatch(workload, complexity) {\n    const availabilityScore = workload.availabilityScore || 50;\n    const utilizationPercentage = workload.utilizationPercentage || 50;\n    const complexityScore = complexity.overallScore || 50;\n    \n    // Higher complexity tasks need more available agents\n    const complexityAdjustment = complexityScore > 70 ? 0.8 : complexityScore > 40 ? 0.9 : 1.0;\n    \n    // Calculate adjusted availability score\n    const adjustedAvailability = availabilityScore * complexityAdjustment;\n    \n    // Determine availability level\n    let availabilityLevel;\n    if (adjustedAvailability >= 80) availabilityLevel = 'excellent';\n    else if (adjustedAvailability >= 60) availabilityLevel = 'good';\n    else if (adjustedAvailability >= 40) availabilityLevel = 'moderate';\n    else if (adjustedAvailability >= 20) availabilityLevel = 'limited';\n    else availabilityLevel = 'poor';\n    \n    return {\n      score: Math.round(adjustedAvailability),\n      availabilityLevel: availabilityLevel,\n      utilizationPercentage: utilizationPercentage,\n      complexityAdjustment: complexityAdjustment,\n      canHandleUrgent: workload.canTakeUrgentTask || false\n    };\n  }\n  \n  function calculateExperienceMatch(agent, complexity) {\n    const agentExperience = agent.experienceLevel || 'intermediate';\n    const complexityScore = complexity.overallScore || 50;\n    const overallCapability = agent.overallScore || 60;\n    \n    // Map experience levels to capability scores\n    const experienceScores = {\n      'beginner': 30,\n      'intermediate': 60,\n      'advanced': 80,\n      'expert': 95,\n      'master': 100\n    };\n    \n    const experienceScore = experienceScores[agentExperience.toLowerCase()] || 60;\n    \n    // Calculate if agent is over/under qualified\n    const capabilityGap = experienceScore - complexityScore;\n    \n    let match;\n    if (Math.abs(capabilityGap) <= 15) {\n      match = 90; // Good fit\n    } else if (capabilityGap > 15) {\n      match = Math.max(60, 90 - (capabilityGap - 15) * 2); // Overqualified\n    } else {\n      match = Math.max(20, 90 + capabilityGap * 2); // Underqualified\n    }\n    \n    return {\n      score: Math.round(match),\n      experienceLevel: agentExperience,\n      experienceScore: experienceScore,\n      complexityRequirement: complexityScore,\n      capabilityGap: capabilityGap,\n      fitType: capabilityGap > 15 ? 'overqualified' : capabilityGap < -15 ? 'underqualified' : 'good-fit'\n    };\n  }\n  \n  function calculateSpecializationMatch(agent, requirements) {\n    const agentSpecializations = agent.specializations || [];\n    const requiredDomains = requirements.domainKnowledge || [];\n    \n    if (requiredDomains.length === 0) {\n      return { score: 50, hasSpecialization: false }; // Neutral if no domains required\n    }\n    \n    let matches = 0;\n    requiredDomains.forEach(domain => {\n      const domainName = typeof domain === 'string' ? domain : domain.name || domain.domain;\n      const hasMatch = agentSpecializations.some(spec => \n        spec.toLowerCase().includes(domainName.toLowerCase()) ||\n        domainName.toLowerCase().includes(spec.toLowerCase())\n      );\n      if (hasMatch) matches++;\n    });\n    \n    const specializationScore = requiredDomains.length > 0 ? (matches / requiredDomains.length) * 100 : 50;\n    \n    return {\n      score: Math.round(specializationScore),\n      matchedDomains: matches,\n      totalRequired: requiredDomains.length,\n      hasSpecialization: matches > 0,\n      specializations: agentSpecializations\n    };\n  }\n  \n  function calculateMatchConfidence(skillMatch, availabilityMatch, experienceMatch, agent) {\n    // Base confidence on data completeness\n    let confidence = 100;\n    \n    // Reduce confidence if missing key data\n    if (!agent.skillCategories || Object.keys(agent.skillCategories).length === 0) {\n      confidence -= 30;\n    }\n    \n    if (!agent.experienceLevel) {\n      confidence -= 15;\n    }\n    \n    if (skillMatch.totalRequired === 0) {\n      confidence -= 20; // Low confidence if no specific requirements\n    }\n    \n    // Increase confidence for strong matches\n    if (skillMatch.matchPercentage >= 80 && availabilityMatch.score >= 70) {\n      confidence += 10;\n    }\n    \n    return Math.min(100, Math.max(20, confidence));\n  }\n  \n  function generateMatchRationale(skillMatch, availabilityMatch, experienceMatch, specializationMatch, totalScore) {\n    const rationale = [];\n    \n    // Skill assessment\n    if (skillMatch.matchPercentage >= 80) {\n      rationale.push(`Strong skill match (${skillMatch.matchPercentage}% coverage)`);\n    } else if (skillMatch.matchPercentage >= 60) {\n      rationale.push(`Moderate skill match (${skillMatch.matchPercentage}% coverage)`);\n    } else {\n      rationale.push(`Limited skill match (${skillMatch.matchPercentage}% coverage)`);\n      if (skillMatch.missingSkills.length > 0) {\n        rationale.push(`Missing: ${skillMatch.missingSkills.join(', ')}`);\n      }\n    }\n    \n    // Availability assessment\n    if (availabilityMatch.score >= 70) {\n      rationale.push(`Good availability (${availabilityMatch.availabilityLevel})`);\n    } else if (availabilityMatch.score >= 40) {\n      rationale.push(`Moderate availability (${availabilityMatch.availabilityLevel})`);\n    } else {\n      rationale.push(`Limited availability (${availabilityMatch.availabilityLevel})`);\n    }\n    \n    // Experience fit\n    if (experienceMatch.fitType === 'good-fit') {\n      rationale.push(`Well-suited experience level (${experienceMatch.experienceLevel})`);\n    } else if (experienceMatch.fitType === 'overqualified') {\n      rationale.push(`Overqualified but capable (${experienceMatch.experienceLevel})`);\n    } else {\n      rationale.push(`May need support due to experience gap (${experienceMatch.experienceLevel})`);\n    }\n    \n    // Specialization bonus\n    if (specializationMatch.hasSpecialization) {\n      rationale.push(`Relevant domain expertise`);\n    }\n    \n    // Overall assessment\n    if (totalScore >= 80) {\n      rationale.push('Excellent overall match');\n    } else if (totalScore >= 60) {\n      rationale.push('Good overall match');\n    } else if (totalScore >= 40) {\n      rationale.push('Acceptable match with reservations');\n    } else {\n      rationale.push('Poor match - consider alternatives');\n    }\n    \n    return rationale;\n  }\n  \n  // Sort top candidates by match score\n  topCandidates.sort((a, b) => b.matchScore - a.matchScore);\n  \n  // Limit to top 5 candidates\n  const bestMatches = topCandidates.slice(0, 5);\n  \n  // Generate selection reasons summary\n  const selectionReasons = {\n    topChoice: bestMatches[0] || null,\n    alternativeOptions: bestMatches.slice(1, 3),\n    matchingCriteria: {\n      skillRequirements: Object.keys(skillRequirements).length,\n      availableAgents: topCandidates.length,\n      averageMatchScore: topCandidates.length > 0 ? \n        Math.round(topCandidates.reduce((sum, c) => sum + c.matchScore, 0) / topCandidates.length) : 0\n    },\n    recommendations: generateMatchRecommendations(bestMatches, complexity)\n  };\n  \n  function generateMatchRecommendations(matches, complexity) {\n    const recommendations = [];\n    \n    if (matches.length === 0) {\n      recommendations.push('No suitable agents found - consider reducing requirements or training agents');\n      return recommendations;\n    }\n    \n    const topScore = matches[0]?.matchScore || 0;\n    \n    if (topScore >= 80) {\n      recommendations.push('Excellent match found - proceed with assignment');\n    } else if (topScore >= 60) {\n      recommendations.push('Good match found - minor gaps can be addressed during execution');\n    } else if (topScore >= 40) {\n      recommendations.push('Acceptable match with some concerns - provide additional support');\n    } else {\n      recommendations.push('Weak matches only - consider task modification or agent training');\n    }\n    \n    if (complexity.overallScore > 70 && topScore < 70) {\n      recommendations.push('High complexity task with moderate match - consider breaking down task');\n    }\n    \n    if (matches.length === 1) {\n      recommendations.push('Only one suitable agent - consider developing backup options');\n    }\n    \n    return recommendations;\n  }\n  \n  return {\n    agentMatchScores: matchScores,\n    bestMatches: bestMatches,\n    selectionReasons: selectionReasons\n  };\n}"
          }
        },
        "formInput": {
          "__version": "1.0",
          "schema": {
            "containers": [],
            "elements": [
              {
                "fieldName": "requiredSkills",
                "id": "required_skills_input",
                "label": "Skill Requirements",
                "type": "JSON",
                "isRequired": true,
                "props": {
                  "placeholder": "Required skills and competencies for the task"
                }
              },
              {
                "fieldName": "agentCapabilities",
                "id": "agent_capabilities_input",
                "label": "Skill Matrix",
                "type": "JSON",
                "isRequired": true,
                "props": {
                  "placeholder": "Agent skill assessments and capabilities"
                }
              },
              {
                "fieldName": "workloadScores",
                "id": "workload_scores_input",
                "label": "Utilization Metrics",
                "type": "JSON",
                "isRequired": true,
                "props": {
                  "placeholder": "Agent workload and availability data"
                }
              },
              {
                "fieldName": "taskComplexity",
                "id": "task_complexity_input",
                "label": "Complexity Score",
                "type": "JSON",
                "isRequired": false,
                "props": {
                  "placeholder": "Task complexity and difficulty assessment"
                }
              }
            ]
          }
        },
        "formOutput": {
          "__version": "1.0",
          "schema": {
            "containers": [],
            "elements": [
              {
                "fieldName": "agentMatchScores",
                "id": "agent_match_scores_output",
                "label": "Match Scores",
                "type": "JSON"
              },
              {
                "fieldName": "bestMatches",
                "id": "best_matches_output",
                "label": "Top Candidates",
                "type": "JSON"
              },
              {
                "fieldName": "selectionReasons",
                "id": "selection_reasons_output",
                "label": "Match Rationale",
                "type": "JSON"
              }
            ]
          }
        },
        "executionStrategy": "deterministic"
      },
      "translations": [
        {
          "id": "7829564732190850309",
          "language": "en",
          "name": "Task Matcher",
          "description": "Finds optimal agent-task matches based on multiple factors using skill matching, availability analysis, and experience fit algorithms.",
          "instructions": "Provide skill requirements, agent capabilities, workload scores, and task complexity. The routine will calculate match scores and identify the best candidates."
        }
      ]
    }
  ]
}