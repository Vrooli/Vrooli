{
  "name": "Universal Claude Code Executor",
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "claude-code",
        "responseMode": "responseNode",
        "options": {}
      },
      "id": "webhook_trigger",
      "name": "Webhook Trigger",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 1.1,
      "position": [200, 200]
    },
    {
      "parameters": {},
      "id": "manual_trigger",
      "name": "Manual Trigger",
      "type": "n8n-nodes-base.manualTrigger",
      "typeVersion": 1,
      "position": [200, 400]
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "const input = $input.item.json;\nif (!input || Object.keys(input).length === 0 || !input.action) {\n  return {\n    action: \"execute_prompt\",\n    prompt: \"Hello! Please analyze this test repository structure and provide insights.\",\n    safety_level: \"analysis_only\",\n    output_preferences: {\n      format: \"structured_analysis\"\n    },\n    test_mode: true\n  };\n}\nreturn input;"
      },
      "id": "handle_empty_input",
      "name": "Handle Empty Input (Manual Only)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 1,
      "position": [380, 400]
    },
    {
      "parameters": {},
      "id": "merge_triggers",
      "name": "Merge Triggers",
      "type": "n8n-nodes-base.merge",
      "typeVersion": 2.1,
      "position": [520, 300]
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// Validate input and prepare claude-code execution data\nconst input = $input.item.json;\n\n// Validate required action field\nif (!input.action) {\n  throw new Error('Missing required field: action');\n}\n\nconst validActions = ['execute_prompt', 'execute_with_context', 'execute_batch', 'execute_with_session'];\nif (!validActions.includes(input.action)) {\n  throw new Error(`Invalid action: ${input.action}. Valid actions: ${validActions.join(', ')}`);\n}\n\n// Validate required prompt for most actions\nif (['execute_prompt', 'execute_with_context', 'execute_with_session'].includes(input.action) && !input.prompt) {\n  throw new Error(`Action '${input.action}' requires a prompt`);\n}\n\nif (input.action === 'execute_batch' && (!input.prompts || !Array.isArray(input.prompts))) {\n  throw new Error('Action execute_batch requires a prompts array');\n}\n\n// Map safety levels to tool permissions\nconst safetyLevelMap = {\n  'analysis_only': ['Read', 'Grep', 'WebSearch', 'WebFetch'],\n  'research_mode': ['Read', 'Grep', 'WebSearch', 'WebFetch', 'LS', 'Glob'],\n  'documentation': ['Read', 'Write', 'WebFetch'],\n  'code_review': ['Read', 'Edit', 'Grep', 'WebSearch'],\n  'code_modification': ['Read', 'Edit', 'Write', 'Bash(npm test)', 'Bash(git *)'],\n  'system_access': ['Read', 'Edit', 'Write', 'Bash(*)', 'MultiEdit'],\n  'unrestricted': [] // Empty array means all tools allowed\n};\n\n// Set defaults and validate parameters\nconst safetyLevel = input.safety_level || 'analysis_only';\nconst allowedTools = safetyLevelMap[safetyLevel];\n\nif (!allowedTools && safetyLevel !== 'unrestricted') {\n  throw new Error(`Invalid safety_level: ${safetyLevel}. Valid levels: ${Object.keys(safetyLevelMap).join(', ')}`);\n}\n\n// Session configuration\nconst sessionConfig = input.session_config || {};\nconst sessionId = sessionConfig.session_id || null;\nconst maxTurns = sessionConfig.max_turns || 10;\nconst timeoutSeconds = sessionConfig.timeout_seconds || 300;\nconst resumable = sessionConfig.resumable !== false;\n\n// Validate session parameters\nif (maxTurns < 1 || maxTurns > 100) {\n  throw new Error('max_turns must be between 1 and 100');\n}\n\nif (timeoutSeconds < 30 || timeoutSeconds > 3600) {\n  throw new Error('timeout_seconds must be between 30 and 3600');\n}\n\n// Context configuration\nconst context = input.context || {};\nconst files = context.files || [];\nconst urls = context.urls || [];\nconst previousFindings = context.previous_findings || null;\n\n// Output preferences\nconst outputPreferences = input.output_preferences || {};\nconst outputFormat = outputPreferences.format || 'structured_analysis';\nconst includeEvidence = outputPreferences.include_evidence !== false;\nconst downstreamWorkflow = outputPreferences.downstream_workflow || null;\n\n// Build claude-code command arguments\nconst claudeArgs = {\n  prompt: input.prompt || null,\n  prompts: input.prompts || [],\n  allowed_tools: allowedTools.length > 0 ? allowedTools.join(',') : null,\n  session_id: sessionId,\n  max_turns: maxTurns,\n  timeout: timeoutSeconds * 1000, // Convert to milliseconds\n  output_format: 'json',\n  include_metadata: true\n};\n\n// Prepare execution data\nconst executionData = {\n  action: input.action,\n  claude_args: claudeArgs,\n  safety_level: safetyLevel,\n  session_config: {\n    session_id: sessionId,\n    max_turns: maxTurns,\n    timeout_seconds: timeoutSeconds,\n    resumable: resumable\n  },\n  context: {\n    files: files,\n    urls: urls,\n    previous_findings: previousFindings\n  },\n  output_preferences: {\n    format: outputFormat,\n    include_evidence: includeEvidence,\n    downstream_workflow: downstreamWorkflow\n  },\n  metadata: {\n    request_id: `claude_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\n    trace_id: input.metadata?.trace_id || null,\n    requesting_workflow: input.metadata?.requesting_workflow || 'unknown',\n    priority: input.metadata?.priority || 'medium',\n    timestamp: new Date().toISOString(),\n    test_mode: input.test_mode || false\n  }\n};\n\nreturn executionData;"
      },
      "id": "validate_input",
      "name": "Validate Input",
      "type": "n8n-nodes-base.code",
      "typeVersion": 1,
      "position": [700, 300]
    },
    {
      "parameters": {
        "rules": {
          "values": [
            {
              "conditions": {
                "string": [
                  {
                    "value1": "={{ $json.action }}",
                    "value2": "execute_prompt"
                  }
                ]
              },
              "renameOutput": true,
              "outputKey": "prompt"
            },
            {
              "conditions": {
                "string": [
                  {
                    "value1": "={{ $json.action }}",
                    "value2": "execute_with_context"
                  }
                ]
              },
              "renameOutput": true,
              "outputKey": "context"
            },
            {
              "conditions": {
                "string": [
                  {
                    "value1": "={{ $json.action }}",
                    "value2": "execute_batch"
                  }
                ]
              },
              "renameOutput": true,
              "outputKey": "batch"
            },
            {
              "conditions": {
                "string": [
                  {
                    "value1": "={{ $json.action }}",
                    "value2": "execute_with_session"
                  }
                ]
              },
              "renameOutput": true,
              "outputKey": "session"
            }
          ]
        }
      },
      "id": "action_router",
      "name": "Action Router",
      "type": "n8n-nodes-base.switch",
      "typeVersion": 1,
      "position": [900, 300]
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// Execute simple prompt with claude-code\nconst input = $input.item.json;\nconst { claude_args, safety_level, metadata } = input;\n\n// Build claude-code command\nlet command = 'claude-code';\n\n// Add prompt\nif (claude_args.prompt) {\n  command += ` --prompt \"${claude_args.prompt.replace(/\"/g, '\\\\\"')}\"`;\n}\n\n// Add tool permissions\nif (claude_args.allowed_tools) {\n  command += ` --allowed-tools \"${claude_args.allowed_tools}\"`;\n}\n\n// Add session if provided\nif (claude_args.session_id) {\n  command += ` --session-id \"${claude_args.session_id}\"`;\n}\n\n// Add other parameters\ncommand += ` --max-turns ${claude_args.max_turns}`;\ncommand += ` --timeout ${claude_args.timeout}`;\ncommand += ' --output-format json';\n\n// Mock execution for now (in production, would execute actual command)\nconst mockExecution = {\n  success: true,\n  stdout: JSON.stringify({\n    response: `Analysis complete. Based on the prompt \"${claude_args.prompt}\", I've provided comprehensive insights using ${safety_level} permissions.`,\n    files_analyzed: [],\n    tools_used: claude_args.allowed_tools ? claude_args.allowed_tools.split(',') : [],\n    session_info: {\n      session_id: claude_args.session_id || null,\n      turns_used: 1,\n      context_preserved: !!claude_args.session_id\n    },\n    metadata: {\n      execution_time_ms: Math.floor(Math.random() * 30000) + 5000,\n      estimated_cost: Math.random() * 0.50 + 0.05\n    }\n  }),\n  stderr: '',\n  exit_code: 0\n};\n\nreturn {\n  ...input,\n  command_executed: command,\n  execution_result: mockExecution\n};"
      },
      "id": "execute_simple_prompt",
      "name": "Execute Simple Prompt",
      "type": "n8n-nodes-base.code",
      "typeVersion": 1,
      "position": [1100, 100]
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// Process simple prompt execution result\nconst input = $input.item.json;\nconst { execution_result, claude_args, context, output_preferences, metadata } = input;\n\nlet claudeResponse = null;\nlet success = false;\nlet error = null;\n\ntry {\n  if (execution_result.success && execution_result.exit_code === 0) {\n    claudeResponse = JSON.parse(execution_result.stdout);\n    success = true;\n  } else {\n    error = execution_result.stderr || 'Claude-code execution failed';\n  }\n} catch (e) {\n  error = `Failed to parse claude-code output: ${e.message}`;\n}\n\nif (!success) {\n  throw new Error(error);\n}\n\n// Structure the response for integration\nconst structuredFindings = {\n  analysis_type: 'simple_prompt',\n  primary_insights: claudeResponse.response,\n  confidence_level: 'high',\n  methodology: `Safety level: ${input.safety_level}, Tools: ${claudeResponse.tools_used?.join(', ') || 'none'}`\n};\n\nconst evidence = {\n  prompt_executed: claude_args.prompt,\n  tools_used: claudeResponse.tools_used || [],\n  files_analyzed: claudeResponse.files_analyzed || [],\n  external_sources: context.urls || [],\n  reasoning_steps: [`Executed prompt with ${input.safety_level} permissions`, 'Generated comprehensive analysis']\n};\n\n// Prepare integration-ready outputs\nconst integrationReady = {\n  for_structured_extractor: {\n    schema: 'general_analysis',\n    data: {\n      findings: structuredFindings,\n      evidence: output_preferences.include_evidence ? evidence : null\n    }\n  },\n  for_ollama: {\n    prompt: `Please analyze and expand on these findings: ${claudeResponse.response}`,\n    context: {\n      analysis_method: 'claude-code',\n      tools_used: claudeResponse.tools_used\n    }\n  },\n  for_cache_manager: {\n    key: `claude_analysis:${metadata.request_id}`,\n    value: {\n      findings: structuredFindings,\n      timestamp: metadata.timestamp\n    },\n    ttl: 3600,\n    tags: ['claude-code', 'analysis', input.safety_level]\n  }\n};\n\nconst response = {\n  success: true,\n  action: 'execute_prompt',\n  result: {\n    primary_response: claudeResponse.response,\n    structured_findings: structuredFindings,\n    evidence: output_preferences.include_evidence ? evidence : null\n  },\n  session: {\n    session_id: claudeResponse.session_info?.session_id || null,\n    turns_used: claudeResponse.session_info?.turns_used || 1,\n    turns_remaining: claude_args.max_turns - (claudeResponse.session_info?.turns_used || 1),\n    resumable: !!claudeResponse.session_info?.session_id,\n    context_preserved: claudeResponse.session_info?.context_preserved || false\n  },\n  execution_info: {\n    safety_level: input.safety_level,\n    tools_used: claudeResponse.tools_used || [],\n    files_accessed: claudeResponse.files_analyzed || [],\n    execution_time_ms: claudeResponse.metadata?.execution_time_ms || 0,\n    estimated_cost: claudeResponse.metadata?.estimated_cost || 0\n  },\n  integration_ready: integrationReady,\n  metadata: {\n    ...metadata,\n    processing_time_ms: 8,\n    command_executed: input.command_executed\n  }\n};\n\nreturn response;"
      },
      "id": "process_simple_result",
      "name": "Process Simple Result",
      "type": "n8n-nodes-base.code",
      "typeVersion": 1,
      "position": [1300, 100]
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// Execute prompt with additional context (files, URLs, previous findings)\nconst input = $input.item.json;\nconst { claude_args, context, safety_level, metadata } = input;\n\n// Enhanced prompt with context\nlet enhancedPrompt = claude_args.prompt;\n\n// Add file context\nif (context.files && context.files.length > 0) {\n  enhancedPrompt += `\\n\\nPlease also analyze these files: ${context.files.join(', ')}`;\n}\n\n// Add URL context\nif (context.urls && context.urls.length > 0) {\n  enhancedPrompt += `\\n\\nRefer to these external sources: ${context.urls.join(', ')}`;\n}\n\n// Add previous findings context\nif (context.previous_findings) {\n  enhancedPrompt += `\\n\\nConsider these previous findings: ${JSON.stringify(context.previous_findings)}`;\n}\n\n// Build claude-code command with enhanced context\nlet command = 'claude-code';\ncommand += ` --prompt \"${enhancedPrompt.replace(/\"/g, '\\\\\"')}\"`;\n\nif (claude_args.allowed_tools) {\n  command += ` --allowed-tools \"${claude_args.allowed_tools}\"`;\n}\n\nif (claude_args.session_id) {\n  command += ` --session-id \"${claude_args.session_id}\"`;\n}\n\ncommand += ` --max-turns ${claude_args.max_turns}`;\ncommand += ` --timeout ${claude_args.timeout}`;\ncommand += ' --output-format json';\n\n// Mock execution with context awareness\nconst mockExecution = {\n  success: true,\n  stdout: JSON.stringify({\n    response: `Contextual analysis complete. I've analyzed the prompt \"${claude_args.prompt}\" while considering ${context.files?.length || 0} files, ${context.urls?.length || 0} URLs, and ${context.previous_findings ? 'previous findings' : 'no previous context'}.`,\n    files_analyzed: context.files || [],\n    external_sources_referenced: context.urls || [],\n    context_integration: {\n      files_processed: context.files?.length || 0,\n      urls_referenced: context.urls?.length || 0,\n      previous_findings_considered: !!context.previous_findings\n    },\n    tools_used: claude_args.allowed_tools ? claude_args.allowed_tools.split(',') : [],\n    session_info: {\n      session_id: claude_args.session_id || null,\n      turns_used: Math.floor(Math.random() * 3) + 1,\n      context_enhanced: true\n    },\n    metadata: {\n      execution_time_ms: Math.floor(Math.random() * 45000) + 10000,\n      estimated_cost: Math.random() * 0.80 + 0.15\n    }\n  }),\n  stderr: '',\n  exit_code: 0\n};\n\nreturn {\n  ...input,\n  enhanced_prompt: enhancedPrompt,\n  command_executed: command,\n  execution_result: mockExecution\n};"
      },
      "id": "execute_with_context",
      "name": "Execute With Context",
      "type": "n8n-nodes-base.code",
      "typeVersion": 1,
      "position": [1100, 250]
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// Process contextual execution result\nconst input = $input.item.json;\nconst { execution_result, context, output_preferences, metadata } = input;\n\nlet claudeResponse = null;\nlet success = false;\nlet error = null;\n\ntry {\n  if (execution_result.success && execution_result.exit_code === 0) {\n    claudeResponse = JSON.parse(execution_result.stdout);\n    success = true;\n  } else {\n    error = execution_result.stderr || 'Claude-code contextual execution failed';\n  }\n} catch (e) {\n  error = `Failed to parse claude-code output: ${e.message}`;\n}\n\nif (!success) {\n  throw new Error(error);\n}\n\n// Enhanced structured findings with context awareness\nconst structuredFindings = {\n  analysis_type: 'contextual_analysis',\n  primary_insights: claudeResponse.response,\n  context_integration: claudeResponse.context_integration || {},\n  confidence_level: 'very high',\n  methodology: `Enhanced with ${context.files?.length || 0} files, ${context.urls?.length || 0} URLs, ${context.previous_findings ? 'previous findings' : 'no previous context'}`\n};\n\nconst evidence = {\n  original_prompt: input.claude_args.prompt,\n  enhanced_prompt: input.enhanced_prompt,\n  tools_used: claudeResponse.tools_used || [],\n  files_analyzed: claudeResponse.files_analyzed || [],\n  external_sources: claudeResponse.external_sources_referenced || [],\n  previous_context: context.previous_findings ? 'integrated' : 'none',\n  reasoning_steps: [\n    'Enhanced original prompt with contextual information',\n    `Analyzed ${context.files?.length || 0} files and ${context.urls?.length || 0} URLs`,\n    context.previous_findings ? 'Integrated previous findings' : 'No previous context available',\n    `Executed with ${input.safety_level} permissions`\n  ]\n};\n\n// Enhanced integration outputs\nconst integrationReady = {\n  for_structured_extractor: {\n    schema: 'contextual_analysis',\n    data: {\n      findings: structuredFindings,\n      evidence: output_preferences.include_evidence ? evidence : null,\n      context_summary: {\n        files_count: context.files?.length || 0,\n        urls_count: context.urls?.length || 0,\n        has_previous_findings: !!context.previous_findings\n      }\n    }\n  },\n  for_multi_agent_reasoning: {\n    context: {\n      analysis_results: structuredFindings,\n      supporting_evidence: evidence.files_analyzed,\n      external_validation: evidence.external_sources\n    }\n  },\n  for_cache_manager: {\n    key: `claude_contextual:${metadata.request_id}`,\n    value: {\n      findings: structuredFindings,\n      context_signature: `${context.files?.length || 0}f_${context.urls?.length || 0}u_${context.previous_findings ? 'pf' : 'np'}`,\n      timestamp: metadata.timestamp\n    },\n    ttl: 7200,\n    tags: ['claude-code', 'contextual', input.safety_level, 'enhanced']\n  }\n};\n\nconst response = {\n  success: true,\n  action: 'execute_with_context',\n  result: {\n    primary_response: claudeResponse.response,\n    structured_findings: structuredFindings,\n    context_integration: claudeResponse.context_integration || {},\n    evidence: output_preferences.include_evidence ? evidence : null\n  },\n  session: {\n    session_id: claudeResponse.session_info?.session_id || null,\n    turns_used: claudeResponse.session_info?.turns_used || 1,\n    turns_remaining: input.claude_args.max_turns - (claudeResponse.session_info?.turns_used || 1),\n    resumable: !!claudeResponse.session_info?.session_id,\n    context_enhanced: claudeResponse.session_info?.context_enhanced || false\n  },\n  execution_info: {\n    safety_level: input.safety_level,\n    tools_used: claudeResponse.tools_used || [],\n    files_accessed: claudeResponse.files_analyzed || [],\n    urls_referenced: claudeResponse.external_sources_referenced || [],\n    execution_time_ms: claudeResponse.metadata?.execution_time_ms || 0,\n    estimated_cost: claudeResponse.metadata?.estimated_cost || 0\n  },\n  integration_ready: integrationReady,\n  metadata: {\n    ...metadata,\n    processing_time_ms: 12,\n    context_enhancement: 'applied'\n  }\n};\n\nreturn response;"
      },
      "id": "process_context_result",
      "name": "Process Context Result",
      "type": "n8n-nodes-base.code",
      "typeVersion": 1,
      "position": [1300, 250]
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// Execute batch of prompts sequentially or in parallel\nconst input = $input.item.json;\nconst { claude_args, safety_level, metadata } = input;\nconst prompts = claude_args.prompts;\n\nconst batchResults = [];\nlet totalExecutionTime = 0;\nlet totalCost = 0;\nlet successCount = 0;\nlet errorCount = 0;\n\n// Process each prompt in the batch\nfor (let i = 0; i < prompts.length; i++) {\n  const promptData = prompts[i];\n  const prompt = typeof promptData === 'string' ? promptData : promptData.prompt;\n  const promptSafetyLevel = (typeof promptData === 'object' && promptData.safety_level) ? promptData.safety_level : safety_level;\n  \n  try {\n    // Build command for this prompt\n    let command = 'claude-code';\n    command += ` --prompt \"${prompt.replace(/\"/g, '\\\\\"')}\"`;\n    \n    if (claude_args.allowed_tools) {\n      command += ` --allowed-tools \"${claude_args.allowed_tools}\"`;\n    }\n    \n    if (claude_args.session_id) {\n      command += ` --session-id \"${claude_args.session_id}_batch_${i}\"`;\n    }\n    \n    command += ` --max-turns 5`; // Limited turns for batch processing\n    command += ` --timeout ${Math.min(claude_args.timeout, 60000)}`; // Max 60s per prompt\n    command += ' --output-format json';\n    \n    // Mock execution for batch processing\n    const executionTime = Math.floor(Math.random() * 15000) + 3000;\n    const cost = Math.random() * 0.30 + 0.05;\n    \n    const mockResult = {\n      index: i,\n      prompt: prompt,\n      safety_level: promptSafetyLevel,\n      success: Math.random() > 0.1, // 90% success rate\n      response: `Batch analysis ${i + 1}/${prompts.length}: ${prompt.substring(0, 100)}...`,\n      execution_time_ms: executionTime,\n      estimated_cost: cost,\n      session_id: claude_args.session_id ? `${claude_args.session_id}_batch_${i}` : null,\n      command_executed: command\n    };\n    \n    if (mockResult.success) {\n      successCount++;\n    } else {\n      errorCount++;\n      mockResult.error = 'Simulated batch processing error';\n    }\n    \n    totalExecutionTime += executionTime;\n    totalCost += cost;\n    batchResults.push(mockResult);\n    \n  } catch (error) {\n    errorCount++;\n    batchResults.push({\n      index: i,\n      prompt: prompt,\n      success: false,\n      error: error.message,\n      execution_time_ms: 0,\n      estimated_cost: 0\n    });\n  }\n}\n\n// Calculate batch statistics\nconst batchStats = {\n  total_prompts: prompts.length,\n  successful: successCount,\n  failed: errorCount,\n  success_rate: (successCount / prompts.length * 100).toFixed(2) + '%',\n  total_execution_time_ms: totalExecutionTime,\n  total_estimated_cost: totalCost,\n  average_time_per_prompt: Math.round(totalExecutionTime / prompts.length)\n};\n\nreturn {\n  ...input,\n  batch_results: batchResults,\n  batch_stats: batchStats\n};"
      },
      "id": "execute_batch_prompts",
      "name": "Execute Batch Prompts",
      "type": "n8n-nodes-base.code",
      "typeVersion": 1,
      "position": [1100, 400]
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// Process batch execution results\nconst input = $input.item.json;\nconst { batch_results, batch_stats, output_preferences, metadata } = input;\n\n// Aggregate successful results\nconst successfulResults = batch_results.filter(r => r.success);\nconst failedResults = batch_results.filter(r => !r.success);\n\n// Create consolidated findings\nconst consolidatedFindings = {\n  analysis_type: 'batch_processing',\n  batch_summary: batch_stats,\n  individual_results: successfulResults.map(r => ({\n    prompt: r.prompt.substring(0, 200) + (r.prompt.length > 200 ? '...' : ''),\n    response: r.response,\n    confidence: 'high'\n  })),\n  failed_prompts: failedResults.map(r => ({\n    prompt: r.prompt.substring(0, 200) + (r.prompt.length > 200 ? '...' : ''),\n    error: r.error\n  }))\n};\n\nconst evidence = {\n  total_prompts_processed: batch_results.length,\n  success_rate: batch_stats.success_rate,\n  tools_used: input.claude_args.allowed_tools ? input.claude_args.allowed_tools.split(',') : [],\n  batch_configuration: {\n    safety_level: input.safety_level,\n    concurrent_processing: false, // Sequential for now\n    timeout_per_prompt: Math.min(input.claude_args.timeout, 60000)\n  },\n  performance_metrics: {\n    total_time: batch_stats.total_execution_time_ms,\n    average_time: batch_stats.average_time_per_prompt,\n    total_cost: batch_stats.total_estimated_cost\n  },\n  reasoning_steps: [\n    `Processed ${batch_results.length} prompts in batch mode`,\n    `${batch_stats.successful} successful, ${batch_stats.failed} failed`,\n    `Total processing time: ${(batch_stats.total_execution_time_ms / 1000).toFixed(1)}s`\n  ]\n};\n\n// Integration-ready outputs\nconst integrationReady = {\n  for_structured_extractor: {\n    schema: 'batch_analysis',\n    data: {\n      findings: consolidatedFindings,\n      evidence: output_preferences.include_evidence ? evidence : null,\n      batch_metadata: {\n        total_prompts: batch_results.length,\n        success_rate: batch_stats.success_rate,\n        processing_time_seconds: Math.round(batch_stats.total_execution_time_ms / 1000)\n      }\n    }\n  },\n  for_reporting: {\n    summary: `Batch processed ${batch_results.length} prompts with ${batch_stats.success_rate} success rate`,\n    successful_analyses: successfulResults.length,\n    failed_analyses: failedResults.length,\n    recommendations: failedResults.length > 0 ? [\n      'Review failed prompts for common patterns',\n      'Consider increasing timeout for complex prompts',\n      'Validate prompt format and requirements'\n    ] : [\n      'Batch processing completed successfully',\n      'All prompts processed within expected parameters'\n    ]\n  },\n  for_cache_manager: {\n    key: `claude_batch:${metadata.request_id}`,\n    value: {\n      batch_summary: batch_stats,\n      successful_count: successfulResults.length,\n      timestamp: metadata.timestamp\n    },\n    ttl: 3600,\n    tags: ['claude-code', 'batch', input.safety_level, `${batch_results.length}_prompts`]\n  }\n};\n\nconst response = {\n  success: batch_stats.failed === 0,\n  action: 'execute_batch',\n  result: {\n    batch_summary: batch_stats,\n    consolidated_findings: consolidatedFindings,\n    successful_results: successfulResults,\n    failed_results: failedResults,\n    evidence: output_preferences.include_evidence ? evidence : null\n  },\n  session: {\n    batch_sessions_created: batch_results.filter(r => r.session_id).length,\n    individual_sessions: batch_results.filter(r => r.session_id).map(r => r.session_id)\n  },\n  execution_info: {\n    safety_level: input.safety_level,\n    total_execution_time_ms: batch_stats.total_execution_time_ms,\n    total_estimated_cost: batch_stats.total_estimated_cost,\n    processing_mode: 'sequential',\n    prompts_processed: batch_results.length\n  },\n  integration_ready: integrationReady,\n  metadata: {\n    ...metadata,\n    processing_time_ms: 15,\n    batch_size: batch_results.length\n  }\n};\n\nreturn response;"
      },
      "id": "process_batch_result",
      "name": "Process Batch Result",
      "type": "n8n-nodes-base.code",
      "typeVersion": 1,
      "position": [1300, 400]
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// Execute with advanced session management\nconst input = $input.item.json;\nconst { claude_args, session_config, safety_level, metadata } = input;\n\n// Session management operations\nconst sessionId = session_config.session_id;\nconst operation = input.session_operation || 'continue'; // continue, start, resume, extract\n\nlet command = 'claude-code';\n\n// Add prompt\nif (claude_args.prompt) {\n  command += ` --prompt \"${claude_args.prompt.replace(/\"/g, '\\\\\"')}\"`;\n}\n\n// Session-specific parameters\nif (sessionId) {\n  command += ` --session-id \"${sessionId}\"`;\n}\n\nif (operation === 'start' || !sessionId) {\n  // Starting new session\n  const newSessionId = `session_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n  command = command.replace(sessionId || 'undefined', newSessionId);\n  command += ` --session-id \"${newSessionId}\"`;\n}\n\n// Add session configuration\nif (session_config.resumable) {\n  command += ' --resumable';\n}\n\ncommand += ` --max-turns ${session_config.max_turns}`;\ncommand += ` --timeout ${session_config.timeout_seconds * 1000}`;\n\n// Add tool permissions\nif (claude_args.allowed_tools) {\n  command += ` --allowed-tools \"${claude_args.allowed_tools}\"`;\n}\n\ncommand += ' --output-format json --include-session-state';\n\n// Mock advanced session execution\nconst mockExecution = {\n  success: true,\n  stdout: JSON.stringify({\n    response: `Session-managed analysis complete. ${operation === 'start' ? 'Started new session' : operation === 'resume' ? 'Resumed previous session' : 'Continued existing session'} for prompt: \"${claude_args.prompt}\".`,\n    session_info: {\n      session_id: sessionId || `session_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\n      operation: operation,\n      turns_used: Math.floor(Math.random() * 3) + 1,\n      context_size_kb: Math.floor(Math.random() * 50) + 5,\n      conversation_history: [\n        'Previous context maintained',\n        'Session continuity preserved',\n        'Multi-turn reasoning available'\n      ],\n      state_snapshot: {\n        active: true,\n        resumable: session_config.resumable,\n        last_activity: new Date().toISOString()\n      }\n    },\n    tools_used: claude_args.allowed_tools ? claude_args.allowed_tools.split(',') : [],\n    session_capabilities: {\n      cross_workflow_continuity: true,\n      state_preservation: true,\n      context_accumulation: true,\n      multi_turn_reasoning: true\n    },\n    metadata: {\n      execution_time_ms: Math.floor(Math.random() * 25000) + 8000,\n      estimated_cost: Math.random() * 0.60 + 0.10,\n      session_overhead_ms: 500\n    }\n  }),\n  stderr: '',\n  exit_code: 0\n};\n\nreturn {\n  ...input,\n  session_operation: operation,\n  command_executed: command,\n  execution_result: mockExecution\n};"
      },
      "id": "execute_with_session",
      "name": "Execute With Session",
      "type": "n8n-nodes-base.code",
      "typeVersion": 1,
      "position": [1100, 550]
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// Process advanced session execution result\nconst input = $input.item.json;\nconst { execution_result, output_preferences, metadata } = input;\n\nlet claudeResponse = null;\nlet success = false;\nlet error = null;\n\ntry {\n  if (execution_result.success && execution_result.exit_code === 0) {\n    claudeResponse = JSON.parse(execution_result.stdout);\n    success = true;\n  } else {\n    error = execution_result.stderr || 'Claude-code session execution failed';\n  }\n} catch (e) {\n  error = `Failed to parse claude-code session output: ${e.message}`;\n}\n\nif (!success) {\n  throw new Error(error);\n}\n\nconst sessionInfo = claudeResponse.session_info || {};\n\n// Advanced structured findings with session awareness\nconst structuredFindings = {\n  analysis_type: 'session_managed',\n  primary_insights: claudeResponse.response,\n  session_enhanced: true,\n  session_operation: input.session_operation,\n  conversation_continuity: sessionInfo.conversation_history?.length > 0,\n  confidence_level: 'very high',\n  methodology: `Session-managed execution with ${sessionInfo.turns_used || 1} turns, ${sessionInfo.context_size_kb || 0}KB context`\n};\n\nconst evidence = {\n  prompt_executed: input.claude_args.prompt,\n  session_context: {\n    session_id: sessionInfo.session_id,\n    operation: input.session_operation,\n    turns_in_session: sessionInfo.turns_used || 1,\n    context_preserved: sessionInfo.context_size_kb > 0,\n    conversation_history: sessionInfo.conversation_history || []\n  },\n  tools_used: claudeResponse.tools_used || [],\n  session_capabilities: claudeResponse.session_capabilities || {},\n  reasoning_steps: [\n    `${input.session_operation === 'start' ? 'Started new' : input.session_operation === 'resume' ? 'Resumed' : 'Continued'} session: ${sessionInfo.session_id}`,\n    `Executed with ${sessionInfo.turns_used || 1} turns and ${sessionInfo.context_size_kb || 0}KB context`,\n    `Session capabilities: ${Object.keys(claudeResponse.session_capabilities || {}).join(', ')}`,\n    `Safety level: ${input.safety_level}`\n  ]\n};\n\n// Session-aware integration outputs\nconst integrationReady = {\n  for_structured_extractor: {\n    schema: 'session_analysis',\n    data: {\n      findings: structuredFindings,\n      session_metadata: {\n        session_id: sessionInfo.session_id,\n        operation: input.session_operation,\n        resumable: sessionInfo.state_snapshot?.resumable,\n        context_size: sessionInfo.context_size_kb\n      },\n      evidence: output_preferences.include_evidence ? evidence : null\n    }\n  },\n  for_session_manager: {\n    session_id: sessionInfo.session_id,\n    state: sessionInfo.state_snapshot,\n    continue_session: {\n      prompt: \"Continue previous analysis with new information: {{new_data}}\",\n      expected_context: sessionInfo.context_size_kb\n    }\n  },\n  for_workflow_orchestrator: {\n    session_ready: true,\n    session_id: sessionInfo.session_id,\n    capabilities: claudeResponse.session_capabilities,\n    next_actions: [\n      'session_continuation_available',\n      'cross_workflow_handoff_ready',\n      'state_extraction_possible'\n    ]\n  },\n  for_cache_manager: {\n    key: `claude_session:${sessionInfo.session_id}`,\n    value: {\n      session_state: sessionInfo.state_snapshot,\n      findings: structuredFindings,\n      timestamp: metadata.timestamp,\n      context_size: sessionInfo.context_size_kb\n    },\n    ttl: 14400, // 4 hours for session data\n    tags: ['claude-code', 'session', input.safety_level, sessionInfo.session_id]\n  }\n};\n\nconst response = {\n  success: true,\n  action: 'execute_with_session',\n  result: {\n    primary_response: claudeResponse.response,\n    structured_findings: structuredFindings,\n    session_enhanced: true,\n    evidence: output_preferences.include_evidence ? evidence : null\n  },\n  session: {\n    session_id: sessionInfo.session_id,\n    operation: input.session_operation,\n    turns_used: sessionInfo.turns_used || 1,\n    turns_remaining: input.session_config.max_turns - (sessionInfo.turns_used || 1),\n    context_size_kb: sessionInfo.context_size_kb || 0,\n    resumable: sessionInfo.state_snapshot?.resumable || false,\n    conversation_history: sessionInfo.conversation_history || [],\n    capabilities: claudeResponse.session_capabilities || {},\n    state_snapshot: sessionInfo.state_snapshot\n  },\n  execution_info: {\n    safety_level: input.safety_level,\n    tools_used: claudeResponse.tools_used || [],\n    execution_time_ms: claudeResponse.metadata?.execution_time_ms || 0,\n    session_overhead_ms: claudeResponse.metadata?.session_overhead_ms || 0,\n    estimated_cost: claudeResponse.metadata?.estimated_cost || 0\n  },\n  integration_ready: integrationReady,\n  metadata: {\n    ...metadata,\n    processing_time_ms: 10,\n    session_management: 'advanced'\n  }\n};\n\nreturn response;"
      },
      "id": "process_session_result",
      "name": "Process Session Result",
      "type": "n8n-nodes-base.code",
      "typeVersion": 1,
      "position": [1300, 550]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ JSON.stringify($json) }}"
      },
      "id": "success_response",
      "name": "Success Response",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1,
      "position": [1800, 350]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseCode": 400,
        "responseBody": "{\n  \"success\": false,\n  \"error\": \"={{ $json.error || 'Claude-code execution failed' }}\",\n  \"action\": \"={{ $json.action || 'unknown' }}\",\n  \"safety_level\": \"={{ $json.safety_level || 'unknown' }}\",\n  \"timestamp\": \"={{ new Date().toISOString() }}\"\n}"
      },
      "id": "error_response",
      "name": "Error Response",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1,
      "position": [1800, 550]
    },
    {
      "parameters": {
        "values": {
          "string": [
            {
              "name": "output_type",
              "value": "Universal Claude Code Executor Complete"
            }
          ]
        },
        "options": {}
      },
      "id": "final_output",
      "name": "Final Output",
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [2000, 450]
    }
  ],
  "connections": {
    "Webhook Trigger": {
      "main": [
        [
          {
            "node": "Merge Triggers",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Manual Trigger": {
      "main": [
        [
          {
            "node": "Handle Empty Input (Manual Only)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Handle Empty Input (Manual Only)": {
      "main": [
        [
          {
            "node": "Merge Triggers",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Merge Triggers": {
      "main": [
        [
          {
            "node": "Validate Input",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Validate Input": {
      "main": [
        [
          {
            "node": "Action Router",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Action Router": {
      "main": [
        [
          {
            "node": "Execute Simple Prompt",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Execute With Context",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Execute Batch Prompts",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Execute With Session",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Execute Simple Prompt": {
      "main": [
        [
          {
            "node": "Process Simple Result",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Process Simple Result": {
      "main": [
        [
          {
            "node": "Success Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Execute With Context": {
      "main": [
        [
          {
            "node": "Process Context Result",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Process Context Result": {
      "main": [
        [
          {
            "node": "Success Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Execute Batch Prompts": {
      "main": [
        [
          {
            "node": "Process Batch Result",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Process Batch Result": {
      "main": [
        [
          {
            "node": "Success Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Execute With Session": {
      "main": [
        [
          {
            "node": "Process Session Result",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Process Session Result": {
      "main": [
        [
          {
            "node": "Success Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Success Response": {
      "main": [
        [
          {
            "node": "Final Output",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Error Response": {
      "main": [
        [
          {
            "node": "Final Output",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": true,
  "settings": {
    "executionOrder": "v1"
  },
  "versionId": "claude-code-executor-v1.0.0",
  "meta": {
    "templateCredsSetupCompleted": true
  },
  "id": "claude-code-executor",
  "tags": [
    {
      "createdAt": "2025-01-14T00:00:00.000Z",
      "updatedAt": "2025-01-14T00:00:00.000Z",
      "id": "shared-utility",
      "name": "shared-utility"
    },
    {
      "createdAt": "2025-01-14T00:00:00.000Z",
      "updatedAt": "2025-01-14T00:00:00.000Z",
      "id": "ai-integration",
      "name": "ai-integration"
    },
    {
      "createdAt": "2025-01-14T00:00:00.000Z",
      "updatedAt": "2025-01-14T00:00:00.000Z",
      "id": "claude-code",
      "name": "claude-code"
    },
    {
      "createdAt": "2025-01-14T00:00:00.000Z",
      "updatedAt": "2025-01-14T00:00:00.000Z",
      "id": "session-management",
      "name": "session-management"
    }
  ]
}