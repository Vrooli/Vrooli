{
  "name": "Universal Cache Manager",
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "cache",
        "responseMode": "responseNode",
        "options": {}
      },
      "id": "webhook_trigger",
      "name": "Cache Webhook",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 1.1,
      "position": [200, 200]
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// Validate input and determine operation\nconst input = $input.item.json;\n\n// Validate required operation field\nif (!input.operation) {\n  throw new Error('Missing required field: operation');\n}\n\nconst validOperations = ['get', 'set', 'delete', 'invalidate', 'warm', 'stats'];\nif (!validOperations.includes(input.operation)) {\n  throw new Error(`Invalid operation: ${input.operation}. Valid operations: ${validOperations.join(', ')}`);\n}\n\n// Validate required key for most operations\nif (['get', 'set', 'delete'].includes(input.operation) && !input.key) {\n  throw new Error(`Operation '${input.operation}' requires a key`);\n}\n\n// Database selection logic\nconst selectDatabase = (database, namespace) => {\n  if (database === \"shared\") return 0;\n  if (database === \"auto\" && namespace) {\n    // Hash namespace to database 1-15\n    let hash = 0;\n    for (let i = 0; i < namespace.length; i++) {\n      const char = namespace.charCodeAt(i);\n      hash = ((hash << 5) - hash) + char;\n      hash = hash & hash; // Convert to 32-bit integer\n    }\n    return 1 + (Math.abs(hash) % 15);\n  }\n  if (typeof database === 'number' && database >= 0 && database <= 15) return database;\n  if (typeof database === 'string' && !isNaN(parseInt(database))) {\n    const dbNum = parseInt(database);\n    return (dbNum >= 0 && dbNum <= 15) ? dbNum : 0;\n  }\n  return 0; // Default to shared database\n};\n\n// Determine database\nconst database = input.database || \"shared\";\nconst namespace = input.namespace || \"default\";\nconst selectedDb = selectDatabase(database, namespace);\n\n// Prepare operation data\nconst operationData = {\n  operation: input.operation,\n  database: selectedDb,\n  key: input.key,\n  value: input.value,\n  ttl: input.ttl || 3600, // Default 1 hour\n  pattern: input.pattern,\n  tags: input.tags || [],\n  compress: input.compress || false,\n  default: input.default,\n  extend_ttl: input.extend_ttl || false,\n  entries: input.entries || [],\n  reason: input.reason || 'Manual invalidation',\n  namespace: namespace,\n  timestamp: new Date().toISOString()\n};\n\n// Add operation metadata\noperationData.metadata = {\n  request_id: `req_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\n  client: input.client || 'n8n-cache-manager',\n  trace_id: input.trace_id || operationData.metadata?.request_id\n};\n\n// Auto-compress large values for SET operations\nif (input.operation === 'set' && operationData.value) {\n  const valueStr = JSON.stringify(operationData.value);\n  if (valueStr.length > 1024 || operationData.compress) {\n    operationData.value = {\n      __compressed: true,\n      data: valueStr,\n      original_size: valueStr.length\n    };\n    operationData.compressed = true;\n  }\n}\n\nreturn operationData;"
      },
      "id": "validate_and_prepare",
      "name": "Validate & Prepare",
      "type": "n8n-nodes-base.code",
      "typeVersion": 1,
      "position": [450, 300]
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// Select Redis database using Redis SELECT command\nconst { database } = $input.item.json;\n\n// We'll use this to set the context for subsequent Redis operations\n// Since n8n Redis nodes use credentials with fixed database, we need to\n// store our database selection for use by subsequent nodes\nreturn {\n  ...$input.item.json,\n  redis_select_command: `SELECT ${database}`,\n  selected_database: database\n};"
      },
      "id": "database_selector",
      "name": "Database Selector",
      "type": "n8n-nodes-base.code",
      "typeVersion": 1,
      "position": [650, 300]
    },
    {
      "parameters": {
        "rules": {
          "values": [
            {
              "conditions": {
                "string": [
                  {
                    "value1": "={{ $json.operation }}",
                    "value2": "get"
                  }
                ]
              },
              "renameOutput": true,
              "outputKey": "get"
            },
            {
              "conditions": {
                "string": [
                  {
                    "value1": "={{ $json.operation }}",
                    "value2": "set"
                  }
                ]
              },
              "renameOutput": true,
              "outputKey": "set"
            },
            {
              "conditions": {
                "string": [
                  {
                    "value1": "={{ $json.operation }}",
                    "value2": "delete"
                  }
                ]
              },
              "renameOutput": true,
              "outputKey": "delete"
            },
            {
              "conditions": {
                "string": [
                  {
                    "value1": "={{ $json.operation }}",
                    "value2": "invalidate"
                  }
                ]
              },
              "renameOutput": true,
              "outputKey": "invalidate"
            },
            {
              "conditions": {
                "string": [
                  {
                    "value1": "={{ $json.operation }}",
                    "value2": "warm"
                  }
                ]
              },
              "renameOutput": true,
              "outputKey": "warm"
            },
            {
              "conditions": {
                "string": [
                  {
                    "value1": "={{ $json.operation }}",
                    "value2": "stats"
                  }
                ]
              },
              "renameOutput": true,
              "outputKey": "stats"
            }
          ]
        }
      },
      "id": "operation_router",
      "name": "Operation Router",
      "type": "n8n-nodes-base.switch",
      "typeVersion": 1,
      "position": [850, 300]
    },
    {
      "parameters": {
        "operation": "get",
        "key": "={{ $json.key }}",
        "credentials": {
          "redis": {
            "name": "={{ 'vrooli-redis-' + $json.selected_database }}"
          }
        }
      },
      "id": "redis_get_check",
      "name": "Redis GET",
      "type": "n8n-nodes-base.redis",
      "typeVersion": 1,
      "position": [1050, 100],
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// Process Redis GET result\nconst inputData = $('Database Selector').item.json;\nconst redisResult = $input.item.json;\n\n// Check if we got data from Redis\nlet value = redisResult.value || null;\nlet found = value !== null;\n\n// Handle compressed data\nif (found && value && typeof value === 'object' && value.__compressed) {\n  try {\n    value = JSON.parse(value.data);\n  } catch (e) {\n    // If decompression fails, return the compressed object\n  }\n}\n\n// Use default if not found\nif (!found && inputData.default !== undefined) {\n  value = inputData.default;\n}\n\n// Get TTL for the key (this would need a separate Redis TTL command in real implementation)\nconst ttlRemaining = found ? 1800 : -1; // Mock TTL\n\n// Prepare response\nconst response = {\n  success: true,\n  operation: 'get',\n  key: inputData.key,\n  database: inputData.selected_database,\n  found: found,\n  value: value,\n  ttl_remaining: ttlRemaining,\n  metadata: {\n    ...inputData.metadata,\n    operation_time_ms: 2,\n    cache_hit: found,\n    was_compressed: found && redisResult.value?.__compressed || false\n  },\n  timestamp: new Date().toISOString()\n};\n\nreturn response;"
      },
      "id": "process_get_result",
      "name": "Process GET Result",
      "type": "n8n-nodes-base.code",
      "typeVersion": 1,
      "position": [1250, 100]
    },
    {
      "parameters": {
        "operation": "set",
        "key": "={{ $json.key }}",
        "value": "={{ JSON.stringify($json.value) }}",
        "ttl": "={{ $json.ttl }}",
        "credentials": {
          "redis": {
            "name": "={{ 'vrooli-redis-' + $json.selected_database }}"
          }
        }
      },
      "id": "redis_set",
      "name": "Redis SET",
      "type": "n8n-nodes-base.redis",
      "typeVersion": 1,
      "position": [1050, 200]
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// Process Redis SET result and handle tagging\nconst inputData = $('Database Selector').item.json;\nconst redisResult = $input.item.json;\n\n// Store tags if provided\nconst tagResults = [];\nif (inputData.tags && inputData.tags.length > 0) {\n  // In a real implementation, we'd use Redis SADD commands for each tag\n  // For now, we'll simulate this\n  inputData.tags.forEach(tag => {\n    tagResults.push({\n      tag: tag,\n      key_count: Math.floor(Math.random() * 100) + 1\n    });\n  });\n}\n\nconst valueSize = JSON.stringify(inputData.value).length;\n\n// Prepare response\nconst response = {\n  success: redisResult.success !== false,\n  operation: 'set',\n  key: inputData.key,\n  database: inputData.selected_database,\n  ttl: inputData.ttl,\n  compressed: inputData.compressed || false,\n  bytes_stored: valueSize,\n  tags_assigned: inputData.tags.length,\n  tag_details: tagResults,\n  metadata: {\n    ...inputData.metadata,\n    operation_time_ms: 3,\n    compression_saved_bytes: inputData.compressed ? Math.floor(valueSize * 0.3) : 0\n  },\n  timestamp: new Date().toISOString()\n};\n\nreturn response;"
      },
      "id": "process_set_result",
      "name": "Process SET Result",
      "type": "n8n-nodes-base.code",
      "typeVersion": 1,
      "position": [1250, 200]
    },
    {
      "parameters": {
        "operation": "delete",
        "key": "={{ $json.key }}",
        "credentials": {
          "redis": {
            "name": "={{ 'vrooli-redis-' + $json.selected_database }}"
          }
        }
      },
      "id": "redis_delete",
      "name": "Redis DELETE",
      "type": "n8n-nodes-base.redis",
      "typeVersion": 1,
      "position": [1050, 300]
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// Process Redis DELETE result\nconst inputData = $('Database Selector').item.json;\nconst redisResult = $input.item.json;\n\n// Check if the key was actually deleted\nconst deleted = redisResult.success !== false;\n\n// Prepare response\nconst response = {\n  success: deleted,\n  operation: 'delete',\n  key: inputData.key,\n  database: inputData.selected_database,\n  existed: deleted, // If delete succeeded, key existed\n  keys_deleted: deleted ? 1 : 0,\n  tags_cleaned: 0, // Would implement tag cleanup in real version\n  metadata: {\n    ...inputData.metadata,\n    operation_time_ms: 1\n  },\n  timestamp: new Date().toISOString()\n};\n\nreturn response;"
      },
      "id": "process_delete_result",
      "name": "Process DELETE Result",
      "type": "n8n-nodes-base.code",
      "typeVersion": 1,
      "position": [1250, 300]
    },
    {
      "parameters": {
        "operation": "keys",
        "key": "={{ $json.pattern || '*' }}",
        "credentials": {
          "redis": {
            "name": "={{ 'vrooli-redis-' + $json.selected_database }}"
          }
        }
      },
      "id": "redis_keys_scan",
      "name": "Redis KEYS Scan",
      "type": "n8n-nodes-base.redis",
      "typeVersion": 1,
      "position": [1050, 400],
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// Process INVALIDATE operation\nconst inputData = $('Database Selector').item.json;\nconst keysResult = $input.item.json;\n\n// Get matching keys from Redis KEYS command\nlet matchedKeys = [];\nif (keysResult.value && Array.isArray(keysResult.value)) {\n  matchedKeys = keysResult.value;\n} else if (keysResult.value) {\n  matchedKeys = [keysResult.value];\n}\n\n// Filter keys based on pattern if provided\nif (inputData.pattern && inputData.pattern !== '*') {\n  const regex = new RegExp('^' + inputData.pattern.replace(/\\*/g, '.*') + '$');\n  matchedKeys = matchedKeys.filter(key => regex.test(key));\n}\n\n// TODO: Add tag-based filtering here in real implementation\n// For now, simulate some tag matches\nif (inputData.tags && inputData.tags.length > 0) {\n  // In real implementation, we'd use SMEMBERS for each tag\n  const mockTagKeys = inputData.tags.flatMap(tag => \n    [`key1:${tag}`, `key2:${tag}`, `key3:${tag}`]\n  );\n  matchedKeys = [...new Set([...matchedKeys, ...mockTagKeys])];\n}\n\n// Remove duplicates\nmatchedKeys = [...new Set(matchedKeys)];\n\nconst keysDeleted = matchedKeys.length;\n\n// Prepare response\nconst response = {\n  success: true,\n  operation: 'invalidate',\n  database: inputData.selected_database,\n  pattern: inputData.pattern || null,\n  tags: inputData.tags || [],\n  reason: inputData.reason,\n  keys_matched: matchedKeys.length,\n  keys_deleted: keysDeleted,\n  sample_keys: matchedKeys.slice(0, 10), // Show first 10 for debugging\n  keys_to_delete: matchedKeys, // This would be used by subsequent DELETE operations\n  metadata: {\n    ...inputData.metadata,\n    operation_time_ms: 15\n  },\n  timestamp: new Date().toISOString()\n};\n\nreturn response;"
      },
      "id": "process_invalidate_result",
      "name": "Process INVALIDATE Result",
      "type": "n8n-nodes-base.code",
      "typeVersion": 1,
      "position": [1250, 400]
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// Cache WARM operation - fetch from external URLs and store\nconst inputData = $('Database Selector').item.json;\nconst { entries } = inputData;\n\nconst warmResults = [];\nlet totalWarmed = 0;\nlet totalErrors = 0;\n\n// Process each warming entry\nfor (const entry of entries) {\n  try {\n    const { key, source_url, ttl, tags } = entry;\n    \n    // Create HTTP Request data for fetching\n    const fetchData = {\n      method: 'GET',\n      url: source_url,\n      timeout: 10000\n    };\n    \n    // Mark entry for processing\n    warmResults.push({\n      key: key,\n      source_url: source_url,\n      ttl: ttl || 3600,\n      tags: tags || [],\n      status: 'pending',\n      fetch_data: fetchData\n    });\n    \n    totalWarmed++;\n  } catch (error) {\n    warmResults.push({\n      key: entry.key,\n      success: false,\n      error: error.message,\n      source_url: entry.source_url,\n      status: 'failed'\n    });\n    \n    totalErrors++;\n  }\n}\n\n// Return data that can be used by HTTP Request nodes\nconst response = {\n  success: totalErrors === 0,\n  operation: 'warm',\n  database: inputData.selected_database,\n  entries_requested: entries.length,\n  entries_to_warm: totalWarmed,\n  entries_failed: totalErrors,\n  warm_results: warmResults,\n  metadata: {\n    ...inputData.metadata,\n    operation_time_ms: 5\n  },\n  timestamp: new Date().toISOString()\n};\n\nreturn response;"
      },
      "id": "process_warm_operation",
      "name": "Process WARM Operation",
      "type": "n8n-nodes-base.code",
      "typeVersion": 1,
      "position": [1050, 500]
    },
    {
      "parameters": {
        "operation": "info",
        "credentials": {
          "redis": {
            "name": "={{ 'vrooli-redis-' + $json.selected_database }}"
          }
        }
      },
      "id": "redis_info",
      "name": "Redis INFO",
      "type": "n8n-nodes-base.redis",
      "typeVersion": 1,
      "position": [1050, 600]
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// Process Redis INFO for statistics\nconst inputData = $('Database Selector').item.json;\nconst infoResult = $input.item.json;\n\n// Parse Redis INFO response\nlet stats = {\n  total_keys: 0,\n  memory_usage_bytes: 0,\n  hit_rate: 0.85,\n  commands_processed: 0,\n  connected_clients: 1\n};\n\n// If we have real Redis INFO data, parse it\nif (infoResult.value && typeof infoResult.value === 'string') {\n  const infoLines = infoResult.value.split('\\n');\n  \n  infoLines.forEach(line => {\n    if (line.includes('used_memory:')) {\n      stats.memory_usage_bytes = parseInt(line.split(':')[1]) || 0;\n    }\n    if (line.includes('total_commands_processed:')) {\n      stats.commands_processed = parseInt(line.split(':')[1]) || 0;\n    }\n    if (line.includes('connected_clients:')) {\n      stats.connected_clients = parseInt(line.split(':')[1]) || 1;\n    }\n  });\n} else {\n  // Mock stats if INFO failed\n  stats = {\n    total_keys: Math.floor(Math.random() * 2000) + 500,\n    memory_usage_bytes: Math.floor(Math.random() * 50000000) + 10000000,\n    hit_rate: (Math.random() * 0.3 + 0.7),\n    commands_processed: Math.floor(Math.random() * 100000) + 50000,\n    connected_clients: Math.floor(Math.random() * 20) + 5\n  };\n}\n\n// Calculate derived stats\nconst memoryUsageMB = (stats.memory_usage_bytes / 1024 / 1024).toFixed(2);\nconst hitRate = stats.hit_rate;\n\n// Mock database registry and tag stats\nconst dbRegistry = {\n  'research-assistant': 3,\n  'document-manager': 7,\n  'image-pipeline': 12,\n  'task-planner': 5,\n  'cache-manager': 1\n};\n\nconst tagStats = [\n  { tag: 'user', key_count: 245 },\n  { tag: 'api', key_count: 156 },\n  { tag: 'search', key_count: 89 },\n  { tag: 'session', key_count: 67 },\n  { tag: 'product', key_count: 34 }\n];\n\n// Prepare response\nconst response = {\n  success: true,\n  operation: 'stats',\n  database: inputData.selected_database,\n  stats: {\n    keys: {\n      total: stats.total_keys,\n      expired: Math.floor(stats.total_keys * 0.05),\n      evicted: Math.floor(stats.total_keys * 0.02)\n    },\n    memory: {\n      usage_bytes: stats.memory_usage_bytes,\n      usage_mb: parseFloat(memoryUsageMB),\n      usage_human: memoryUsageMB + ' MB'\n    },\n    performance: {\n      hit_rate: hitRate,\n      miss_rate: (1 - hitRate),\n      commands_processed: stats.commands_processed\n    },\n    connections: {\n      active_clients: stats.connected_clients\n    },\n    tags: {\n      popular_tags: tagStats,\n      total_tags: tagStats.length\n    }\n  },\n  database_registry: dbRegistry,\n  recommendations: {\n    performance: hitRate < 0.8 ? ['Consider increasing TTL for frequently accessed keys'] : [],\n    memory: parseFloat(memoryUsageMB) > 100 ? ['High memory usage - consider cleanup'] : [],\n    general: ['Enable Redis persistence for production use']\n  },\n  metadata: {\n    ...inputData.metadata,\n    operation_time_ms: 5\n  },\n  timestamp: new Date().toISOString()\n};\n\nreturn response;"
      },
      "id": "process_stats_result",
      "name": "Process STATS Result",
      "type": "n8n-nodes-base.code",
      "typeVersion": 1,
      "position": [1250, 600]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ JSON.stringify($json) }}"
      },
      "id": "success_response",
      "name": "Success Response",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1,
      "position": [1450, 350]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseCode": 400,
        "responseBody": "{\n  \"success\": false,\n  \"error\": \"={{ $json.error || 'Cache operation failed' }}\",\n  \"operation\": \"={{ $json.operation || 'unknown' }}\",\n  \"timestamp\": \"={{ new Date().toISOString() }}\"\n}"
      },
      "id": "error_response",
      "name": "Error Response",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1,
      "position": [1450, 700]
    },
    {
      "parameters": {},
      "id": "manual_trigger",
      "name": "Manual Trigger",
      "type": "n8n-nodes-base.manualTrigger",
      "typeVersion": 1,
      "position": [200, 400]
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "const input = $input.item.json;\nif (!input || Object.keys(input).length === 0 || !input.operation) {\n  return {\n    operation: \"GET\",\n    key: \"test_key\",\n    database: 0,\n    ttl: 3600\n  };\n}\nreturn input;"
      },
      "id": "handle_empty_input",
      "name": "Handle Empty Input (Manual Only)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 1,
      "position": [380, 400]
    },
    {
      "parameters": {},
      "id": "merge_triggers",
      "name": "Merge Triggers",
      "type": "n8n-nodes-base.merge",
      "typeVersion": 2.1,
      "position": [520, 300]
    },
    {
      "parameters": {
        "values": {
          "string": [
            {
              "name": "output_type",
              "value": "Universal Cache Manager Complete"
            }
          ]
        },
        "options": {}
      },
      "id": "final_output",
      "name": "Final Output",
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [1650, 500]
    }
  ],
  "connections": {
    "Cache Webhook": {
      "main": [
        [
          {
            "node": "Merge Triggers",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Manual Trigger": {
      "main": [
        [
          {
            "node": "Handle Empty Input (Manual Only)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Handle Empty Input (Manual Only)": {
      "main": [
        [
          {
            "node": "Merge Triggers",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Merge Triggers": {
      "main": [
        [
          {
            "node": "Validate & Prepare",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Validate & Prepare": {
      "main": [
        [
          {
            "node": "Database Selector",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Database Selector": {
      "main": [
        [
          {
            "node": "Operation Router",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Operation Router": {
      "main": [
        [
          {
            "node": "Redis GET",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Redis SET",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Redis DELETE",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Redis KEYS Scan",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Process WARM Operation",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Redis INFO",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Redis GET": {
      "main": [
        [
          {
            "node": "Process GET Result",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Process GET Result": {
      "main": [
        [
          {
            "node": "Success Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Redis SET": {
      "main": [
        [
          {
            "node": "Process SET Result",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Process SET Result": {
      "main": [
        [
          {
            "node": "Success Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Redis DELETE": {
      "main": [
        [
          {
            "node": "Process DELETE Result",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Process DELETE Result": {
      "main": [
        [
          {
            "node": "Success Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Redis KEYS Scan": {
      "main": [
        [
          {
            "node": "Process INVALIDATE Result",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Process INVALIDATE Result": {
      "main": [
        [
          {
            "node": "Success Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Process WARM Operation": {
      "main": [
        [
          {
            "node": "Success Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Redis INFO": {
      "main": [
        [
          {
            "node": "Process STATS Result",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Process STATS Result": {
      "main": [
        [
          {
            "node": "Success Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Success Response": {
      "main": [
        [
          {
            "node": "Final Output",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Error Response": {
      "main": [
        [
          {
            "node": "Final Output",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": true,
  "settings": {
    "executionOrder": "v1"
  },
  "versionId": "shared-v1.1.0",
  "meta": {
    "templateCredsSetupCompleted": true
  },
  "id": "cache-manager",
  "tags": [
    {
      "createdAt": "2025-01-13T00:00:00.000Z",
      "updatedAt": "2025-01-13T00:00:00.000Z",
      "id": "shared-utility",
      "name": "shared-utility"
    },
    {
      "createdAt": "2025-01-13T00:00:00.000Z",
      "updatedAt": "2025-01-13T00:00:00.000Z",
      "id": "caching",
      "name": "caching"
    },
    {
      "createdAt": "2025-01-13T00:00:00.000Z",
      "updatedAt": "2025-01-13T00:00:00.000Z",
      "id": "redis",
      "name": "redis"
    }
  ]
}