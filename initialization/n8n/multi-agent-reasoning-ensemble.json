{
  "name": "Multi-Agent Reasoning Ensemble",
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "ensemble-reason",
        "responseMode": "responseNode",
        "options": {}
      },
      "id": "webhook_trigger",
      "name": "Webhook Trigger",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 1.1,
      "position": [
        250,
        300
      ]
    },
    {
      "parameters": {},
      "id": "manual_trigger",
      "name": "Manual Trigger",
      "type": "n8n-nodes-base.manualTrigger",
      "typeVersion": 1,
      "position": [
        250,
        450
      ]
    },
    {
      "parameters": {},
      "id": "merge_triggers",
      "name": "Merge Triggers",
      "type": "n8n-nodes-base.merge",
      "typeVersion": 2.1,
      "position": [
        400,
        375
      ]
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// Check if input is empty and provide defaults for manual testing\nconst input = $input.item.json;\n\n// If input is empty (manual trigger with no data), provide default test data\nif (!input || Object.keys(input).length === 0 || !input.task) {\n  return {\n    task: \"What are the key considerations when choosing between REST and GraphQL for a new API?\",\n    config: {\n      agent_count: 3,\n      reasoning_mode: \"thorough\",\n      consensus_threshold: 0.7\n    },\n    context: {\n      domain: \"software-architecture\",\n      background: \"Building a new SaaS platform that needs to serve both web and mobile clients\",\n      stakeholders: [\"Frontend Team\", \"Mobile Team\", \"DevOps\"],\n      constraints: [\"Must support real-time updates\", \"Need to minimize bandwidth for mobile\"]\n    }\n  };\n}\n\n// Otherwise, pass through the input as-is\nreturn input;"
      },
      "id": "handle_empty_input",
      "name": "Handle Empty Input (Manual Only)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 1,
      "position": [
        350,
        450
      ]
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// Validate and prepare input for multi-agent reasoning\nconst input = $input.item.json;\n\n// Required field validation\nif (!input.task) {\n  throw new Error('Missing required field: task');\n}\n\n// Extract and validate inputs\nconst task = input.task.trim();\nif (task.length === 0) {\n  throw new Error('Task field cannot be empty');\n}\n\nif (task.length > 5000) {\n  throw new Error('Task exceeds maximum length of 5000 characters');\n}\n\n// Configuration with defaults\nconst config = input.config || {};\nconst agentCount = Math.min(Math.max(config.agent_count || 5, 3), 8);\nconst reasoningMode = config.reasoning_mode || 'thorough';\nconst consensusThreshold = Math.min(Math.max(config.consensus_threshold || 0.7, 0.5), 1.0);\nconst maxIterations = Math.min(Math.max(config.max_iterations || 2, 1), 5);\nconst timeLimit = Math.min(config.time_limit || 300, 600);\n\n// Context extraction\nconst context = input.context || {};\nconst domain = context.domain || 'general';\nconst background = context.background || '';\nconst stakeholders = context.stakeholders || [];\nconst constraints = context.constraints || [];\n\n// Advanced options\nconst advanced = input.advanced || {};\nconst agentSpecializations = advanced.agent_specializations || [\n  'analytical', 'creative', 'critical', 'practical', 'strategic'\n];\nconst modelVariety = advanced.model_variety || false;\nconst outputFormat = advanced.output_format || 'comprehensive';\nconst includeDissent = advanced.include_dissent !== false;\n\n// Build context string\nlet contextString = '';\nif (background) contextString += `Background: ${background}\\n`;\nif (stakeholders.length > 0) contextString += `Stakeholders: ${stakeholders.join(', ')}\\n`;\nif (constraints.length > 0) contextString += `Constraints: ${constraints.join(', ')}\\n`;\n\n// Prepare agent prompts with different reasoning strategies\nconst agents = [];\nfor (let i = 0; i < agentCount; i++) {\n  const specialization = agentSpecializations[i % agentSpecializations.length];\n  let promptStrategy = '';\n  \n  switch (specialization) {\n    case 'analytical':\n      promptStrategy = 'Approach this analytically. Break down the problem step-by-step, examine data and evidence, and provide logical reasoning for each conclusion.';\n      break;\n    case 'creative':\n      promptStrategy = 'Think creatively and explore alternative approaches. Consider innovative solutions, unconventional perspectives, and out-of-the-box thinking.';\n      break;\n    case 'critical':\n      promptStrategy = 'Be critical and skeptical. Challenge assumptions, identify potential flaws or risks, and consider what could go wrong.';\n      break;\n    case 'practical':\n      promptStrategy = 'Focus on practical implementation. Consider feasibility, resource requirements, timeline, and real-world constraints.';\n      break;\n    case 'strategic':\n      promptStrategy = 'Think strategically about long-term implications, stakeholder impact, competitive advantages, and organizational alignment.';\n      break;\n    default:\n      promptStrategy = 'Provide thoughtful analysis considering multiple perspectives and potential outcomes.';\n  }\n  \n  const fullPrompt = `You are an expert ${specialization} reasoner. ${promptStrategy}\n\n${contextString ? `Context:\\n${contextString}\\n` : ''}Task: ${task}\n\nProvide your analysis in the following JSON format:\n{\n  \"recommendation\": \"Your primary recommendation or conclusion\",\n  \"confidence\": 0.8,\n  \"reasoning_chain\": \"Step-by-step explanation of your reasoning\",\n  \"key_points\": [\"Important insight 1\", \"Important insight 2\", \"Important insight 3\"],\n  \"pros\": [\"Advantage 1\", \"Advantage 2\"],\n  \"cons\": [\"Risk 1\", \"Risk 2\"],\n  \"implementation_considerations\": [\"Consideration 1\", \"Consideration 2\"]\n}`;\n  \n  agents.push({\n    id: `agent_${i + 1}`,\n    specialization: specialization,\n    prompt: fullPrompt,\n    model: modelVariety && i % 2 === 1 ? 'llama3.1' : 'mistral' // Alternate models if variety enabled\n  });\n}\n\n// Prepare metadata\nconst metadata = {\n  task: task,\n  agent_count: agentCount,\n  reasoning_mode: reasoningMode,\n  consensus_threshold: consensusThreshold,\n  max_iterations: maxIterations,\n  time_limit: timeLimit,\n  domain: domain,\n  output_format: outputFormat,\n  include_dissent: includeDissent,\n  processing_start: new Date().toISOString(),\n  agents: agents\n};\n\nreturn {\n  agents: agents,\n  metadata: metadata\n};"
      },
      "id": "validate_input",
      "name": "Validate Input",
      "type": "n8n-nodes-base.code",
      "typeVersion": 1,
      "position": [
        550,
        375
      ]
    },
    {
      "parameters": {
        "mode": "runOnceForAllItems",
        "jsCode": "// Split agents into parallel execution groups\nconst inputData = $input.all();\nconst data = inputData[0].json;\nconst agents = data.agents;\nconst metadata = data.metadata;\n\n// Create execution items for parallel processing\nconst executionItems = agents.map(agent => ({\n  agent_data: agent,\n  metadata: metadata\n}));\n\nreturn executionItems;"
      },
      "id": "split_agents",
      "name": "Split Agents",
      "type": "n8n-nodes-base.code",
      "typeVersion": 1,
      "position": [
        650,
        300
      ]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "=${service.ollama.url}/api/generate",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "bodyContentType": "json",
        "jsonBody": "={\n  \"model\": \"{{ $json.agent_data.model }}\",\n  \"prompt\": \"{{ $json.agent_data.prompt }}\",\n  \"stream\": false,\n  \"options\": {\n    \"temperature\": 0.7,\n    \"top_p\": 0.9\n  }\n}",
        "options": {
          "timeout": 120000
        }
      },
      "id": "execute_agent",
      "name": "Execute Agent",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        850,
        300
      ]
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// Process individual agent response\nconst agentResponse = $input.item.json;\nconst agentData = $('Split Agents').item.json.agent_data;\nconst metadata = $('Split Agents').item.json.metadata;\n\nlet parsedResponse;\ntry {\n  // Extract response text\n  const responseText = agentResponse.response || agentResponse.text || '';\n  \n  // Try to parse JSON from the response\n  const jsonMatch = responseText.match(/\\{[\\s\\S]*\\}/);\n  if (jsonMatch) {\n    parsedResponse = JSON.parse(jsonMatch[0]);\n  } else {\n    // Fallback structure if JSON parsing fails\n    parsedResponse = {\n      recommendation: responseText.substring(0, 500),\n      confidence: 0.5,\n      reasoning_chain: responseText,\n      key_points: [\"Response parsing incomplete\"],\n      pros: [],\n      cons: [],\n      implementation_considerations: []\n    };\n  }\n} catch (error) {\n  // Error fallback\n  parsedResponse = {\n    recommendation: \"Agent processing failed\",\n    confidence: 0.1,\n    reasoning_chain: `Error: ${error.message}`,\n    key_points: [\"Agent execution error\"],\n    pros: [],\n    cons: [],\n    implementation_considerations: []\n  };\n}\n\n// Validate confidence score\nif (typeof parsedResponse.confidence !== 'number' || parsedResponse.confidence < 0 || parsedResponse.confidence > 1) {\n  parsedResponse.confidence = 0.5;\n}\n\n// Ensure arrays exist\nparsedResponse.key_points = parsedResponse.key_points || [];\nparsedResponse.pros = parsedResponse.pros || [];\nparsedResponse.cons = parsedResponse.cons || [];\nparsedResponse.implementation_considerations = parsedResponse.implementation_considerations || [];\n\nreturn {\n  agent_id: agentData.id,\n  specialization: agentData.specialization,\n  response: parsedResponse,\n  processing_time_ms: Date.now() - new Date(metadata.processing_start).getTime(),\n  success: true\n};"
      },
      "id": "process_agent_response",
      "name": "Process Agent Response",
      "type": "n8n-nodes-base.code",
      "typeVersion": 1,
      "position": [
        1050,
        300
      ]
    },
    {
      "parameters": {
        "mode": "aggregate",
        "aggregate": "aggregateAllItemData",
        "destinationFieldName": "agent_responses",
        "include": "allFields",
        "options": {}
      },
      "id": "aggregate_responses",
      "name": "Aggregate Responses",
      "type": "n8n-nodes-base.aggregate",
      "typeVersion": 1,
      "position": [
        1250,
        300
      ]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "=${service.ollama.url}/api/generate",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "bodyContentType": "json",
        "jsonBody": "={\n  \"model\": \"mistral\",\n  \"prompt\": \"{{ $json.consensus_prompt }}\",\n  \"stream\": false,\n  \"options\": {\n    \"temperature\": 0.3,\n    \"top_p\": 0.8\n  }\n}",
        "options": {
          "timeout": 60000
        }
      },
      "id": "build_consensus",
      "name": "Build Consensus",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        1650,
        300
      ]
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// Analyze agent responses and build consensus prompt\nconst data = $input.item.json;\nconst agentResponses = data.agent_responses;\nconst metadata = data.agent_responses[0]?.processing_time_ms ? data.agent_responses[0] : { metadata: data.agent_responses[0] };\n\n// Analyze agreement patterns\nconst recommendations = agentResponses.map(r => r.response.recommendation);\nconst confidences = agentResponses.map(r => r.response.confidence);\nconst allKeyPoints = agentResponses.flatMap(r => r.response.key_points);\nconst allPros = agentResponses.flatMap(r => r.response.pros);\nconst allCons = agentResponses.flatMap(r => r.response.cons);\n\n// Calculate basic agreement metrics\nconst avgConfidence = confidences.reduce((a, b) => a + b, 0) / confidences.length;\nconst successfulAgents = agentResponses.filter(r => r.success).length;\n\n// Build consensus prompt\nconst consensusPrompt = `You are a consensus-building expert. Multiple reasoning agents have analyzed the same task and provided their recommendations. Your job is to synthesize their insights into a coherent final recommendation.\n\nAgent Responses:\n${agentResponses.map((agent, i) => `\nAgent ${i + 1} (${agent.specialization}):\n- Recommendation: ${agent.response.recommendation}\n- Confidence: ${agent.response.confidence}\n- Key Points: ${agent.response.key_points.join(', ')}\n- Pros: ${agent.response.pros.join(', ')}\n- Cons: ${agent.response.cons.join(', ')}\n- Reasoning: ${agent.response.reasoning_chain.substring(0, 500)}`).join('')}\n\nProvide a synthesized analysis in the following JSON format:\n{\n  \"final_recommendation\": \"Synthesized recommendation combining the best insights\",\n  \"consensus_reached\": true,\n  \"confidence_score\": 0.85,\n  \"reasoning_summary\": \"How you arrived at this consensus\",\n  \"key_insights\": [\"Most important insight 1\", \"Most important insight 2\", \"Most important insight 3\"],\n  \"pros_and_cons\": {\n    \"pros\": [\"Benefit 1\", \"Benefit 2\", \"Benefit 3\"],\n    \"cons\": [\"Risk 1\", \"Risk 2\", \"Risk 3\"]\n  },\n  \"risk_assessment\": {\n    \"high_risks\": [\"Critical risk 1\"],\n    \"medium_risks\": [\"Moderate risk 1\", \"Moderate risk 2\"],\n    \"low_risks\": [\"Minor risk 1\"],\n    \"mitigation_strategies\": [\"Strategy 1\", \"Strategy 2\"]\n  },\n  \"implementation_roadmap\": {\n    \"immediate_actions\": [\"Action 1\", \"Action 2\"],\n    \"short_term_goals\": [\"Goal 1\", \"Goal 2\"],\n    \"long_term_objectives\": [\"Objective 1\"],\n    \"success_metrics\": [\"Metric 1\", \"Metric 2\"]\n  },\n  \"agreement_analysis\": {\n    \"high_agreement\": [\"Point all agents agreed on\"],\n    \"moderate_agreement\": [\"Point most agents agreed on\"],\n    \"low_agreement\": [\"Controversial point\"]\n  }\n}`;\n\nreturn {\n  consensus_prompt: consensusPrompt,\n  agent_responses: agentResponses,\n  preliminary_metrics: {\n    successful_agents: successfulAgents,\n    avg_confidence: avgConfidence,\n    total_agents: agentResponses.length\n  }\n};"
      },
      "id": "prepare_consensus",
      "name": "Prepare Consensus",
      "type": "n8n-nodes-base.code",
      "typeVersion": 1,
      "position": [
        1450,
        300
      ]
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// Process consensus response and build final output\nconst consensusResponse = $input.item.json;\nconst previousData = $('Prepare Consensus').item.json;\nconst agentResponses = previousData.agent_responses;\nconst preliminaryMetrics = previousData.preliminary_metrics;\n\nlet consensus;\ntry {\n  // Extract and parse consensus response\n  const responseText = consensusResponse.response || consensusResponse.text || '';\n  const jsonMatch = responseText.match(/\\{[\\s\\S]*\\}/);\n  \n  if (jsonMatch) {\n    consensus = JSON.parse(jsonMatch[0]);\n  } else {\n    throw new Error('No valid JSON found in consensus response');\n  }\n} catch (error) {\n  // Fallback consensus if parsing fails\n  console.warn('Consensus parsing failed, using fallback:', error.message);\n  \n  const recommendations = agentResponses.map(r => r.response.recommendation);\n  const avgConfidence = preliminaryMetrics.avg_confidence;\n  \n  consensus = {\n    final_recommendation: recommendations[0] || 'Unable to reach consensus',\n    consensus_reached: false,\n    confidence_score: avgConfidence * 0.7, // Reduce confidence due to parsing failure\n    reasoning_summary: 'Consensus building encountered technical issues, using primary agent recommendation',\n    key_insights: agentResponses.flatMap(r => r.response.key_points).slice(0, 5),\n    pros_and_cons: {\n      pros: agentResponses.flatMap(r => r.response.pros).slice(0, 5),\n      cons: agentResponses.flatMap(r => r.response.cons).slice(0, 5)\n    },\n    risk_assessment: {\n      high_risks: [],\n      medium_risks: agentResponses.flatMap(r => r.response.cons).slice(0, 3),\n      low_risks: [],\n      mitigation_strategies: []\n    },\n    implementation_roadmap: {\n      immediate_actions: [],\n      short_term_goals: [],\n      long_term_objectives: [],\n      success_metrics: []\n    },\n    agreement_analysis: {\n      high_agreement: [],\n      moderate_agreement: [],\n      low_agreement: ['Consensus analysis incomplete']\n    }\n  };\n}\n\n// Calculate final metrics\nconst processingEndTime = new Date();\nconst processingStartTime = new Date(agentResponses[0]?.processing_time_ms ? Date.now() - Math.max(...agentResponses.map(r => r.processing_time_ms)) : Date.now() - 30000);\nconst totalProcessingTime = processingEndTime - processingStartTime;\n\n// Build comprehensive output\nconst finalOutput = {\n  meta: {\n    success: true,\n    consensus_reached: consensus.consensus_reached !== false,\n    confidence_score: Math.min(Math.max(consensus.confidence_score || 0.5, 0), 1),\n    processing_time_ms: totalProcessingTime,\n    agents_used: preliminaryMetrics.total_agents,\n    successful_agents: preliminaryMetrics.successful_agents,\n    iterations_completed: 1\n  },\n  \n  results: {\n    final_recommendation: consensus.final_recommendation || 'No recommendation available',\n    reasoning_summary: consensus.reasoning_summary || 'Summary not available',\n    key_insights: (consensus.key_insights || []).map((insight, i) => ({\n      insight: insight,\n      confidence: consensus.confidence_score || 0.5,\n      supporting_agents: Math.ceil(preliminaryMetrics.total_agents * 0.7) // Estimate\n    })),\n    pros_and_cons: consensus.pros_and_cons || { pros: [], cons: [] },\n    risk_assessment: consensus.risk_assessment || {\n      high_risks: [],\n      medium_risks: [],\n      low_risks: [],\n      mitigation_strategies: []\n    },\n    implementation_roadmap: consensus.implementation_roadmap || {\n      immediate_actions: [],\n      short_term_goals: [],\n      long_term_objectives: [],\n      success_metrics: []\n    }\n  },\n  \n  agent_breakdown: {\n    individual_responses: agentResponses.map(agent => ({\n      agent_id: agent.agent_id,\n      specialization: agent.specialization,\n      recommendation: agent.response.recommendation,\n      confidence: agent.response.confidence,\n      key_points: agent.response.key_points,\n      reasoning_chain: agent.response.reasoning_chain,\n      processing_time_ms: agent.processing_time_ms\n    })),\n    \n    agreement_matrix: consensus.agreement_analysis || {\n      high_agreement: [],\n      moderate_agreement: [],\n      low_agreement: []\n    },\n    \n    dissenting_opinions: agentResponses\n      .filter(agent => agent.response.confidence < 0.6)\n      .map(agent => ({\n        viewpoint: agent.response.recommendation,\n        supporting_agents: 1,\n        reasoning: agent.response.reasoning_chain.substring(0, 200),\n        concerns: agent.response.cons\n      }))\n  },\n  \n  quality_metrics: {\n    reasoning_depth_score: Math.min(consensus.confidence_score + 0.1, 1.0),\n    consistency_score: preliminaryMetrics.successful_agents / preliminaryMetrics.total_agents,\n    creativity_score: agentResponses.filter(r => r.specialization === 'creative').length > 0 ? 0.8 : 0.6,\n    practicality_score: agentResponses.filter(r => r.specialization === 'practical').length > 0 ? 0.8 : 0.6,\n    evidence_quality_score: consensus.confidence_score || 0.5\n  },\n  \n  follow_up_suggestions: {\n    additional_research_needed: consensus.implementation_roadmap?.success_metrics || [],\n    stakeholders_to_consult: [],\n    decisions_requiring_more_data: consensus.agreement_analysis?.low_agreement || [],\n    recommended_pilot_programs: consensus.implementation_roadmap?.immediate_actions || []\n  }\n};\n\nreturn finalOutput;"
      },
      "id": "build_final_output",
      "name": "Build Final Output",
      "type": "n8n-nodes-base.code",
      "typeVersion": 1,
      "position": [
        1850,
        300
      ]
    },
    {
      "parameters": {
        "conditions": {
          "boolean": [
            {
              "value1": "={{ $json.meta.success }}",
              "value2": true
            }
          ]
        }
      },
      "id": "check_success",
      "name": "Success Check",
      "type": "n8n-nodes-base.if",
      "typeVersion": 1,
      "position": [
        2050,
        300
      ]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ JSON.stringify($json) }}"
      },
      "id": "success_response",
      "name": "Success Response",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1,
      "position": [
        2250,
        200
      ]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseCode": 500,
        "responseBody": "{\n  \"success\": false,\n  \"error\": \"={{ $json.error || 'Multi-agent reasoning failed' }}\",\n  \"meta\": {\n    \"consensus_reached\": false,\n    \"confidence_score\": 0.0,\n    \"processing_time_ms\": \"={{ Date.now() }}\",\n    \"agents_used\": 0\n  },\n  \"timestamp\": \"={{ new Date().toISOString() }}\"\n}"
      },
      "id": "error_response",
      "name": "Error Response",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1,
      "position": [
        2250,
        400
      ]
    },
    {
      "parameters": {
        "values": {
          "string": [
            {
              "name": "output_type",
              "value": "Multi-Agent Reasoning Complete"
            }
          ]
        },
        "options": {}
      },
      "id": "final_output",
      "name": "Final Output",
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        2450,
        300
      ]
    }
  ],
  "connections": {
    "Webhook Trigger": {
      "main": [
        [
          {
            "node": "Merge Triggers",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Manual Trigger": {
      "main": [
        [
          {
            "node": "Handle Empty Input (Manual Only)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Handle Empty Input (Manual Only)": {
      "main": [
        [
          {
            "node": "Merge Triggers",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Merge Triggers": {
      "main": [
        [
          {
            "node": "Validate Input",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Validate Input": {
      "main": [
        [
          {
            "node": "Split Agents",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Split Agents": {
      "main": [
        [
          {
            "node": "Execute Agent",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Execute Agent": {
      "main": [
        [
          {
            "node": "Process Agent Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Process Agent Response": {
      "main": [
        [
          {
            "node": "Aggregate Responses",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Aggregate Responses": {
      "main": [
        [
          {
            "node": "Prepare Consensus",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Consensus": {
      "main": [
        [
          {
            "node": "Build Consensus",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build Consensus": {
      "main": [
        [
          {
            "node": "Build Final Output",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build Final Output": {
      "main": [
        [
          {
            "node": "Success Check",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Success Check": {
      "main": [
        [
          {
            "node": "Success Response",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Error Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Success Response": {
      "main": [
        [
          {
            "node": "Final Output",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Error Response": {
      "main": [
        [
          {
            "node": "Final Output",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": true,
  "settings": {
    "executionOrder": "v1",
    "executionTimeout": 120
  },
  "versionId": "multi-agent-v1.0.0",
  "meta": {
    "templateCredsSetupCompleted": true
  },
  "id": "multi-agent-reasoning-ensemble",
  "tags": [
    {
      "createdAt": "2025-01-14T00:00:00.000Z",
      "updatedAt": "2025-01-14T00:00:00.000Z",
      "id": "ai-reasoning",
      "name": "ai-reasoning"
    },
    {
      "createdAt": "2025-01-14T00:00:00.000Z",
      "updatedAt": "2025-01-14T00:00:00.000Z",
      "id": "multi-agent",
      "name": "multi-agent"
    },
    {
      "createdAt": "2025-01-14T00:00:00.000Z",
      "updatedAt": "2025-01-14T00:00:00.000Z",
      "id": "shared-utility",
      "name": "shared-utility"
    }
  ]
}
