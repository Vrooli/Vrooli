{
  "name": "N8N Workflow Executor",
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "n8n/execute",
        "responseMode": "responseNode",
        "options": {}
      },
      "id": "webhook_trigger",
      "name": "Webhook Trigger",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 1.1,
      "position": [200, 200]
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// Validate and prepare input for n8n workflow execution\nconst input = $input.item.json;\n\n// Required field validation\nif (!input.workflow_id) {\n  throw new Error('Missing required field: workflow_id');\n}\n\n// Extract and validate workflow ID\nconst workflowId = input.workflow_id.toString().trim();\nif (!workflowId) {\n  throw new Error('workflow_id cannot be empty');\n}\n\n// Configuration with defaults\nconst config = {\n  workflowId: workflowId,\n  n8nBaseUrl: input.n8n_base_url || '${service.n8n.url}',\n  executionTimeout: Math.min(Math.max(input.execution_timeout || 60000, 10000), 300000), // 10s to 5min\n  inputData: input.input_data || {},\n  captureScreenshots: input.capture_screenshots !== false, // default true\n  waitAfterClick: Math.min(Math.max(input.wait_after_click || 2000, 500), 10000), // 0.5s to 10s\n  pollInterval: Math.min(Math.max(input.poll_interval || 1000, 500), 5000), // 0.5s to 5s\n  maxPolls: Math.min(Math.max(input.max_polls || 60, 10), 300), // 10 to 300 polls\n  includeDetailedLogs: input.include_detailed_logs !== false, // default true\n  viewport: input.viewport || {\n    width: 1920,\n    height: 1080\n  }\n};\n\n// Build the workflow URL\nlet workflowUrl;\nif (workflowId.startsWith('http://') || workflowId.startsWith('https://')) {\n  // Full URL provided\n  workflowUrl = workflowId;\n} else {\n  // Workflow ID provided, build URL\n  workflowUrl = `${config.n8nBaseUrl}/workflow/${workflowId}`;\n}\n\n// Validate URL format\ntry {\n  new URL(workflowUrl);\n} catch (error) {\n  throw new Error(`Invalid workflow URL format: ${workflowUrl}`);\n}\n\n// Prepare metadata\nconst metadata = {\n  executionId: `n8n_exec_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\n  startTime: new Date().toISOString(),\n  workflowUrl: workflowUrl,\n  expectedDuration: config.executionTimeout\n};\n\nreturn {\n  config: config,\n  metadata: metadata\n};"
      },
      "id": "validate_input",
      "name": "Validate Input",
      "type": "n8n-nodes-base.code",
      "typeVersion": 1,
      "position": [400, 300]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "${service.n8n.url}/webhook/browser/console",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "bodyContentType": "json",
        "jsonBody": "={\n  \"url\": {{ JSON.stringify($json.metadata.workflowUrl) }},\n  \"wait_time\": 3000,\n  \"capture_screenshot\": {{ $json.config.captureScreenshots }},\n  \"include_network_logs\": true,\n  \"include_performance\": true,\n  \"timeout\": 30000,\n  \"viewport\": {{ JSON.stringify($json.config.viewport) }},\n  \"interactions\": [\n    {\n      \"type\": \"wait\",\n      \"selector\": \"[data-test-id='execute-workflow-button']\",\n      \"timeout\": 10000\n    },\n    {\n      \"type\": \"click\",\n      \"selector\": \"[data-test-id='execute-workflow-button']\"\n    },\n    {\n      \"type\": \"wait\",\n      \"duration\": {{ $json.config.waitAfterClick }}\n    }\n  ]\n}",
        "options": {
          "timeout": 45000
        }
      },
      "id": "initial_execution",
      "name": "Execute Workflow via Browser",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [600, 300]
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// Process initial execution results and prepare for monitoring\nconst browserResult = $input.item.json;\nconst inputData = $('Validate Input').item.json;\n\n// Check if browser automation succeeded\nif (!browserResult.success) {\n  throw new Error(`Browser automation failed: ${browserResult.error || 'Unknown error'}`);\n}\n\n// Analyze initial execution state\nconst initialAnalysis = {\n  executionTriggered: false,\n  errors: [],\n  warnings: [],\n  networkIssues: []\n};\n\n// Check console logs for execution indicators\nif (browserResult.consoleLogs) {\n  browserResult.consoleLogs.forEach(log => {\n    const text = log.text.toLowerCase();\n    \n    // Look for execution start indicators\n    if (text.includes('workflow execution') || \n        text.includes('starting execution') ||\n        text.includes('execution started')) {\n      initialAnalysis.executionTriggered = true;\n    }\n    \n    // Collect errors and warnings\n    if (log.type === 'error') {\n      initialAnalysis.errors.push({\n        message: log.text,\n        timestamp: log.timestamp\n      });\n    } else if (log.type === 'warn') {\n      initialAnalysis.warnings.push({\n        message: log.text,\n        timestamp: log.timestamp\n      });\n    }\n  });\n}\n\n// Check for network issues\nif (browserResult.networkErrors && browserResult.networkErrors.length > 0) {\n  initialAnalysis.networkIssues = browserResult.networkErrors.map(err => ({\n    url: err.url,\n    error: err.failure,\n    timestamp: err.timestamp\n  }));\n}\n\n// Check page errors\nif (browserResult.pageErrors && browserResult.pageErrors.length > 0) {\n  initialAnalysis.errors.push(...browserResult.pageErrors.map(err => ({\n    message: err.message,\n    stack: err.stack,\n    timestamp: err.timestamp,\n    type: 'javascript_error'\n  })));\n}\n\n// Determine if we should start monitoring\nconst shouldMonitor = initialAnalysis.errors.length === 0;\n\nreturn {\n  config: inputData.config,\n  metadata: {\n    ...inputData.metadata,\n    initialExecution: {\n      success: browserResult.success,\n      executionTriggered: initialAnalysis.executionTriggered,\n      timestamp: new Date().toISOString()\n    }\n  },\n  initialAnalysis: initialAnalysis,\n  shouldMonitor: shouldMonitor,\n  browserResult: browserResult,\n  pollCount: 0,\n  executionLogs: [],\n  executionComplete: false\n};"
      },
      "id": "process_initial_execution",
      "name": "Process Initial Execution",
      "type": "n8n-nodes-base.code",
      "typeVersion": 1,
      "position": [800, 300]
    },
    {
      "parameters": {
        "conditions": {
          "boolean": [
            {
              "value1": "={{ $json.shouldMonitor }}",
              "value2": true
            }
          ]
        }
      },
      "id": "check_monitoring_needed",
      "name": "Should Monitor Execution?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 1,
      "position": [1000, 300]
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// Check if we should continue monitoring the execution\nconst data = $input.item.json;\n\n// Stop monitoring if:\n// 1. Execution is complete\n// 2. Max polls reached\n// 3. Timeout exceeded\nconst shouldContinue = !data.executionComplete && \n                      data.pollCount < data.config.maxPolls;\n\nif (shouldContinue) {\n  data.pollCount += 1;\n  \n  console.log(`[N8N Executor] Monitoring poll ${data.pollCount}/${data.config.maxPolls}`);\n  \n  return data;\n} else {\n  data.monitoringComplete = true;\n  \n  if (data.pollCount >= data.config.maxPolls) {\n    console.log(`[N8N Executor] Monitoring stopped: Max polls (${data.config.maxPolls}) reached`);\n  } else {\n    console.log(`[N8N Executor] Monitoring stopped: Execution complete`);\n  }\n  \n  return data;\n}"
      },
      "id": "check_monitoring_condition",
      "name": "Check Monitoring Condition",
      "type": "n8n-nodes-base.code",
      "typeVersion": 1,
      "position": [1200, 200]
    },
    {
      "parameters": {
        "conditions": {
          "boolean": [
            {
              "value1": "={{ $json.monitoringComplete }}",
              "value2": false
            }
          ]
        }
      },
      "id": "continue_monitoring_check",
      "name": "Continue Monitoring?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 1,
      "position": [1400, 200]
    },
    {
      "parameters": {
        "amount": "={{ $json.config.pollInterval }}",
        "unit": "ms"
      },
      "id": "wait_poll_interval",
      "name": "Wait Poll Interval",
      "type": "n8n-nodes-base.wait",
      "typeVersion": 1.1,
      "position": [1600, 100]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "${service.n8n.url}/webhook/browser/console",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "bodyContentType": "json",
        "jsonBody": "={\n  \"url\": {{ JSON.stringify($json.metadata.workflowUrl) }},\n  \"wait_time\": 2000,\n  \"capture_screenshot\": false,\n  \"include_network_logs\": true,\n  \"include_performance\": false,\n  \"timeout\": 15000,\n  \"viewport\": {{ JSON.stringify($json.config.viewport) }}\n}",
        "options": {
          "timeout": 20000
        }
      },
      "id": "monitor_execution",
      "name": "Monitor Execution Progress",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [1800, 100]
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// Process monitoring results and update execution state\nconst monitorResult = $input.item.json;\nconst previousData = $('Wait Poll Interval').item.json;\n\n// Check if monitoring succeeded\nif (!monitorResult.success) {\n  console.warn(`[N8N Executor] Monitoring poll ${previousData.pollCount} failed: ${monitorResult.error || 'Unknown error'}`);\n  \n  // Continue with previous data but mark this poll as failed\n  previousData.executionLogs.push({\n    type: 'monitoring_error',\n    message: `Poll ${previousData.pollCount} failed: ${monitorResult.error || 'Unknown error'}`,\n    timestamp: new Date().toISOString()\n  });\n  \n  return previousData;\n}\n\n// Analyze new console logs for execution status\nconst newLogs = [];\nconst executionStatus = {\n  inProgress: false,\n  completed: false,\n  failed: false,\n  statusMessages: []\n};\n\nif (monitorResult.consoleLogs) {\n  monitorResult.consoleLogs.forEach(log => {\n    const text = log.text.toLowerCase();\n    \n    // Look for execution completion indicators\n    if (text.includes('workflow execution finished') ||\n        text.includes('execution completed') ||\n        text.includes('execution successful') ||\n        text.includes('finished executing')) {\n      executionStatus.completed = true;\n      executionStatus.statusMessages.push('Execution completed successfully');\n    }\n    \n    // Look for execution failure indicators\n    else if (text.includes('workflow execution failed') ||\n             text.includes('execution error') ||\n             text.includes('execution failed') ||\n             (log.type === 'error' && text.includes('execution'))) {\n      executionStatus.failed = true;\n      executionStatus.statusMessages.push(`Execution failed: ${log.text}`);\n    }\n    \n    // Look for execution progress indicators\n    else if (text.includes('executing node') ||\n             text.includes('running workflow') ||\n             text.includes('processing') ||\n             text.includes('workflow running')) {\n      executionStatus.inProgress = true;\n    }\n    \n    // Collect all relevant logs\n    if (text.includes('workflow') || \n        text.includes('execution') ||\n        text.includes('node') ||\n        log.type === 'error' ||\n        log.type === 'warn') {\n      newLogs.push({\n        type: log.type,\n        message: log.text,\n        timestamp: log.timestamp,\n        poll: previousData.pollCount\n      });\n    }\n  });\n}\n\n// Check for network errors that might indicate execution issues\nif (monitorResult.networkErrors && monitorResult.networkErrors.length > 0) {\n  monitorResult.networkErrors.forEach(err => {\n    if (err.url.includes('/rest/executions') || err.url.includes('/api/')) {\n      newLogs.push({\n        type: 'network_error',\n        message: `Network error: ${err.failure} - ${err.url}`,\n        timestamp: err.timestamp,\n        poll: previousData.pollCount\n      });\n    }\n  });\n}\n\n// Update execution state\nconst updatedData = {\n  ...previousData,\n  executionLogs: [...previousData.executionLogs, ...newLogs],\n  executionComplete: executionStatus.completed || executionStatus.failed,\n  executionStatus: executionStatus,\n  lastMonitorResult: {\n    success: monitorResult.success,\n    pollNumber: previousData.pollCount,\n    timestamp: new Date().toISOString(),\n    logsFound: newLogs.length,\n    healthScore: monitorResult.summary?.healthScore || null\n  }\n};\n\n// Log status updates\nif (executionStatus.completed) {\n  console.log(`[N8N Executor] Execution completed after ${previousData.pollCount} polls`);\n} else if (executionStatus.failed) {\n  console.log(`[N8N Executor] Execution failed after ${previousData.pollCount} polls`);\n} else if (executionStatus.inProgress) {\n  console.log(`[N8N Executor] Execution in progress (poll ${previousData.pollCount})`);\n} else {\n  console.log(`[N8N Executor] No execution status detected (poll ${previousData.pollCount})`);\n}\n\nreturn updatedData;"
      },
      "id": "process_monitoring_result",
      "name": "Process Monitoring Result",
      "type": "n8n-nodes-base.code",
      "typeVersion": 1,
      "position": [2000, 100]
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// Build final execution report\nconst executionData = $input.item.json;\n\n// Calculate execution statistics\nconst stats = {\n  totalPolls: executionData.pollCount,\n  executionDuration: null,\n  totalLogs: executionData.executionLogs.length,\n  logsByType: {},\n  errorCount: 0,\n  warningCount: 0,\n  networkErrorCount: 0\n};\n\n// Calculate execution duration if we have timestamps\nif (executionData.metadata.initialExecution?.timestamp && executionData.executionComplete) {\n  const startTime = new Date(executionData.metadata.initialExecution.timestamp);\n  const endTime = new Date();\n  stats.executionDuration = endTime - startTime;\n}\n\n// Analyze logs\nexecutionData.executionLogs.forEach(log => {\n  stats.logsByType[log.type] = (stats.logsByType[log.type] || 0) + 1;\n  \n  if (log.type === 'error') stats.errorCount++;\n  else if (log.type === 'warn') stats.warningCount++;\n  else if (log.type === 'network_error') stats.networkErrorCount++;\n});\n\n// Determine overall success\nconst success = executionData.executionComplete && \n                !executionData.executionStatus?.failed &&\n                stats.errorCount === 0;\n\n// Create insights\nconst insights = [];\n\nif (success) {\n  insights.push('Workflow executed successfully');\n} else if (executionData.executionStatus?.failed) {\n  insights.push('Workflow execution failed');\n} else if (!executionData.executionComplete) {\n  insights.push(`Execution monitoring timed out after ${stats.totalPolls} polls`);\n}\n\nif (stats.errorCount > 0) {\n  insights.push(`Found ${stats.errorCount} error(s) during execution`);\n}\n\nif (stats.warningCount > 0) {\n  insights.push(`Found ${stats.warningCount} warning(s) during execution`);\n}\n\nif (stats.networkErrorCount > 0) {\n  insights.push(`Detected ${stats.networkErrorCount} network error(s)`);\n}\n\nif (executionData.pollCount >= executionData.config.maxPolls) {\n  insights.push(`Monitoring reached maximum poll limit (${executionData.config.maxPolls})`);\n}\n\n// Build final response\nconst response = {\n  success: success,\n  executionId: executionData.metadata.executionId,\n  workflowId: executionData.config.workflowId,\n  workflowUrl: executionData.metadata.workflowUrl,\n  \n  // Summary\n  summary: {\n    executionComplete: executionData.executionComplete,\n    executionSuccessful: success,\n    insights: insights,\n    duration: stats.executionDuration,\n    monitoringPolls: stats.totalPolls,\n    completedAt: new Date().toISOString()\n  },\n  \n  // Statistics\n  stats: stats,\n  \n  // Execution details\n  execution: {\n    triggered: executionData.metadata.initialExecution?.executionTriggered || false,\n    status: executionData.executionStatus || {},\n    logs: executionData.executionLogs,\n    initialAnalysis: executionData.initialAnalysis\n  },\n  \n  // Browser automation results\n  browserResults: {\n    initial: {\n      success: executionData.browserResult.success,\n      screenshot: executionData.browserResult.screenshot || null,\n      healthScore: executionData.browserResult.summary?.healthScore || null,\n      consoleLogs: executionData.browserResult.consoleLogs || [],\n      pageErrors: executionData.browserResult.pageErrors || [],\n      networkErrors: executionData.browserResult.networkErrors || []\n    },\n    monitoring: {\n      pollsExecuted: stats.totalPolls,\n      lastPollResult: executionData.lastMonitorResult || null\n    }\n  },\n  \n  // Configuration used\n  config: executionData.config,\n  \n  // Error information if any\n  errors: executionData.initialAnalysis?.errors || []\n};\n\nreturn response;"
      },
      "id": "build_final_report",
      "name": "Build Final Report",
      "type": "n8n-nodes-base.code",
      "typeVersion": 1,
      "position": [1400, 400]
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// Handle case where monitoring is skipped due to initial errors\nconst data = $input.item.json;\n\n// Build error response\nconst response = {\n  success: false,\n  executionId: data.metadata.executionId,\n  workflowId: data.config.workflowId,\n  workflowUrl: data.metadata.workflowUrl,\n  \n  summary: {\n    executionComplete: false,\n    executionSuccessful: false,\n    insights: [\n      'Initial workflow execution failed',\n      `Found ${data.initialAnalysis.errors.length} error(s) during initial execution`,\n      'Monitoring was skipped due to execution errors'\n    ],\n    duration: null,\n    monitoringPolls: 0,\n    failedAt: new Date().toISOString()\n  },\n  \n  stats: {\n    totalPolls: 0,\n    executionDuration: null,\n    totalLogs: data.initialAnalysis.errors.length,\n    errorCount: data.initialAnalysis.errors.length,\n    warningCount: data.initialAnalysis.warnings.length,\n    networkErrorCount: data.initialAnalysis.networkIssues.length\n  },\n  \n  execution: {\n    triggered: data.metadata.initialExecution?.executionTriggered || false,\n    status: { failed: true },\n    logs: [],\n    initialAnalysis: data.initialAnalysis\n  },\n  \n  browserResults: {\n    initial: {\n      success: data.browserResult.success,\n      screenshot: data.browserResult.screenshot || null,\n      healthScore: data.browserResult.summary?.healthScore || null,\n      consoleLogs: data.browserResult.consoleLogs || [],\n      pageErrors: data.browserResult.pageErrors || [],\n      networkErrors: data.browserResult.networkErrors || []\n    },\n    monitoring: {\n      pollsExecuted: 0,\n      lastPollResult: null\n    }\n  },\n  \n  config: data.config,\n  errors: data.initialAnalysis.errors\n};\n\nreturn response;"
      },
      "id": "build_error_report",
      "name": "Build Error Report",
      "type": "n8n-nodes-base.code",
      "typeVersion": 1,
      "position": [1000, 500]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ JSON.stringify($json) }}"
      },
      "id": "success_response",
      "name": "Success Response",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1,
      "position": [1600, 400]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseCode": 500,
        "responseBody": "{\n  \"success\": false,\n  \"error\": \"={{ $json.error || 'N8N workflow execution monitoring failed' }}\",\n  \"executionId\": \"={{ $json.executionId || 'unknown' }}\",\n  \"workflowId\": \"={{ $json.workflowId || 'unknown' }}\",\n  \"timestamp\": \"={{ new Date().toISOString() }}\",\n  \"partial_data\": {\n    \"browserResult\": \"={{ $json.browserResult ? 'available' : 'unavailable' }}\",\n    \"monitoring\": \"={{ $json.shouldMonitor ? 'attempted' : 'skipped' }}\"\n  }\n}"
      },
      "id": "error_response",
      "name": "Error Response",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1,
      "position": [1600, 600]
    },
    {
      "parameters": {},
      "id": "manual_trigger",
      "name": "Manual Trigger",
      "type": "n8n-nodes-base.manualTrigger",
      "typeVersion": 1,
      "position": [200, 400]
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "const input = $input.item.json;\nif (!input || Object.keys(input).length === 0 || !input.workflow_id) {\n  return {\n    workflow_id: \"test-workflow\",\n    execution_timeout: 30000,\n    capture_screenshots: true,\n    include_detailed_logs: true,\n    poll_interval: 2000,\n    max_polls: 30\n  };\n}\nreturn input;"
      },
      "id": "handle_empty_input",
      "name": "Handle Empty Input (Manual Only)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 1,
      "position": [380, 400]
    },
    {
      "parameters": {},
      "id": "merge_triggers",
      "name": "Merge Triggers",
      "type": "n8n-nodes-base.merge",
      "typeVersion": 2.1,
      "position": [520, 300]
    },
    {
      "parameters": {
        "values": {
          "string": [
            {
              "name": "output_type",
              "value": "N8N Workflow Execution Complete"
            }
          ]
        },
        "options": {}
      },
      "id": "final_output",
      "name": "Final Output",
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [1800, 500]
    }
  ],
  "connections": {
    "Webhook Trigger": {
      "main": [
        [
          {
            "node": "Merge Triggers",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Manual Trigger": {
      "main": [
        [
          {
            "node": "Handle Empty Input (Manual Only)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Handle Empty Input (Manual Only)": {
      "main": [
        [
          {
            "node": "Merge Triggers",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Merge Triggers": {
      "main": [
        [
          {
            "node": "Validate Input",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Validate Input": {
      "main": [
        [
          {
            "node": "Execute Workflow via Browser",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Execute Workflow via Browser": {
      "main": [
        [
          {
            "node": "Process Initial Execution",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Process Initial Execution": {
      "main": [
        [
          {
            "node": "Should Monitor Execution?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Should Monitor Execution?": {
      "main": [
        [
          {
            "node": "Check Monitoring Condition",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Build Error Report",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Check Monitoring Condition": {
      "main": [
        [
          {
            "node": "Continue Monitoring?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Continue Monitoring?": {
      "main": [
        [
          {
            "node": "Wait Poll Interval",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Build Final Report",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Wait Poll Interval": {
      "main": [
        [
          {
            "node": "Monitor Execution Progress",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Monitor Execution Progress": {
      "main": [
        [
          {
            "node": "Process Monitoring Result",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Process Monitoring Result": {
      "main": [
        [
          {
            "node": "Check Monitoring Condition",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build Final Report": {
      "main": [
        [
          {
            "node": "Success Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build Error Report": {
      "main": [
        [
          {
            "node": "Error Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Success Response": {
      "main": [
        [
          {
            "node": "Final Output",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Error Response": {
      "main": [
        [
          {
            "node": "Final Output",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": true,
  "settings": {
    "executionOrder": "v1"
  },
  "versionId": "n8n-workflow-executor-v1.0.0",
  "meta": {
    "templateCredsSetupCompleted": true
  },
  "id": "n8n-workflow-executor",
  "tags": [
    {
      "createdAt": "2025-01-14T00:00:00.000Z",
      "updatedAt": "2025-01-14T00:00:00.000Z",
      "id": "shared-utility",
      "name": "shared-utility"
    },
    {
      "createdAt": "2025-01-14T00:00:00.000Z",
      "updatedAt": "2025-01-14T00:00:00.000Z",
      "id": "meta-automation",
      "name": "meta-automation"
    },
    {
      "createdAt": "2025-01-14T00:00:00.000Z",
      "updatedAt": "2025-01-14T00:00:00.000Z",
      "id": "workflow-orchestration",
      "name": "workflow-orchestration"
    },
    {
      "createdAt": "2025-01-14T00:00:00.000Z",
      "updatedAt": "2025-01-14T00:00:00.000Z",
      "id": "monitoring",
      "name": "monitoring"
    }
  ]
}