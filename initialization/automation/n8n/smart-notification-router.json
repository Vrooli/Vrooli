{
  "name": "Smart Notification Router",
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "notify",
        "responseMode": "responseNode",
        "options": {}
      },
      "id": "webhook_trigger",
      "name": "Notification Webhook",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 1.1,
      "position": [250, 300]
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// Validate input and determine operation\nconst input = $input.item.json;\n\n// Validate required operation field\nif (!input.operation) {\n  throw new Error('Missing required field: operation');\n}\n\nconst validOperations = ['send', 'get_templates', 'create_template', 'get_status', 'get_stats'];\nif (!validOperations.includes(input.operation)) {\n  throw new Error(`Invalid operation: ${input.operation}. Valid operations: ${validOperations.join(', ')}`);\n}\n\n// Initialize request metadata\nconst requestId = `req_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\nconst timestamp = new Date().toISOString();\n\n// Common validation and preparation\nconst operationData = {\n  operation: input.operation,\n  request_id: requestId,\n  timestamp: timestamp,\n  client: input.client || 'n8n-notification-router'\n};\n\n// Operation-specific validation and preparation\nswitch (input.operation) {\n  case 'send':\n    // Validate notification object\n    if (!input.notification) {\n      throw new Error('Missing required field: notification');\n    }\n    \n    const notification = input.notification;\n    if (!notification.title || !notification.message) {\n      throw new Error('Notification must have title and message');\n    }\n    \n    // Validate and set priority\n    const validPriorities = ['low', 'normal', 'high', 'critical'];\n    const priority = notification.priority || 'normal';\n    if (!validPriorities.includes(priority)) {\n      throw new Error(`Invalid priority: ${priority}. Valid priorities: ${validPriorities.join(', ')}`);\n    }\n    \n    // Validate channels\n    const validChannels = ['email', 'slack', 'webhook', 'sms'];\n    const channels = notification.channels || ['email'];\n    const invalidChannels = channels.filter(ch => !validChannels.includes(ch));\n    if (invalidChannels.length > 0) {\n      throw new Error(`Invalid channels: ${invalidChannels.join(', ')}. Valid channels: ${validChannels.join(', ')}`);\n    }\n    \n    // Validate recipients\n    if (!notification.recipients || notification.recipients.length === 0) {\n      throw new Error('At least one recipient is required');\n    }\n    \n    // Prepare retry configuration\n    const retryConfig = {\n      max_attempts: input.retry_config?.max_attempts || 3,\n      backoff_seconds: input.retry_config?.backoff_seconds || 5,\n      escalate_on_failure: input.retry_config?.escalate_on_failure || false\n    };\n    \n    // Priority-based escalation rules\n    const escalationRules = {\n      low: { timeout_minutes: 60, escalate_to: 'normal' },\n      normal: { timeout_minutes: 30, escalate_to: 'high' },\n      high: { timeout_minutes: 15, escalate_to: 'critical' },\n      critical: { timeout_minutes: 5, escalate_to: null }\n    };\n    \n    operationData.notification = {\n      ...notification,\n      priority: priority,\n      channels: channels,\n      message_id: `msg_${requestId}`,\n      original_message: notification.message\n    };\n    \n    operationData.template_vars = input.template_vars || {};\n    operationData.retry_config = retryConfig;\n    operationData.escalation_rule = escalationRules[priority];\n    operationData.delivery_status = {};\n    operationData.attempt_count = 1;\n    break;\n    \n  case 'get_templates':\n    operationData.template_type = input.template_type || 'all';\n    operationData.category = input.category || 'all';\n    break;\n    \n  case 'create_template':\n    if (!input.template) {\n      throw new Error('Missing required field: template');\n    }\n    if (!input.template.name || !input.template.content) {\n      throw new Error('Template must have name and content');\n    }\n    operationData.template = input.template;\n    break;\n    \n  case 'get_status':\n    if (!input.message_id && !input.request_id) {\n      throw new Error('Either message_id or request_id is required');\n    }\n    operationData.message_id = input.message_id;\n    operationData.lookup_request_id = input.request_id;\n    break;\n    \n  case 'get_stats':\n    operationData.time_range = input.time_range || '24h';\n    operationData.group_by = input.group_by || 'channel';\n    break;\n}\n\nreturn operationData;"
      },
      "id": "validate_and_prepare",
      "name": "Validate & Prepare",
      "type": "n8n-nodes-base.code",
      "typeVersion": 1,
      "position": [450, 300]
    },
    {
      "parameters": {
        "rules": {
          "values": [
            {
              "conditions": {
                "string": [
                  {
                    "value1": "={{ $json.operation }}",
                    "value2": "send"
                  }
                ]
              },
              "renameOutput": true,
              "outputKey": "send_notification"
            },
            {
              "conditions": {
                "string": [
                  {
                    "value1": "={{ $json.operation }}",
                    "value2": "get_templates"
                  }
                ]
              },
              "renameOutput": true,
              "outputKey": "get_templates"
            },
            {
              "conditions": {
                "string": [
                  {
                    "value1": "={{ $json.operation }}",
                    "value2": "create_template"
                  }
                ]
              },
              "renameOutput": true,
              "outputKey": "create_template"
            },
            {
              "conditions": {
                "string": [
                  {
                    "value1": "={{ $json.operation }}",
                    "value2": "get_status"
                  }
                ]
              },
              "renameOutput": true,
              "outputKey": "get_status"
            },
            {
              "conditions": {
                "string": [
                  {
                    "value1": "={{ $json.operation }}",
                    "value2": "get_stats"
                  }
                ]
              },
              "renameOutput": true,
              "outputKey": "get_stats"
            }
          ]
        },
        "options": {}
      },
      "id": "operation_router",
      "name": "Operation Router",
      "type": "n8n-nodes-base.switch",
      "typeVersion": 1,
      "position": [650, 300]
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// Template processing with variable substitution\nconst data = $input.item.json;\nconst notification = data.notification;\nconst templateVars = data.template_vars || {};\n\n// Template substitution function\nfunction substituteTemplate(template, vars) {\n  if (!template || typeof template !== 'string') return template;\n  \n  // Replace {{variable}} patterns\n  return template.replace(/\\{\\{\\s*([^}]+)\\s*\\}\\}/g, (match, varName) => {\n    const keys = varName.trim().split('.');\n    let value = vars;\n    \n    // Navigate nested object paths\n    for (const key of keys) {\n      if (value && typeof value === 'object' && key in value) {\n        value = value[key];\n      } else {\n        return match; // Return original if path not found\n      }\n    }\n    \n    return value !== null && value !== undefined ? String(value) : match;\n  });\n}\n\n// Process message template\nconst processedMessage = substituteTemplate(notification.message, templateVars);\nconst processedTitle = substituteTemplate(notification.title, templateVars);\n\n// Priority-based channel configuration\nconst channelConfigs = {\n  email: {\n    timeout: 30000,\n    retry_delay: 5000,\n    bulk_supported: true\n  },\n  slack: {\n    timeout: 10000,\n    retry_delay: 2000,\n    bulk_supported: false\n  },\n  webhook: {\n    timeout: 15000,\n    retry_delay: 3000,\n    bulk_supported: true\n  },\n  sms: {\n    timeout: 20000,\n    retry_delay: 10000,\n    bulk_supported: false\n  }\n};\n\n// Priority-based delivery timing\nconst priorityConfigs = {\n  critical: { immediate: true, batch_delay: 0 },\n  high: { immediate: true, batch_delay: 5 },\n  normal: { immediate: false, batch_delay: 30 },\n  low: { immediate: false, batch_delay: 300 }\n};\n\nconst priorityConfig = priorityConfigs[notification.priority];\n\n// Prepare channel delivery data\nconst channelDeliveries = notification.channels.map(channel => {\n  const config = channelConfigs[channel];\n  return {\n    channel: channel,\n    config: config,\n    recipients: notification.recipients.filter(recipient => {\n      // Basic recipient validation for channel\n      switch (channel) {\n        case 'email': return recipient.includes('@');\n        case 'slack': return recipient.startsWith('#') || recipient.startsWith('@');\n        case 'webhook': return recipient.startsWith('http');\n        case 'sms': return /^\\+?[1-9]\\d{1,14}$/.test(recipient.replace(/[\\s\\-\\(\\)]/g, ''));\n        default: return true;\n      }\n    }),\n    status: 'pending',\n    attempts: 0\n  };\n}).filter(delivery => delivery.recipients.length > 0);\n\nif (channelDeliveries.length === 0) {\n  throw new Error('No valid recipients found for any channel');\n}\n\nreturn {\n  ...data,\n  notification: {\n    ...notification,\n    title: processedTitle,\n    message: processedMessage,\n    processed_at: new Date().toISOString()\n  },\n  channel_deliveries: channelDeliveries,\n  priority_config: priorityConfig,\n  should_batch: !priorityConfig.immediate,\n  batch_delay_seconds: priorityConfig.batch_delay\n};"
      },
      "id": "template_processor",
      "name": "Template Processor",
      "type": "n8n-nodes-base.code",
      "typeVersion": 1,
      "position": [850, 200]
    },
    {
      "parameters": {
        "rules": {
          "values": [
            {
              "conditions": {
                "boolean": [
                  {
                    "value1": "={{ $json.should_batch }}",
                    "value2": false
                  }
                ]
              },
              "renameOutput": true,
              "outputKey": "immediate_delivery"
            },
            {
              "conditions": {
                "boolean": [
                  {
                    "value1": "={{ $json.should_batch }}",
                    "value2": true
                  }
                ]
              },
              "renameOutput": true,
              "outputKey": "batch_delivery"
            }
          ]
        },
        "options": {}
      },
      "id": "delivery_timing_router",
      "name": "Delivery Timing Router",
      "type": "n8n-nodes-base.switch",
      "typeVersion": 1,
      "position": [1050, 200]
    },
    {
      "parameters": {
        "unit": "seconds",
        "amount": "={{ $json.batch_delay_seconds }}"
      },
      "id": "batch_delay",
      "name": "Batch Delay",
      "type": "n8n-nodes-base.wait",
      "typeVersion": 1,
      "position": [1250, 300]
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// Multi-channel delivery orchestrator\nconst data = $input.item.json;\nconst channelDeliveries = data.channel_deliveries;\nconst notification = data.notification;\n\n// Prepare delivery results structure\nconst deliveryResults = {\n  request_id: data.request_id,\n  message_id: notification.message_id,\n  notification_title: notification.title,\n  priority: notification.priority,\n  total_channels: channelDeliveries.length,\n  started_at: new Date().toISOString(),\n  channels: {},\n  summary: {\n    successful: 0,\n    failed: 0,\n    pending: channelDeliveries.length\n  }\n};\n\n// Initialize channel status tracking\nchannelDeliveries.forEach(delivery => {\n  deliveryResults.channels[delivery.channel] = {\n    status: 'pending',\n    recipients: delivery.recipients,\n    attempts: 0,\n    last_attempt: null,\n    error: null,\n    delivery_id: `${notification.message_id}_${delivery.channel}`,\n    config: delivery.config\n  };\n});\n\n// Store delivery context for tracking\nconst deliveryContext = {\n  ...data,\n  delivery_results: deliveryResults,\n  current_delivery_index: 0,\n  total_deliveries: channelDeliveries.length\n};\n\nreturn deliveryContext;"
      },
      "id": "delivery_orchestrator",
      "name": "Delivery Orchestrator",
      "type": "n8n-nodes-base.code",
      "typeVersion": 1,
      "position": [1450, 200]
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// Split channels for parallel delivery\nconst data = $input.item.json;\nconst channelDeliveries = data.channel_deliveries;\n\n// Create separate items for each channel delivery\nconst channelItems = channelDeliveries.map((delivery, index) => ({\n  ...data,\n  current_channel_delivery: delivery,\n  delivery_index: index,\n  channel_name: delivery.channel\n}));\n\nreturn channelItems;"
      },
      "id": "channel_splitter",
      "name": "Channel Splitter",
      "type": "n8n-nodes-base.code",
      "typeVersion": 1,
      "position": [1650, 200]
    },
    {
      "parameters": {
        "rules": {
          "values": [
            {
              "conditions": {
                "string": [
                  {
                    "value1": "={{ $json.channel_name }}",
                    "value2": "email"
                  }
                ]
              },
              "renameOutput": true,
              "outputKey": "email_delivery"
            },
            {
              "conditions": {
                "string": [
                  {
                    "value1": "={{ $json.channel_name }}",
                    "value2": "slack"
                  }
                ]
              },
              "renameOutput": true,
              "outputKey": "slack_delivery"
            },
            {
              "conditions": {
                "string": [
                  {
                    "value1": "={{ $json.channel_name }}",
                    "value2": "webhook"
                  }
                ]
              },
              "renameOutput": true,
              "outputKey": "webhook_delivery"
            },
            {
              "conditions": {
                "string": [
                  {
                    "value1": "={{ $json.channel_name }}",
                    "value2": "sms"
                  }
                ]
              },
              "renameOutput": true,
              "outputKey": "sms_delivery"
            }
          ]
        },
        "options": {}
      },
      "id": "channel_router",
      "name": "Channel Router",
      "type": "n8n-nodes-base.switch",
      "typeVersion": 1,
      "position": [1850, 200]
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// Email delivery handler\nconst data = $input.item.json;\nconst delivery = data.current_channel_delivery;\nconst notification = data.notification;\n\ntry {\n  // Simulate email delivery\n  const emailResults = delivery.recipients.map(recipient => {\n    // Basic email validation\n    const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n    if (!emailRegex.test(recipient)) {\n      return {\n        recipient: recipient,\n        status: 'failed',\n        error: 'Invalid email address',\n        delivery_time: new Date().toISOString()\n      };\n    }\n    \n    // Simulate delivery success/failure based on priority\n    const failureRate = {\n      critical: 0.01,\n      high: 0.02,\n      normal: 0.05,\n      low: 0.1\n    };\n    \n    const shouldFail = Math.random() < failureRate[notification.priority];\n    \n    if (shouldFail) {\n      return {\n        recipient: recipient,\n        status: 'failed',\n        error: 'SMTP server temporarily unavailable',\n        delivery_time: new Date().toISOString()\n      };\n    }\n    \n    return {\n      recipient: recipient,\n      status: 'delivered',\n      message_id: `email_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\n      delivery_time: new Date().toISOString()\n    };\n  });\n  \n  const successCount = emailResults.filter(r => r.status === 'delivered').length;\n  const failCount = emailResults.filter(r => r.status === 'failed').length;\n  \n  return {\n    ...data,\n    channel_result: {\n      channel: 'email',\n      status: failCount === 0 ? 'success' : (successCount === 0 ? 'failed' : 'partial'),\n      successful_deliveries: successCount,\n      failed_deliveries: failCount,\n      total_recipients: delivery.recipients.length,\n      results: emailResults,\n      delivery_time: new Date().toISOString(),\n      attempt: delivery.attempts + 1\n    }\n  };\n  \n} catch (error) {\n  return {\n    ...data,\n    channel_result: {\n      channel: 'email',\n      status: 'failed',\n      error: error.message,\n      successful_deliveries: 0,\n      failed_deliveries: delivery.recipients.length,\n      total_recipients: delivery.recipients.length,\n      delivery_time: new Date().toISOString(),\n      attempt: delivery.attempts + 1\n    }\n  };\n}"
      },
      "id": "email_handler",
      "name": "Email Handler",
      "type": "n8n-nodes-base.code",
      "typeVersion": 1,
      "position": [2050, 100]
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// Slack delivery handler\nconst data = $input.item.json;\nconst delivery = data.current_channel_delivery;\nconst notification = data.notification;\n\ntry {\n  // Simulate Slack delivery\n  const slackResults = delivery.recipients.map(recipient => {\n    // Basic Slack recipient validation\n    const isChannel = recipient.startsWith('#');\n    const isUser = recipient.startsWith('@');\n    \n    if (!isChannel && !isUser) {\n      return {\n        recipient: recipient,\n        status: 'failed',\n        error: 'Invalid Slack recipient format (must start with # or @)',\n        delivery_time: new Date().toISOString()\n      };\n    }\n    \n    // Simulate delivery success/failure\n    const failureRate = {\n      critical: 0.005,\n      high: 0.01,\n      normal: 0.03,\n      low: 0.07\n    };\n    \n    const shouldFail = Math.random() < failureRate[notification.priority];\n    \n    if (shouldFail) {\n      return {\n        recipient: recipient,\n        status: 'failed',\n        error: isChannel ? 'Channel not found or bot not in channel' : 'User not found or DM disabled',\n        delivery_time: new Date().toISOString()\n      };\n    }\n    \n    return {\n      recipient: recipient,\n      status: 'delivered',\n      message_id: `slack_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\n      delivery_time: new Date().toISOString(),\n      channel_type: isChannel ? 'channel' : 'direct_message'\n    };\n  });\n  \n  const successCount = slackResults.filter(r => r.status === 'delivered').length;\n  const failCount = slackResults.filter(r => r.status === 'failed').length;\n  \n  return {\n    ...data,\n    channel_result: {\n      channel: 'slack',\n      status: failCount === 0 ? 'success' : (successCount === 0 ? 'failed' : 'partial'),\n      successful_deliveries: successCount,\n      failed_deliveries: failCount,\n      total_recipients: delivery.recipients.length,\n      results: slackResults,\n      delivery_time: new Date().toISOString(),\n      attempt: delivery.attempts + 1\n    }\n  };\n  \n} catch (error) {\n  return {\n    ...data,\n    channel_result: {\n      channel: 'slack',\n      status: 'failed',\n      error: error.message,\n      successful_deliveries: 0,\n      failed_deliveries: delivery.recipients.length,\n      total_recipients: delivery.recipients.length,\n      delivery_time: new Date().toISOString(),\n      attempt: delivery.attempts + 1\n    }\n  };\n}"
      },
      "id": "slack_handler",
      "name": "Slack Handler",
      "type": "n8n-nodes-base.code",
      "typeVersion": 1,
      "position": [2050, 200]
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// Webhook delivery handler\nconst data = $input.item.json;\nconst delivery = data.current_channel_delivery;\nconst notification = data.notification;\n\ntry {\n  // Simulate webhook delivery\n  const webhookResults = delivery.recipients.map(recipient => {\n    // Basic URL validation\n    try {\n      new URL(recipient);\n    } catch {\n      return {\n        recipient: recipient,\n        status: 'failed',\n        error: 'Invalid webhook URL format',\n        delivery_time: new Date().toISOString()\n      };\n    }\n    \n    // Simulate delivery success/failure\n    const failureRate = {\n      critical: 0.02,\n      high: 0.03,\n      normal: 0.05,\n      low: 0.08\n    };\n    \n    const shouldFail = Math.random() < failureRate[notification.priority];\n    \n    if (shouldFail) {\n      const errors = [\n        'Connection timeout',\n        'HTTP 500 Internal Server Error',\n        'HTTP 404 Not Found',\n        'Connection refused',\n        'SSL certificate verification failed'\n      ];\n      const randomError = errors[Math.floor(Math.random() * errors.length)];\n      \n      return {\n        recipient: recipient,\n        status: 'failed',\n        error: randomError,\n        delivery_time: new Date().toISOString()\n      };\n    }\n    \n    // Simulate successful response\n    const responseCodes = [200, 201, 202];\n    const responseCode = responseCodes[Math.floor(Math.random() * responseCodes.length)];\n    \n    return {\n      recipient: recipient,\n      status: 'delivered',\n      message_id: `webhook_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\n      delivery_time: new Date().toISOString(),\n      response_code: responseCode,\n      response_time_ms: Math.floor(Math.random() * 2000) + 100\n    };\n  });\n  \n  const successCount = webhookResults.filter(r => r.status === 'delivered').length;\n  const failCount = webhookResults.filter(r => r.status === 'failed').length;\n  \n  return {\n    ...data,\n    channel_result: {\n      channel: 'webhook',\n      status: failCount === 0 ? 'success' : (successCount === 0 ? 'failed' : 'partial'),\n      successful_deliveries: successCount,\n      failed_deliveries: failCount,\n      total_recipients: delivery.recipients.length,\n      results: webhookResults,\n      delivery_time: new Date().toISOString(),\n      attempt: delivery.attempts + 1\n    }\n  };\n  \n} catch (error) {\n  return {\n    ...data,\n    channel_result: {\n      channel: 'webhook',\n      status: 'failed',\n      error: error.message,\n      successful_deliveries: 0,\n      failed_deliveries: delivery.recipients.length,\n      total_recipients: delivery.recipients.length,\n      delivery_time: new Date().toISOString(),\n      attempt: delivery.attempts + 1\n    }\n  };\n}"
      },
      "id": "webhook_handler",
      "name": "Webhook Handler",
      "type": "n8n-nodes-base.code",
      "typeVersion": 1,
      "position": [2050, 300]
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// SMS delivery handler (simulation)\nconst data = $input.item.json;\nconst delivery = data.current_channel_delivery;\nconst notification = data.notification;\n\ntry {\n  // Simulate SMS delivery\n  const smsResults = delivery.recipients.map(recipient => {\n    // Basic phone number validation\n    const phoneRegex = /^\\+?[1-9]\\d{1,14}$/;\n    const cleanedPhone = recipient.replace(/[\\s\\-\\(\\)]/g, '');\n    \n    if (!phoneRegex.test(cleanedPhone)) {\n      return {\n        recipient: recipient,\n        status: 'failed',\n        error: 'Invalid phone number format',\n        delivery_time: new Date().toISOString()\n      };\n    }\n    \n    // Simulate delivery success/failure\n    const failureRate = {\n      critical: 0.01,\n      high: 0.02,\n      normal: 0.04,\n      low: 0.06\n    };\n    \n    const shouldFail = Math.random() < failureRate[notification.priority];\n    \n    if (shouldFail) {\n      const errors = [\n        'Invalid destination number',\n        'SMS service temporarily unavailable',\n        'Message blocked by carrier',\n        'Insufficient credits',\n        'Network timeout'\n      ];\n      const randomError = errors[Math.floor(Math.random() * errors.length)];\n      \n      return {\n        recipient: recipient,\n        status: 'failed',\n        error: randomError,\n        delivery_time: new Date().toISOString()\n      };\n    }\n    \n    return {\n      recipient: recipient,\n      status: 'delivered',\n      message_id: `sms_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\n      delivery_time: new Date().toISOString(),\n      carrier: ['Verizon', 'AT&T', 'T-Mobile', 'Sprint'][Math.floor(Math.random() * 4)],\n      segments: Math.ceil(notification.message.length / 160)\n    };\n  });\n  \n  const successCount = smsResults.filter(r => r.status === 'delivered').length;\n  const failCount = smsResults.filter(r => r.status === 'failed').length;\n  \n  return {\n    ...data,\n    channel_result: {\n      channel: 'sms',\n      status: failCount === 0 ? 'success' : (successCount === 0 ? 'failed' : 'partial'),\n      successful_deliveries: successCount,\n      failed_deliveries: failCount,\n      total_recipients: delivery.recipients.length,\n      results: smsResults,\n      delivery_time: new Date().toISOString(),\n      attempt: delivery.attempts + 1\n    }\n  };\n  \n} catch (error) {\n  return {\n    ...data,\n    channel_result: {\n      channel: 'sms',\n      status: 'failed',\n      error: error.message,\n      successful_deliveries: 0,\n      failed_deliveries: delivery.recipients.length,\n      total_recipients: delivery.recipients.length,\n      delivery_time: new Date().toISOString(),\n      attempt: delivery.attempts + 1\n    }\n  };\n}"
      },
      "id": "sms_handler",
      "name": "SMS Handler",
      "type": "n8n-nodes-base.code",
      "typeVersion": 1,
      "position": [2050, 400]
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// Retry logic for failed deliveries\nconst data = $input.item.json;\nconst channelResult = data.channel_result;\nconst retryConfig = data.retry_config;\nconst currentAttempt = channelResult.attempt;\n\n// Check if retry is needed and allowed\nconst needsRetry = channelResult.status === 'failed' || channelResult.status === 'partial';\nconst canRetry = currentAttempt < retryConfig.max_attempts;\n\nif (needsRetry && canRetry) {\n  // Calculate exponential backoff delay\n  const baseDelay = retryConfig.backoff_seconds * 1000;\n  const retryDelay = baseDelay * Math.pow(2, currentAttempt - 1);\n  const jitter = Math.random() * 1000; // Add jitter to prevent thundering herd\n  const totalDelay = retryDelay + jitter;\n  \n  return {\n    ...data,\n    retry_needed: true,\n    retry_delay_ms: totalDelay,\n    retry_attempt: currentAttempt + 1,\n    channel_result: {\n      ...channelResult,\n      retry_scheduled: true,\n      next_retry_at: new Date(Date.now() + totalDelay).toISOString()\n    }\n  };\n} else {\n  // No retry needed or attempts exhausted\n  return {\n    ...data,\n    retry_needed: false,\n    final_result: true,\n    channel_result: {\n      ...channelResult,\n      final_attempt: true,\n      attempts_exhausted: currentAttempt >= retryConfig.max_attempts\n    }\n  };\n}"
      },
      "id": "retry_logic",
      "name": "Retry Logic",
      "type": "n8n-nodes-base.code",
      "typeVersion": 1,
      "position": [2250, 250]
    },
    {
      "parameters": {
        "rules": {
          "values": [
            {
              "conditions": {
                "boolean": [
                  {
                    "value1": "={{ $json.retry_needed }}",
                    "value2": true
                  }
                ]
              },
              "renameOutput": true,
              "outputKey": "needs_retry"
            },
            {
              "conditions": {
                "boolean": [
                  {
                    "value1": "={{ $json.final_result }}",
                    "value2": true
                  }
                ]
              },
              "renameOutput": true,
              "outputKey": "final_result"
            }
          ]
        },
        "options": {}
      },
      "id": "retry_router",
      "name": "Retry Router",
      "type": "n8n-nodes-base.switch",
      "typeVersion": 1,
      "position": [2450, 250]
    },
    {
      "parameters": {
        "unit": "milliseconds",
        "amount": "={{ $json.retry_delay_ms }}"
      },
      "id": "retry_delay",
      "name": "Retry Delay",
      "type": "n8n-nodes-base.wait",
      "typeVersion": 1,
      "position": [2650, 150]
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// Aggregate results from all channels\nconst items = $input.all();\nconst firstItem = items[0].json;\nconst requestId = firstItem.request_id;\nconst messageId = firstItem.notification.message_id;\n\n// Group results by request ID\nconst resultsByRequest = items.reduce((acc, item) => {\n  const data = item.json;\n  const reqId = data.request_id;\n  \n  if (!acc[reqId]) {\n    acc[reqId] = {\n      request_id: reqId,\n      message_id: data.notification.message_id,\n      notification: data.notification,\n      started_at: data.timestamp,\n      completed_at: new Date().toISOString(),\n      channels: {},\n      summary: {\n        total_channels: 0,\n        successful_channels: 0,\n        failed_channels: 0,\n        partial_channels: 0,\n        total_recipients: 0,\n        successful_deliveries: 0,\n        failed_deliveries: 0\n      },\n      escalation_triggered: false\n    };\n  }\n  \n  // Add channel result\n  const channelResult = data.channel_result;\n  acc[reqId].channels[channelResult.channel] = channelResult;\n  \n  // Update summary\n  const summary = acc[reqId].summary;\n  summary.total_channels++;\n  summary.total_recipients += channelResult.total_recipients;\n  summary.successful_deliveries += channelResult.successful_deliveries;\n  summary.failed_deliveries += channelResult.failed_deliveries;\n  \n  if (channelResult.status === 'success') {\n    summary.successful_channels++;\n  } else if (channelResult.status === 'failed') {\n    summary.failed_channels++;\n  } else if (channelResult.status === 'partial') {\n    summary.partial_channels++;\n  }\n  \n  return acc;\n}, {});\n\n// Check for escalation conditions\nconst result = resultsByRequest[requestId];\nconst totalFailures = result.summary.failed_channels + result.summary.partial_channels;\nconst escalationThreshold = Math.ceil(result.summary.total_channels * 0.5);\n\nif (totalFailures >= escalationThreshold && firstItem.escalation_rule?.escalate_to) {\n  result.escalation_triggered = true;\n  result.escalation_to = firstItem.escalation_rule.escalate_to;\n  result.escalation_reason = `${totalFailures}/${result.summary.total_channels} channels failed or partially failed`;\n}\n\n// Calculate overall status\nif (result.summary.successful_channels === result.summary.total_channels) {\n  result.overall_status = 'success';\n} else if (result.summary.failed_channels === result.summary.total_channels) {\n  result.overall_status = 'failed';\n} else {\n  result.overall_status = 'partial';\n}\n\n// Calculate delivery rate\nresult.delivery_rate = result.summary.total_recipients > 0 \n  ? (result.summary.successful_deliveries / result.summary.total_recipients) * 100 \n  : 0;\n\nreturn result;"
      },
      "id": "result_aggregator",
      "name": "Result Aggregator",
      "type": "n8n-nodes-base.code",
      "typeVersion": 1,
      "position": [2650, 350]
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// Template management operations\nconst data = $input.item.json;\n\n// Default templates\nconst defaultTemplates = {\n  alert: {\n    name: 'alert',\n    category: 'system',\n    title: 'System Alert: {{alert_type}}',\n    content: {\n      email: 'Alert: {{alert_type}}\\n\\nMessage: {{message}}\\n\\nTime: {{timestamp}}\\n\\nSeverity: {{severity}}',\n      slack: ':warning: *{{alert_type}}* Alert\\n{{message}}\\n_Severity: {{severity}}_',\n      sms: 'ALERT: {{alert_type}} - {{message}}',\n      webhook: {\n        title: '{{alert_type}}',\n        message: '{{message}}',\n        severity: '{{severity}}',\n        timestamp: '{{timestamp}}'\n      }\n    },\n    created_at: new Date().toISOString(),\n    updated_at: new Date().toISOString()\n  },\n  notification: {\n    name: 'notification',\n    category: 'general',\n    title: '{{title}}',\n    content: {\n      email: '{{message}}\\n\\n---\\nSent via Smart Notification Router',\n      slack: '{{message}}',\n      sms: '{{message}}',\n      webhook: {\n        title: '{{title}}',\n        message: '{{message}}'\n      }\n    },\n    created_at: new Date().toISOString(),\n    updated_at: new Date().toISOString()\n  },\n  reminder: {\n    name: 'reminder',\n    category: 'productivity',\n    title: 'Reminder: {{subject}}',\n    content: {\n      email: 'This is a reminder about: {{subject}}\\n\\nDetails: {{details}}\\n\\nDue: {{due_date}}',\n      slack: ':clock1: *Reminder*\\n{{subject}}\\n{{details}}\\nDue: {{due_date}}',\n      sms: 'Reminder: {{subject}} - Due {{due_date}}',\n      webhook: {\n        type: 'reminder',\n        subject: '{{subject}}',\n        details: '{{details}}',\n        due_date: '{{due_date}}'\n      }\n    },\n    created_at: new Date().toISOString(),\n    updated_at: new Date().toISOString()\n  }\n};\n\nif (data.template_type === 'all' || !data.template_type) {\n  return {\n    request_id: data.request_id,\n    operation: 'get_templates',\n    templates: defaultTemplates,\n    total_templates: Object.keys(defaultTemplates).length,\n    categories: ['system', 'general', 'productivity'],\n    retrieved_at: new Date().toISOString()\n  };\n} else {\n  const filteredTemplates = Object.entries(defaultTemplates)\n    .filter(([_, template]) => template.category === data.category || template.name === data.template_type)\n    .reduce((acc, [key, template]) => ({ ...acc, [key]: template }), {});\n    \n  return {\n    request_id: data.request_id,\n    operation: 'get_templates',\n    templates: filteredTemplates,\n    total_templates: Object.keys(filteredTemplates).length,\n    filter_applied: data.template_type || data.category,\n    retrieved_at: new Date().toISOString()\n  };\n}"
      },
      "id": "template_manager",
      "name": "Template Manager",
      "type": "n8n-nodes-base.code",
      "typeVersion": 1,
      "position": [850, 400]
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// Create new template\nconst data = $input.item.json;\nconst template = data.template;\n\n// Validate template structure\nif (!template.name || !template.content) {\n  throw new Error('Template must have name and content');\n}\n\nif (typeof template.content !== 'object') {\n  throw new Error('Template content must be an object with channel-specific content');\n}\n\n// Validate channels in template\nconst validChannels = ['email', 'slack', 'sms', 'webhook'];\nconst templateChannels = Object.keys(template.content);\nconst invalidChannels = templateChannels.filter(ch => !validChannels.includes(ch));\n\nif (invalidChannels.length > 0) {\n  throw new Error(`Invalid channels in template: ${invalidChannels.join(', ')}`);\n}\n\n// Create template with metadata\nconst newTemplate = {\n  name: template.name,\n  category: template.category || 'custom',\n  title: template.title || '{{title}}',\n  description: template.description || '',\n  content: template.content,\n  variables: template.variables || [],\n  created_at: new Date().toISOString(),\n  updated_at: new Date().toISOString(),\n  created_by: data.client || 'n8n-notification-router',\n  version: '1.0.0'\n};\n\n// In a real implementation, this would be saved to a database\n// For now, we'll just return success with the created template\nreturn {\n  request_id: data.request_id,\n  operation: 'create_template',\n  success: true,\n  template: newTemplate,\n  message: `Template '${template.name}' created successfully`,\n  created_at: new Date().toISOString()\n};"
      },
      "id": "template_creator",
      "name": "Template Creator",
      "type": "n8n-nodes-base.code",
      "typeVersion": 1,
      "position": [850, 500]
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// Status lookup handler\nconst data = $input.item.json;\n\n// Simulate status lookup\nconst messageId = data.message_id;\nconst requestId = data.lookup_request_id || data.request_id;\n\nif (!messageId && !requestId) {\n  throw new Error('Either message_id or request_id is required');\n}\n\n// Simulate status data (in real implementation, this would query a database)\nconst mockStatuses = [\n  {\n    message_id: messageId,\n    request_id: requestId,\n    status: 'delivered',\n    channels: {\n      email: { status: 'delivered', delivered_at: new Date(Date.now() - 300000).toISOString() },\n      slack: { status: 'delivered', delivered_at: new Date(Date.now() - 250000).toISOString() }\n    },\n    created_at: new Date(Date.now() - 600000).toISOString(),\n    completed_at: new Date(Date.now() - 200000).toISOString()\n  },\n  {\n    message_id: messageId,\n    request_id: requestId,\n    status: 'partial',\n    channels: {\n      email: { status: 'delivered', delivered_at: new Date(Date.now() - 180000).toISOString() },\n      webhook: { status: 'failed', error: 'Connection timeout', last_attempt: new Date(Date.now() - 60000).toISOString() }\n    },\n    created_at: new Date(Date.now() - 300000).toISOString(),\n    retry_in_progress: true\n  },\n  {\n    message_id: messageId,\n    request_id: requestId,\n    status: 'pending',\n    channels: {\n      email: { status: 'pending', scheduled_for: new Date(Date.now() + 120000).toISOString() },\n      sms: { status: 'pending', scheduled_for: new Date(Date.now() + 120000).toISOString() }\n    },\n    created_at: new Date(Date.now() - 60000).toISOString(),\n    batch_delivery: true\n  }\n];\n\n// Select a random mock status for demonstration\nconst selectedStatus = mockStatuses[Math.floor(Math.random() * mockStatuses.length)];\n\nreturn {\n  request_id: data.request_id,\n  operation: 'get_status',\n  lookup_id: messageId || requestId,\n  found: true,\n  status_data: selectedStatus,\n  retrieved_at: new Date().toISOString()\n};"
      },
      "id": "status_lookup",
      "name": "Status Lookup",
      "type": "n8n-nodes-base.code",
      "typeVersion": 1,
      "position": [850, 600]
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// Statistics generator\nconst data = $input.item.json;\nconst timeRange = data.time_range || '24h';\nconst groupBy = data.group_by || 'channel';\n\n// Generate mock statistics based on time range\nconst now = new Date();\nconst timeRanges = {\n  '1h': 60 * 60 * 1000,\n  '24h': 24 * 60 * 60 * 1000,\n  '7d': 7 * 24 * 60 * 60 * 1000,\n  '30d': 30 * 24 * 60 * 60 * 1000\n};\n\nconst rangeMs = timeRanges[timeRange] || timeRanges['24h'];\nconst startTime = new Date(now.getTime() - rangeMs);\n\n// Mock statistics by channel\nconst channelStats = {\n  email: {\n    total_sent: Math.floor(Math.random() * 1000) + 100,\n    delivered: Math.floor(Math.random() * 900) + 90,\n    failed: Math.floor(Math.random() * 50) + 5,\n    avg_delivery_time_ms: Math.floor(Math.random() * 5000) + 1000,\n    success_rate: 0.95\n  },\n  slack: {\n    total_sent: Math.floor(Math.random() * 500) + 50,\n    delivered: Math.floor(Math.random() * 450) + 45,\n    failed: Math.floor(Math.random() * 25) + 2,\n    avg_delivery_time_ms: Math.floor(Math.random() * 2000) + 500,\n    success_rate: 0.97\n  },\n  webhook: {\n    total_sent: Math.floor(Math.random() * 300) + 30,\n    delivered: Math.floor(Math.random() * 270) + 25,\n    failed: Math.floor(Math.random() * 20) + 3,\n    avg_delivery_time_ms: Math.floor(Math.random() * 3000) + 800,\n    success_rate: 0.92\n  },\n  sms: {\n    total_sent: Math.floor(Math.random() * 200) + 20,\n    delivered: Math.floor(Math.random() * 180) + 18,\n    failed: Math.floor(Math.random() * 15) + 1,\n    avg_delivery_time_ms: Math.floor(Math.random() * 8000) + 2000,\n    success_rate: 0.94\n  }\n};\n\n// Calculate overall statistics\nconst overallStats = {\n  total_sent: Object.values(channelStats).reduce((sum, ch) => sum + ch.total_sent, 0),\n  total_delivered: Object.values(channelStats).reduce((sum, ch) => sum + ch.delivered, 0),\n  total_failed: Object.values(channelStats).reduce((sum, ch) => sum + ch.failed, 0),\n  overall_success_rate: 0,\n  avg_delivery_time_ms: 0\n};\n\noverallStats.overall_success_rate = overallStats.total_sent > 0 \n  ? (overallStats.total_delivered / overallStats.total_sent) * 100 \n  : 0;\n\noverallStats.avg_delivery_time_ms = Object.values(channelStats)\n  .reduce((sum, ch, _, arr) => sum + (ch.avg_delivery_time_ms / arr.length), 0);\n\n// Priority distribution mock\nconst priorityStats = {\n  critical: { count: Math.floor(Math.random() * 50) + 5, success_rate: 99.2 },\n  high: { count: Math.floor(Math.random() * 200) + 50, success_rate: 97.8 },\n  normal: { count: Math.floor(Math.random() * 800) + 200, success_rate: 95.5 },\n  low: { count: Math.floor(Math.random() * 300) + 100, success_rate: 93.2 }\n};\n\n// Hourly breakdown for time series\nconst hourlyBreakdown = [];\nconst hoursInRange = Math.min(24, Math.ceil(rangeMs / (60 * 60 * 1000)));\n\nfor (let i = 0; i < hoursInRange; i++) {\n  const hourStart = new Date(now.getTime() - (i * 60 * 60 * 1000));\n  hourlyBreakdown.unshift({\n    hour: hourStart.toISOString().substr(0, 13) + ':00:00.000Z',\n    sent: Math.floor(Math.random() * 100) + 10,\n    delivered: Math.floor(Math.random() * 90) + 8,\n    failed: Math.floor(Math.random() * 10) + 1\n  });\n}\n\nconst result = {\n  request_id: data.request_id,\n  operation: 'get_stats',\n  time_range: timeRange,\n  group_by: groupBy,\n  period: {\n    start: startTime.toISOString(),\n    end: now.toISOString(),\n    duration_ms: rangeMs\n  },\n  overall: overallStats,\n  generated_at: new Date().toISOString()\n};\n\n// Add grouping-specific data\nif (groupBy === 'channel') {\n  result.by_channel = channelStats;\n} else if (groupBy === 'priority') {\n  result.by_priority = priorityStats;\n} else if (groupBy === 'time') {\n  result.time_series = hourlyBreakdown;\n} else {\n  result.by_channel = channelStats;\n  result.by_priority = priorityStats;\n  result.time_series = hourlyBreakdown;\n}\n\nreturn result;"
      },
      "id": "stats_generator",
      "name": "Stats Generator",
      "type": "n8n-nodes-base.code",
      "typeVersion": 1,
      "position": [850, 700]
    },
    {
      "parameters": {
        "respondWith": "allIncomingItems",
        "options": {}
      },
      "id": "webhook_response",
      "name": "Response",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1,
      "position": [2850, 400]
    }
  ],
  "connections": {
    "webhook_trigger": {
      "main": [
        [
          {
            "node": "validate_and_prepare",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "validate_and_prepare": {
      "main": [
        [
          {
            "node": "operation_router",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "operation_router": {
      "main": [
        [
          {
            "node": "template_processor",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "template_manager",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "template_creator",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "status_lookup",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "stats_generator",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "template_processor": {
      "main": [
        [
          {
            "node": "delivery_timing_router",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "delivery_timing_router": {
      "main": [
        [
          {
            "node": "delivery_orchestrator",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "batch_delay",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "batch_delay": {
      "main": [
        [
          {
            "node": "delivery_orchestrator",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "delivery_orchestrator": {
      "main": [
        [
          {
            "node": "channel_splitter",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "channel_splitter": {
      "main": [
        [
          {
            "node": "channel_router",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "channel_router": {
      "main": [
        [
          {
            "node": "email_handler",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "slack_handler",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "webhook_handler",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "sms_handler",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "email_handler": {
      "main": [
        [
          {
            "node": "retry_logic",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "slack_handler": {
      "main": [
        [
          {
            "node": "retry_logic",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "webhook_handler": {
      "main": [
        [
          {
            "node": "retry_logic",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "sms_handler": {
      "main": [
        [
          {
            "node": "retry_logic",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "retry_logic": {
      "main": [
        [
          {
            "node": "retry_router",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "retry_router": {
      "main": [
        [
          {
            "node": "retry_delay",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "result_aggregator",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "retry_delay": {
      "main": [
        [
          {
            "node": "channel_router",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "result_aggregator": {
      "main": [
        [
          {
            "node": "webhook_response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "template_manager": {
      "main": [
        [
          {
            "node": "webhook_response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "template_creator": {
      "main": [
        [
          {
            "node": "webhook_response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "status_lookup": {
      "main": [
        [
          {
            "node": "webhook_response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "stats_generator": {
      "main": [
        [
          {
            "node": "webhook_response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "pinData": {},
  "versionId": "1.0.0"
}