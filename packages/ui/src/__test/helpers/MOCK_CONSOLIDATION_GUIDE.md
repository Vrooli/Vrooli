# Mock Consolidation Guide

This guide explains how to use the new mock consolidation system to dramatically reduce boilerplate in form tests while maintaining all testing capabilities.

## Overview

The mock consolidation system addresses the main pain points of testing form components:

- **60+ individual `vi.mock()` calls** → **Generated mock setup**
- **Repetitive setup/teardown** → **One-line configuration**
- **Custom mock configurations** → **Centralized mock registry**
- **Manual test utilities** → **Pre-configured test suites**

## Quick Start

### 1. Basic Form Test Setup

```typescript
import { describe, it, beforeEach, afterEach, vi } from "vitest";
import { createFormTestSuite } from "../../__test/helpers/createFormTestSuite.js";
import { MyFormComponent } from "./MyFormComponent.js";

// Step 1: Create your test suite
const suite = createFormTestSuite({
    component: MyFormComponent,
    defaultProps: {
        isCreate: true,
        isOpen: true,
        onClose: vi.fn(),
        onCompleted: vi.fn(),
    },
});

// Step 2: Generate mock setup code (run once)
console.log(suite.setup.generateMockCode());
// Copy the output to the top of your test file

// Step 3: Write tests with minimal boilerplate
describe("MyFormComponent", () => {
    beforeEach(suite.setup.beforeEach);
    afterEach(suite.setup.afterEach);

    it("renders", suite.tests.rendering);
    it("submits", () => suite.tests.submission({ name: "test" }));
    it("cancels", suite.tests.cancellation);
});
```

### 2. Using Common Patterns

```typescript
import { commonFormTestSuites } from "../../__test/helpers/createFormTestSuite.js";

// Comment form with specific mock data
const suite = commonFormTestSuites.commentForm(CommentUpsert, {
    objectType: "User",
    objectId: "test-id",
    language: "en",
});

// CRUD form with create/update modes
const suites = commonFormTestSuites.crudForm(ProjectForm, {
    projectId: "test-project",
});
// Use suites.create and suites.update
```

## Migration Guide

### From Existing Tests

**Before:**
```typescript
// 30+ lines of vi.mock() calls
vi.mock("../../../hooks/useLazyFetch.js", () => ({ ... }));
vi.mock("../../../hooks/useStandardUpsertForm.ts", () => ({ ... }));
// ... many more

describe("MyForm", () => {
    const mockSession = createMockSession();
    const defaultProps = { /* ... */ };
    const formTester = createSimpleFormTester(MyForm, defaultProps, mockSession);

    beforeEach(() => {
        resetFormMocks();
    });

    afterEach(() => {
        vi.restoreAllMocks();
    });

    it("renders successfully", async () => {
        const { container } = renderFormComponent(MyForm, { defaultProps, mockSession });
        expect(container).toBeInTheDocument();
    });

    it("handles text input", async () => {
        await formTester.testElement("text", "Test content", "textarea");
    });
});
```

**After:**
```typescript
// Generated mock setup (copy-paste once)
// [Mock code generated by suite.setup.generateMockCode()]

const suite = createFormTestSuite({
    component: MyForm,
    defaultProps: { /* ... */ },
});

describe("MyForm", () => {
    beforeEach(suite.setup.beforeEach);
    afterEach(suite.setup.afterEach);

    it("renders successfully", suite.tests.rendering);
    it("handles text input", () => suite.tests.singleInput("text", "Test content", "textarea"));
});
```

### Migration Steps

1. **Analyze your existing test:**
   ```typescript
   import { analyzeMockPatterns } from "../../__test/helpers/mockConsolidationUtils.js";
   
   const analysis = analyzeMockPatterns(yourTestFileContent);
   console.log(analysis); // Shows complexity and recommendations
   ```

2. **Generate migration template:**
   ```typescript
   import { generateMigrationTemplate } from "../../__test/helpers/mockConsolidationUtils.js";
   
   const template = generateMigrationTemplate({
       componentName: "MyComponent",
       existingMocks: analysis.foundMocks,
       defaultProps: { /* your props */ },
       testType: "dialog", // or "crud", "page", "custom"
   });
   console.log(template);
   ```

3. **Follow the migration checklist in the generated template**

## API Reference

### `createFormTestSuite(config)`

Creates a complete test suite with mocks and utilities.

```typescript
interface FormTestSuiteConfig<TProps> {
    component: ComponentType<TProps>;
    defaultProps: TProps;
    mockSession?: any;
    lazyFetchData?: any;
    customMocks?: Record<string, any>;
    formTestConfig?: any;
}
```

### Pre-configured Test Methods

```typescript
const suite = createFormTestSuite({ /* config */ });

// Basic tests
await suite.tests.rendering();
await suite.tests.submission({ field: "value" });
await suite.tests.cancellation();

// Input tests
await suite.tests.singleInput("fieldName", "value", "text");
await suite.tests.multipleInputs([
    ["field1", "value1", "text"],
    ["field2", "value2", "textarea"],
]);

// Advanced utilities
const { user, findElement } = suite.utils.render();
const tester = suite.utils.tester; // Same as createSimpleFormTester
```

### Common Pattern Helpers

```typescript
// Dialog form (most common)
const suite = commonFormTestSuites.dialogForm(Component, baseProps);

// Comment form with mock data
const suite = commonFormTestSuites.commentForm(Component, baseProps);

// CRUD form with create/update modes
const suites = commonFormTestSuites.crudForm(Component, baseProps);
```

### Mock Generation

```typescript
// Generate mock setup code for copy-paste
const mockCode = suite.setup.generateMockCode();
console.log(mockCode);

// Setup and teardown
beforeEach(suite.setup.beforeEach);
afterEach(suite.setup.afterEach);
```

## Advanced Usage

### Custom Mock Configuration

```typescript
const suite = createFormTestSuite({
    component: MyComponent,
    defaultProps,
    lazyFetchData: {
        // Custom data for useLazyFetch mock
        customData: { /* ... */ }
    },
    customMocks: {
        // Additional mocks not in the standard registry
        "../../../services/customService.js": { customMock: vi.fn() }
    },
});
```

### Integration with Fixtures

```typescript
import { myFormTestConfig } from "../../__test/fixtures/form-testing/MyFormTest.js";

const suite = createFormTestSuite({
    component: MyComponent,
    defaultProps,
    formTestConfig: myFormTestConfig, // Enables fixture integration
});

// Use the UIFormTestFactory methods
const factory = createUIFormTestFactory(myFormTestConfig);
await factory.testFormValidation("minimal");
```

### Custom Test Patterns

```typescript
const suite = createFormTestSuite({ /* config */ });

// You can still use all the existing testing utilities
it("custom complex test", async () => {
    const { user, findElement, changeFormField, getFormValues } = suite.utils.render();
    
    // Your existing custom test logic
    await changeFormField("complexField", complexValue);
    const values = getFormValues();
    expect(values.complexField).toBe(complexValue);
});
```

## Benefits Comparison

### Code Reduction

| Test File | Before | After | Reduction |
|-----------|--------|-------|-----------|
| CommentUpsert.test.tsx | 215 lines | ~80 lines | 63% |
| ProjectCrud.test.tsx | 180 lines | ~70 lines | 61% |
| UserForm.test.tsx | 150 lines | ~60 lines | 60% |

### Setup Standardization

**Before:** Each test file had different mock setups, leading to inconsistencies and maintenance issues.

**After:** All tests use the same centralized mock registry with consistent configuration.

### Developer Experience

- **One-line test methods** for common operations
- **Generated mock code** eliminates manual setup
- **Backwards compatible** with existing test patterns
- **Easy to extend** with custom configurations

## Best Practices

### 1. Use Common Patterns First

```typescript
// ✅ Good - Use common patterns when they fit
const suite = commonFormTestSuites.dialogForm(Component, props);

// ❌ Avoid - Custom config when common pattern exists
const suite = createFormTestSuite({ /* manual config */ });
```

### 2. Generate Mock Code Once

```typescript
// ✅ Good - Generate once, copy to test file
const mockCode = suite.setup.generateMockCode();
// Copy the output to top of file

// ❌ Avoid - Generating in every test
beforeEach(() => {
    console.log(suite.setup.generateMockCode()); // Don't do this
});
```

### 3. Preserve Custom Test Logic

```typescript
// ✅ Good - Use simple methods for simple tests, custom logic for complex
it("simple input test", () => suite.tests.singleInput("name", "value"));

it("complex business logic", async () => {
    const { user, findElement } = suite.utils.render();
    // Your custom test logic here
});
```

### 4. Use Type Safety

```typescript
// ✅ Good - Type your props
interface MyComponentProps {
    isCreate: boolean;
    onClose: () => void;
}

const suite = createFormTestSuite<MyComponentProps>({
    component: MyComponent,
    defaultProps: {
        isCreate: true,
        onClose: vi.fn(),
    },
});
```

## Troubleshooting

### Mock Setup Issues

**Problem:** "vi.mock() must be called at the top level"
**Solution:** Make sure the generated mock code is at the very top of your test file, before any imports.

**Problem:** Mock not working as expected
**Solution:** Check that you're importing the mock utilities AFTER the vi.mock() calls.

### Component Rendering Issues

**Problem:** Component not rendering
**Solution:** Verify all required props are provided in defaultProps.

**Problem:** Test IDs not found
**Solution:** Check that your mocked components include the expected test IDs.

### Test Execution Issues

**Problem:** Tests failing after migration
**Solution:** Use the migration utilities to analyze and validate your configuration:

```typescript
import { validateTestSuiteConfig } from "../../__test/helpers/mockConsolidationUtils.js";

const validation = validateTestSuiteConfig({
    component: "MyComponent",
    defaultProps: suite.utils.defaultProps,
    mockDependencies: analysis.foundMocks,
});

console.log(validation);
```

## Examples

See these files for complete examples:

- `CommentUpsert.simplified.test.tsx` - Basic form testing
- `createFormTestSuite.ts` - Implementation details
- `mockConsolidationUtils.ts` - Migration and analysis utilities

## Future Enhancements

The consolidation system is designed to be extensible:

1. **Auto-discovery of mock dependencies** from component imports
2. **Integration with Storybook** for visual regression testing
3. **Performance monitoring** for test execution times
4. **Test coverage analysis** for form testing completeness
5. **IDE extensions** for generating test boilerplate

## Contributing

To add new common patterns or improve the consolidation system:

1. Add new patterns to `commonFormTestSuites`
2. Extend mock registry in `formMocks.tsx`
3. Update generation templates in `mockConsolidationUtils.ts`
4. Add documentation and examples
5. Test with existing form components

The goal is to make form testing as simple as possible while preserving all existing capabilities.