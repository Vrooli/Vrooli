import Box from "@mui/material/Box";
import Button from "@mui/material/Button";
import Dialog from "@mui/material/Dialog";
import IconButton from "@mui/material/IconButton";
import LinearProgress from "@mui/material/LinearProgress";
import List from "@mui/material/List";
import ListItem from "@mui/material/ListItem";
import ListItemText from "@mui/material/ListItemText";
import ListSubheader from "@mui/material/ListSubheader";
import Menu from "@mui/material/Menu";
import MenuItem from "@mui/material/MenuItem";
import MobileStepper from "@mui/material/MobileStepper";
import Paper from "@mui/material/Paper";
import Stack from "@mui/material/Stack";
import Typography from "@mui/material/Typography";
import type { PaperProps } from "@mui/material";
import { styled, useTheme } from "@mui/material";
import { LINKS, SEEDED_PUBLIC_IDS, SearchPageTabOption, UrlTools, getObjectUrl, type TutorialViewSearchParams } from "@vrooli/shared";
import { useCallback, useEffect, useMemo, useRef, useState } from "react";
import Draggable from "react-draggable";
import { useTranslation } from "react-i18next";
import { FormRunView } from "../../forms/FormView/FormView.js";
import { useHotkeys } from "../../hooks/useHotkeys.js";
import { useMenu } from "../../hooks/useMenu.js";
import { usePopover } from "../../hooks/usePopover.js";
import { useWindowSize } from "../../hooks/useWindowSize.js";
import { IconCommon } from "../../icons/Icons.js";
import { useLocation } from "../../route/router.js";
import { addSearchParams, removeSearchParams } from "../../route/searchParams.js";
import { ELEMENT_IDS, Z_INDEX } from "../../utils/consts.js";
import { TUTORIAL_HIGHLIGHT, addHighlight, removeHighlights } from "../../utils/display/documentTools.js";
import { PubSub, type MenuPayloads } from "../../utils/pubsub.js";
import { routineTypes } from "../../utils/search/schemas/resource.js";
import { PopoverWithArrow } from "../dialogs/PopoverWithArrow/PopoverWithArrow.js";
import { MarkdownDisplay } from "../text/MarkdownDisplay.js";
import { DialogTitle } from "./DialogTitle/DialogTitle.js";
import { tutorialSections } from "./TutorialDialog/tutorialSections.js";
import type { Place, TutorialDialogProps, TutorialSection, TutorialStep } from "./TutorialDialog/types.js";

// Use sections from external file
const sections: TutorialSection[] = tutorialSections;

/**
                        label: "Welcome to the future of productivity",
                        tag: "h1",
                    },
                    {
                        type: FormStructureType.Header,
                        id: nanoid(),
                        isCollapsible: false,
                        isMarkdown: true,
                        label: "Vrooli uses **AI agent swarms** - teams of specialized AI that collaborate to accomplish your goals. Think of it as having a brilliant team that never sleeps, working 24/7 to make your ideas reality.",
                        tag: "body1",
                    },
                    {
                        type: FormStructureType.Tip,
                        icon: "Info",
                        id: nanoid(),
                        isMarkdown: true,
                        label: "AI agent swarms coordinate automatically - no micromanagement needed!",
                    },
                    {
                        type: FormStructureType.Divider,
                        id: nanoid(),
                        label: "",
                    },
                    {
                        type: FormStructureType.Tip,
                        id: nanoid(),
                        label: "Need this tutorial again? Look for \"Tutorial\" in the user menu",
                        icon: "Info",
                    },
                ],
                location: {
                    page: LINKS.Home,
                },
            },
            {
                content: [
                    {
                        type: FormStructureType.Header,
                        color: "primary",
                        id: nanoid(),
                        isCollapsible: false,
                        label: "Meet your new workspace",
                        tag: "h2",
                    },
                    {
                        type: FormStructureType.Header,
                        id: nanoid(),
                        isCollapsible: false,
                        isMarkdown: true,
                        label: "This chat interface is your primary workspace. Instead of navigating menus or filling forms, you simply **type what you want to accomplish**.",
                        tag: "body1",
                    },
                    {
                        type: FormStructureType.Tip,
                        icon: "Info",
                        id: nanoid(),
                        isMarkdown: true,
                        label: "**Example**: Try typing 'Help me plan my weekly schedule'",
                    },
                ],
                location: {
                    element: "chat-input-area",
                    page: LINKS.Home,
                },
            },
            {
                content: [
                    {
                        type: FormStructureType.Header,
                        color: "secondary",
                        id: nanoid(),
                        isCollapsible: false,
                        label: "Valyxa - AI Assistant",
                        tag: "body2",
                    },
                    {
                        type: FormStructureType.Header,
                        id: nanoid(),
                        isCollapsible: false,
                        isMarkdown: true,
                        label: "Hello! I'm **Valyxa**, your AI assistant. I coordinate with specialized AI agents to help you accomplish any task. What would you like to work on today?",
                        tag: "body1",
                    },
                    {
                        type: FormStructureType.Divider,
                        id: nanoid(),
                        label: "",
                    },
                    {
                        type: FormStructureType.Tip,
                        icon: "Info",
                        id: nanoid(),
                        isMarkdown: true,
                        label: "Valyxa can help with everything from simple reminders to complex project planning. Just describe what you need in **natural language**.",
                    },
                ],
                location: {
                    element: "chat-bubble-tree",
                    page: LINKS.Home,
                },
            },
            {
                content: [
                    {
                        type: FormStructureType.Header,
                        color: "primary",
                        id: nanoid(),
                        isCollapsible: false,
                        label: "Interface Overview",
                        tag: "h3",
                    },
                    {
                        type: FormStructureType.Header,
                        id: nanoid(),
                        isCollapsible: false,
                        isMarkdown: true,
                        label: "**Left Panel**: Navigation & History\n**Center**: Main Conversation\n**Right Panel**: Context & Tools",
                        tag: "body1",
                    },
                    {
                        type: FormStructureType.Tip,
                        icon: "Info",
                        id: nanoid(),
                        label: "The layout automatically adjusts to your screen size and preferences",
                    },
                ],
                location: {
                    page: LINKS.Home,
                },
            },
        ],
    },
    {
        title: "Your First AI Conversation",
        steps: [
            {
                content: [
                    {
                        type: FormStructureType.Header,
                        color: "primary",
                        id: nanoid(),
                        isCollapsible: false,
                        label: "Start your first conversation",
                        tag: "h2",
                    },
                    {
                        type: FormStructureType.Header,
                        id: nanoid(),
                        isCollapsible: false,
                        isMarkdown: true,
                        label: "Click in the message area below and type what you want to work on. Here are some ideas to get started:",
                        tag: "body1",
                    },
                    {
                        type: FormStructureType.Header,
                        id: nanoid(),
                        isCollapsible: false,
                        isMarkdown: true,
                        label: "**Examples to try:**\n• Help me organize my daily tasks\n• I need to plan a project presentation\n• Create a workout routine for busy professionals\n• Help me write a professional email",
                        tag: "body1",
                    },
                    {
                        type: FormStructureType.Tip,
                        icon: "Info",
                        id: nanoid(),
                        label: "Simply type what you want to accomplish - no special syntax needed",
                    },
                ],
                location: {
                    element: "chat-input-area",
                    page: LINKS.Home,
                },
            },
            {
                content: [
                    {
                        type: FormStructureType.Tip,
                        icon: "Info",
                        id: nanoid(),
                        label: "Great! You sent your first message naturally",
                    },
                    {
                        type: FormStructureType.Header,
                        id: nanoid(),
                        isCollapsible: false,
                        isMarkdown: true,
                        label: "Notice how you wrote that like you were talking to a person? That's exactly right. Valyxa understands natural language, so you can:",
                        tag: "body1",
                    },
                    {
                        type: FormStructureType.Header,
                        id: nanoid(),
                        isCollapsible: false,
                        isMarkdown: true,
                        label: "• **Ask questions**: 'How should I approach this?'\n• **Request actions**: 'Create a schedule for my week'\n• **Brainstorm**: 'What are some creative solutions for...'\n• **Problem-solve**: 'I'm stuck with this issue...'",
                        tag: "body1",
                    },
                ],
                location: {
                    element: "chat-bubble-tree",
                    page: LINKS.Home,
                },
            },
            {
                content: [
                    {
                        type: FormStructureType.Tip,
                        icon: "Info",
                        id: nanoid(),
                        label: "Look how Valyxa structured the response",
                    },
                    {
                        type: FormStructureType.Header,
                        id: nanoid(),
                        isCollapsible: false,
                        label: "AI responses typically include:",
                        tag: "body1",
                    },
                    {
                        type: FormStructureType.Header,
                        id: nanoid(),
                        isCollapsible: false,
                        isMarkdown: true,
                        label: "• Clear understanding of your request\n• Specific suggestions or solutions\n• Follow-up questions for clarification\n• Action buttons for immediate next steps",
                        tag: "body1",
                    },
                    {
                        type: FormStructureType.Tip,
                        icon: "Info",
                        id: nanoid(),
                        isMarkdown: true,
                        label: "The AI builds context from everything you've said. **No need to repeat yourself!**",
                    },
                ],
                location: {
                    element: "chat-bubble-tree",
                    page: LINKS.Home,
                },
            },
            {
                content: [
                    {
                        type: FormStructureType.Header,
                        color: "primary",
                        id: nanoid(),
                        isCollapsible: false,
                        label: "Continue the conversation",
                        tag: "h3",
                    },
                    {
                        type: FormStructureType.Header,
                        id: nanoid(),
                        isCollapsible: false,
                        label: "Now respond to Valyxa's suggestions. You can:",
                        tag: "body1",
                    },
                    {
                        type: FormStructureType.Tip,
                        icon: "Info",
                        id: nanoid(),
                        isMarkdown: true,
                        label: "**Ask for more details**: 'Can you elaborate on the second suggestion?'",
                    },
                    {
                        type: FormStructureType.Tip,
                        icon: "Info",
                        id: nanoid(),
                        isMarkdown: true,
                        label: "**Request changes**: 'That's good, but make it simpler'",
                    },
                    {
                        type: FormStructureType.Tip,
                        icon: "Info",
                        id: nanoid(),
                        isMarkdown: true,
                        label: "**Try something different**: 'Actually, let's focus on time management instead'",
                    },
                ],
                location: {
                    element: "chat-input-area",
                    page: LINKS.Home,
                },
            },
        ],
    },
    {
        title: "AI Agents Working Together",
        steps: [
            {
                content: [
                    {
                        type: FormStructureType.Header,
                        color: "primary",
                        id: nanoid(),
                        isCollapsible: false,
                        label: "Understanding Agent Swarms",
                        tag: "h2",
                    },
                    {
                        type: FormStructureType.Header,
                        id: nanoid(),
                        isCollapsible: false,
                        isMarkdown: true,
                        label: "Think of agent swarms like a specialized team where each member has different expertise:",
                        tag: "body1",
                    },
                    {
                        type: FormStructureType.Tip,
                        icon: "Info",
                        id: nanoid(),
                        isMarkdown: true,
                        label: "**Research Agent**: Gathers information and analyzes data",
                    },
                    {
                        type: FormStructureType.Tip,
                        icon: "Info",
                        id: nanoid(),
                        isMarkdown: true,
                        label: "**Planning Agent**: Creates strategies and organizes workflows",
                    },
                    {
                        type: FormStructureType.Tip,
                        icon: "Info",
                        id: nanoid(),
                        isMarkdown: true,
                        label: "**Execution Agent**: Completes tasks and uses tools",
                    },
                    {
                        type: FormStructureType.Tip,
                        icon: "Info",
                        id: nanoid(),
                        isMarkdown: true,
                        label: "**Coordination Agent**: Manages the team and synthesizes results",
                    },
                    {
                        type: FormStructureType.Header,
                        id: nanoid(),
                        isCollapsible: false,
                        isMarkdown: true,
                        label: "**The magic**: They work simultaneously, share knowledge instantly, and produce results no single AI could achieve alone.",
                        tag: "body1",
                    },
                ],
                location: {
                    element: "chat-bubble-tree",
                    page: LINKS.Home,
                },
            },
            {
                content: [
                    {
                        type: FormStructureType.Header,
                        color: "primary",
                        id: nanoid(),
                        isCollapsible: false,
                        label: "Watch agents collaborate",
                        tag: "h3",
                    },
                    {
                        type: FormStructureType.Header,
                        id: nanoid(),
                        isCollapsible: false,
                        isMarkdown: true,
                        label: "When you request something complex, you'll see multiple agents working together in real-time. Each agent contributes their expertise to create a comprehensive solution.",
                        tag: "body1",
                    },
                    {
                        type: FormStructureType.Tip,
                        icon: "Info",
                        id: nanoid(),
                        isMarkdown: true,
                        label: "**Real-time collaboration**: Agents share information and build on each other's work",
                    },
                    {
                        type: FormStructureType.Tip,
                        icon: "Info",
                        id: nanoid(),
                        isMarkdown: true,
                        label: "**Quality improvement**: Multiple perspectives lead to better solutions",
                    },
                ],
                location: {
                    element: "chat-bubble-tree",
                    page: LINKS.Home,
                },
            },
        ],
    },
    {
        title: "Watching Tasks Execute",
        steps: [
            {
                content: [
                    {
                        type: FormStructureType.Header,
                        color: "primary",
                        id: nanoid(),
                        isCollapsible: false,
                        label: "Watch your task come to life",
                        tag: "h2",
                    },
                    {
                        type: FormStructureType.Header,
                        id: nanoid(),
                        isCollapsible: false,
                        isMarkdown: true,
                        label: "When your request requires multiple steps, agents automatically create and execute a routine. You'll see the execution begin immediately.",
                        tag: "body1",
                    },
                    {
                        type: FormStructureType.Tip,
                        icon: "Info",
                        id: nanoid(),
                        isMarkdown: true,
                        label: "**Execution Starting**: Agents are analyzing your request and preparing the routine",
                    },
                ],
                location: {
                    element: "routine-executor",
                    page: LINKS.Home,
                },
            },
            {
                content: [
                    {
                        type: FormStructureType.Header,
                        color: "primary",
                        id: nanoid(),
                        isCollapsible: false,
                        label: "Monitor progress",
                        tag: "h3",
                    },
                    {
                        type: FormStructureType.Header,
                        id: nanoid(),
                        isCollapsible: false,
                        isMarkdown: true,
                        label: "You can monitor task progress in real-time. Agents will ask for your input when needed and keep you updated on their progress.",
                        tag: "body1",
                    },
                    {
                        type: FormStructureType.Tip,
                        icon: "Info",
                        id: nanoid(),
                        isMarkdown: true,
                        label: "**Real-time updates**: See progress as agents work",
                    },
                    {
                        type: FormStructureType.Tip,
                        icon: "Info",
                        id: nanoid(),
                        isMarkdown: true,
                        label: "**Interactive decisions**: Agents will ask for your input when needed",
                    },
                ],
                location: {
                    element: "routine-executor",
                    page: LINKS.Home,
                },
            },
        ],
    },
    {
        title: "Your Profile and Settings",
        steps: [
            {
                action: () => { PubSub.get().publish("menu", { id: ELEMENT_IDS.UserMenu, isOpen: false }); },
                content: [
                    {
                        type: FormStructureType.Header,
                        color: "primary",
                        id: nanoid(),
                        isCollapsible: false,
                        label: "Access your profile",
                        tag: "h2",
                    },
                    {
                        type: FormStructureType.Header,
                        id: nanoid(),
                        isCollapsible: false,
                        isMarkdown: true,
                        label: "Click on your profile picture to access account settings, preferences, and personalization options.",
                        tag: "body1",
                    },
                ],
                location: {
                    element: ELEMENT_IDS.UserMenuProfileIcon,
                },
            },
            {
                action: () => { PubSub.get().publish("menu", { id: ELEMENT_IDS.UserMenu, isOpen: true }); },
                content: [
                    {
                        type: FormStructureType.Header,
                        color: "primary",
                        id: nanoid(),
                        isCollapsible: false,
                        label: "Profile and settings",
                        tag: "h3",
                    },
                    {
                        type: FormStructureType.Header,
                        id: nanoid(),
                        isCollapsible: false,
                        isMarkdown: true,
                        label: "Here you can manage your account, switch between accounts, access settings, and personalize your AI experience.",
                        tag: "body1",
                    },
                    {
                        type: FormStructureType.Tip,
                        icon: "Info",
                        id: nanoid(),
                        isMarkdown: true,
                        label: "**Account switching**: Click on different accounts to switch between them",
                    },
                    {
                        type: FormStructureType.Tip,
                        icon: "Info",
                        id: nanoid(),
                        isMarkdown: true,
                        label: "**Settings**: Customize your AI behavior and preferences",
                    },
                ],
                location: {
                    element: ELEMENT_IDS.UserMenuAccountList,
                },
            },
        ],
    },
    {
        title: "Personalizing Your AI Experience",
        steps: [
            {
                content: [
                    {
                        type: FormStructureType.Header,
                        color: "primary",
                        id: nanoid(),
                        isCollapsible: false,
                        label: "Customize your AI assistant",
                        tag: "h2",
                    },
                    {
                        type: FormStructureType.Header,
                        id: nanoid(),
                        isCollapsible: false,
                        isMarkdown: true,
                        label: "You can personalize how Valyxa and other AI agents interact with you. Access settings to adjust communication style, expertise areas, and behavior preferences.",
                        tag: "body1",
                    },
                    {
                        type: FormStructureType.Tip,
                        icon: "Info",
                        id: nanoid(),
                        isMarkdown: true,
                        label: "**Communication style**: Adjust formality, verbosity, and tone",
                    },
                    {
                        type: FormStructureType.Tip,
                        icon: "Info",
                        id: nanoid(),
                        isMarkdown: true,
                        label: "**Expertise areas**: Focus AI assistance on your specific domains",
                    },
                    {
                        type: FormStructureType.Tip,
                        icon: "Info",
                        id: nanoid(),
                        isMarkdown: true,
                        label: "**Behavior preferences**: Set how proactive or conservative the AI should be",
                    },
                ],
                location: {
                    page: LINKS.Home,
                },
            },
        ],
    },
    {
        title: "Getting Help and Next Steps",
        steps: [
            {
                content: [
                    {
                        type: FormStructureType.Header,
                        color: "primary",
                        id: nanoid(),
                        isCollapsible: false,
                        label: "You're ready to be productive!",
                        tag: "h2",
                    },
                    {
                        type: FormStructureType.Header,
                        id: nanoid(),
                        isCollapsible: false,
                        isMarkdown: true,
                        label: "Congratulations! You now understand the basics of AI-powered productivity with Vrooli. Start by typing what you want to accomplish in the chat.",
                        tag: "body1",
                    },
                    {
                        type: FormStructureType.Divider,
                        id: nanoid(),
                        label: "",
                    },
                    {
                        type: FormStructureType.Tip,
                        icon: "Info",
                        id: nanoid(),
                        isMarkdown: true,
                        label: "**Need help?** Type 'help' in the chat or access the Tutorial again from your profile menu",
                    },
                    {
                        type: FormStructureType.Tip,
                        icon: "Info",
                        id: nanoid(),
                        isMarkdown: true,
                        label: "**Start simple**: Begin with basic requests and gradually try more complex tasks",
                    },
                    {
                        type: FormStructureType.Tip,
                        icon: "Info",
                        id: nanoid(),
                        isMarkdown: true,
                        label: "**Experiment**: The AI learns from your interactions and gets better over time",
                    },
                ],
                location: {
                    page: LINKS.Home,
                },
            },
        ],
];

function getTotalSteps(sections) {
    return sections.reduce((total, section) => total + section.steps.length, 0);
}

function getCurrentStepIndex(sections, place) {
    let stepIndex = 0;
    for (let i = 0; i < place.section; i++) {
        stepIndex += sections[i].steps.length;
    }
    stepIndex += place.step;
    return stepIndex;
}

/**
 * Returns information about the current tutorial step.
 * @param sections - Array of tutorial sections.
 * @param Current section and step index in the tutorial.
 */
export function getTutorialStepInfo(
    sections: TutorialSection[],
    place: Place,
) {
    const section = sections[place.section];
    const nextSection = sections[place.section + 1];

    if (!section || place.step < 0 || place.step >= section.steps.length) {
        return {
            isFinalStep: false,
            isFinalStepInSection: false,
            nextStep: null,
        };
    }

    const isFinalStepInSection = place.step === section.steps.length - 1;
    const isFinalSection = place.section === sections.length - 1;
    const isFinalStep = isFinalStepInSection && isFinalSection;

    const nextStep = isFinalStep
        ? null
        : isFinalStepInSection
            ? nextSection?.steps[0] || null
            : section.steps[place.step + 1];

    return { isFinalStep, isFinalStepInSection, nextStep };
}

export function isValidPlace(sections: TutorialSection[], place: Place) {
    if (!place || typeof place.section !== "number" || typeof place.step !== "number") return false;
    const section = sections[place.section];
    if (!section) return false;
    const step = section.steps[place.step];
    return !!step;
}

export function getNextPlace(
    sections: TutorialSection[],
    place: Place,
): Place | null {
    // Check if place object exists and has valid properties
    if (!place || typeof place.section !== "number" || typeof place.step !== "number") {
        return { section: 0, step: 0 };
    }

    // Check if section is valid
    const currentSection = sections[place.section];
    if (!currentSection) {
        return null; // Invalid section
    }

    // Check if step is valid, if not but section is valid, move to next section
    const currentStep = currentSection.steps[place.step];
    if (!currentStep) {
        const nextSection = sections[place.section + 1];
        if (nextSection && nextSection.steps[0]) {
            return { section: place.section + 1, step: 0 };
        } else {
            return null; // No next section
        }
    }

    // If the step has a specific next place, use that
    if (currentStep.next) return currentStep.next;

    // If current step has exactly one option, use that as next place
    if (currentStep.options?.length === 1) {
        return currentStep.options[0].place;
    }

    // Otherwise follow normal sequential flow
    if (currentSection.steps[place.step + 1]) {
        return { section: place.section, step: place.step + 1 };
    } else {
        const nextSection = sections[place.section + 1];
        if (nextSection && nextSection.steps[0]) {
            return { section: place.section + 1, step: 0 };
        } else {
            return null; // No more steps
        }
    }
}

export function getPrevPlace(
    sections: TutorialSection[],
    place: Place,
): Place | null {
    // Check if place object exists and has valid properties
    if (!place || typeof place.section !== "number" || typeof place.step !== "number") {
        return { section: 0, step: 0 };
    }

    // Check if section is valid
    const currentSection = sections[place.section];
    if (!currentSection) {
        return null; // Invalid section
    }

    // Check if step is valid, if not but section is valid, move to previous section's last step
    const currentStep = currentSection.steps[place.step];
    if (!currentStep) {
        const previousSection = sections[place.section - 1];
        if (previousSection && previousSection.steps.length > 0) {
            const prevStepIndex = previousSection.steps.length - 1;
            return { section: place.section - 1, step: prevStepIndex };
        } else {
            return null; // No previous section
        }
    }

    // If the step has a specific previous place, use that
    if (currentStep.previous) return currentStep.previous;

    // Otherwise follow normal sequential flow
    if (currentSection.steps[place.step - 1]) {
        return { section: place.section, step: place.step - 1 };
    } else {
        const previousSection = sections[place.section - 1];
        if (previousSection && previousSection.steps.length > 0) {
            const prevStepIndex = previousSection.steps.length - 1;
            return { section: place.section - 1, step: prevStepIndex };
        } else {
            return null; // No previous steps
        }
    }
}

export function getCurrentElement(
    sections: TutorialSection[],
    place: Place,
): HTMLElement | null {
    if (!isValidPlace(sections, place)) return null;
    const currentSection = sections[place.section];
    const currentStep = currentSection?.steps[place.step];
    const elementId = currentStep?.location?.element;
    return elementId ? document.getElementById(elementId) : null;
}

export function getCurrentStep(
    sections: TutorialSection[],
    place: Place,
): TutorialStep | null {
    if (!isValidPlace(sections, place)) return null;
    const currentSection = sections[place.section];
    return currentSection?.steps[place.step] || null;
}

const titleId = "tutorial-dialog-title";
/** Poll interval for finding anchor element */
const POLL_INTERVAL_MS = 1000;
const INITIAL_RENDER_DELAY_MS = 100;

const wrongPageDialogTitleStyle = { root: { cursor: "move" } } as const;
const popoverWithArrowStyle = {
    root: {
        zIndex: Z_INDEX.TutorialDialog,
        maxWidth: "500px",
        borderRadius: "12px",
        boxShadow: "0 8px 32px rgba(0, 0, 0, 0.12)",
        overflow: "hidden",
    },
    content: { 
        padding: 0,
        borderRadius: "12px",
    },
} as const;
const sectionMenuSlotProps = {
    root: {
        style: {
            zIndex: Z_INDEX.TutorialDialog + 1,
        },
    },
    paper: {
        style: {
            maxHeight: "60vh",
            width: "320px",
            borderRadius: "12px",
            boxShadow: "0 8px 32px rgba(0, 0, 0, 0.12)",
            marginTop: "8px",
            overflow: "hidden",
        },
    },
} as const;

const SectionTitleBox = styled(Box)(({ theme }) => ({
    display: "flex",
    flexDirection: "row",
    alignItems: "center",
    gap: theme.spacing(1),
    paddingBottom: theme.spacing(2),
    cursor: "pointer",
}));
const StyledStepper = styled(MobileStepper)(({ theme }) => ({
    background: theme.palette.background.default,
    borderTop: `1px solid ${theme.palette.divider}`,
    position: "relative",
    padding: theme.spacing(1, 2),
    "& .MuiMobileStepper-dots": {
        gap: theme.spacing(1),
    },
    "& .MuiMobileStepper-dot": {
        width: 12,
        height: 12,
        margin: "0 2px",
        transition: "all 0.3s ease",
        cursor: "pointer",
        "&:hover": {
            transform: "scale(1.2)",
            backgroundColor: theme.palette.primary.light,
        },
    },
    "& .MuiMobileStepper-dotActive": {
        backgroundColor: theme.palette.primary.main,
        width: 28,
        borderRadius: 6,
        "&:hover": {
            backgroundColor: theme.palette.primary.main,
            transform: "scale(1.1)",
        },
    },
}));

const StyledIconButton = styled(IconButton)(({ theme }) => ({
    transition: "all 0.2s ease",
    "&:hover": {
        backgroundColor: theme.palette.action.hover,
        transform: "scale(1.05)",
    },
}));

const StyledLinearProgress = styled(LinearProgress)(({ theme }) => ({
    height: 4,
    borderRadius: 2,
    backgroundColor: theme.palette.action.hover,
    "& .MuiLinearProgress-bar": {
        borderRadius: 2,
        backgroundColor: theme.palette.secondary.main,
    },
}));

const StyledMenuItem = styled(MenuItem)(({ theme }) => ({
    padding: theme.spacing(1.5, 2),
    borderRadius: theme.spacing(1),
    margin: theme.spacing(0.5, 1),
    "&:hover": {
        backgroundColor: theme.palette.action.hover,
    },
    "&.Mui-selected": {
        backgroundColor: theme.palette.primary.main + "20",
        "&:hover": {
            backgroundColor: theme.palette.primary.main + "30",
        },
    },
}));

const StyledListSubheader = styled(ListSubheader)(({ theme }) => ({
    backgroundColor: "transparent",
    fontSize: "0.75rem",
    fontWeight: 600,
    textTransform: "uppercase",
    letterSpacing: "0.05em",
    color: theme.palette.text.secondary,
    padding: theme.spacing(2, 2.5),
    lineHeight: 1,
}));

const StyledDialog = styled(Dialog)(({ theme }) => ({
    zIndex: Z_INDEX.TutorialDialog,
    pointerEvents: "none",
    "& > .MuiDialog-container": {
        "& > .MuiPaper-root": {
            zIndex: Z_INDEX.TutorialDialog,
            pointerEvents: "auto",
            borderRadius: theme.spacing(2),
            margin: theme.spacing(2),
            maxWidth: "500px",
            background: theme.palette.background.paper,
            position: "absolute",
            top: "0",
            left: "0",
        },
    },
    "& .MuiBackdrop-root": {
        display: "none",
    },
}));

export type TutorialDialogProps = {
    /**
     * When true, bypasses page validation logic.
     * Useful for Storybook stories where URL doesn't match tutorial expectations.
     */
    bypassPageValidation?: boolean;
};

export function TutorialDialog(props: TutorialDialogProps = {}) {
    const { bypassPageValidation = false } = props;

    const { t } = useTranslation();
    const { palette } = useTheme();
    const [location, setLocation] = useLocation();
    const { pathname, search } = location;
    
    // Menu state
    const [isOpen, , close] = useMenu("tutorial");
    const [place, setPlace] = useState<Place>({ section: 0, step: 0 });

    // Parse tutorial parameters from URL
    const urlParams = useMemo(() => parseSearchParams(search), [search]);
    
    useEffect(function initializeFromUrlEffect() {
        const sectionParam = urlParams.tutorial_section;
        const stepParam = urlParams.tutorial_step;
        
        if (sectionParam !== undefined && stepParam !== undefined) {
            const section = parseInt(sectionParam, 10);
            const step = parseInt(stepParam, 10);
            
            if (!isNaN(section) && !isNaN(step)) {
                setPlace({ section, step });
                if (!isOpen) {
                    PubSub.get().publish("menu", { id: ELEMENT_IDS.Tutorial, isOpen: true });
                }
            }
        }
    }, [urlParams.tutorial_section, urlParams.tutorial_step, isOpen]);

    useEffect(function updateUrlEffect() {
        if (isOpen) {
            addSearchParams(setLocation, {
                tutorial_section: place.section.toString(),
                tutorial_step: place.step.toString(),
            });
        }
    }, [isOpen, place, setLocation]);

    const pollIntervalRef = useRef<number>();

    // Manage initial render state to prevent immediate keyboard triggers
    const initialRenderRef = useRef(true);
    const [isInitialRender, setIsInitialRender] = useState(true);

    useEffect(function clearInitialRenderEffect() {
        // Clear the initial render flag after a short delay
        if (isOpen && initialRenderRef.current) {
            const timer = setTimeout(() => {
                initialRenderRef.current = false;
                setIsInitialRender(false);
            }, INITIAL_RENDER_DELAY_MS); // Small delay to avoid the initial Enter keypress
            return () => clearTimeout(timer);
        }
    }, [isOpen]);

    const handleClose = useCallback(function handleCloseCallback() {
        setPlace({ section: 0, step: 0 });
        removeHighlights(TUTORIAL_HIGHLIGHT);
        removeSearchParams(setLocation, ["tutorial_section", "tutorial_step"]);
        close();
        setTimeout(() => {
            setIsInitialRender(true);
            initialRenderRef.current = true;
        }, INITIAL_RENDER_DELAY_MS);
    }, [close, setLocation]);

    useEffect(function triggerStepLoadAction() {
        if (!isOpen || !isValidPlace(sections, place)) return;
        sections[place.section]?.steps[place.step]?.action?.();
    }, [isOpen, place]);

    // Find information about our position in the tutorial
    const {
        isFinalStep,
        isFinalStepInSection,
        nextStep,
    } = useMemo(() => getTutorialStepInfo(sections, place), [place]);

    const totalSteps = getTotalSteps(sections);
    const currentStepIndex = getCurrentStepIndex(sections, place);
    const percentageComplete = Math.round(((currentStepIndex + 1) / totalSteps) * 100);

    const handleNext = useCallback(function handleNextCallback() {
        const nextPlace = getNextPlace(sections, place);
        if (nextPlace) {
            const nextStep = getCurrentStep(sections, nextPlace);
            const nextPage = nextStep?.location?.page;
            if (nextPage && nextPage !== pathname) {
                setLocation(nextPage);
            }
            setPlace(nextPlace);
        } else {
            handleClose();
        }
    }, [pathname, handleClose, place, setLocation]);

    const handlePrev = useCallback(function handlePreviousCallback() {
        const prevPlace = getPrevPlace(sections, place);
        if (prevPlace) {
            const prevStep = getCurrentStep(sections, prevPlace);
            const prevPage = prevStep?.location?.page;
            if (prevPage && prevPage !== pathname) {
                setLocation(prevPage);
            }
            setPlace(prevPlace);
        }
    }, [pathname, place, setLocation]);

    const handleStepDotClick = useCallback(function handleStepDotClickCallback(stepIndex: number) {
        if (stepIndex !== place.step && stepIndex >= 0 && stepIndex < sections[place.section].steps.length) {
            const newPlace = { section: place.section, step: stepIndex };
            const targetStep = getCurrentStep(sections, newPlace);
            const targetPage = targetStep?.location?.page;
            if (targetPage && targetPage !== pathname) {
                setLocation(targetPage);
            }
            setPlace(newPlace);
        }
    }, [pathname, place, setLocation]);

    const handleStepperClick = useCallback(function handleStepperClickCallback(event: React.MouseEvent) {
        const stepper = event.currentTarget;
        const dotsContainer = stepper.querySelector('.MuiMobileStepper-dots');
        if (!dotsContainer) return;

        const dots = dotsContainer.querySelectorAll('.MuiMobileStepper-dot');
        if (dots.length === 0) return;

        const clickX = event.clientX;
        let closestDotIndex = -1;
        let closestDistance = Infinity;

        dots.forEach((dot, index) => {
            const rect = dot.getBoundingClientRect();
            const dotCenterX = rect.left + rect.width / 2;
            const distance = Math.abs(clickX - dotCenterX);
            
            if (distance < closestDistance) {
                closestDistance = distance;
                closestDotIndex = index;
            }
        });

        if (closestDotIndex !== -1) {
            handleStepDotClick(closestDotIndex);
        }
    }, [handleStepDotClick]);

    useHotkeys([
        {
            keys: ["ArrowRight", "l"],
            callback: handleNext,
        },
        {
            keys: ["ArrowLeft", "h"],
            callback: handlePrev,
        },
        {
            keys: ["Enter", " "],
            callback: handleNext,
        },
    ], isOpen && !isInitialRender);

    const anchorElement = useMemo(
        () => getCurrentElement(sections, place),
        [place],
    );
    // Poll for anchor element, since it might not be available yet on initial render
    useEffect(function pollForAnchorElementEffect() {
        if (!isOpen || anchorElement) {
            // Clear interval if dialog is closed, element is found, or polling is disabled
            if (pollIntervalRef.current) {
                window.clearInterval(pollIntervalRef.current);
                pollIntervalRef.current = undefined;
            }
            return;
        }

        // Start polling if element is not found
        pollIntervalRef.current = window.setInterval(() => {
            const element = getCurrentElement(sections, place);
            if (element) {
                // Found the element, clear polling
                window.clearInterval(pollIntervalRef.current!);
                pollIntervalRef.current = undefined;
            }
        }, POLL_INTERVAL_MS);

        // Clean up on unmount
        return () => {
            if (pollIntervalRef.current) {
                window.clearInterval(pollIntervalRef.current);
                pollIntervalRef.current = undefined;
            }
        };
    }, [isOpen, anchorElement, place]);

    // Store anchor element ref for comparison  
    const anchorElementRef = useRef(anchorElement);
    useEffect(function updateAnchorElementRef() {
        anchorElementRef.current = anchorElement;
    }, [anchorElement]);

    // Add highlighting to the anchor element
    useEffect(function highlightAnchorElementEffect() {
        if (!isOpen || !anchorElement) return;
        addHighlight(anchorElement, TUTORIAL_HIGHLIGHT);
        return () => removeHighlights(TUTORIAL_HIGHLIGHT);
    }, [isOpen, anchorElement]);

    // Handle section menu
    const [sectionMenuAnchorEl, handleSectionMenuOpen, handleSectionMenuClose, isSectionMenuOpen] = usePopover();
    const handleSectionSelect = useCallback(function handleSectionSelectCallback(sectionIndex: number) {
        const updatedPlace = { section: sectionIndex, step: 0 };
        setPlace(updatedPlace);
        handleSectionMenuClose();
        
        // Navigate to the correct page for the selected section
        const section = sections[updatedPlace.section];
        const firstStep = section.steps[0];
        const page = firstStep?.location?.page;
        if (page && page !== pathname) {
            setLocation(page);
        }
    }, [handleSectionMenuClose, pathname, setLocation]);

    const content = useMemo(() => {
        // Don't render if not open or position is invalid
        if (!isOpen || !isValidPlace(sections, place)) return null;
        
        const currentSection = sections[place.section];
        if (!currentSection) return null;
        
        const currentStep = currentSection.steps[place.step];
        if (!currentStep) return null;

        // Check if we need to handle page navigation
        const correctPage = currentStep.location?.page;
        if (correctPage && !bypassPageValidation) {
            // Parse current and expected URLs to compare
            const currentURL = new URL(window.location.href);
            const correctURL = new URL(correctPage, window.location.origin);
            
            // Compare pathnames
            const isPathnameDifferent = pathname !== correctURL.pathname;
            
            // Compare search parameters (ignoring tutorial parameters)
            const correctParams = new URLSearchParams(correctURL.search);
            const currentParams = new URLSearchParams(search);
            // Remove tutorial params for comparison
            correctParams.delete("tutorial_section");
            correctParams.delete("tutorial_step");
            currentParams.delete("tutorial_section");
            currentParams.delete("tutorial_step");
            
            const isQueryParamsDifferent = correctParams.toString() !== currentParams.toString();
            
            const isOnWrongPage = !bypassPageValidation && (isPathnameDifferent || isQueryParamsDifferent);

            // Handle wrong page case - currently disabled per user request
            // TODO: Re-enable with proper bypass logic
            /*
            if (isOnWrongPage) {
                return (
                    <ContentWrapper>
                        <DialogTitle
                            id={titleId}
                            title={"Wrong Page"}
                            onClose={handleClose}
                            variant="subheader"
                            sxs={wrongPageDialogTitleStyle}
                        />
                        <Box className="content">
                            <Stack direction="column" spacing={2} p={2}>
                                <MarkdownDisplay
                                    variant="body1"
                                    content={"Please return to the correct page to continue the tutorial."}
                                />
                                <Button
                                    fullWidth
                                    variant="contained"
                                    color="primary"
                                    onClick={toCorrectPage}
                                >
                                    Continue
                                </Button>
                            </Stack>
                        </Box>
                    </ContentWrapper>
                );
            }
            */
            
        }

        // Otherwise, show the current step
        const dialogTitleStyle = { root: { cursor: anchorElement ? "auto" : "move" } } as const; // Can only drag dialogs, not popovers
        const stepFormSchema = {
            containers: [{
                direction: "column",
                disableCollapse: true,
                totalItems: currentStep.content.length,
            }],
            elements: currentStep.content,
        } as const;
        return (
            <ContentWrapper>
                <DialogTitle
                    id={titleId}
                    title={t("Tutorial")}
                    onClose={handleClose}
                    variant="subheader"
                    sxs={dialogTitleStyle}
                />
                <Box className="content">
                    <SectionTitleBox onClick={handleSectionMenuOpen}>
                        <Typography 
                            variant="h6" 
                            component="h2" 
                            sx={{ 
                                fontWeight: 600,
                                flex: 1,
                            }}
                        >
                            {currentSection.title}
                        </Typography>
                        <StyledIconButton 
                            edge="end" 
                            size="small"
                            sx={{ ml: 1 }}
                        >
                            {
                                isSectionMenuOpen ?
                                    <IconCommon name="ExpandLess" fill={palette.background.textPrimary} /> :
                                    <IconCommon name="ExpandMore" fill={palette.background.textPrimary} />
                            }
                        </StyledIconButton>
                    </SectionTitleBox>
                    <Menu
                        id="section-menu"
                        anchorEl={sectionMenuAnchorEl}
                        open={isSectionMenuOpen}
                        onClose={handleSectionMenuClose}
                        slotProps={sectionMenuSlotProps}
                    >
                        <StyledListSubheader>
                            Jump to Section
                        </StyledListSubheader>
                        <Box sx={{ p: 1 }}>
                            {sections.filter((section) => !section.hideFromMenu).map((section, index) => {
                                function handleSectionSelectCallback() {
                                    handleSectionSelect(index);
                                }

                                const currentStepInSection = index === place.section ? place.step + 1 : 0;
                                const totalStepsInSection = section.steps.length;

                                const isCompleted = index < place.section;
                                const isCurrent = index === place.section;

                                return (
                                    <StyledMenuItem
                                        key={index}
                                        onClick={handleSectionSelectCallback}
                                        selected={isCurrent}
                                    >
                                        <Box sx={{ 
                                            display: "flex", 
                                            alignItems: "center", 
                                            gap: 2, 
                                            width: "100%",
                                        }}>
                                            <Box
                                                sx={{
                                                    width: 24,
                                                    height: 24,
                                                    borderRadius: "50%",
                                                    display: "flex",
                                                    alignItems: "center",
                                                    justifyContent: "center",
                                                    fontSize: "0.75rem",
                                                    fontWeight: 600,
                                                    backgroundColor: isCompleted 
                                                        ? palette.success.main 
                                                        : isCurrent 
                                                            ? palette.primary.main 
                                                            : palette.action.hover,
                                                    color: isCompleted || isCurrent 
                                                        ? palette.primary.contrastText 
                                                        : palette.text.secondary,
                                                    position: "relative",
                                                    "&::before": index > 0 ? {
                                                        content: '""',
                                                        position: "absolute",
                                                        top: -16,
                                                        left: "50%",
                                                        transform: "translateX(-50%)",
                                                        width: 2,
                                                        height: 16,
                                                        backgroundColor: isCompleted 
                                                            ? palette.success.main 
                                                            : palette.divider,
                                                    } : {},
                                                }}
                                            >
                                                {isCompleted ? (
                                                    <IconCommon 
                                                        name="Complete" 
                                                        size={14} 
                                                        fill={palette.primary.contrastText}
                                                    />
                                                ) : (
                                                    index + 1
                                                )}
                                            </Box>
                                            <Box sx={{ flex: 1 }}>
                                                <Typography variant="body2" sx={{ fontWeight: 500 }}>
                                                    {section.title}
                                                </Typography>
                                                <Typography variant="caption" color="text.secondary">
                                                    {isCurrent 
                                                        ? `${currentStepInSection}/${totalStepsInSection}` 
                                                        : `${totalStepsInSection} step${totalStepsInSection !== 1 ? 's' : ''}`
                                                    }
                                                </Typography>
                                            </Box>
                                        </Box>
                                    </StyledMenuItem>
                                );
                            })}
                        </Box>
                    </Menu>
                    <FormRunView
                        disabled={true}
                        schema={stepFormSchema}
                    />
                    {/* Display redirect options if available */}
                    {currentStep.options && currentStep.options.length > 1 && (
                        <Box mt={3}>
                            <Typography 
                                variant="subtitle2" 
                                sx={{ 
                                    mb: 2, 
                                    fontWeight: 600,
                                    color: palette.text.secondary,
                                    textTransform: "uppercase",
                                    letterSpacing: 1.2,
                                    fontSize: "0.75rem",
                                }}
                            >
                                Choose your path
                            </Typography>
                            <List sx={{ p: 0 }}>
                                {currentStep.options.map((option, index) => {
                                    function handleOptionSelect() {
                                        setPlace(option.place);
                                        const page = sections[option.place.section].steps[0].location?.page;
                                        if (page && page !== pathname) {
                                            setLocation(page);
                                        }
                                    }

                                    return (
                                        <ListItem
                                            key={index}
                                            button
                                            onClick={handleOptionSelect}
                                            sx={{
                                                borderRadius: 1,
                                                mb: 1,
                                                border: `1px solid ${palette.divider}`,
                                                "&:hover": {
                                                    backgroundColor: palette.action.hover,
                                                },
                                            }}
                                        >
                                            <ListItemText
                                                primary={
                                                    <Typography 
                                                        sx={{
                                                            fontWeight: 500,
                                                            color: palette.mode === "light" ? palette.primary.main : palette.primary.light,
                                                            display: "flex",
                                                            alignItems: "center",
                                                            gap: 1,
                                                        }}
                                                    >
                                                        <IconCommon 
                                                            name="ArrowRight" 
                                                            fill={palette.mode === "light" ? palette.primary.main : palette.primary.light}
                                                            style={{ width: 16, height: 16 }}
                                                        />
                                                        {option.label}
                                                    </Typography>
                                                }
                                            />
                                        </ListItem>
                                    );
                                })}
                            </List>
                        </Box>
                    )}
                </Box>
                <StyledStepper
                    className="stepper"
                    variant="dots"
                    steps={currentSection.steps.length}
                    activeStep={place.step}
                    onClick={handleStepperClick}
                    backButton={
                        <StyledIconButton
                            onClick={handlePrev}
                            disabled={place.section === 0 && place.step === 0}
                            size="small"
                        >
                            <IconCommon name="ArrowLeft" />
                        </StyledIconButton>
                    }
                    nextButton={
                        <StyledIconButton
                            onClick={handleNext}
                            size="small"
                            color={isFinalStep ? "success" : "primary"}
                        >
                            {isFinalStep ? <IconCommon name="CompleteAll" /> : isFinalStepInSection ? <IconCommon name="Complete" /> : <IconCommon name="ArrowRight" />}
                        </StyledIconButton>
                    }
                />
                <StyledLinearProgress variant="determinate" value={percentageComplete} />
            </ContentWrapper>
        );
    }, [place, anchorElement, t, handleClose, handleSectionMenuOpen, isSectionMenuOpen, palette.background.textPrimary, palette.mode, sectionMenuAnchorEl, handleSectionMenuClose, handlePrev, handleNext, handleStepperClick, isFinalStep, isFinalStepInSection, percentageComplete, setLocation, pathname, search, handleSectionSelect, bypassPageValidation]);

    useEffect(function autoAdvanceOnCorrectNavigationEffect() {
        if (!isValidPlace(sections, place)) return;
        const currentSection = sections[place.section];
        if (!currentSection || !currentSection.steps[place.step]) {
            PubSub.get().publish("snack", { message: "Failed to load tutorial", severity: "Error" });
            return;
        }
        const currentStep = currentSection.steps[place.step];
        // Find current step's page
        const currPage = currentStep.location?.page;
        // If already on the correct page, return
        if (currPage && currPage === pathname) return;
        // Otherwise, check if we should advance
        const nextPlace = getNextPlace(sections, place);
        if (!nextPlace) return;
        const nextStep = getCurrentStep(sections, nextPlace);
        const nextPage = nextStep?.location?.page;
        if (nextPage && nextPage === pathname) {
            setPlace(nextPlace);
        }
    }, [pathname, place]);

    const ContentWrapper = anchorElement ? Paper : React.Fragment;
    const DraggableDialogPaper = useCallback(function DraggableDialogPaperCallback(props: PaperProps) {
        return (
            <Draggable handle={`#${titleId}`} cancel={'[class*="MuiDialogContent-root"]'}>
                <Paper {...props} />
            </Draggable>
        );
    }, []);

    if (!isOpen) return null;

    return (
        <>
            {anchorElement ? (
                <PopoverWithArrow
                    open={!!anchorElement}
                    anchorEl={anchorElement}
                    disableScrollLock={true}
                    sxs={popoverWithArrowStyle}
                >
                    {content}
                </PopoverWithArrow>
            ) : (
                <StyledDialog
                    open={isOpen}
                    scroll="paper"
                    disableScrollLock={true}
                    aria-labelledby={titleId}
                    PaperComponent={DraggableDialogPaper}
                >
                    {content}
                </StyledDialog>
            )}
        </>
    );
}
                        isMarkdown: true,
                        label: "In this example, we're showing off the form-building capabilities of routines.",
                        tag: "body1",
                    },
                    {
                        type: FormStructureType.Header,
                        color: "secondary",
                        id: nanoid(),
                        isCollapsible: false,
                        isMarkdown: true,
                        label: "Typically, basic routines like this one are created as part of a multi-step routine. They're important for collecting information to use in later steps.",
                        tag: "body2",
                    },
                ],
                location: {
                    page: getObjectUrl({ __typename: "Resource", publicId: SEEDED_PUBLIC_IDS.ProjectKickoffChecklist } as const),
                },
                previous: { section: 4, step: 2 },
            },
            {
                content: [
                    {
                        type: FormStructureType.Header,
                        color: "primary",
                        id: nanoid(),
                        isCollapsible: false,
                        isMarkdown: true,
                        label: "Here is some general information about the routine, such as its completion status and owner.",
                        tag: "body1",
                    },
                    {
                        type: FormStructureType.Divider,
                        id: nanoid(),
                        label: "",
                    },
                    {
                        type: FormStructureType.Tip,
                        icon: "Info",
                        id: nanoid(),
                        label: "Press on the owner's name to view their profile",
                    },
                ],
                location: {
                    element: ELEMENT_IDS.RelationshipList,
                    page: getObjectUrl({ __typename: "Resource", publicId: SEEDED_PUBLIC_IDS.ProjectKickoffChecklist } as const),
                },
            },
            {
                content: [
                    {
                        type: FormStructureType.Header,
                        color: "primary",
                        id: nanoid(),
                        isCollapsible: false,
                        isMarkdown: true,
                        label: "Here are relevant links and resources for the routine.",
                        tag: "body1",
                    },
                ],
                location: {
                    element: ELEMENT_IDS.ResourceCards,
                    page: getObjectUrl({ __typename: "Resource", publicId: SEEDED_PUBLIC_IDS.ProjectKickoffChecklist } as const),
                },
            },
            {
                content: [
                    {
                        type: FormStructureType.Header,
                        color: "primary",
                        id: nanoid(),
                        isCollapsible: false,
                        isMarkdown: true,
                        label: "Here is the form that is filled out when running the routine.",
                        tag: "body1",
                    },
                    {
                        type: FormStructureType.Header,
                        color: "secondary",
                        id: nanoid(),
                        isCollapsible: false,
                        isMarkdown: true,
                        label: "All of the text and input components you see here (and more!) can be added to your own routines.",
                        tag: "body2",
                    },
                ],
                location: {
                    element: ELEMENT_IDS.RoutineTypeForm,
                    page: getObjectUrl({ __typename: "Resource", publicId: SEEDED_PUBLIC_IDS.ProjectKickoffChecklist } as const),
                },
                next: { section: 4, step: 2 },
            },
        ],
    },
    {
        hideFromMenu: true,
        title: "Routine - Workout Plan Generator",
        steps: [
            {
                content: [
                    {
                        type: FormStructureType.Header,
                        color: "primary",
                        id: nanoid(),
                        isCollapsible: false,
                        isMarkdown: true,
                        label: "In this example, we're showcasing the AI generation capabilities of routines.",
                        tag: "body1",
                    },
                    {
                        type: FormStructureType.Header,
                        color: "secondary",
                        id: nanoid(),
                        isCollapsible: false,
                        isMarkdown: true,
                        label: "\"Generate\" routines use the inputs you provide to produce an output.",
                        tag: "body2",
                    },
                    {
                        type: FormStructureType.Divider,
                        id: nanoid(),
                        label: "",
                    },
                    {
                        type: FormStructureType.Tip,
                        icon: "Warning",
                        id: nanoid(),
                        label: "We currently support only text inputs and outputs. This will be expanded in the future.",
                    },

                ],
                location: {
                    page: getObjectUrl({ __typename: "Resource", publicId: SEEDED_PUBLIC_IDS.WorkoutPlanGenerator } as const),
                },
                previous: { section: 4, step: 2 },
            },
            {
                content: [
                    {
                        type: FormStructureType.Header,
                        color: "primary",
                        id: nanoid(),
                        isCollapsible: false,
                        isMarkdown: true,
                        label: "Here is some general information about the routine, such as its completion status and owner.",
                        tag: "body1",
                    },
                    {
                        type: FormStructureType.Divider,
                        id: nanoid(),
                        label: "",
                    },
                    {
                        type: FormStructureType.Tip,
                        icon: "Info",
                        id: nanoid(),
                        label: "Press on the owner's name to view their profile.",
                    },
                ],
                location: {
                    element: ELEMENT_IDS.RelationshipList,
                    page: getObjectUrl({ __typename: "Resource", publicId: SEEDED_PUBLIC_IDS.WorkoutPlanGenerator } as const),
                },
            },
            {
                content: [
                    {
                        type: FormStructureType.Header,
                        color: "primary",
                        id: nanoid(),
                        isCollapsible: false,
                        isMarkdown: true,
                        label: "You can choose the AI model and bot style for generating the output.",
                        tag: "body1",
                    },
                    {
                        type: FormStructureType.Tip,
                        icon: "Info",
                        id: nanoid(),
                        label: "Selecting different bots or styles can significantly affect the generated output.",
                    },
                ],
                location: {
                    element: ELEMENT_IDS.RoutineGenerateSettings,
                    page: getObjectUrl({ __typename: "Resource", publicId: SEEDED_PUBLIC_IDS.WorkoutPlanGenerator } as const),
                },
            },
            {
                content: [
                    {
                        type: FormStructureType.Header,
                        color: "primary",
                        id: nanoid(),
                        isCollapsible: false,
                        isMarkdown: true,
                        label: "Here is the form that is filled out when running the routine.",
                        tag: "body1",
                    },
                    {
                        type: FormStructureType.Header,
                        color: "secondary",
                        id: nanoid(),
                        isCollapsible: false,
                        isMarkdown: true,
                        label: "The inputs you provide here will be used by the AI to generate a personalized workout plan.",
                        tag: "body2",
                    },
                ],
                location: {
                    element: `input-${ELEMENT_IDS.FormRunView}`,
                    page: getObjectUrl({ __typename: "Resource", publicId: SEEDED_PUBLIC_IDS.WorkoutPlanGenerator } as const),
                },
                next: { section: 4, step: 2 },
            },
        ],
    },
    {
        hideFromMenu: true,
        title: "Routine - Fiction Book Writer",
        steps: [],//TODO
    },
    {
        hideFromMenu: true,
        title: "Routine - Create Reminder",
        steps: [],//TODO
    },
    {
        hideFromMenu: true,
        title: "Routine - Plaintext to JSON Converter",
        steps: [],//TODO
    },
    {
        title: "Site Navigator Menu",
        steps: [
            {
                action: () => { PubSub.get().publish("menu", { id: ELEMENT_IDS.LeftDrawer, isOpen: false }); },
                content: [
                    {
                        type: FormStructureType.Header,
                        color: "primary",
                        id: nanoid(),
                        isCollapsible: false,
                        isMarkdown: true,
                        label: "Open the navigation menu by pressing the list icon.",
                        tag: "body1",
                    },
                ],
                location: {
                    element: ELEMENT_IDS.SiteNavigatorMenuIcon,
                    page: LINKS.Search,
                },
                previous: { section: 4, step: 2 },
            },
        ],
    },
    // {
    //     title: "Informational Routine",
    //     steps: [],//TODO
    // },
    // {
    //     title: "Action Routine",
    //     steps: [],//TODO
    // },
    // {
    //     title: "Code Routine",
    //     steps: [],//TODO
    // },
    // {
    //     title: "Multi-step Routine",
    //     steps: [],//TODO
    // },
    // //TODO add sections for projects and teams maybe
    // {
    //     title: "Other Objects",
    //     steps: [],//TODO should replace "Create Objects"
    // },
    // {
    //     title: "Creating Objects",
    //     steps: [
    //         {
    //             content: {
    //                 text: "This page allows you to create new objects on Vrooli.",
    //             },
    //             location: {
    //                 page: LINKS.Create,
    //             },
    //         },
    //     ],
    // },
    // {
    //     title: "Your Stuff",
    //     steps: [
    //         {
    //             content: {
    //                 text: "After you've created an object, you can find it here.",
    //             },
    //             location: {
    //                 page: LINKS.MyStuff,
    //             },
    //         },
    //         {
    //             content: {
    //                 text: "Just like the search page, you can use these tabs to switch between different types of objects.",
    //             },
    //             location: {
    //                 element: ELEMENT_IDS.MyStuffTabs,
    //                 page: LINKS.MyStuff,
    //             },
    //         },
    //     ],
    // },
    // {
    //     title: "Inbox",
    //     steps: [
    //         {
    //             content: {
    //                 text: "This page allows you to view your messages and notifications.\n\nIf you have a premium account, you can message bots and have them run tasks and perform other actions for you.",
    //             },
    //             location: {
    //                 page: LINKS.Inbox,
    //             },
    //         },
    //     ],
    // },
    // {
    //     title: "That's it!",
    //     steps: [
    //         {
    //             content: {
    //                 text: "Now you know the basics of Vrooli. Have fun!",
    //             },
    //         },
    //         // TODO add suggested next steps, like buying premium/credits, creating a team, etc.
    //     ],
    // },
];

function getTotalSteps(sections) {
    return sections.reduce((total, section) => total + section.steps.length, 0);
}

function getCurrentStepIndex(sections, place) {
    let stepIndex = 0;
    for (let i = 0; i < place.section; i++) {
        stepIndex += sections[i].steps.length;
    }
    stepIndex += place.step;
    return stepIndex;
}

/**
 * Returns information about the current tutorial step.
 * @param sections - Array of tutorial sections.
 * @param Current section and step index in the tutorial.
 */
export function getTutorialStepInfo(
    sections: TutorialSection[],
    place: Place,
) {
    const section = sections[place.section];
    const nextSection = sections[place.section + 1];

    if (!section || place.step < 0 || place.step >= section.steps.length) {
        return {
            isFinalStep: false,
            isFinalStepInSection: false,
            nextStep: null,
        };
    }

    const isFinalStepInSection = place.step === section.steps.length - 1;
    const isFinalSection = place.section === sections.length - 1;
    const isFinalStep = isFinalStepInSection && isFinalSection;

    const nextStep = isFinalStep
        ? null
        : isFinalStepInSection
            ? nextSection?.steps[0] || null
            : section.steps[place.step + 1];

    return { isFinalStep, isFinalStepInSection, nextStep };
}

export function isValidPlace(sections: TutorialSection[], place: Place) {
    if (!place || typeof place.section !== "number" || typeof place.step !== "number") return false;
    const section = sections[place.section];
    if (!section) return false;
    const step = section.steps[place.step];
    return !!step;
}

export function getNextPlace(
    sections: TutorialSection[],
    place: Place,
): Place | null {
    // Check if place object exists and has valid properties
    if (!place || typeof place.section !== "number" || typeof place.step !== "number") {
        return { section: 0, step: 0 };
    }

    // Check if section is valid
    const currentSection = sections[place.section];
    if (!currentSection) {
        return null; // Invalid section
    }

    // Check if step is valid, if not but section is valid, move to next section
    const currentStep = currentSection.steps[place.step];
    if (!currentStep) {
        const nextSection = sections[place.section + 1];
        if (nextSection && nextSection.steps[0]) {
            return { section: place.section + 1, step: 0 };
        } else {
            return null; // No next section
        }
    }

    // If the step has a specific next place, use that
    if (currentStep.next) return currentStep.next;

    // If current step has exactly one option, use that as next place
    if (currentStep.options?.length === 1) {
        return currentStep.options[0].place;
    }

    // Otherwise follow normal sequential flow
    if (currentSection.steps[place.step + 1]) {
        return { section: place.section, step: place.step + 1 };
    } else {
        const nextSection = sections[place.section + 1];
        if (nextSection && nextSection.steps[0]) {
            return { section: place.section + 1, step: 0 };
        } else {
            return null; // No more steps
        }
    }
}

export function getPrevPlace(
    sections: TutorialSection[],
    place: Place,
): Place | null {
    // Check if place object exists and has valid properties
    if (!place || typeof place.section !== "number" || typeof place.step !== "number") {
        return { section: 0, step: 0 };
    }

    // Check if section is valid
    const currentSection = sections[place.section];
    if (!currentSection) {
        return null; // Invalid section
    }

    // Check if step is valid, if not but section is valid, move to previous section's last step
    const currentStep = currentSection.steps[place.step];
    if (!currentStep) {
        const previousSection = sections[place.section - 1];
        if (previousSection && previousSection.steps.length > 0) {
            const prevStepIndex = previousSection.steps.length - 1;
            return { section: place.section - 1, step: prevStepIndex };
        } else {
            return null; // No previous section
        }
    }

    // If the step has a specific previous place, use that
    if (currentStep.previous) return currentStep.previous;

    // Otherwise follow normal sequential flow
    if (currentSection.steps[place.step - 1]) {
        return { section: place.section, step: place.step - 1 };
    } else {
        const previousSection = sections[place.section - 1];
        if (previousSection && previousSection.steps.length > 0) {
            const prevStepIndex = previousSection.steps.length - 1;
            return { section: place.section - 1, step: prevStepIndex };
        } else {
            return null; // No previous steps
        }
    }
}

export function getCurrentElement(
    sections: TutorialSection[],
    place: Place,
): HTMLElement | null {
    if (!isValidPlace(sections, place)) return null;
    const currentSection = sections[place.section];
    const currentStep = currentSection?.steps[place.step];
    const elementId = currentStep?.location?.element;
    return elementId ? document.getElementById(elementId) : null;
}

export function getCurrentStep(
    sections: TutorialSection[],
    place: Place,
): TutorialStep | null {
    if (!isValidPlace(sections, place)) return null;
    const currentSection = sections[place.section];
    return currentSection?.steps[place.step] || null;
}

const titleId = "tutorial-dialog-title";
/** Poll interval for finding anchor element */
const POLL_INTERVAL_MS = 1000;
const INITIAL_RENDER_DELAY_MS = 100;

const wrongPageDialogTitleStyle = { root: { cursor: "move" } } as const;
const popoverWithArrowStyle = {
    root: {
        zIndex: Z_INDEX.TutorialDialog,
        maxWidth: "500px",
        borderRadius: "12px",
        boxShadow: "0 8px 32px rgba(0, 0, 0, 0.12)",
        overflow: "hidden",
    },
    content: { 
        padding: 0,
        borderRadius: "12px",
    },
} as const;
const sectionMenuSlotProps = {
    root: {
        style: {
            zIndex: Z_INDEX.TutorialDialog + 1,
        },
    },
    paper: {
        style: {
            maxHeight: "60vh",
            width: "320px",
            borderRadius: "12px",
            boxShadow: "0 8px 32px rgba(0, 0, 0, 0.12)",
            marginTop: "8px",
            overflow: "hidden",
        },
    },
} as const;

function DraggableDialogPaper(props: PaperProps) {
    return (
        <Draggable
            handle={`#${titleId}`}
            cancel={"[class*=\"MuiDialogContent-root\"]"}
        >
            <Paper {...props} />
        </Draggable>
    );
}

const ContentWrapper = styled(Box)(({ theme }) => ({
    display: "flex",
    flexDirection: "column",
    height: "100%",
    background: theme.palette.background.paper,
    borderRadius: theme.shape.borderRadius,
    overflow: "hidden",
    "& .content": {
        flex: 1,
        overflowY: "auto",
        padding: theme.spacing(3),
        // Smooth scrollbar styling
        "&::-webkit-scrollbar": {
            width: "8px",
        },
        "&::-webkit-scrollbar-track": {
            background: theme.palette.action.hover,
            borderRadius: "4px",
        },
        "&::-webkit-scrollbar-thumb": {
            background: theme.palette.action.selected,
            borderRadius: "4px",
            "&:hover": {
                background: theme.palette.action.disabled,
            },
        },
    },
    "& .stepper": {
        flexShrink: 0,
        borderTop: `1px solid ${theme.palette.divider}`,
        background: theme.palette.background.default,
    },
}));
const SectionTitleBox = styled(Box)(({ theme }) => ({
    display: "flex",
    flexDirection: "row",
    alignItems: "center",
    gap: theme.spacing(1),
    paddingBottom: theme.spacing(2),
    cursor: "pointer",
}));
const StyledStepper = styled(MobileStepper)(({ theme }) => ({
    background: theme.palette.background.default,
    borderTop: `1px solid ${theme.palette.divider}`,
    position: "relative",
    padding: theme.spacing(1, 2),
    "& .MuiMobileStepper-dots": {
        gap: theme.spacing(1),
    },
    "& .MuiMobileStepper-dot": {
        width: 12,
        height: 12,
        margin: "0 2px",
        transition: "all 0.3s ease",
        cursor: "pointer",
        "&:hover": {
            transform: "scale(1.2)",
            backgroundColor: theme.palette.primary.light,
        },
    },
    "& .MuiMobileStepper-dotActive": {
        backgroundColor: theme.palette.primary.main,
        width: 28,
        borderRadius: 6,
        "&:hover": {
            backgroundColor: theme.palette.primary.main,
            transform: "scale(1.1)",
        },
    },
}));

const StyledIconButton = styled(IconButton)(({ theme }) => ({
    transition: "all 0.2s ease",
    "&:hover": {
        transform: "scale(1.1)",
        backgroundColor: theme.palette.action.hover,
    },
    "&:disabled": {
        opacity: 0.3,
    },
}));

const StyledLinearProgress = styled(LinearProgress)(({ theme }) => ({
    height: 3,
    backgroundColor: theme.palette.action.disabledBackground,
    "& .MuiLinearProgress-bar": {
        backgroundColor: theme.palette.secondary.main,
        borderRadius: 3,
    },
}));

const StyledListItem = styled(ListItem)(({ theme }) => ({
    borderRadius: theme.spacing(1),
    marginBottom: theme.spacing(1),
    transition: "all 0.2s ease",
    cursor: "pointer",
    "&:hover": {
        backgroundColor: theme.palette.action.hover,
        transform: "translateX(8px)",
    },
    "& .MuiListItemText-primary": {
        display: "flex",
        alignItems: "center",
        gap: theme.spacing(1),
    },
}));

const StyledMenuItem = styled(MenuItem)(({ theme }) => ({
    padding: theme.spacing(1.5, 2),
    minHeight: 48,
    position: "relative",
    "&.Mui-selected": {
        backgroundColor: theme.palette.action.selected,
        fontWeight: 600,
        "&:hover": {
            backgroundColor: theme.palette.action.selected,
        },
    },
    "&:hover": {
        backgroundColor: theme.palette.action.hover,
    },
    "& .section-number": {
        display: "inline-flex",
        alignItems: "center",
        justifyContent: "center",
        width: 28,
        height: 28,
        borderRadius: "50%",
        backgroundColor: theme.palette.background.paper,
        border: `2px solid ${theme.palette.divider}`,
        color: theme.palette.text.primary,
        fontWeight: 700,
        fontSize: "0.875rem",
        marginRight: theme.spacing(1.5),
        position: "relative",
        zIndex: 2,
    },
    "&.Mui-selected .section-number": {
        backgroundColor: theme.palette.primary.main,
        borderColor: theme.palette.primary.main,
        color: theme.palette.primary.contrastText,
    },
    // Vertical line connecting the circles - positioned to center of circle
    "&:not(:last-child)::before": {
        content: '""',
        position: "absolute",
        left: "27px", // center of 28px circle (14px) + 16px padding - 1px for centering
        top: "40px", // below the circle 
        height: "24px", // connect to next item
        width: "2px",
        backgroundColor: theme.palette.text.disabled,
        zIndex: 1,
    },
    "&.Mui-selected:not(:last-child)::before": {
        backgroundColor: theme.palette.primary.main,
    },
    // Completed sections
    "&.completed .section-number": {
        backgroundColor: theme.palette.success.main,
        borderColor: theme.palette.success.main,
        color: "white",
    },
    "&.completed:not(:last-child)::before": {
        backgroundColor: `${theme.palette.success.main} !important`,
    },
}));

const StyledListSubheader = styled(ListSubheader)(({ theme }) => ({
    backgroundColor: theme.palette.background.paper,
    borderBottom: `1px solid ${theme.palette.divider}`,
    fontWeight: 700,
    fontSize: "0.875rem",
    textTransform: "uppercase",
    letterSpacing: "0.05em",
    color: theme.palette.text.secondary,
    padding: theme.spacing(2, 2.5),
    lineHeight: 1,
}));

const StyledDialog = styled(Dialog)(({ theme }) => ({
    zIndex: Z_INDEX.TutorialDialog,
    pointerEvents: "none",
    "& > .MuiDialog-container": {
        "& > .MuiPaper-root": {
            zIndex: Z_INDEX.TutorialDialog,
            pointerEvents: "auto",
            borderRadius: theme.spacing(2),
            margin: theme.spacing(2),
            maxWidth: "500px",
            background: theme.palette.background.paper,
            position: "absolute",
            top: "0",
            left: "0",
        },
    },
    "& .MuiBackdrop-root": {
        display: "none",
    },
}));

export type TutorialDialogProps = {
    /**
     * When true, bypasses page validation logic.
     * Useful for Storybook stories where URL structure differs from production.
     */
    bypassPageValidation?: boolean;
};

export function TutorialDialog(props: TutorialDialogProps = {}) {
    const { bypassPageValidation = false } = props;
    const { breakpoints, palette } = useTheme();
    const { t } = useTranslation();
    const [{ pathname, search }, setLocation] = useLocation();
    const [place, setPlace] = useState<Place>({ section: 0, step: 0 });

    // Debug logging
    if (process.env.NODE_ENV !== "production") {
        console.log("TutorialDialog props:", { bypassPageValidation, props });
    }
    const isMobile = useWindowSize(({ width }) => width <= breakpoints.values.md);

    // Handle opening and closing
    const onEvent = useCallback(function onEventCallback({ data }: MenuPayloads[typeof ELEMENT_IDS.Tutorial]) {
        if (!data) return;
        // Add data here
    }, []);
    const { isOpen, close } = useMenu({
        id: ELEMENT_IDS.Tutorial,
        isMobile,
        onEvent,
    });

    useEffect(function initializePlaceEffect() {
        const searchParams = UrlTools.parseSearchParams("Tutorial");
        const section = searchParams.tutorial_section ? parseInt(searchParams.tutorial_section + "", 10) : undefined;
        const step = searchParams.tutorial_step ? parseInt(searchParams.tutorial_step + "", 10) : undefined;
        // If we have a valid place, open the dialog (if not already open)
        if (section !== undefined && step !== undefined && isValidPlace(sections, { section, step })) {
            setPlace({ section, step });
            PubSub.get().publish("menu", { id: ELEMENT_IDS.Tutorial, isOpen: true });
        }
    }, []);
    useEffect(function updatePlaceInUrlEffect() {
        if (!isOpen) return;
        addSearchParams(setLocation, {
            tutorial_section: place.section,
            tutorial_step: place.step,
        } as TutorialViewSearchParams);
    }, [place.section, place.step, isOpen, setLocation]);

    const pollIntervalRef = useRef<number>();
    // Add a ref to track initial render. Added to prevent hotkeys 
    // from triggering on initial render, if tutorial is selected using 
    // hotkeys in the command palette.
    const initialRenderRef = useRef(true);
    const [isInitialRender, setIsInitialRender] = useState(true);

    useEffect(function clearInitialRenderEffect() {
        // Clear the initial render flag after a short delay
        if (isOpen && initialRenderRef.current) {
            const timer = setTimeout(() => {
                initialRenderRef.current = false;
                setIsInitialRender(false);
            }, INITIAL_RENDER_DELAY_MS); // Small delay to avoid the initial Enter keypress
            return () => clearTimeout(timer);
        }
    }, [isOpen]);

    const handleClose = useCallback(function handleCloseCallback() {
        setPlace({ section: 0, step: 0 });
        removeHighlights(TUTORIAL_HIGHLIGHT);
        removeSearchParams(setLocation, ["tutorial_section", "tutorial_step"]);
        close();
        setTimeout(() => {
            setIsInitialRender(true);
            initialRenderRef.current = true;
        }, INITIAL_RENDER_DELAY_MS);
    }, [close, setLocation]);

    useEffect(function triggerStepLoadAction() {
        if (!isOpen || !isValidPlace(sections, place)) return;
        sections[place.section]?.steps[place.step]?.action?.();
    }, [isOpen, place]);

    // Find information about our position in the tutorial
    const {
        isFinalStep,
        isFinalStepInSection,
        nextStep,
    } = useMemo(() => getTutorialStepInfo(sections, place), [place]);

    const totalSteps = getTotalSteps(sections);
    const currentStepIndex = getCurrentStepIndex(sections, place);
    const percentageComplete = Math.round(((currentStepIndex + 1) / totalSteps) * 100);

    const handleNext = useCallback(function handleNextCallback() {
        const nextPlace = getNextPlace(sections, place);
        if (nextPlace) {
            const nextStep = getCurrentStep(sections, nextPlace);
            const nextPage = nextStep?.location?.page;
            if (nextPage && nextPage !== pathname) {
                setLocation(nextPage);
            }
            setPlace(nextPlace);
        } else {
            handleClose();
        }
    }, [pathname, handleClose, place, setLocation]);

    const handlePrev = useCallback(function handlePreviousCallback() {
        const prevPlace = getPrevPlace(sections, place);
        if (prevPlace) {
            const prevStep = getCurrentStep(sections, prevPlace);
            const prevPage = prevStep?.location?.page;
            if (prevPage && prevPage !== pathname) {
                setLocation(prevPage);
            }
            setPlace(prevPlace);
        }
    }, [pathname, place, setLocation]);

    const handleStepDotClick = useCallback(function handleStepDotClickCallback(stepIndex: number) {
        if (stepIndex !== place.step && stepIndex >= 0 && stepIndex < sections[place.section].steps.length) {
            const newPlace = { section: place.section, step: stepIndex };
            const targetStep = getCurrentStep(sections, newPlace);
            const targetPage = targetStep?.location?.page;
            if (targetPage && targetPage !== pathname) {
                setLocation(targetPage);
            }
            setPlace(newPlace);
        }
    }, [pathname, place, setLocation]);

    const handleStepperClick = useCallback(function handleStepperClickCallback(event: React.MouseEvent) {
        const stepper = event.currentTarget;
        const dotsContainer = stepper.querySelector('.MuiMobileStepper-dots');
        if (!dotsContainer) return;

        const dots = dotsContainer.querySelectorAll('.MuiMobileStepper-dot');
        if (dots.length === 0) return;

        const clickX = event.clientX;
        let closestDotIndex = -1;
        let closestDistance = Infinity;

        dots.forEach((dot, index) => {
            const rect = dot.getBoundingClientRect();
            const dotCenterX = rect.left + rect.width / 2;
            const distance = Math.abs(clickX - dotCenterX);
            
            if (distance < closestDistance) {
                closestDistance = distance;
                closestDotIndex = index;
            }
        });

        if (closestDotIndex !== -1) {
            handleStepDotClick(closestDotIndex);
        }
    }, [handleStepDotClick]);

    useHotkeys([
        {
            keys: ["ArrowRight", "l"],
            callback: handleNext,
        },
        {
            keys: ["ArrowLeft", "h"],
            callback: handlePrev,
        },
        {
            keys: ["Enter", " "],
            callback: handleNext,
        },
    ], isOpen && !isInitialRender);

    const anchorElement = useMemo(
        () => getCurrentElement(sections, place),
        [place],
    );
    // Poll for anchor element, since it might not be available yet on initial render
    useEffect(function pollForAnchorElementEffect() {
        if (!isOpen || anchorElement) {
            // Clear interval if dialog is closed, element is found, or polling is disabled
            if (pollIntervalRef.current) {
                window.clearInterval(pollIntervalRef.current);
                pollIntervalRef.current = undefined;
            }
            return;
        }

        // Start polling if element is not found
        pollIntervalRef.current = window.setInterval(() => {
            const element = getCurrentElement(sections, place);
            if (element) {
                // Force a re-render to update the anchor element
                setPlace(prev => ({ ...prev }));
            }
        }, POLL_INTERVAL_MS);

        return () => {
            if (pollIntervalRef.current) {
                window.clearInterval(pollIntervalRef.current);
                pollIntervalRef.current = undefined;
            }
        };
    }, [isOpen, anchorElement, place]);
    const anchorElementRef = useRef(anchorElement);

    useEffect(function highlightElementEffect() {
        // Remove highlight from previous element
        if (anchorElementRef.current) {
            removeHighlights(TUTORIAL_HIGHLIGHT, anchorElementRef.current);
        }
        // Highlight current element
        if (anchorElement) {
            addHighlight(TUTORIAL_HIGHLIGHT, anchorElement);
        }
        anchorElementRef.current = anchorElement;
    }, [anchorElement, palette.action.hover]);

    const [sectionMenuAnchorEl, handleSectionMenuOpen, handleSectionMenuClose, isSectionMenuOpen] = usePopover();
    const handleSectionSelect = useCallback(function handleSectionSelectCallback(sectionIndex: number) {
        const updatedPlace = { section: sectionIndex, step: 0 };
        if (!isValidPlace(sections, updatedPlace)) return;
        setPlace(updatedPlace);
        handleSectionMenuClose();
        const section = sections[updatedPlace.section];
        const firstStep = section.steps[0];
        const page = firstStep?.location?.page;
        if (page && page !== pathname) {
            setLocation(page);
        }
    }, [handleSectionMenuClose, pathname, setLocation]);

    const content = useMemo(() => {
        if (!isValidPlace(sections, place)) {
            PubSub.get().publish("snack", { message: "Failed to load tutorial", severity: "Error" });
            return null;
        }
        const currentSection = sections[place.section];
        if (!currentSection || !currentSection.steps[place.step]) {
            PubSub.get().publish("snack", { message: "Failed to load tutorial step", severity: "Error" });
            return null;
        }
        const currentStep = currentSection.steps[place.step];

        // Guide user to correct page if they're on the wrong one
        const correctPage = currentStep.location?.page;
        function toCorrectPage() {
            if (!correctPage) return;
            setLocation(correctPage);
        }
        
        // If page validation is bypassed, skip all validation checks
        if (bypassPageValidation) {
            console.log("BYPASSING page validation - showing tutorial content");
        } else if (correctPage) {
            const correctURL = new URL(correctPage, window.location.origin);

            // Compare pathnames
            const isPathnameDifferent = pathname !== correctURL.pathname;

            // Compare required query parameters
            const correctParams = new URLSearchParams(correctURL.search);
            const currentParams = new URLSearchParams(search);

            let isQueryParamsDifferent = false;
            for (const [key, value] of correctParams.entries()) {
                if (currentParams.get(key) !== value) {
                    isQueryParamsDifferent = true;
                    break;
                }
            }

            const isOnWrongPage = !bypassPageValidation && (isPathnameDifferent || isQueryParamsDifferent);

            // Debug logging for Storybook
            if (process.env.NODE_ENV !== "production") {
                console.log("TutorialDialog page validation:", {
                    bypassPageValidation,
                    isPathnameDifferent,
                    isQueryParamsDifferent,
                    isOnWrongPage,
                    pathname,
                    correctURL: correctURL.pathname,
                    search,
                    correctSearch: correctURL.search,
                    step: place.step,
                    section: place.section
                });
            }

            // TEMPORARILY DISABLED - Wrong page dialog causing issues in Storybook
            // TODO: Re-enable with proper bypass logic
            /*
            if (isOnWrongPage) {
                return (
                    <ContentWrapper>
                        <DialogTitle
                            id={titleId}
                            title={"Wrong Page"}
                            onClose={handleClose}
                            variant="subheader"
                            sxs={wrongPageDialogTitleStyle}
                        />
                        <Box className="content">
                            <Stack direction="column" spacing={2} p={2}>
                                <MarkdownDisplay
                                    variant="body1"
                                    content={"Please return to the correct page to continue the tutorial."}
                                />
                                <Button
                                    fullWidth
                                    variant="contained"
                                    color="primary"
                                    onClick={toCorrectPage}
                                >
                                    Continue
                                </Button>
                            </Stack>
                        </Box>
                    </ContentWrapper>
                );
            }
            */
            
        }

        // Otherwise, show the current step
        const dialogTitleStyle = { root: { cursor: anchorElement ? "auto" : "move" } } as const; // Can only drag dialogs, not popovers
        const stepFormSchema = {
            containers: [{
                direction: "column",
                disableCollapse: true,
                totalItems: currentStep.content.length,
            }],
            elements: currentStep.content,
        } as const;
        return (
            <ContentWrapper>
                <DialogTitle
                    id={titleId}
                    title={t("Tutorial")}
                    onClose={handleClose}
                    variant="subheader"
                    sxs={dialogTitleStyle}
                />
                <Box className="content">
                    <SectionTitleBox onClick={handleSectionMenuOpen}>
                        <Typography 
                            variant="h6" 
                            component="h2" 
                            sx={{ 
                                fontWeight: 600,
                                flex: 1,
                            }}
                        >
                            {currentSection.title}
                        </Typography>
                        <StyledIconButton 
                            edge="end" 
                            size="small"
                            sx={{ ml: 1 }}
                        >
                            {
                                isSectionMenuOpen ?
                                    <IconCommon name="ExpandLess" fill={palette.background.textPrimary} /> :
                                    <IconCommon name="ExpandMore" fill={palette.background.textPrimary} />
                            }
                        </StyledIconButton>
                    </SectionTitleBox>
                    <Menu
                        id="section-menu"
                        anchorEl={sectionMenuAnchorEl}
                        open={isSectionMenuOpen}
                        onClose={handleSectionMenuClose}
                        slotProps={sectionMenuSlotProps}
                    >
                        <StyledListSubheader>
                            Jump to Section
                        </StyledListSubheader>
                        <Box sx={{ p: 1 }}>
                            {sections.filter((section) => !section.hideFromMenu).map((section, index) => {
                                function handleSectionSelectCallback() {
                                    handleSectionSelect(index);
                                }

                                const currentStepInSection = index === place.section ? place.step + 1 : 0;
                                const totalStepsInSection = section.steps.length;

                                const isCompleted = index < place.section;
                                const isCurrent = index === place.section;

                                return (
                                    <StyledMenuItem
                                        key={index}
                                        selected={isCurrent}
                                        onClick={handleSectionSelectCallback}
                                        className={isCompleted ? "completed" : ""}
                                    >
                                        <Box sx={{ display: "flex", alignItems: "center", width: "100%" }}>
                                            <Box 
                                                className="section-number"
                                                sx={{
                                                    ...(isCompleted && {
                                                        backgroundColor: `${palette.success.main} !important`,
                                                        borderColor: `${palette.success.main} !important`,
                                                        color: "white !important",
                                                    }),
                                                }}
                                            >
                                                {isCompleted ? "✓" : index + 1}
                                            </Box>
                                            <Box sx={{ flex: 1 }}>
                                                <Typography 
                                                    variant="body2" 
                                                    sx={{ 
                                                        fontWeight: isCurrent ? 600 : 400,
                                                        color: isCurrent ? palette.text.primary : isCompleted ? palette.text.primary : palette.text.secondary,
                                                    }}
                                                >
                                                    {section.title}
                                                </Typography>
                                                {isCurrent && (
                                                    <Typography 
                                                        variant="caption" 
                                                        sx={{ 
                                                            color: palette.text.secondary,
                                                            fontSize: "0.7rem",
                                                        }}
                                                    >
                                                        Step {currentStepInSection} of {totalStepsInSection}
                                                    </Typography>
                                                )}
                                            </Box>
                                            {isCurrent && (
                                                <IconCommon 
                                                    name="ArrowRight" 
                                                    fill={palette.primary.main}
                                                    style={{ width: 20, height: 20 }}
                                                />
                                            )}
                                        </Box>
                                    </StyledMenuItem>
                                );
                            })}
                        </Box>
                    </Menu>
                    <FormRunView
                        disabled={true}
                        schema={stepFormSchema}
                    />
                    {/* Display redirect options if available */}
                    {currentStep.options && currentStep.options.length > 1 && (
                        <Box mt={3}>
                            <Typography 
                                variant="subtitle2" 
                                sx={{ 
                                    mb: 2, 
                                    fontWeight: 600,
                                    color: palette.text.secondary,
                                    textTransform: "uppercase",
                                    letterSpacing: 1.2,
                                    fontSize: "0.75rem",
                                }}
                            >
                                Choose your path
                            </Typography>
                            <List sx={{ p: 0 }}>
                                {currentStep.options.map((option, index) => {
                                    function handleOptionSelect() {
                                        setPlace(option.place);
                                        const page = sections[option.place.section].steps[0].location?.page;
                                        if (page && page !== pathname) {
                                            setLocation(page);
                                        }
                                    }

                                    return (
                                        <StyledListItem
                                            key={index}
                                            button
                                            onClick={handleOptionSelect}
                                        >
                                            <ListItemText
                                                primary={
                                                    <Typography 
                                                        sx={{
                                                            fontWeight: 500,
                                                            color: palette.mode === "light" ? palette.primary.main : palette.primary.light,
                                                            display: "flex",
                                                            alignItems: "center",
                                                            gap: 1,
                                                        }}
                                                    >
                                                        <IconCommon 
                                                            name="ArrowRight" 
                                                            fill={palette.mode === "light" ? palette.primary.main : palette.primary.light}
                                                            style={{ width: 16, height: 16 }}
                                                        />
                                                        {option.label}
                                                    </Typography>
                                                }
                                            />
                                        </StyledListItem>
                                    );
                                })}
                            </List>
                        </Box>
                    )}
                </Box>
                <StyledStepper
                    className="stepper"
                    variant="dots"
                    steps={currentSection.steps.length}
                    activeStep={place.step}
                    onClick={handleStepperClick}
                    backButton={
                        <StyledIconButton
                            onClick={handlePrev}
                            disabled={place.section === 0 && place.step === 0}
                            size="small"
                        >
                            <IconCommon name="ArrowLeft" />
                        </StyledIconButton>
                    }
                    nextButton={
                        <StyledIconButton
                            onClick={handleNext}
                            size="small"
                            color={isFinalStep ? "success" : "primary"}
                        >
                            {isFinalStep ? <IconCommon name="CompleteAll" /> : isFinalStepInSection ? <IconCommon name="Complete" /> : <IconCommon name="ArrowRight" />}
                        </StyledIconButton>
                    }
                />
                <StyledLinearProgress variant="determinate" value={percentageComplete} />
            </ContentWrapper>
        );
    }, [place, anchorElement, t, handleClose, handleSectionMenuOpen, isSectionMenuOpen, palette.background.textPrimary, palette.mode, sectionMenuAnchorEl, handleSectionMenuClose, handlePrev, handleNext, handleStepperClick, isFinalStep, isFinalStepInSection, percentageComplete, setLocation, pathname, search, handleSectionSelect, bypassPageValidation]);

    useEffect(function autoAdvanceOnCorrectNavigationEffect() {
        if (!isValidPlace(sections, place)) return;
        const currentSection = sections[place.section];
        if (!currentSection || !currentSection.steps[place.step]) {
            PubSub.get().publish("snack", { message: "Failed to load tutorial", severity: "Error" });
            return;
        }
        const currentStep = currentSection.steps[place.step];
        // Find current step's page
        const currPage = currentStep.location?.page;
        // If already on the correct page, return
        if (currPage && currPage === pathname) return;

        // Find next step's page
        const nextPage = nextStep?.location?.page;

        // If next step has a page and it's the current page, advance
        if (currPage && nextPage && nextPage === pathname) {
            handleNext();
        }
    }, [handleNext, pathname, nextStep?.location?.page, place, setLocation]);

    return (
        <>
            {anchorElement ? (
                <PopoverWithArrow
                    anchorEl={anchorElement}
                    disableScrollLock={true}
                    sxs={popoverWithArrowStyle}
                >
                    {content}
                </PopoverWithArrow>
            ) : (
                <StyledDialog
                    open={isOpen}
                    scroll="paper"
                    disableScrollLock={true}
                    aria-labelledby={titleId}
                    PaperComponent={DraggableDialogPaper}
                >
                    {content}
                </StyledDialog>
            )}
        </>
    );
}
