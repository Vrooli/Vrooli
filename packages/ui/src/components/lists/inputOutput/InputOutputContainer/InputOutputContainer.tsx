import { Box, IconButton, Stack, Tooltip, Typography } from '@mui/material';
import { BaseEdge, HelpButton } from 'components';
import { InputOutputContainerProps } from '../types';
import { Fragment, useCallback, useEffect, useMemo, useState } from 'react';
import {
    Add as AddIcon,
} from '@mui/icons-material';
import { InputShape, OutputShape, updateArray } from 'utils';
import { InputOutputListItem } from '../InputOutputListItem/InputOutputListItem';
import { RoutineInput, RoutineOutput } from 'types';
import { v4 as uuid } from 'uuid';

const inputHelpText =
    `Inputs specify the information required to complete a routine. 
    
For example, a routine for creating a business entity might require its name, mission statement, wallet address, and a logo.

An input may also be associated with a standard, which specifies the shape of data that is expected to be entered. 
This is used to generate a form component when executing the routine manually, or to ensure interoperability with other rotines 
when executing the routine automatically.

Inputs and outputs with the same identifier and standard can be reused in different subroutines.`

const outputHelpText =
    `Outputs specify the information that is generated by a routine.  
    
For example, a routine for creating a business entity might generate a governance token.

Outputs may either be sent to the Vrooli protocol, or stored as a reference to another location. The governance token, for example, 
would be sent directly to the business's wallet address. This means the output would be JSON indicating the object type and token's address.

Outputs and inputs with the same identifier and standard can be reused in different subroutines.`

interface AddButtonProps {
    index: number;
    isInput: boolean;
    handleAdd: (index: number, newItem: RoutineInput | RoutineOutput) => void;
}
/**
 * Add button for adding new inputs/outputs
 */
const AddButton = ({ index, isInput, handleAdd }: AddButtonProps) => (
    <Tooltip placement="top" title="Add">
        <IconButton
            id={`add-${isInput ? 'input' : 'output'}-item-${index}`}
            color="inherit"
            onClick={() => handleAdd(index, {} as any)}
            aria-label="close"
            sx={{
                zIndex: 1,
                width: 'fit-content',
                margin: '5px auto !important',
                padding: '0',
                marginBottom: '16px !important',
                display: 'flex',
                alignItems: 'center',
                backgroundColor: '#6daf72',
                color: 'white',
                borderRadius: '100%',
                '&:hover': {
                    backgroundColor: '#6daf72',
                    filter: `brightness(110%)`,
                    transition: 'filter 0.2s',
                },
            }}
        >
            <AddIcon />
        </IconButton>
    </Tooltip>
)

export const InputOutputContainer = ({
    handleUpdate,
    isEditing,
    isInput,
    language,
    list,
    session,
    zIndex,
}: InputOutputContainerProps) => {
    const type = useMemo(() => isInput ? 'input' : 'output', [isInput]);
    // Store open/close state of each list item
    const [isOpenArray, setIsOpenArray] = useState<boolean[]>([]);
    useEffect(() => {
        if (list.length > 0 && list.length !== isOpenArray.length) {
            setIsOpenArray(list.map(() => false));
        }
    }, [list, isOpenArray]);

    /**
     * Open item at index, and close all others
     */
    const handleOpen = useCallback((index: number) => {
        setIsOpenArray(isOpenArray.map((_, i) => i === index ? true : false));
    }, [isOpenArray]);

    /**
     * Close all items
     */
    const handleClose = useCallback((index: number) => {
        setIsOpenArray(isOpenArray.map((_) => false));
    }, [isOpenArray]);

    const onAdd = useCallback((index: number, newItem: RoutineInput | RoutineOutput) => {
        const newIsOpenArray = new Array(list.length + 1).fill(false);
        newIsOpenArray[Math.min(index + 1, list.length)] = true;
        setIsOpenArray(newIsOpenArray);
        const newList = [...list];
        let newItemFormatted: RoutineInput | RoutineOutput = {
            ...newItem,
            id: uuid(),
            name: newItem.name || `${isInput ? 'Input' : 'Output'} ${list.length + 1}`,
            standard: newItem.standard || null,
            translations: newItem.translations ? newItem.translations : [{
                id: uuid(),
                language,
                description: ''
            }] as any,
        };
        if (isInput && (newItem as RoutineInput).isRequired !== true && (newItem as RoutineInput).isRequired !== false) (newItemFormatted as RoutineInput).isRequired = true;
        // Add new item to list at index (splice does not work)
        const listStart = newList.slice(0, index);
        const listEnd = newList.slice(index);
        const combined = [...listStart, newItemFormatted, ...listEnd];
        // newList.splice(index + 1, 0, newItemFormatted);
        handleUpdate(combined as any);
    }, [list, language, isInput, handleUpdate]);

    const onUpdate = useCallback((index: number, updatedItem: InputShape | OutputShape) => {
        handleUpdate(updateArray(list, index, updatedItem));
    }, [handleUpdate, list]);

    const onDelete = useCallback((index: number) => {
        setIsOpenArray(isOpenArray.filter((_, i) => i !== index));
        handleUpdate([...list.filter((_, i) => i !== index)]);
    }, [handleUpdate, list, isOpenArray]);

    return (
        <Box
            id={`${type}-container`}
            sx={{
                position: 'relative',
                maxWidth: '500px',
                marginLeft: 'auto',
                marginRight: 'auto',
            }}
        >
            <Stack direction="row" marginRight="auto" alignItems="center" justifyContent="center">
                {/* Title */}
                <Typography component="h2" variant="h5" textAlign="left">{isInput ? 'Inputs' : 'Outputs'}</Typography>
                {/* Help button */}
                <HelpButton markdown={isInput ? inputHelpText : outputHelpText} />
            </Stack>
            <Stack direction="column">
                {/* List of inputs. If editing, display delete icon next to each and an add button at the bottom */}
                {list.map((item, index) => (
                    <Fragment key={index}>
                        {isEditing && <AddButton
                            key={`add-${type}-item-${index}`}
                            index={index}
                            isInput={isInput}
                            handleAdd={onAdd}
                        />}
                        <InputOutputListItem
                            key={`${type}-item-${item.id}`}
                            index={index}
                            isInput={isInput}
                            isOpen={isOpenArray.length > index && isOpenArray[index]}
                            item={item}
                            isEditing={isEditing}
                            handleOpen={handleOpen}
                            handleClose={handleClose}
                            handleDelete={onDelete}
                            handleUpdate={onUpdate}
                            language={language}
                            session={session}
                            zIndex={zIndex}
                        />
                    </Fragment>
                ))}
                {/* Show add button at bottom of list */}
                {isEditing && <AddButton
                key={`add-${type}-item-${list.length}`}
                    index={list.length}
                    isInput={isInput}
                    handleAdd={onAdd}
                />}
            </Stack>
            {/* Edges displayed between items (and add button) is actually one edge, since it will be a 
                straight line anyway */}
            {((isEditing && list.length > 0) || (!isEditing && list.length > 1)) && <BaseEdge
                containerId={`${type}-container`}
                fromId={`add-${type}-item-0`}
                isEditing={isEditing}
                thiccness={30}
                timeBetweenDraws={100}
                toId={`add-${type}-item-${list.length}`}
            />}
        </Box>
    )
}