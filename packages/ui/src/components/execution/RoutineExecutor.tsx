import { type ResourceVersion, type RunTaskInfo, type Run, RunStatus, ResourceSubType, noop } from "@vrooli/shared";
import { useCallback, useEffect, useReducer, useState } from "react";
import { Box, Skeleton } from "@mui/material";
import { ExecutionTimeline } from "./ExecutionTimeline.js";
import { ExecutionHeader } from "./ExecutionHeader.js";
import { StepDetails } from "./StepDetails.js";
import { DecisionPrompt } from "./DecisionPrompt.js";
import { useSocketRun } from "../../hooks/runs.js";

interface RoutineExecutorProps {
    runId: string;
    resourceVersion: ResourceVersion;
    runStatus?: string; // Pass the actual run status from ChatMessageRunConfig
    isCollapsed?: boolean;
    defaultCollapsed?: boolean;
    onToggleCollapse?: () => void;
    onClose?: () => void;
    onRemove?: () => void;
    className?: string;
    chatMode?: boolean;
    isFirstInGroup?: boolean;
    isLastInGroup?: boolean;
    showInUnifiedContainer?: boolean;
    isLoading?: boolean;
}

export interface ExecutionStep {
    id: string;
    name: string;
    description?: string;
    status: "pending" | "running" | "completed" | "failed";
    startTime?: string;
    endTime?: string;
    error?: string;
    errorDetails?: string;
    inputs?: Record<string, unknown>;
    outputs?: Record<string, unknown>;
    progress?: number;
    retryCount?: number;
}

interface BranchInfo {
    id: string;
    name: string;
    stepIndex: number;
}

interface DeferredDecisionData {
    stepId: string;
    options: Array<{ id: string; label: string }>;
    prompt: string;
}

interface ExecutionState {
    run: Run | null;
    steps: ExecutionStep[];
    currentStepIndex: number;
    activeBranches: BranchInfo[];
    contextValues: Record<string, unknown>;
    pendingDecision: DeferredDecisionData | null;
    metrics: {
        elapsedTime: number;
        contextSwitches: number;
    };
}

type ExecutionAction = 
    | { type: "UPDATE_RUN"; payload: RunTaskInfo }
    | { type: "DECISION_REQUESTED"; payload: DeferredDecisionData }
    | { type: "DECISION_SUBMITTED"; stepId: string }
    | { type: "UPDATE_METRICS"; elapsedTime: number; contextSwitches: number }
    | { type: "SET_RUN"; run: Run }
    | { type: "UPDATE_STEPS"; steps: ExecutionStep[]; currentStepIndex: number };

function executionReducer(state: ExecutionState, action: ExecutionAction): ExecutionState {
    switch (action.type) {
        case "UPDATE_RUN": {
            const { payload } = action;
            // Update run status
            const updatedRun = state.run ? {
                ...state.run,
                status: payload.runStatus || state.run.status,
            } : null;
            
            // TODO: Process step updates from payload
            // For now, just update the run
            return {
                ...state,
                run: updatedRun,
            };
        }
        case "DECISION_REQUESTED":
            return {
                ...state,
                pendingDecision: action.payload,
            };
        case "DECISION_SUBMITTED":
            return {
                ...state,
                pendingDecision: null,
            };
        case "UPDATE_METRICS":
            return {
                ...state,
                metrics: {
                    elapsedTime: action.elapsedTime,
                    contextSwitches: action.contextSwitches,
                },
            };
        case "SET_RUN":
            return {
                ...state,
                run: action.run,
                // Keep existing steps since they're generated from resourceVersion
                // In real implementation, we'd parse run.progress to update step statuses
            };
        case "UPDATE_STEPS":
            return {
                ...state,
                steps: action.steps,
                currentStepIndex: action.currentStepIndex,
            };
        default:
            return state;
    }
}

function createStepsFromRun(run: Run): ExecutionStep[] {
    // TODO: Parse actual RunProgress data from run to create steps:
    // - run.progress.steps[] for completed steps
    // - run.progress.branches[] for current locations
    // For now, return empty array - steps will be generated by generateSteps()
    return [];
}

const initialState: ExecutionState = {
    run: null,
    steps: [],
    currentStepIndex: 0,
    activeBranches: [],
    contextValues: {},
    pendingDecision: null,
    metrics: {
        elapsedTime: 0,
        contextSwitches: 0,
    },
};

export function RoutineExecutor({
    runId,
    resourceVersion,
    runStatus,
    isCollapsed = false,
    defaultCollapsed = false,
    onToggleCollapse = noop,
    onClose = noop,
    onRemove = noop,
    className = "",
    chatMode = false,
    isFirstInGroup = true,
    isLastInGroup = true,
    showInUnifiedContainer = false,
    isLoading = false,
}: RoutineExecutorProps) {
    // Generate steps based on routine type and execution state
    const generateSteps = (): ExecutionStep[] => {
        const isMultiStep = resourceVersion?.resourceSubType === ResourceSubType.RoutineMultiStep;
        
        // Single-step routines don't show steps in timeline
        if (!isMultiStep) {
            return [];
        }
        
        // Multi-step routine - generate steps based on graph config and run state
        const steps: ExecutionStep[] = [];
        const graphConfig = resourceVersion?.config?.graph;
        
        if (graphConfig?.nodes && graphConfig.nodes.length > 0) {
            // For now, generate steps based on graph nodes
            // TODO: In real implementation, this should use RunProgress data:
            // - Use runProgress.steps[] for completed steps with actual timing data
            // - Use runProgress.branches[] to determine current step locations
            // - For sequential routines: Use navigator.getNextLocations() to predict future steps  
            // - For complex routines (BPMN): Show placeholders since exact flow depends on runtime conditions
            const totalNodes = graphConfig.nodes.length;
            const currentStepIndex = Math.floor(totalNodes * 0.4); // Mock: 40% complete
            
            graphConfig.nodes.forEach((node: any, index: number) => {
                let status: ExecutionStep["status"];
                let startTime: string | undefined;
                let endTime: string | undefined;
                
                if (index < currentStepIndex) {
                    status = "completed";
                    startTime = new Date(Date.now() - (totalNodes - index) * 2000).toISOString();
                    endTime = new Date(Date.now() - (totalNodes - index - 1) * 2000).toISOString();
                } else if (index === currentStepIndex) {
                    status = "running";
                    startTime = new Date(Date.now() - 1000).toISOString();
                } else {
                    status = "pending";
                }
                
                steps.push({
                    id: node.id || `step-${index + 1}`,
                    name: node.data?.routine?.name || node.data?.label || `Step ${index + 1}`,
                    status,
                    startTime,
                    endTime,
                    progress: status === "running" ? 65 : undefined,
                });
            });
            
            // For complex routines (like BPMN), add placeholder steps for unknown future paths
            const isComplexRoutine = graphConfig.__type === "BPMN-2.0" || graphConfig.nodes.some((node: any) => 
                node.type === "gateway" || node.type === "decision",
            );
            
            if (isComplexRoutine && currentStepIndex < totalNodes - 1) {
                steps.push({
                    id: "placeholder-future",
                    name: "Additional steps may follow...",
                    status: "pending",
                    description: "The exact steps depend on runtime conditions and decisions",
                });
            }
        } else {
            // Fallback for routines without proper graph config
            steps.push({
                id: "step-1",
                name: "Processing Multi-Step Routine",
                status: runStatus === "Completed" ? "completed" : 
                       runStatus === "Failed" ? "failed" :
                       runStatus === "Running" || runStatus === "InProgress" ? "running" : "pending",
                startTime: runStatus !== "Scheduled" ? new Date(Date.now() - 2000).toISOString() : undefined,
                endTime: runStatus === "Completed" || runStatus === "Failed" ? new Date().toISOString() : undefined,
            });
        }
        
        return steps;
    };

    const generatedSteps = generateSteps();
    const [state, dispatch] = useReducer(executionReducer, {
        ...initialState,
        steps: generatedSteps,
        currentStepIndex: generatedSteps.findIndex(step => step.status === "running") || 0,
        metrics: {
            elapsedTime: 5, // Start with some elapsed time
            contextSwitches: 0,
        },
    });
    
    // Track if config is expanded to adjust container size
    const [isConfigExpanded, setIsConfigExpanded] = useState(false);

    // Update steps when resourceVersion changes
    useEffect(() => {
        const newSteps = generateSteps();
        dispatch({ 
            type: "UPDATE_STEPS", 
            steps: newSteps,
            currentStepIndex: newSteps.findIndex(step => step.status === "running") || 0,
        });
    // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [resourceVersion?.resourceSubType, resourceVersion?.config, runStatus]);

    // Handle run updates from socket
    const handleRunUpdate = useCallback((updatedRun: Run | null) => {
        if (updatedRun) {
            dispatch({ type: "SET_RUN", run: updatedRun });
        }
    }, []);

    // Handle decision requests from socket
    const handleDecisionRequest = useCallback((decisionData: DeferredDecisionData) => {
        dispatch({ type: "DECISION_REQUESTED", payload: decisionData });
    }, []);

    // Connect to socket for real-time updates
    useSocketRun({
        runId,
        applyRunUpdate: handleRunUpdate,
        onDecisionRequest: handleDecisionRequest,
    });

    // Handle decision submission
    const handleDecisionSubmit = useCallback((stepId: string, decision: unknown) => {
        // TODO: Emit decision to server via socket
        dispatch({ type: "DECISION_SUBMITTED", stepId });
    }, []);

    // Handle step selection
    const handleStepSelect = useCallback((stepIndex: number) => {
        // TODO: Update current step index
    }, []);

    // Calculate progress based on completed steps
    const calculateProgress = useCallback(() => {
        if (state.steps.length === 0) return 0;
        const completedSteps = state.steps.filter(step => step.status === "completed").length;
        const runningSteps = state.steps.filter(step => step.status === "running").length;
        // Give partial credit for running steps
        return Math.round(((completedSteps + runningSteps * 0.5) / state.steps.length) * 100);
    }, [state.steps]);

    const progress = calculateProgress();

    // Update metrics periodically (only when run is active)
    useEffect(() => {
        // Only update timer if run is in progress
        const isRunActive = runStatus === "Running" || runStatus === "InProgress";
        
        if (!isRunActive) {
            return; // Don't start timer if run is not active
        }

        const interval = setInterval(() => {
            dispatch({
                type: "UPDATE_METRICS",
                elapsedTime: state.metrics.elapsedTime + 1,
                contextSwitches: state.metrics.contextSwitches,
            });
        }, 1000);

        return () => clearInterval(interval);
    }, [state.metrics.elapsedTime, state.metrics.contextSwitches, runStatus]);

    // Always return the full structure, but hide content when collapsed
    const shouldShowRoundedCorners = !showInUnifiedContainer || (isFirstInGroup && isLastInGroup);

    if (isLoading) {
        return (
            <Box 
                className={`routine-executor ${className} loading`}
                sx={{
                    display: "flex",
                    flexDirection: "column",
                    height: chatMode ? "auto" : "100%",
                    minHeight: chatMode ? 200 : "auto",
                    minWidth: { xs: 280, sm: chatMode ? 480 : 500, md: chatMode ? 600 : 700 },
                    maxWidth: { xs: "100%", sm: chatMode ? 600 : 800, md: chatMode ? 700 : 900 },
                    width: "auto",
                    mx: "auto",
                    bgcolor: showInUnifiedContainer ? "transparent" : "background.paper",
                    borderRadius: showInUnifiedContainer 
                        ? 0 
                        : shouldShowRoundedCorners ? 3 : 0,
                    borderTopLeftRadius: showInUnifiedContainer && isFirstInGroup ? 0 : undefined,
                    borderTopRightRadius: showInUnifiedContainer && isFirstInGroup ? 0 : undefined,
                    borderBottomLeftRadius: showInUnifiedContainer && !isLastInGroup ? 0 : undefined,
                    borderBottomRightRadius: showInUnifiedContainer && !isLastInGroup ? 0 : undefined,
                    boxShadow: showInUnifiedContainer ? "none" : chatMode ? 1 : 2,
                    overflow: "hidden",
                    p: 2,
                }}
            >
                {/* Header skeleton */}
                <Box sx={{ display: "flex", alignItems: "center", justifyContent: "space-between", mb: 2 }}>
                    <Box sx={{ display: "flex", alignItems: "center", gap: 1, flex: 1 }}>
                        <Skeleton variant="text" width={150} height={24} />
                        <Skeleton variant="rectangular" width={100} height={8} sx={{ borderRadius: 1 }} />
                    </Box>
                    <Box sx={{ display: "flex", gap: 1 }}>
                        <Skeleton variant="circular" width={32} height={32} />
                        <Skeleton variant="circular" width={32} height={32} />
                    </Box>
                </Box>

                {!isCollapsed && (
                    <Box sx={{ display: "flex", gap: 2 }}>
                        {/* Timeline skeleton */}
                        <Box sx={{ 
                            width: chatMode ? 220 : 280, 
                            display: { xs: "none", sm: "block" },
                        }}>
                            <Box sx={{ display: "flex", flexDirection: "column", gap: 1, p: 1 }}>
                                {[1, 2, 3, 4].map((i) => (
                                    <Box key={i} sx={{ display: "flex", alignItems: "center", gap: 1 }}>
                                        <Skeleton variant="circular" width={12} height={12} />
                                        <Skeleton variant="text" width={160} height={16} />
                                    </Box>
                                ))}
                            </Box>
                        </Box>
                        
                        {/* Details skeleton */}
                        <Box sx={{ flex: 1 }}>
                            <Skeleton variant="text" width="60%" height={20} sx={{ mb: 1 }} />
                            <Skeleton variant="text" width="40%" height={16} sx={{ mb: 2 }} />
                            <Skeleton variant="rectangular" width="100%" height={chatMode ? 120 : 200} sx={{ borderRadius: 1 }} />
                        </Box>
                    </Box>
                )}
            </Box>
        );
    }

    return (
        <Box 
            className={`routine-executor ${className}`}
            sx={{
                display: "flex",
                flexDirection: "column",
                height: chatMode ? "auto" : "100%",
                minHeight: chatMode && !isCollapsed ? 200 : "auto",
                maxHeight: isConfigExpanded ? { xs: "80vh", sm: "90vh" } : (chatMode && !isCollapsed ? 400 : "none"),
                minWidth: { xs: 280, sm: chatMode ? 480 : 500, md: chatMode ? 600 : 700 },
                maxWidth: isConfigExpanded 
                    ? { xs: "95vw", sm: "90vw", md: "100%" } 
                    : { xs: "100%", sm: chatMode ? 600 : 800, md: chatMode ? 700 : 900 },
                width: isConfigExpanded ? "100%" : "auto",
                mx: isConfigExpanded ? 0 : "auto",
                bgcolor: showInUnifiedContainer ? "transparent" : "background.paper",
                borderRadius: showInUnifiedContainer 
                    ? 0 
                    : shouldShowRoundedCorners ? 3 : 0,
                borderTopLeftRadius: showInUnifiedContainer && isFirstInGroup ? 0 : undefined,
                borderTopRightRadius: showInUnifiedContainer && isFirstInGroup ? 0 : undefined,
                borderBottomLeftRadius: showInUnifiedContainer && !isLastInGroup ? 0 : undefined,
                borderBottomRightRadius: showInUnifiedContainer && !isLastInGroup ? 0 : undefined,
                boxShadow: showInUnifiedContainer ? "none" : chatMode ? 1 : 2,
                overflow: "hidden",
                transition: "all 0.3s ease-in-out",
            }}
        >
            <ExecutionHeader
                title={resourceVersion.name || "Routine"}
                description={chatMode ? undefined : resourceVersion.description}
                progress={progress}
                elapsedTime={state.metrics.elapsedTime}
                isCollapsed={isCollapsed}
                onToggleCollapse={onToggleCollapse}
                onClose={chatMode ? onRemove : onClose}
                chatMode={chatMode}
                currentStepTitle={state.steps[state.currentStepIndex]?.name}
                runStatus={runStatus || state.run?.status}
                onPause={() => console.log("Pause run:", runId)}
                onResume={() => console.log("Resume run:", runId)}
                onRetry={() => console.log("Retry run:", runId)}
            />
            
            {!isCollapsed && (
                <Box sx={{ display: "flex", flex: 1, overflow: "hidden" }}>
                    {/* Only show timeline for multi-step routines */}
                    {state.steps.length > 0 && (
                        <Box sx={{ 
                            width: chatMode ? 220 : 280, 
                            borderRight: 1, 
                            borderColor: "divider",
                            display: { xs: "none", sm: "block" },
                        }}>
                            <ExecutionTimeline
                                steps={state.steps}
                                currentStepIndex={state.currentStepIndex}
                                onStepSelect={handleStepSelect}
                                compact={chatMode}
                            />
                        </Box>
                    )}
                    
                    <Box sx={{ flex: 1, display: "flex", flexDirection: "column", position: "relative", overflow: "hidden" }}>
                        <Box sx={{ flex: 1, overflow: "auto", p: 2 }}>
                            {state.pendingDecision ? (
                                <DecisionPrompt
                                    decision={state.pendingDecision}
                                    onSubmit={(decision) => handleDecisionSubmit(state.pendingDecision!.stepId, decision)}
                                    onCancel={() => dispatch({ type: "DECISION_SUBMITTED", stepId: state.pendingDecision!.stepId })}
                                />
                            ) : (
                                <StepDetails
                                    step={state.steps[state.currentStepIndex]}
                                    contextValues={state.contextValues}
                                    totalSteps={state.steps.length}
                                    currentStepIndex={state.currentStepIndex}
                                    resourceVersion={resourceVersion}
                                    onConfigExpandChange={setIsConfigExpanded}
                                />
                            )}
                        </Box>
                    </Box>
                </Box>
            )}
        </Box>
    );
}
