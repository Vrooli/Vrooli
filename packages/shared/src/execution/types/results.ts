/**
 * Unified Result Types for Clean Data Flow
 * 
 * These result types provide a consistent interface for returning execution
 * results across all tiers and services. They maintain compatibility with
 * existing ExecutionResult types while adding specific result information.
 * 
 * Design Principles:
 * - Consistent success/error handling
 * - Unified resource tracking
 * - Rich metadata for debugging and monitoring
 * - Compatible with existing ExecutionResult
 */

import type { ChatMessage } from "../../api/types.js";
import type { BotParticipantState } from "./context.js";
import type { ToolCall } from "./conversation.js";
import type { ExecutionError, ExecutionResourceUsage, ExecutionResult } from "./core.js";
import type { BotId, SwarmId, TurnId } from "./ids.js";

/**
 * Base result interface shared across all execution operations
 * Provides consistent success/error handling and resource tracking
 */
export interface BaseResult {
    /** Whether the operation completed successfully */
    success: boolean;

    /** Resources consumed during execution */
    resourcesUsed: ExecutionResourceUsage;

    /** Total execution duration in milliseconds */
    duration: number;

    /** Optional metadata for debugging and monitoring */
    metadata?: Record<string, unknown>;

    /** Error information if the operation failed */
    error?: ExecutionError;
}

/**
 * Result from individual bot response generation
 * Contains the generated message and execution details
 */
export interface ResponseResult extends BaseResult {
    /** The message generated by the bot */
    message: ChatMessage;

    /** Tool calls made during response generation (if any) */
    toolCalls?: ToolCall[];

    /** AI confidence score for the response (0-1) */
    confidence?: number;

    /** Whether the conversation should continue after this response */
    continueConversation: boolean;

    /** The bot that generated this response */
    botId?: BotId;

    /** Response-specific metadata */
    metadata?: {
        /** Execution strategy used */
        strategy?: string;

        /** Model used for generation */
        model?: string;

        /** Token counts */
        tokens?: {
            input?: number;
            output?: number;
            total?: number;
        };

        /** Tool execution details */
        toolExecutionDetails?: Array<{
            toolName: string;
            success: boolean;
            duration: number;
            creditsUsed: string;
        }>;
    } & Record<string, unknown>;
}

/**
 * Result from conversation orchestration
 * Contains all messages generated and conversation state updates
 */
export interface ConversationResult extends BaseResult {
    /** All messages generated during this conversation turn */
    messages: ChatMessage[];

    /** Updated participant states after the conversation */
    updatedParticipants: BotParticipantResult[];

    /** What should happen next in the conversation */
    nextAction?: ConversationAction;

    /** Whether the conversation has completed */
    conversationComplete: boolean;

    /** Unique identifier for this conversation turn */
    turnId: TurnId;

    /** The swarm this conversation belongs to */
    swarmId: SwarmId;

    /** Conversation-specific metadata */
    metadata?: {
        /** Number of bots that participated */
        participantCount?: number;

        /** Conversation strategy used */
        strategy?: string;

        /** Turn number in the conversation */
        turnNumber?: number;

        /** Reason the conversation ended (if complete) */
        completionReason?: string;

        /** Bot selection details */
        botSelection?: {
            requested: BotId[];
            selected: BotId[];
            selectionReason: string;
            fallbackUsed: boolean;
        };
    } & Record<string, unknown>;
}

/**
 * Result from a bot's participation in a conversation
 */
export interface BotParticipantResult {
    /** The bot that participated */
    botId: BotId;

    /** Whether the bot successfully participated */
    success: boolean;

    /** Message generated by this bot (if any) */
    message?: ChatMessage;

    /** Updated state of this bot */
    updatedState: BotParticipantState;

    /** Resources used by this bot */
    resourcesUsed: ExecutionResourceUsage;

    /** Error if the bot failed to participate */
    error?: ExecutionError;
}

/**
 * Actions that can happen next in a conversation
 */
export type ConversationAction =
    | { type: "continue"; participants?: BotId[]; reason: string }
    | { type: "wait_for_user"; prompt?: string }
    | { type: "complete"; result: string; reason: string }
    | { type: "error"; error: ExecutionError }
    | { type: "delegate_to_tool"; toolName: string; parameters: Record<string, unknown> }
    | { type: "escalate"; reason: string; targetTier?: "tier1" | "tier2" };

/**
 * Conversion utilities for compatibility with existing ExecutionResult
 */

/**
 * Convert a ResponseResult to ExecutionResult format
 * Maintains compatibility with existing tier communication interfaces
 */
export function responseResultToExecutionResult(
    result: ResponseResult,
    swarmId: SwarmId,
    userData: any,
): ExecutionResult {
    return {
        success: result.success,
        result: result.success ? result.message : null,
        outputs: result.success ? {
            messageId: result.message.id,
            botId: result.botId,
            toolCallCount: result.toolCalls?.length || 0,
            confidence: result.confidence,
            continueConversation: result.continueConversation,
        } : undefined,
        resourcesUsed: {
            creditsUsed: result.resourcesUsed.creditsUsed,
            durationMs: result.resourcesUsed.durationMs,
            stepsExecuted: result.resourcesUsed.stepsExecuted || 0,
            memoryUsedMB: result.resourcesUsed.memoryUsedMB || 0,
            toolCalls: result.resourcesUsed.toolCalls || 0,
        },
        duration: result.duration,
        context: {
            swarmId,
            userData, // Will be provided by caller
            timestamp: new Date(),
        },
        error: result.error,
        metadata: result.metadata,
    };
}

/**
 * Convert a ConversationResult to ExecutionResult format
 * Maintains compatibility with existing tier communication interfaces
 */
export function conversationResultToExecutionResult(
    result: ConversationResult,
    userData: any,
): ExecutionResult {
    return {
        success: result.success,
        result: result.success ? result.messages : null,
        outputs: result.success ? {
            messageCount: result.messages.length,
            participantCount: result.updatedParticipants.length,
            turnId: result.turnId,
            conversationComplete: result.conversationComplete,
            nextAction: result.nextAction,
        } : undefined,
        resourcesUsed: {
            creditsUsed: result.resourcesUsed.creditsUsed,
            durationMs: result.resourcesUsed.durationMs,
            stepsExecuted: result.resourcesUsed.stepsExecuted || 0,
            memoryUsedMB: result.resourcesUsed.memoryUsedMB || 0,
            toolCalls: result.resourcesUsed.toolCalls || 0,
        },
        duration: result.duration,
        context: {
            swarmId: result.swarmId,
            userData,
            timestamp: new Date(),
        },
        error: result.error,
        metadata: result.metadata,
    };
}

/**
 * Aggregate multiple ResponseResults into a single ConversationResult
 * Used when multiple bots participate in a single conversation turn
 */
export function aggregateResponseResults(
    responses: ResponseResult[],
    turnId: TurnId,
    swarmId: SwarmId,
    participantStates: BotParticipantState[],
): ConversationResult {
    const allSuccessful = responses.every(r => r.success);
    const allMessages = responses.filter(r => r.success).map(r => r.message);

    // Aggregate resource usage
    const totalCredits = responses.reduce(
        (sum, r) => sum + BigInt(r.resourcesUsed.creditsUsed),
        BigInt(0),
    );
    const totalDuration = Math.max(...responses.map(r => r.duration));
    const totalToolCalls = responses.reduce((sum, r) => sum + r.resourcesUsed.toolCalls, 0);

    // Create participant results
    const updatedParticipants: BotParticipantResult[] = responses.map((response, index) => ({
        botId: response.botId!,
        success: response.success,
        message: response.success ? response.message : undefined,
        updatedState: participantStates[index] || {
            isProcessing: false,
            isWaiting: false,
            hasResponded: response.success,
            error: response.error?.message,
            lastActive: new Date(),
        },
        resourcesUsed: response.resourcesUsed,
        error: response.error,
    }));

    // Determine next action
    const hasToolCalls = responses.some(r => r.toolCalls && r.toolCalls.length > 0);
    const shouldContinue = responses.some(r => r.continueConversation);

    let nextAction: ConversationAction | undefined;
    if (!allSuccessful) {
        nextAction = { type: "error", error: responses.find(r => !r.success)!.error! };
    } else if (hasToolCalls) {
        nextAction = { type: "continue", reason: "Tool calls require follow-up" };
    } else if (shouldContinue) {
        nextAction = { type: "continue", reason: "Bots indicated conversation should continue" };
    } else {
        nextAction = { type: "wait_for_user" };
    }

    const result: ConversationResult = {
        success: allSuccessful,
        messages: allMessages,
        updatedParticipants,
        nextAction,
        conversationComplete: !shouldContinue && !hasToolCalls,
        turnId,
        swarmId,
        resourcesUsed: {
            creditsUsed: totalCredits.toString(),
            durationMs: totalDuration,
            stepsExecuted: responses.length,
            toolCalls: totalToolCalls,
            memoryUsedMB: 0, // TODO: Add memory used
        },
        duration: totalDuration,
        metadata: {
            participantCount: responses.length,
            strategy: responses[0]?.metadata?.strategy,
            botSelection: {
                requested: responses.map(r => r.botId!),
                selected: responses.filter(r => r.success).map(r => r.botId!),
                selectionReason: "All available participants",
                fallbackUsed: false,
            },
        },
        error: allSuccessful ? undefined : responses.find(r => !r.success)?.error,
    };

    return result;
}
