import i18next from "i18next";
import { RoutineType } from "../api/types";
import { PassableLogger } from "../consts/commonTypes";
import { InputType } from "../consts/model";
import { FormSchema } from "../forms/types";
import { BotStyle, ConfigCallDataApi, ConfigCallDataGenerate, ConfigCallDataSmartContract } from "./runUtils";

type StringifyMode = "json";// Add more as needed. E.g. "yaml", "xml"

function stringifyObject(data: object, mode: StringifyMode): string {
    switch (mode) {
        case "json":
            return JSON.stringify(data);
        default:
            throw new Error(`Unsupported stringify mode: ${mode}`);
    }
}

function parseObject<T extends object>(data: string, mode: StringifyMode, logger: PassableLogger): T | null {
    try {
        switch (mode) {
            case "json":
                return JSON.parse(data);
            default:
                throw new Error(`Unsupported parse mode: ${mode}`);
        }
    } catch (error) {
        logger.error(`Error parsing data: ${JSON.stringify(error)}`);
        return null;
    }
}

type CallDataBaseConfigObject = {
    __version: string;
    __type: RoutineType;
}
type CallDataApiConfigObject = CallDataBaseConfigObject & {
    __type: RoutineType.Api;
    schema: ConfigCallDataApi;
};
type CallDataGenerateConfigObject = CallDataBaseConfigObject & {
    __type: RoutineType.Generate;
    schema: ConfigCallDataGenerate;
};
type CallDataSmartContractConfigObject = CallDataBaseConfigObject & {
    __type: RoutineType.SmartContract;
    schema: ConfigCallDataSmartContract;
};
export type CallDataConfigObject = CallDataApiConfigObject | CallDataGenerateConfigObject | CallDataSmartContractConfigObject;

type FormInputConfigObject = {
    __version: string;
    schema: FormSchema;
};
type FormOutputConfigObject = {
    __version: string;
    schema: FormSchema;
};

type GraphType = "BPMN-2.0"; // Add more as needed
type GraphBaseConfigObject = {
    __version: string;
    __type: GraphType;
};
type BpmnSchema = {
    __format: "xml";
    data: string;
};
type GraphBpmnConfigObject = GraphBaseConfigObject & {
    __type: "BPMN-2.0";
    schema: BpmnSchema;
};
type GraphConfigObject = GraphBpmnConfigObject;

/**
 * Represents the configuration for a routine version. 
 * Includes configs for calling another service, I/O, and more.
 */
type RoutineVersionConfigObject = {
    /** Store the version number for future compatibility */
    __version: string;
    /** Config for calling another service (e.g. API, LLM, smart contract) */
    callData?: CallDataConfigObject;
    /** Config for entering information to complete the routine */
    formInput?: FormInputConfigObject;
    /** Config for information generated by the routine */
    formOutput?: FormOutputConfigObject;
    /** Config for running multi-step routines */
    graph?: GraphConfigObject;
};

function defaultConfigCallData(routineType: RoutineType): CallDataConfigObject {
    return {
        __version: "1.0",
        __type: routineType,
    } as CallDataConfigObject;
}
function defaultConfigCallDataApi(): CallDataApiConfigObject {
    return {
        __version: "1.0",
        __type: RoutineType.Api,
        schema: {
            endpoint: "",
            method: "GET",
        },
    };
}
function defaultConfigCallDataGenerate(): CallDataGenerateConfigObject {
    return {
        __version: "1.0",
        __type: RoutineType.Generate,
        schema: {
            botStyle: BotStyle.Default,
            maxTokens: null,
            model: null,
            prompt: null,
            respondingBot: null,
        },
    };
}
function defaultConfigCallDataSmartContract(): CallDataSmartContractConfigObject {
    return {
        __version: "1.0",
        __type: RoutineType.SmartContract,
        schema: {
            contractAddress: "",
            chain: "ethereum",
            methodName: "",
        },
    };
}

const defaultConfigCallDataMap = {
    [RoutineType.Action]: () => defaultConfigCallData(RoutineType.Action),
    [RoutineType.Api]: () => defaultConfigCallDataApi(),
    [RoutineType.Code]: () => defaultConfigCallData(RoutineType.Code),
    [RoutineType.Data]: () => defaultConfigCallData(RoutineType.Data),
    [RoutineType.Generate]: () => defaultConfigCallDataGenerate(),
    [RoutineType.Informational]: () => defaultConfigCallData(RoutineType.Informational),
    [RoutineType.MultiStep]: () => defaultConfigCallData(RoutineType.MultiStep),
    [RoutineType.SmartContract]: () => defaultConfigCallDataSmartContract(),
} as const;

function defaultSchemaInput(): FormInputConfigObject {
    return {
        __version: "1.0",
        schema: {
            containers: [],
            elements: [],
        },
    };
}

function defaultSchemaOutput(): FormOutputConfigObject {
    return {
        __version: "1.0",
        schema: {
            containers: [],
            elements: [],
        },
    };
}

/**
 * @return The default output form object for a Generate routine, 
 * which always returns text (for now, since we only call LLMs)
 */
function defaultSchemaOutputGenerate(): FormOutputConfigObject {
    return {
        __version: "1.0",
        schema: {
            containers: [],
            elements: [
                {
                    fieldName: "response",
                    id: "response",
                    label: i18next.t("Response", { count: 1 }),
                    props: {
                        placeholder: "Model response will be displayed here",
                    },
                    type: InputType.Text,
                },
            ],
        },
    };
}

const defaultConfigFormInputMap = {
    [RoutineType.Action]: () => defaultSchemaInput(),
    [RoutineType.Api]: () => defaultSchemaInput(),
    [RoutineType.Code]: () => defaultSchemaInput(),
    [RoutineType.Data]: () => defaultSchemaInput(),
    [RoutineType.Generate]: () => defaultSchemaInput(),
    [RoutineType.Informational]: () => defaultSchemaInput(),
    [RoutineType.MultiStep]: () => defaultSchemaInput(),
    [RoutineType.SmartContract]: () => defaultSchemaInput(),
};

const defaultConfigFormOutputMap = {
    [RoutineType.Action]: () => defaultSchemaOutput(),
    [RoutineType.Api]: () => defaultSchemaOutput(),
    [RoutineType.Code]: () => defaultSchemaOutput(),
    [RoutineType.Data]: () => defaultSchemaOutput(),
    [RoutineType.Generate]: () => defaultSchemaOutputGenerate(),
    [RoutineType.Informational]: () => defaultSchemaOutput(),
    [RoutineType.MultiStep]: () => defaultSchemaOutput(),
    [RoutineType.SmartContract]: () => defaultSchemaOutput(),
};

function isValidFormSchema(schema: FormSchema): boolean {
    return (
        Object.prototype.hasOwnProperty.call(schema, "containers") &&
        Array.isArray(schema.containers) &&
        Object.prototype.hasOwnProperty.call(schema, "elements") &&
        Array.isArray(schema.elements)
    );
}

/**
 * Top-level routine config that encapsulates all sub-config sections.
 */
export class RoutineVersionConfig {
    __version: string;
    callData?: CallDataConfig;
    formInput?: FormInputConfig;
    formOutput?: FormOutputConfig;
    graph?: GraphConfig;

    constructor(data: RoutineVersionConfigObject) {
        this.__version = data.__version ?? "1.0";
        this.callData = data.callData ? CallDataConfig.create(data.callData) : undefined;
        this.formInput = data.formInput ? new FormInputConfig(data.formInput) : undefined;
        this.formOutput = data.formOutput ? new FormOutputConfig(data.formOutput) : undefined;
        this.graph = data.graph ? GraphConfig.create(data.graph) : undefined;
    }

    static deserialize(
        { config, routineType }: { config?: string | null | undefined, routineType: RoutineType },
        logger: PassableLogger,
        { mode = "json", useFallbacks = true }: { mode?: StringifyMode, useFallbacks?: boolean },
    ): RoutineVersionConfig {
        const obj = config ? (parseObject<RoutineVersionConfigObject>(config, mode, logger) || { __version: "1.0" }) : { __version: "1.0" };
        if (useFallbacks) {
            if (!obj.callData && routineType in defaultConfigCallDataMap) {
                obj.callData = defaultConfigCallDataMap[routineType]();
            }
            if ((!obj.formInput || !isValidFormSchema(obj.formInput.schema)) && routineType in defaultConfigFormInputMap) {
                obj.formInput = defaultConfigFormInputMap[routineType]();
            }
            if ((!obj.formOutput || !isValidFormSchema(obj.formOutput.schema)) && routineType in defaultConfigFormOutputMap) {
                obj.formOutput = defaultConfigFormOutputMap[routineType]();
            }
            if (!obj.graph) {
                // Add if needed
            }
        }
        return new RoutineVersionConfig(obj);
    }

    serialize(mode: StringifyMode): string {
        return stringifyObject(this.export(), mode);
    }

    export(): RoutineVersionConfigObject {
        return {
            __version: this.__version,
            callData: this.callData?.export(),
            formInput: this.formInput?.export(),
            formOutput: this.formOutput?.export(),
            graph: this.graph?.export(),
        };
    }
}

/**
 * Represents the configuration for calling another service in a routine.
 */
abstract class CallDataConfig {
    __version: string;
    __type: RoutineType;

    constructor(data: CallDataBaseConfigObject) {
        this.__version = data.__version ?? "1.0";
        this.__type = data.__type;
    }

    abstract export(): CallDataConfigObject;

    static create(data: CallDataConfigObject): CallDataConfig {
        switch (data.__type) {
            case RoutineType.Api:
                return new CallDataApiConfig(data);
            case RoutineType.Generate:
                return new CallDataGenerateConfig(data);
            case RoutineType.SmartContract:
                return new CallDataSmartContractConfig(data);
            default:
                throw new Error(`Unsupported __type: ${(data as { __type: string }).__type}`);
        }
    }
}

class CallDataApiConfig extends CallDataConfig {
    schema: ConfigCallDataApi;

    constructor(data: CallDataApiConfigObject) {
        super(data);
        this.schema = data.schema;
    }

    export(): CallDataApiConfigObject {
        return {
            __version: this.__version,
            __type: this.__type as RoutineType.Api, // or just RoutineType.Api
            schema: this.schema,
        };
    }

    // Add API-specific methods here
}

export class CallDataGenerateConfig extends CallDataConfig {
    schema: ConfigCallDataGenerate;

    constructor(data: CallDataGenerateConfigObject) {
        super(data);
        this.schema = data.schema;
    }

    export(): CallDataGenerateConfigObject {
        return {
            __version: this.__version,
            __type: this.__type as RoutineType.Generate,
            schema: this.schema,
        };
    }

    // Add Generate-specific methods here
}

class CallDataSmartContractConfig extends CallDataConfig {
    schema: ConfigCallDataSmartContract;

    constructor(data: CallDataSmartContractConfigObject) {
        super(data);
        this.schema = data.schema;
    }

    export(): CallDataSmartContractConfigObject {
        return {
            __version: this.__version,
            __type: this.__type as RoutineType.SmartContract,
            schema: this.schema,
        };
    }

    // Add SmartContract-specific methods here
}

/**
 * Represents the configuration for form input fields in a routine.
 */
class FormInputConfig {
    __version: string;
    schema: FormSchema;

    constructor(data: FormInputConfigObject) {
        this.__version = data.__version ?? "1.0";
        this.schema = data.schema;
    }

    export(): FormInputConfigObject {
        return {
            __version: this.__version,
            schema: this.schema,
        };
    }
}

/**
 * Represents the configuration for form output fields in a routine.
 */
class FormOutputConfig {
    __version: string;
    schema: FormSchema;

    constructor(data: FormOutputConfigObject) {
        this.__version = data.__version ?? "1.0";
        this.schema = data.schema;
    }

    export(): FormOutputConfigObject {
        return {
            __version: this.__version,
            schema: this.schema,
        };
    }
}

/**
 * Represents the configuration for a graph in a routine.
 */
abstract class GraphConfig {
    __version: string;
    __type: GraphType;

    constructor(data: GraphBaseConfigObject) {
        this.__version = data.__version ?? "1.0";
        this.__type = data.__type;
    }

    abstract export(): GraphConfigObject;

    static create(data: GraphConfigObject): GraphConfig {
        switch (data.__type) {
            case "BPMN-2.0":
                return new GraphBpmnConfig(data);
            default:
                throw new Error(`Unsupported __type: ${(data as { __type: string }).__type}`);
        }
    }
}

class GraphBpmnConfig extends GraphConfig {
    schema: BpmnSchema;

    constructor(data: GraphBpmnConfigObject) {
        super(data);
        this.schema = data.schema;
    }

    export(): GraphBpmnConfigObject {
        return {
            __version: this.__version,
            __type: this.__type as GraphType,
            schema: this.schema,
        };
    }

    // Add BPMN methods here
}
