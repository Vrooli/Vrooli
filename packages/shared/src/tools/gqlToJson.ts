/**
 * This script converts the TypeScript types generated by GraphQL Code Generator to an OpenAPI schema,
 * since we use the GraphQL types for our REST API as well.
 * To run this script, run `ts-node --esm --experimental-specifier-resolution node ./src/tools/gqlToJson.ts` from the `packages/shared` directory.
 */
import * as fs from "fs";
import * as path from "path";
import { getOpenApiWriter, getTypeScriptReader, makeConverter } from "typeconv";
import { fileURLToPath } from "url";

const main = async () => {
    // Get the directory name of the current module
    const dirname = path.dirname(fileURLToPath(import.meta.url));

    const pathToTsFile = path.resolve(dirname, "../api/generated/graphqlTypes.ts");

    // Read the TypeScript file
    let tsData = fs.readFileSync(pathToTsFile, "utf8");

    // Split into blocks of types
    let blocks = tsData.split("\n\n");

    // Remove the first block, which contains imports, Maybe, InputMaybe, and other types which are not used by the REST API
    blocks.shift();

    // Filter out other GraphQL-specific types from the rest of the blocks:
    // - Anything with `Resolver` in the name
    // - Maybe
    // - InputMaybe
    // - Exact
    // - MakeOptional
    // - MakeMaybe
    // - Omit
    // - RequireFields
    // - Scalars
    // - Mutation and Mutation...Args
    // - Query and Query...Args
    // Most of these were probably included in the first block, but depending on spacing maybe not
    blocks = blocks.filter(block => {
        // Get the first line of code (excluding comments)
        const firstLineOfCode = block.split("\n").find(line => !line.trim().startsWith("//") && !line.trim().startsWith("/*") && line.trim().length > 0);
        return !firstLineOfCode?.match(/export type .*Resolver.*/) &&
            !firstLineOfCode?.startsWith("export type Maybe<T> =") &&
            !firstLineOfCode?.startsWith("export type InputMaybe<T> = ") &&
            !firstLineOfCode?.startsWith("export type Exact<T extends ") &&
            !firstLineOfCode?.startsWith("export type MakeOptional<T, K extends ") &&
            !firstLineOfCode?.startsWith("export type MakeMaybe<T, K extends ") &&
            !firstLineOfCode?.startsWith("export type Omit<T, K extends ") &&
            !firstLineOfCode?.startsWith("export type RequireFields<T, K extends ") &&
            !firstLineOfCode?.startsWith("export type Scalars = ") &&
            !firstLineOfCode?.match(/export type Mutation[A-Za-z]* = /) &&
            !firstLineOfCode?.match(/export type Query[A-Za-z]* = /);
    });

    // Define a Map to store the enums and their corresponding string unions
    const enumMap = new Map<string, string>();

    // Convert TypeScript enums to string unions
    tsData = tsData.replace(/export enum (\w+) \{([^}]+)\}/g, (match, enumName, enumBody) => {
        // Split the body of the enum into individual members
        const enumMembers = enumBody.split(",");

        // Map each member to its value (the part after the equals sign)
        const enumValues = enumMembers.map(member => {
            const parts = member.trim().split("=");
            return parts[1]?.trim() || parts[0]?.trim();
        });

        // Join the values into a union
        const union = enumValues.join(" | ");

        // Store the enum and its corresponding union in the map
        enumMap.set(enumName, union);

        // Return an empty string to remove the enum block
        return "";
    });

    // Remove enum blocks from the array of blocks
    blocks = blocks.filter(block => !block.startsWith("export enum "));

    // Replace enum usages with their corresponding unions
    blocks = blocks.map(block => {
        let replacedBlock = block;
        for (const [enumName, union] of enumMap.entries()) {
            const enumRegex = new RegExp(`\\b${enumName}\\b`, "g");
            replacedBlock = replacedBlock.replace(enumRegex, union);
        }
        return replacedBlock;
    });

    // Join the blocks back together
    tsData = blocks.join("\n\n");

    // Replace GraphQL's custom scalar types with TypeScript's built-in types
    tsData = tsData.replace(/Scalars\['[A-Za-z]+'\]/g, (match) => {
        // Includes all built-in types, and any additional custom types (typically defined in `root` GraphQL typeDef)
        switch (match) {
            case "Scalars['Boolean']":
                return "boolean";
            case "Scalars['Date']":
                return "string";
            case "Scalars['Float']":
                return "number";
            case "Scalars['ID']":
                return "string";
            case "Scalars['Int']":
                return "number";
            case "Scalars['String']":
                return "string";
            case "Scalars['Upload']":
                return "unknown";
            default:
                throw new Error(`Unknown scalar type: ${match}`);
        }
    });

    // Replace GraphQL's `InputMaybe<T>` and `Maybe<T>` with TypeScript's `T | null`
    tsData = tsData.replace(/InputMaybe<Array<([^>]+)>>/g, "Array<$1> | null | undefined");
    tsData = tsData.replace(/Maybe<Array<([^>]+)>>/g, "Array<$1> | null | undefined");
    tsData = tsData.replace(/InputMaybe<([^>]+)>/g, "$1 | null | undefined");
    tsData = tsData.replace(/Maybe<([^>]+)>/g, "$1 | null | undefined");

    // Create the reader and writer
    const reader = getTypeScriptReader();
    const writer = getOpenApiWriter({ format: "json", title: "Vrooli", version: "1.9.4" });

    // Create the converter
    const { convert } = makeConverter(reader, writer);

    // Convert the TypeScript types to OpenAPI
    let { data } = await convert({ data: tsData });

    // Parse the JSON
    const openApiSchema = JSON.parse(data);

    // Add additional fields
    openApiSchema.info.description = "This is the REST API for Vrooli. Find out more about Vrooli at https://vrooli.com/about";
    openApiSchema.info.termsOfService = "https://vrooli.com/terms";
    openApiSchema.info.contact = {
        name: "Vrooli API Support",
        email: "support@vrooli.com",
    };
    openApiSchema.info.license = {
        name: "GPL-3.0",
        url: "https://opensource.org/licenses/GPL-3.0",
    };

    // Stringify the JSON
    data = JSON.stringify(openApiSchema, null, 2);

    // Write the OpenAPI schema to a file
    fs.writeFile(path.resolve(dirname, "../../../docs/docs/assets/openapi.json"), data, (err) => {
        if (err) throw err;
        console.log("The OpenAPI schema has been saved!");
    });
};

main().catch(console.error);
