// Import common types and utilities
import { API_CREDITS_MULTIPLIER } from "../../consts/api.js";
import { type PassableLogger } from "../../consts/commonTypes.js";
import { DAYS_1_MS, MINUTES_10_MS, MINUTES_1_MS, SECONDS_1_MS } from "../../consts/numbers.js";
import { EventTypes } from "../../consts/socketEvents.js";
import { RunState } from "../../execution/routine.js";
import { type ResourceSpec } from "./bot.js";
import { type ModelConfig } from "./base.js";

// Keep track of config version for future compatibility
const LATEST_CONFIG_VERSION = "1.0";

/**
 * Configuration for sensitive data protection within the swarm.
 * Defines what data is considered sensitive and how it should be handled.
 */
export interface DataSensitivityConfig {
    /** Type of sensitive data (PII, PHI, FINANCIAL, CREDENTIAL, PROPRIETARY) */
    type: "PII" | "PHI" | "FINANCIAL" | "CREDENTIAL" | "PROPRIETARY";
    /** Human-readable description of what this sensitivity covers */
    description?: string;
    /** Whether to log access attempts to this sensitive data */
    accessLog?: boolean;
    /** Whether to require explicit user consent before accessing */
    requireConfirmation?: boolean;
}

/**
 * Represents a single sub-task within a swarm's shared state.
 */
export interface SwarmSubTask {
    /** Any unique string to identify the sub-task (e.g. epoch time + random string). */
    id: string;
    /** Detailed description of the sub-task. */
    description: string;
    /** Current status of the sub-task. */
    status: "todo" | "in_progress" | "done" | "blocked" | "failed" | "canceled";
    /** Optional ID of the bot assigned to this sub-task. */
    assignee_bot_id?: string;
    /** Optional array of IDs of other sub-tasks that this sub-task depends on. */
    depends_on?: string[];
    /** The timestamp when the resource was created */
    created_at: string;
    /** Optional priority level for the task. */
    priority?: "low" | "medium" | "high";
}

/** 
 * Immutable reference to any resource the swarm might use
 * 
 * NOTE: This must be an actual resource that can be found using the ResourceManage tool.
 */
export interface SwarmResource {
    /** The ID of the resource */
    id: string;
    /** The kind of resource */
    kind: "Note" | "File" | "URL" | "Vector" | "Image" | "Other";
    /** The MIME type of the resource */
    mime?: string;
    /** The ID of the bot that created the resource */
    creator_bot_id: string;
    /** The timestamp when the resource was created */
    created_at: string;
    meta?: Record<string, any>; // size, checksum, model, etc.
}

/**
 * An item in the shared scratchpad.
 */
export interface BlackboardItem {
    /** Any unique string to identify the sub-task (e.g. epoch time + random string). */
    id: string;
    /** The value of the item */
    value: unknown;
    /** The timestamp when the item was created */
    created_at: string;
}


/**
 * Defines the possible states for a pending tool call that is awaiting approval or scheduled execution.
 */
export enum PendingToolCallStatus {
    PENDING_APPROVAL = "PENDING_APPROVAL",
    SCHEDULED_FOR_EXECUTION = "SCHEDULED_FOR_EXECUTION",
    APPROVED_READY_FOR_EXECUTION = "APPROVED_READY_FOR_EXECUTION",
    REJECTED_BY_USER = "REJECTED_BY_USER",
    REJECTED_BY_TIMEOUT = "REJECTED_BY_TIMEOUT",
    EXECUTING = "EXECUTING",
    COMPLETED_SUCCESS = "COMPLETED_SUCCESS",
    COMPLETED_FAILURE = "COMPLETED_FAILURE",
    CANCELLED_BY_SYSTEM = "CANCELLED_BY_SYSTEM"
}

/**
 * Represents a tool call that has been deferred, awaiting user approval or scheduled execution.
 * This entry would typically be stored in a persistent or semi-persistent store (e.g., DB table or Redis).
 */
export interface PendingToolCallEntry {
    /** Unique ID for this pending request, generated by Vrooli server-side (e.g., nanoid). */
    pendingId: string;
    /** Original tool_call_id from the LLM, used to link back to the assistant's message that requested the call. */
    toolCallId: string;
    /** The name of the tool to be executed (e.g., "web_search", "file_search"). */
    toolName: string;
    /** JSON string of arguments for the tool, as provided by the LLM. */
    toolArguments: string;
    /** ID of the bot that initiated this tool call. */
    callerBotId: string;
    /** ID of the chat this pending tool call pertains to. */
    conversationId: string;
    /** Timestamp (epoch milliseconds) when the tool call was first identified by the LLM and deferred. */
    requestedAt: number;
    /** Current status of this pending tool call. */
    status: PendingToolCallStatus;
    /** Optional human-readable reason for the current status (e.g., "User rejected due to cost concerns", "Approval timed out"). */
    statusReason?: string;
    /** Timestamp (epoch milliseconds) for when it should run if explicitly scheduled or after approval has been granted (if a post-approval delay is configured). */
    scheduledExecutionTime?: number;
    /** Timestamp (epoch milliseconds) when the approval window expires (if approval is required). */
    approvalTimeoutAt?: number;
    /** Optional: ID of the specific user whose approval is required (e.g., based on conversation owner or specific permissions). */
    userIdToApprove?: string;
    /** Optional: ID of the user who made the approval/rejection decision. */
    approvedOrRejectedByUserId?: string;
    /** Optional: Timestamp (epoch milliseconds) of the approval or rejection decision. */
    decisionTime?: number;
    /** Counter for how many times execution has been attempted (useful for implementing retries). Initialized to 0. */
    executionAttempts: number;
    /** Timestamp (epoch milliseconds) of the last execution attempt. */
    lastAttemptTime?: number;
    /** JSON string of the tool's output (if status is COMPLETED_SUCCESS). */
    result?: string;
    /** JSON string of error details (if status is COMPLETED_FAILURE or during execution attempts that failed). */
    error?: string;
    /** Cost of the tool call (as a string, to be parsed to BigInt), recorded after successful or failed execution. */
    cost?: string;
}

/**
 * Governs who can read, publish or join this swarm chat. Optional.
 */
export interface SwarmPolicy {
    /** "open" (anyone on server), "restricted" (read-only for all, write for ACL), "private" (visible only to ACL). */
    visibility: "open" | "restricted" | "private";
    /** Whitelist of bot or user IDs relevant when visibility ≠ "open". */
    acl?: string[];
}

/**
 * Context for managing agent resources within a swarm.
 * Combines resources from multiple sources with proper precedence resolution.
 */
export interface SwarmResourceContext {
    /** Resources brought by bots (portable across swarms) */
    botResources: ResourceSpec[];
    /** Resources specific to the current swarm */
    swarmResources: ResourceSpec[];
    /** Platform-wide resources available to all agents */
    globalResources: ResourceSpec[];
    /** Computed: All resources available to agents with precedence resolved */
    availableResources: ResourceSpec[];
}

// Import ServiceEvent type - will be resolved at build time
type ServiceEvent = any; // Placeholder - actual type comes from server events

/**
 * Configuration for parent-child swarm relationships
 */
export interface SwarmHierarchy {
    /** ID of parent swarm (set automatically when spawned as child) */
    parentSwarmId?: string;
    
    /** Current depth in hierarchy (0 = root, 1 = child, 2 = grandchild) */
    currentDepth: number;
    
    /** Maximum allowed depth (0 = no children, 1 = children but no grandchildren) */
    maxDepth: number;
    
    /** Child spawn policy */
    childPolicy: {
        /** Mode for child spawning */
        mode: "unrestricted" | "exclusive";
        
        /** Maximum number of concurrent children (-1 = unlimited) */
        maxConcurrentChildren: number;
    };
    
    /** Templates for child swarms */
    childTemplates?: ChildSwarmTemplate[];
}

/**
 * Template for spawning child swarms
 */
export interface ChildSwarmTemplate {
    /** Unique identifier for this template */
    id: string;
    
    /** Human-readable name */
    name: string;
    
    /** Description of what this child swarm does */
    description: string;
    
    /** Spawn requirement */
    requirement: "required" | "recommended" | "optional";
    
    /** Configuration template for the child */
    config: ChildSwarmConfig;
}

/**
 * Configuration for a child swarm
 */
export interface ChildSwarmConfig {
    /** Goal for the child swarm (can use {{variables}} from parent context) */
    goal: string;
    
    /** Model configuration (null = inherit from parent) */
    modelConfig?: ModelConfig | null;
    
    /** Team configuration */
    team?: {
        /** Use parent's team */
        inheritFromParent?: boolean;
        /** Or specify team ID */
        teamId?: string;
        /** Or create ad-hoc team */
        bots?: string[]; // bot IDs
    };
    
    /** Communication settings */
    communication?: {
        /** How child reports to parent */
        reportingMode: "events-only" | "on-completion";
        /** Event types child should forward to parent */
        forwardedEvents?: string[];
    };
}

/**
 * Runtime tracking of an active child swarm
 */
export interface ActiveChildSwarm {
    /** Child swarm's conversation ID */
    childSwarmId: string;
    
    /** Template ID if spawned from template */
    templateId?: string;
    
    /** When the child was spawned */
    spawnedAt: string;
    
    /** Current state of child */
    state: RunState;
    
    /** Stop reason if stopped/failed */
    stopReason?: string;
    
    /** Resources allocated to child (auto-calculated from parent's remaining resources) */
    allocatedResources: {
        maxCredits: string;
        maxToolCalls: number;
    };
    
    /** Summary statistics from child */
    summary?: {
        lastUpdated: string;
        subtasksCompleted: number;
        creditsUsed: string;
        toolCallsUsed: number;
        currentGoal?: string;
    };
}

/**
 * Represents all data that can be stored in a chat's stringified config.
 * Corresponds to Conversation.meta in the server-side types.
 */
export interface ChatConfigObject {
    /** Store the version number for future compatibility */
    __version: string;
    /** The primary objective of the swarm. Can only be set if there is no current goal, or if the goal is the default "Follow the user's instructions." */
    goal?: string;
    /** The model configuration for this conversation. Persisted when user selects a model. */
    modelConfig?: ModelConfig;
    /** Optional initial list of sub-tasks for the swarm. Defaults to an empty list if not provided. */
    subtasks?: SwarmSubTask[];
    /** ID of the swarm leader. Read-only.. */
    swarmLeader?: string;
    /** subtaskId → botId */
    subtaskLeaders?: Record<string, string>;
    /** ID of the team associated with the swarm. */
    teamId?: string;
    /** ID of the bot that currently has the conversation "baton" for turn-taking control */
    activeBotId?: string;
    /** A shared scratchpad for notes, data, intermediate results, and any other short-form and short-lived text that's relevant to completing the goal or current subtask. */
    blackboard?: BlackboardItem[];
    /** A list of resources created by the swarm or that are useful context for completing the goal or current subtask. */
    resources?: SwarmResource[];
    /** A list of events that have occurred in the swarm */
    records?: ServiceEvent[];
    /** Configuration for event persistence */
    eventConfig?: {
        /** Which event types to record (using existing EventTypes constants) */
        recordedEventTypes: string[];
        /** Maximum total events to keep */
        maxTotalEvents?: number;
        /** Method for removing events when limit is reached */
        compressionMethod?: "remove_oldest" | "remove_middle" | "ai_prioritize";
    };
    /** Governs who can read, publish or join this swarm chat. Optional. */
    policy?: SwarmPolicy;
    /** Statistics about the swarm's duration and resource usage. Read-only. */
    stats: {
        /** since convo began */
        totalToolCalls: number;
        totalCredits: string; // Stringified bigint
        /** conversation creation or first‑seen time */
        startedAt: number | null;
        /** wall‑clock of last completed processing cycle */
        lastProcessingCycleEndedAt: number | null;
        /** Bot-level stats, by botId */
        botStats?: Record<string, {
            tasksCompleted: number;
            averageTaskDuration: number;
            successRate: number;
        }>;
    };
    /** Defined limits on the swarm's duration and resource usage. Read-only. */
    limits?: {
        /** Maximum number of tool calls a single bot can make during its response generation. */
        maxToolCallsPerBotResponse?: number;
        /** Maximum number of tool calls per conversation */
        maxToolCalls?: number;
        /** Maximum API credits a single bot can consume for its response generation, as a stringified bigint */
        maxCreditsPerBotResponse?: string;
        /** Maximum API credits per conversation, as a stringified bigint */
        maxCredits?: string;
        /** Maximum duration for a single bot's response generation (ms) */
        maxDurationPerBotResponseMs?: number;
        /** Maximum duration per conversation (ms) */
        maxDurationMs?: number;
        /** Delay between processing cycles (e.g., after a full multi-bot response cycle before another might begin) (ms) */
        delayBetweenProcessingCyclesMs?: number;
    };
    /** Configuration for scheduling and approval of tool calls. Read-only. */
    scheduling?: {
        /** Default delay in milliseconds for tool calls that are scheduled but don't require explicit user approval. Applied if no tool-specific delay is found. */
        defaultDelayMs?: number;
        /** Delays for specific tools, overriding defaultDelayMs. Key is tool name, value is delay in ms. */
        toolSpecificDelays?: { [toolName: string]: number };
        /** Defines which tools require user approval. Can be an array of tool names, "all" for all tools, or "none" (or undefined) for no tools requiring approval. */
        requiresApprovalTools?: string[] | "all" | "none";
        /** Time in milliseconds to wait for user approval before the request times out. */
        approvalTimeoutMs?: number;
        /** If true, a tool call pending approval is automatically rejected when approvalTimeoutMs is reached. Defaults to true if not specified. */
        autoRejectOnTimeout?: boolean;
    };
    /** Optional array of tool calls that are pending approval or scheduled for later execution. */
    pendingToolCalls?: PendingToolCallEntry[];
    /** Configuration for sensitive data patterns and access controls */
    secrets?: Record<string, DataSensitivityConfig>;
    /** Parent-child swarm configuration */
    hierarchy?: SwarmHierarchy;
    /** Runtime tracking of spawned children */
    activeChildren?: ActiveChildSwarm[];
}

/**
 * Top-level Chat config that encapsulates all chat-related configuration data.
 */
export class ChatConfig {
    __version: string;
    goal?: ChatConfigObject["goal"];
    modelConfig?: ChatConfigObject["modelConfig"];
    subtasks?: ChatConfigObject["subtasks"];
    swarmLeader?: ChatConfigObject["swarmLeader"];
    subtaskLeaders?: ChatConfigObject["subtaskLeaders"];
    teamId?: ChatConfigObject["teamId"];
    blackboard?: ChatConfigObject["blackboard"];
    resources?: ChatConfigObject["resources"];
    records?: ChatConfigObject["records"];
    eventConfig?: ChatConfigObject["eventConfig"];
    policy?: ChatConfigObject["policy"];
    stats: ChatConfigObject["stats"];
    limits?: ChatConfigObject["limits"];
    scheduling?: ChatConfigObject["scheduling"];
    pendingToolCalls?: ChatConfigObject["pendingToolCalls"];
    secrets?: ChatConfigObject["secrets"];
    hierarchy?: ChatConfigObject["hierarchy"];
    activeChildren?: ChatConfigObject["activeChildren"];

    constructor({ config }: { config: ChatConfigObject }) {
        this.__version = config.__version ?? LATEST_CONFIG_VERSION;
        this.goal = config.goal;
        this.modelConfig = config.modelConfig;
        this.subtasks = config.subtasks ?? [];
        this.swarmLeader = config.swarmLeader;
        this.subtaskLeaders = config.subtaskLeaders;
        this.teamId = config.teamId;
        this.blackboard = config.blackboard ?? [];
        this.resources = config.resources ?? [];
        this.records = config.records ?? [];
        this.eventConfig = config.eventConfig;
        this.policy = config.policy;
        this.stats = config.stats ?? ChatConfig.defaultStats();
        this.limits = config.limits;
        this.scheduling = config.scheduling;
        this.pendingToolCalls = config.pendingToolCalls ?? [];
        this.secrets = config.secrets;
        this.hierarchy = config.hierarchy;
        this.activeChildren = config.activeChildren;
    }

    /**
     * Parse and instantiate a ChatConfig from a serialized string.
     * Populates defaults when useFallbacks is true.
     */
    static parse(
        version: { config: ChatConfigObject },
        logger: PassableLogger,
        opts?: { useFallbacks?: boolean },
    ): ChatConfig {
        const config = version.config;
        if (opts?.useFallbacks ?? true) {
            config.limits ??= ChatConfig.defaultLimits();
            config.stats ??= ChatConfig.defaultStats();
            config.scheduling ??= ChatConfig.defaultScheduling();
        }
        return new ChatConfig({ config });
    }

    /**
     * Creates a default ChatConfig with no active bot and default limits.
     */
    static default(): ChatConfig {
        const config: ChatConfigObject = {
            __version: LATEST_CONFIG_VERSION,
            resources: [],
            records: [],
            eventConfig: {
                recordedEventTypes: [
                    EventTypes.TOOL.COMPLETED,
                    EventTypes.TOOL.FAILED,
                    EventTypes.TOOL.APPROVAL_GRANTED,
                    EventTypes.TOOL.APPROVAL_REJECTED,
                    EventTypes.SWARM.STATE_CHANGED,
                    EventTypes.CHAT.MESSAGE_ADDED,
                ],
                maxTotalEvents: 500,
                compressionMethod: "remove_oldest",
            },
            limits: ChatConfig.defaultLimits(),
            stats: ChatConfig.defaultStats(),
            scheduling: ChatConfig.defaultScheduling(),
            pendingToolCalls: [],
        };
        return new ChatConfig({ config });
    }

    /**
     * Exports the config to a plain object.
     */
    export(): ChatConfigObject {
        return {
            __version: this.__version,
            goal: this.goal,
            modelConfig: this.modelConfig,
            subtasks: this.subtasks,
            swarmLeader: this.swarmLeader,
            subtaskLeaders: this.subtaskLeaders,
            teamId: this.teamId,
            blackboard: this.blackboard,
            resources: this.resources,
            records: this.records,
            eventConfig: this.eventConfig,
            policy: this.policy,
            stats: this.stats,
            limits: this.limits,
            scheduling: this.scheduling,
            pendingToolCalls: this.pendingToolCalls,
            secrets: this.secrets,
            hierarchy: this.hierarchy,
            activeChildren: this.activeChildren,
        };
    }

    /**
     * Provides default conversation limits (empty object of optional fields).
     */
    static defaultLimits(): ChatConfigObject["limits"] {
        return { ...ChatConfig.DEFAULT_LIMITS };
    }

    /**
     * Default stats for a conversation.
     */
    static defaultStats(): ChatConfigObject["stats"] {
        return {
            totalToolCalls: 0,
            totalCredits: "0",
            startedAt: new Date().getTime(),
            lastProcessingCycleEndedAt: null,
        };
    }

    /**
     * Absolute caps for conversation limits.
     */
    public static ABSOLUTE_LIMITS = {
        maxToolCallsPerBotResponse: 50,
        maxToolCalls: 1000,
        maxCreditsPerBotResponse: API_CREDITS_MULTIPLIER * BigInt(2),
        maxCredits: API_CREDITS_MULTIPLIER * BigInt(100),
        maxDurationPerBotResponseMs: MINUTES_10_MS,
        maxDurationMs: DAYS_1_MS,
        delayBetweenProcessingCyclesMs: MINUTES_1_MS,
    } as const;

    /**
     * Sensible default limits for a conversation.
     */
    public static readonly DEFAULT_LIMITS: Required<NonNullable<ChatConfigObject["limits"]>> = {
        maxToolCallsPerBotResponse: 10,
        maxToolCalls: 50,
        maxCreditsPerBotResponse: (API_CREDITS_MULTIPLIER * BigInt(1)).toString(),
        // eslint-disable-next-line no-magic-numbers
        maxCredits: (API_CREDITS_MULTIPLIER * BigInt(5)).toString(), // $5.00
        maxDurationPerBotResponseMs: MINUTES_1_MS,
        maxDurationMs: MINUTES_10_MS,
        delayBetweenProcessingCyclesMs: 0,
    };

    /**
     * Sets or replaces the conversation limits.
     */
    setLimits(limits: ChatConfigObject["limits"]): void {
        this.limits = limits;
    }

    /**
     * Merges configured limits with absolute caps to produce effective limits.
     */
    public getEffectiveLimits(): Required<NonNullable<ChatConfigObject["limits"]>> {
        // Start with a full set of sensible defaults
        const mergedLimits: Required<NonNullable<ChatConfigObject["limits"]>> = {
            ...ChatConfig.DEFAULT_LIMITS,
            ...(this.limits ?? {}),
        };

        const { maxToolCallsPerBotResponse, maxToolCalls, maxCreditsPerBotResponse, maxCredits, maxDurationPerBotResponseMs, maxDurationMs, delayBetweenProcessingCyclesMs } = ChatConfig.ABSOLUTE_LIMITS;

        function inNumberRange(absMax: number, currentVal: number, absMin = 0): number {
            return Math.max(absMin, Math.min(absMax, currentVal));
        }
        function inBigIntRange(absMax: bigint, currentValStr: string, absMin = BigInt(0)): bigint {
            const currentVal = BigInt(currentValStr);
            const numAbsMax = Number(absMax);
            const numCurrentVal = Number(currentVal);
            const numAbsMin = Number(absMin);
            const clampedNum = Math.max(numAbsMin, Math.min(numAbsMax, numCurrentVal));
            return BigInt(clampedNum);
        }

        return {
            maxToolCallsPerBotResponse: inNumberRange(maxToolCallsPerBotResponse, mergedLimits.maxToolCallsPerBotResponse),
            maxToolCalls: inNumberRange(maxToolCalls, mergedLimits.maxToolCalls),
            maxCreditsPerBotResponse: inBigIntRange(maxCreditsPerBotResponse, mergedLimits.maxCreditsPerBotResponse).toString(),
            maxCredits: inBigIntRange(maxCredits, mergedLimits.maxCredits).toString(),
            maxDurationPerBotResponseMs: inNumberRange(maxDurationPerBotResponseMs, mergedLimits.maxDurationPerBotResponseMs),
            maxDurationMs: inNumberRange(maxDurationMs, mergedLimits.maxDurationMs),
            delayBetweenProcessingCyclesMs: inNumberRange(delayBetweenProcessingCyclesMs, mergedLimits.delayBetweenProcessingCyclesMs),
        };
    }

    /**
     * Sensible default scheduling for a conversation.
     */
    public static readonly DEFAULT_SCHEDULING: Required<NonNullable<ChatConfigObject["scheduling"]>> = {
        defaultDelayMs: 0,
        toolSpecificDelays: {},
        requiresApprovalTools: "none",
        approvalTimeoutMs: MINUTES_10_MS,
        autoRejectOnTimeout: true,
    };

    /**
     * Default scheduling for a conversation.
     */
    static defaultScheduling(): ChatConfigObject["scheduling"] {
        return { ...ChatConfig.DEFAULT_SCHEDULING };
    }

    /**
     * Sets or replaces the conversation scheduling.
     */
    setScheduling(scheduling: ChatConfigObject["scheduling"]): void {
        this.scheduling = scheduling;
    }

    /**
     * Merges configured scheduling with default scheduling to produce effective scheduling.
     */
    public getEffectiveScheduling(): Required<NonNullable<ChatConfigObject["scheduling"]>> {
        // Start with the class defaults
        const defaults = ChatConfig.DEFAULT_SCHEDULING;
        // Merge with current instance's scheduling settings, if they exist
        const current = this.scheduling ?? {};

        // Ensure all required fields are present, falling back to defaults if necessary
        const effectiveScheduling: Required<NonNullable<ChatConfigObject["scheduling"]>> = {
            defaultDelayMs: current.defaultDelayMs ?? defaults.defaultDelayMs,
            toolSpecificDelays: { ...defaults.toolSpecificDelays, ...(current.toolSpecificDelays ?? {}) },
            requiresApprovalTools: current.requiresApprovalTools ?? defaults.requiresApprovalTools,
            approvalTimeoutMs: current.approvalTimeoutMs ?? defaults.approvalTimeoutMs,
            autoRejectOnTimeout: current.autoRejectOnTimeout ?? defaults.autoRejectOnTimeout,
        };

        // --- Validation and Clamping ---

        // Ensure defaultDelayMs is non-negative
        effectiveScheduling.defaultDelayMs = Math.max(0, effectiveScheduling.defaultDelayMs);

        // Ensure all toolSpecificDelays are non-negative
        const clampedToolSpecificDelays: { [toolName: string]: number } = {};
        for (const toolName in effectiveScheduling.toolSpecificDelays) {
            if (Object.prototype.hasOwnProperty.call(effectiveScheduling.toolSpecificDelays, toolName)) {
                clampedToolSpecificDelays[toolName] = Math.max(0, effectiveScheduling.toolSpecificDelays[toolName]);
            }
        }
        effectiveScheduling.toolSpecificDelays = clampedToolSpecificDelays;

        // Ensure approvalTimeoutMs is at least SECONDS_1_MS (1 second)
        // No explicit maximum is defined here, but could be added similarly to ABSOLUTE_LIMITS if needed.
        const MIN_APPROVAL_TIMEOUT_MS = SECONDS_1_MS;
        effectiveScheduling.approvalTimeoutMs = Math.max(MIN_APPROVAL_TIMEOUT_MS, effectiveScheduling.approvalTimeoutMs);

        // The requiresApprovalTools and autoRejectOnTimeout are boolean/string enum types,
        // so direct clamping isn't applicable in the same way.
        // Their validity is primarily based on adhering to the allowed string values or boolean type,
        // which TypeScript helps enforce at compile time if types are strict.

        return effectiveScheduling;
    }

    /**
     * Updates the events (records) array with size limiting and compression.
     * Ensures the array doesn't grow unbounded while maintaining important history.
     * 
     * @param newEvent The new event to add to the records
     * @param maxEvents Maximum number of events to keep (default: 500)
     * @param compressionMethod Method for removing events when limit is reached
     */
    public updateEvents(
        newEvent: ServiceEvent,
        maxEvents = 500,
        compressionMethod: "remove_oldest" | "remove_middle" | "ai_prioritize" = "remove_oldest",
    ): void {
        // Initialize records array if it doesn't exist
        if (!this.records) {
            this.records = [];
        }

        const updatedRecords = [...this.records, newEvent];

        // Apply size limit using specified compression method
        if (updatedRecords.length > maxEvents) {
            switch (compressionMethod) {
                case "remove_oldest": {
                    this.records = updatedRecords.slice(-maxEvents); // Keep most recent
                    break;
                }
                case "remove_middle": {
                    // Keep first 25% and last 75%
                    const keepFirst = Math.floor(maxEvents * 0.25);
                    const keepLast = maxEvents - keepFirst;
                    this.records = [
                        ...updatedRecords.slice(0, keepFirst),
                        ...updatedRecords.slice(-keepLast),
                    ];
                    break;
                }
                case "ai_prioritize": {
                    // For now, fallback to remove_oldest (AI prioritization can be implemented later)
                    this.records = updatedRecords.slice(-maxEvents);
                    break;
                }
                default: {
                    this.records = updatedRecords.slice(-maxEvents);
                    break;
                }
            }
        } else {
            this.records = updatedRecords;
        }
    }

    /**
     * Add a swarm event to the records if it should be recorded
     * 
     * @param event The ServiceEvent to potentially add
     */
    public addSwarmEvent(event: ServiceEvent): void {
        const eventConfig = this.eventConfig || this.getDefaultEventConfig();

        // Check if this event type should be recorded
        if (!eventConfig.recordedEventTypes.includes(event.type)) {
            return;
        }

        this.updateEvents(
            event,
            eventConfig.maxTotalEvents || 500,
            eventConfig.compressionMethod || "remove_oldest",
        );
    }

    /**
     * Get default event recording configuration
     */
    private getDefaultEventConfig() {
        return {
            recordedEventTypes: [
                EventTypes.TOOL.COMPLETED,
                EventTypes.TOOL.FAILED,
                EventTypes.TOOL.APPROVAL_GRANTED,
                EventTypes.TOOL.APPROVAL_REJECTED,
                EventTypes.SWARM.STATE_CHANGED,
                EventTypes.CHAT.MESSAGE_ADDED,
            ],
            maxTotalEvents: 500,
            compressionMethod: "remove_oldest" as const,
        };
    }
} 
