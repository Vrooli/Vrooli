/**
 * Converts query/mutation data (which is set up to be type-safe and reduce code duplication) into either graphql tags 
 * or PartialGraphQLInfo objects, depending on whether the desired endpoint is a graphql endpoint or a rest endpoint.
 * This is done during build to reduce runtime computation.
 */
import fs from "fs";
import path from "path";
import { fileURLToPath } from "url";
import { endpoints } from "./endpoints";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// TODO 1 for morning: This script should now only generate prisma select objects, using a simplified version of the GqlPartial objects that doesn't use  __union or anything like that (can still use nav, common, etc.). And shared package script should still generate OpenAPI schema, but in a better way probably. When done, we should make sure that any old references to GraphQL in the 2 API_GENERATE scripts (see build.sh) are removed, and any code with "loc" (indicating old generated graphql types) is removed. Then rename toPartialGqlInfo, graphqlFields, and toGraphQL
// TODO 2: Rewrite toPartialGqlInfo. Types shouldn't need caching, and shouldn't be designed in a way that needs modification (i.e. remove search shape, so that the shapes generated by this script (which are passed into `info`) are the exact prisma select)

/**
 * Creates a folder if it doesn't exist
 */
function createFolder(folder: string) {
    const absolutePath = path.resolve(__dirname, folder);
    const folderName = path.basename(absolutePath);
    if (!fs.existsSync(absolutePath)) {
        console.info(`Creating folder: "${folderName}" at "${absolutePath}"`);
        fs.mkdirSync(absolutePath, { recursive: true });
    } else {
        console.info(`Folder "${folderName}" already exists at "${absolutePath}"`);
    }
}

/**
 * Empties the contents of a folder if it exists (files only, not subfolders)
 */
function clearFilesInFolder(folder: string) {
    const absolutePath = path.resolve(__dirname, folder);
    if (fs.existsSync(absolutePath)) {
        const files = fs.readdirSync(absolutePath);
        for (const file of files) {
            const filePath = path.resolve(absolutePath, file);
            if (fs.lstatSync(filePath).isFile()) {
                fs.unlinkSync(filePath);
            }
        }
    }
}

async function main() {
    // Create output folder
    const outputPath = "../../endpoints/generated";
    createFolder(outputPath);
    // clearFilesInFolder(outputPath);

    // Unlazy each endpoint group and write it to a separate file
    console.info("Generating graphql-tag strings for endpoints...");
    for (const group of Object.keys(endpoints)) {
        const endpointGroup = await endpoints[group]();
        console.info(`generating endpoints for ${group}...`);
        for (const endpoint of Object.keys(endpointGroup)) {
            // Get the endpoint data
            const data = await endpointGroup[endpoint] as object;
            // Create file name
            const outputName = `${group}_${endpoint}`;
            // Write the data to a file, as a JavaScript export
            // eslint-disable-next-line no-magic-numbers
            const output = `export const ${outputName} = ${JSON.stringify(data, null, 4)};`;
            console.log("Writing to file", outputName);
            // fs.writeFileSync(path.resolve(__dirname, outputPath, `${outputName}.ts`), output);
            process.exit();
        }
    }
    process.exit();

    console.info("Finished generating graphql-tag strings for endpointsðŸš€");
}

main().catch(console.error).finally(() => process.exit());
