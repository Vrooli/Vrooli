// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.11
// 	protoc        (unknown)
// source: browser-automation-studio/v1/actions/action.proto

package actions

import (
	base "github.com/vrooli/vrooli/packages/proto/gen/go/browser-automation-studio/v1/base"
	domain "github.com/vrooli/vrooli/packages/proto/gen/go/browser-automation-studio/v1/domain"
	v1 "github.com/vrooli/vrooli/packages/proto/gen/go/common/v1"
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	timestamppb "google.golang.org/protobuf/types/known/timestamppb"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// ActionType enumerates all supported browser automation action kinds.
//
// Each type corresponds to a specific *Params message in ActionDefinition.params.
// The type field MUST match the populated params oneof case.
//
// @usage ActionDefinition.type, workflow editor action palette
type ActionType int32

const (
	// Default/unknown action type. Should not be used.
	// Indicates missing or corrupted type field.
	ActionType_ACTION_TYPE_UNSPECIFIED ActionType = 0
	// Navigate to a URL or scenario page.
	// Params: NavigateParams (url, wait_for_selector, timeout_ms, etc.)
	// Example: Go to "https://example.com/login"
	ActionType_ACTION_TYPE_NAVIGATE ActionType = 1
	// Click on an element (left, right, or middle button).
	// Params: ClickParams (selector, button, click_count, modifiers, etc.)
	// Example: Click the "Submit" button
	ActionType_ACTION_TYPE_CLICK ActionType = 2
	// Type text into an input field.
	// Params: InputParams (selector, value, is_sensitive, submit, etc.)
	// Example: Enter "user@example.com" into email field
	ActionType_ACTION_TYPE_INPUT ActionType = 3
	// Wait for a condition (time delay or element state).
	// Params: WaitParams (duration_ms OR selector with state)
	// Example: Wait for ".loading-spinner" to disappear
	ActionType_ACTION_TYPE_WAIT ActionType = 4
	// Assert a condition about an element.
	// Params: AssertParams (selector, mode, expected, negated, etc.)
	// Example: Assert ".success-message" is visible
	ActionType_ACTION_TYPE_ASSERT ActionType = 5
	// Scroll the page or a specific element.
	// Params: ScrollParams (selector, x, y, delta_x, delta_y, behavior)
	// Example: Scroll to bottom of page
	ActionType_ACTION_TYPE_SCROLL ActionType = 6
	// Select an option from a dropdown/select element.
	// Params: SelectParams (selector, value/label/index)
	// Example: Select "United States" from country dropdown
	ActionType_ACTION_TYPE_SELECT ActionType = 7
	// Execute arbitrary JavaScript in the page context.
	// Params: EvaluateParams (expression, store_result, args)
	// Example: Extract the order ID from page content
	ActionType_ACTION_TYPE_EVALUATE ActionType = 8
	// Press keyboard keys (single key or sequence).
	// Params: KeyboardParams (key, keys, modifiers, action)
	// Example: Press Ctrl+A to select all
	ActionType_ACTION_TYPE_KEYBOARD ActionType = 9
	// Hover over an element (trigger hover states/tooltips).
	// Params: HoverParams (selector, timeout_ms)
	// Example: Hover over menu item to reveal submenu
	ActionType_ACTION_TYPE_HOVER ActionType = 10
	// Capture a screenshot of the page or element.
	// Params: ScreenshotParams (full_page, selector, quality)
	// Example: Capture full-page screenshot for documentation
	ActionType_ACTION_TYPE_SCREENSHOT ActionType = 11
	// Focus an input element (for keyboard input).
	// Params: FocusParams (selector, scroll, timeout_ms)
	// Example: Focus the search input before typing
	ActionType_ACTION_TYPE_FOCUS ActionType = 12
	// Remove focus from the currently focused element.
	// Params: BlurParams (selector, timeout_ms)
	// Example: Blur input to trigger validation
	ActionType_ACTION_TYPE_BLUR ActionType = 13
	// Execute another workflow as a nested call.
	// Params: SubflowParams (workflow_id OR workflow_path, args)
	// Example: Call "login" workflow before continuing
	ActionType_ACTION_TYPE_SUBFLOW ActionType = 14
)

// Enum value maps for ActionType.
var (
	ActionType_name = map[int32]string{
		0:  "ACTION_TYPE_UNSPECIFIED",
		1:  "ACTION_TYPE_NAVIGATE",
		2:  "ACTION_TYPE_CLICK",
		3:  "ACTION_TYPE_INPUT",
		4:  "ACTION_TYPE_WAIT",
		5:  "ACTION_TYPE_ASSERT",
		6:  "ACTION_TYPE_SCROLL",
		7:  "ACTION_TYPE_SELECT",
		8:  "ACTION_TYPE_EVALUATE",
		9:  "ACTION_TYPE_KEYBOARD",
		10: "ACTION_TYPE_HOVER",
		11: "ACTION_TYPE_SCREENSHOT",
		12: "ACTION_TYPE_FOCUS",
		13: "ACTION_TYPE_BLUR",
		14: "ACTION_TYPE_SUBFLOW",
	}
	ActionType_value = map[string]int32{
		"ACTION_TYPE_UNSPECIFIED": 0,
		"ACTION_TYPE_NAVIGATE":    1,
		"ACTION_TYPE_CLICK":       2,
		"ACTION_TYPE_INPUT":       3,
		"ACTION_TYPE_WAIT":        4,
		"ACTION_TYPE_ASSERT":      5,
		"ACTION_TYPE_SCROLL":      6,
		"ACTION_TYPE_SELECT":      7,
		"ACTION_TYPE_EVALUATE":    8,
		"ACTION_TYPE_KEYBOARD":    9,
		"ACTION_TYPE_HOVER":       10,
		"ACTION_TYPE_SCREENSHOT":  11,
		"ACTION_TYPE_FOCUS":       12,
		"ACTION_TYPE_BLUR":        13,
		"ACTION_TYPE_SUBFLOW":     14,
	}
)

func (x ActionType) Enum() *ActionType {
	p := new(ActionType)
	*p = x
	return p
}

func (x ActionType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (ActionType) Descriptor() protoreflect.EnumDescriptor {
	return file_browser_automation_studio_v1_actions_action_proto_enumTypes[0].Descriptor()
}

func (ActionType) Type() protoreflect.EnumType {
	return &file_browser_automation_studio_v1_actions_action_proto_enumTypes[0]
}

func (x ActionType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use ActionType.Descriptor instead.
func (ActionType) EnumDescriptor() ([]byte, []int) {
	return file_browser_automation_studio_v1_actions_action_proto_rawDescGZIP(), []int{0}
}

// MouseButton enumerates supported mouse buttons for click actions.
//
// @usage ClickParams.button
type MouseButton int32

const (
	// Default. Uses LEFT button.
	MouseButton_MOUSE_BUTTON_UNSPECIFIED MouseButton = 0
	// Standard left mouse button. Most common for normal clicks.
	MouseButton_MOUSE_BUTTON_LEFT MouseButton = 1
	// Right mouse button. Opens context menus on most elements.
	MouseButton_MOUSE_BUTTON_RIGHT MouseButton = 2
	// Middle mouse button (scroll wheel click).
	// Often used for opening links in new tabs.
	MouseButton_MOUSE_BUTTON_MIDDLE MouseButton = 3
)

// Enum value maps for MouseButton.
var (
	MouseButton_name = map[int32]string{
		0: "MOUSE_BUTTON_UNSPECIFIED",
		1: "MOUSE_BUTTON_LEFT",
		2: "MOUSE_BUTTON_RIGHT",
		3: "MOUSE_BUTTON_MIDDLE",
	}
	MouseButton_value = map[string]int32{
		"MOUSE_BUTTON_UNSPECIFIED": 0,
		"MOUSE_BUTTON_LEFT":        1,
		"MOUSE_BUTTON_RIGHT":       2,
		"MOUSE_BUTTON_MIDDLE":      3,
	}
)

func (x MouseButton) Enum() *MouseButton {
	p := new(MouseButton)
	*p = x
	return p
}

func (x MouseButton) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (MouseButton) Descriptor() protoreflect.EnumDescriptor {
	return file_browser_automation_studio_v1_actions_action_proto_enumTypes[1].Descriptor()
}

func (MouseButton) Type() protoreflect.EnumType {
	return &file_browser_automation_studio_v1_actions_action_proto_enumTypes[1]
}

func (x MouseButton) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use MouseButton.Descriptor instead.
func (MouseButton) EnumDescriptor() ([]byte, []int) {
	return file_browser_automation_studio_v1_actions_action_proto_rawDescGZIP(), []int{1}
}

// NavigateWaitEvent enumerates events to wait for after navigation.
//
// Controls when navigation is considered "complete". Affects reliability
// vs. speed tradeoff. Maps to Playwright's waitUntil option.
//
// @usage NavigateParams.wait_until
type NavigateWaitEvent int32

const (
	// Default. Uses LOAD event.
	NavigateWaitEvent_NAVIGATE_WAIT_EVENT_UNSPECIFIED NavigateWaitEvent = 0
	// Wait for the 'load' event (all resources loaded).
	// Most reliable but slowest. Use for complex pages.
	NavigateWaitEvent_NAVIGATE_WAIT_EVENT_LOAD NavigateWaitEvent = 1
	// Wait for 'DOMContentLoaded' event (HTML parsed, deferred scripts run).
	// Faster than LOAD. Good when you don't need images/stylesheets.
	NavigateWaitEvent_NAVIGATE_WAIT_EVENT_DOMCONTENTLOADED NavigateWaitEvent = 2
	// Wait until network is idle (no requests for 500ms).
	// Good for SPAs that load data dynamically after initial render.
	NavigateWaitEvent_NAVIGATE_WAIT_EVENT_NETWORKIDLE NavigateWaitEvent = 3
)

// Enum value maps for NavigateWaitEvent.
var (
	NavigateWaitEvent_name = map[int32]string{
		0: "NAVIGATE_WAIT_EVENT_UNSPECIFIED",
		1: "NAVIGATE_WAIT_EVENT_LOAD",
		2: "NAVIGATE_WAIT_EVENT_DOMCONTENTLOADED",
		3: "NAVIGATE_WAIT_EVENT_NETWORKIDLE",
	}
	NavigateWaitEvent_value = map[string]int32{
		"NAVIGATE_WAIT_EVENT_UNSPECIFIED":      0,
		"NAVIGATE_WAIT_EVENT_LOAD":             1,
		"NAVIGATE_WAIT_EVENT_DOMCONTENTLOADED": 2,
		"NAVIGATE_WAIT_EVENT_NETWORKIDLE":      3,
	}
)

func (x NavigateWaitEvent) Enum() *NavigateWaitEvent {
	p := new(NavigateWaitEvent)
	*p = x
	return p
}

func (x NavigateWaitEvent) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (NavigateWaitEvent) Descriptor() protoreflect.EnumDescriptor {
	return file_browser_automation_studio_v1_actions_action_proto_enumTypes[2].Descriptor()
}

func (NavigateWaitEvent) Type() protoreflect.EnumType {
	return &file_browser_automation_studio_v1_actions_action_proto_enumTypes[2]
}

func (x NavigateWaitEvent) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use NavigateWaitEvent.Descriptor instead.
func (NavigateWaitEvent) EnumDescriptor() ([]byte, []int) {
	return file_browser_automation_studio_v1_actions_action_proto_rawDescGZIP(), []int{2}
}

// NavigateDestinationType indicates how a navigate target should be interpreted.
//
// Allows workflows to navigate to other Vrooli scenarios by name instead
// of hardcoding URLs, enabling portable workflows across environments.
//
// @usage NavigateParams.destination_type
type NavigateDestinationType int32

const (
	// Default. Treat as URL type.
	NavigateDestinationType_NAVIGATE_DESTINATION_TYPE_UNSPECIFIED NavigateDestinationType = 0
	// Target is a literal URL string.
	// Use NavigateParams.url field.
	NavigateDestinationType_NAVIGATE_DESTINATION_TYPE_URL NavigateDestinationType = 1
	// Target is a Vrooli scenario name + path.
	// Use NavigateParams.scenario and scenario_path fields.
	// The URL is resolved via the scenario registry.
	NavigateDestinationType_NAVIGATE_DESTINATION_TYPE_SCENARIO NavigateDestinationType = 2
)

// Enum value maps for NavigateDestinationType.
var (
	NavigateDestinationType_name = map[int32]string{
		0: "NAVIGATE_DESTINATION_TYPE_UNSPECIFIED",
		1: "NAVIGATE_DESTINATION_TYPE_URL",
		2: "NAVIGATE_DESTINATION_TYPE_SCENARIO",
	}
	NavigateDestinationType_value = map[string]int32{
		"NAVIGATE_DESTINATION_TYPE_UNSPECIFIED": 0,
		"NAVIGATE_DESTINATION_TYPE_URL":         1,
		"NAVIGATE_DESTINATION_TYPE_SCENARIO":    2,
	}
)

func (x NavigateDestinationType) Enum() *NavigateDestinationType {
	p := new(NavigateDestinationType)
	*p = x
	return p
}

func (x NavigateDestinationType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (NavigateDestinationType) Descriptor() protoreflect.EnumDescriptor {
	return file_browser_automation_studio_v1_actions_action_proto_enumTypes[3].Descriptor()
}

func (NavigateDestinationType) Type() protoreflect.EnumType {
	return &file_browser_automation_studio_v1_actions_action_proto_enumTypes[3]
}

func (x NavigateDestinationType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use NavigateDestinationType.Descriptor instead.
func (NavigateDestinationType) EnumDescriptor() ([]byte, []int) {
	return file_browser_automation_studio_v1_actions_action_proto_rawDescGZIP(), []int{3}
}

// WaitState enumerates element states for wait conditions.
//
// Used with WaitParams to wait for specific element lifecycle events.
// Maps to Playwright's waitForSelector state option.
//
// @usage WaitParams.state
type WaitState int32

const (
	// Default. Uses VISIBLE state.
	WaitState_WAIT_STATE_UNSPECIFIED WaitState = 0
	// Wait until element is attached to DOM (may not be visible).
	// Fast check; use when you just need the element to exist.
	WaitState_WAIT_STATE_ATTACHED WaitState = 1
	// Wait until element is removed from DOM.
	// Use for waiting for loading indicators to disappear.
	WaitState_WAIT_STATE_DETACHED WaitState = 2
	// Wait until element is visible to user (in viewport, displayed).
	// Most common state; ensures element can be interacted with.
	WaitState_WAIT_STATE_VISIBLE WaitState = 3
	// Wait until element becomes hidden (display:none or removed).
	// Use for waiting for modals/overlays to close.
	WaitState_WAIT_STATE_HIDDEN WaitState = 4
)

// Enum value maps for WaitState.
var (
	WaitState_name = map[int32]string{
		0: "WAIT_STATE_UNSPECIFIED",
		1: "WAIT_STATE_ATTACHED",
		2: "WAIT_STATE_DETACHED",
		3: "WAIT_STATE_VISIBLE",
		4: "WAIT_STATE_HIDDEN",
	}
	WaitState_value = map[string]int32{
		"WAIT_STATE_UNSPECIFIED": 0,
		"WAIT_STATE_ATTACHED":    1,
		"WAIT_STATE_DETACHED":    2,
		"WAIT_STATE_VISIBLE":     3,
		"WAIT_STATE_HIDDEN":      4,
	}
)

func (x WaitState) Enum() *WaitState {
	p := new(WaitState)
	*p = x
	return p
}

func (x WaitState) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (WaitState) Descriptor() protoreflect.EnumDescriptor {
	return file_browser_automation_studio_v1_actions_action_proto_enumTypes[4].Descriptor()
}

func (WaitState) Type() protoreflect.EnumType {
	return &file_browser_automation_studio_v1_actions_action_proto_enumTypes[4]
}

func (x WaitState) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use WaitState.Descriptor instead.
func (WaitState) EnumDescriptor() ([]byte, []int) {
	return file_browser_automation_studio_v1_actions_action_proto_rawDescGZIP(), []int{4}
}

// ScrollBehavior enumerates scroll animation behaviors.
//
// Controls whether scrolling is instant or animated. Smooth scrolling
// is more realistic but slower.
//
// @usage ScrollParams.behavior
type ScrollBehavior int32

const (
	// Default. Browser decides (usually instant).
	ScrollBehavior_SCROLL_BEHAVIOR_UNSPECIFIED ScrollBehavior = 0
	// Instant scroll jump. Fast and reliable.
	ScrollBehavior_SCROLL_BEHAVIOR_AUTO ScrollBehavior = 1
	// Animated smooth scroll. More realistic but takes time.
	// May cause timing issues if subsequent actions don't wait.
	ScrollBehavior_SCROLL_BEHAVIOR_SMOOTH ScrollBehavior = 2
)

// Enum value maps for ScrollBehavior.
var (
	ScrollBehavior_name = map[int32]string{
		0: "SCROLL_BEHAVIOR_UNSPECIFIED",
		1: "SCROLL_BEHAVIOR_AUTO",
		2: "SCROLL_BEHAVIOR_SMOOTH",
	}
	ScrollBehavior_value = map[string]int32{
		"SCROLL_BEHAVIOR_UNSPECIFIED": 0,
		"SCROLL_BEHAVIOR_AUTO":        1,
		"SCROLL_BEHAVIOR_SMOOTH":      2,
	}
)

func (x ScrollBehavior) Enum() *ScrollBehavior {
	p := new(ScrollBehavior)
	*p = x
	return p
}

func (x ScrollBehavior) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (ScrollBehavior) Descriptor() protoreflect.EnumDescriptor {
	return file_browser_automation_studio_v1_actions_action_proto_enumTypes[5].Descriptor()
}

func (ScrollBehavior) Type() protoreflect.EnumType {
	return &file_browser_automation_studio_v1_actions_action_proto_enumTypes[5]
}

func (x ScrollBehavior) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use ScrollBehavior.Descriptor instead.
func (ScrollBehavior) EnumDescriptor() ([]byte, []int) {
	return file_browser_automation_studio_v1_actions_action_proto_rawDescGZIP(), []int{5}
}

// KeyAction enumerates keyboard action types.
//
// Controls the keyboard event lifecycle. Most actions should use PRESS.
// DOWN/UP are for advanced scenarios like holding modifier keys.
//
// @usage KeyboardParams.action
type KeyAction int32

const (
	// Default. Uses PRESS (down + up).
	KeyAction_KEY_ACTION_UNSPECIFIED KeyAction = 0
	// Press and release the key (keydown + keyup).
	// Use for normal key presses (Enter, Tab, letters).
	KeyAction_KEY_ACTION_PRESS KeyAction = 1
	// Press the key down without releasing.
	// Use for holding keys (e.g., hold Shift while clicking).
	KeyAction_KEY_ACTION_DOWN KeyAction = 2
	// Release a previously pressed key.
	// Use to complete a DOWN action.
	KeyAction_KEY_ACTION_UP KeyAction = 3
)

// Enum value maps for KeyAction.
var (
	KeyAction_name = map[int32]string{
		0: "KEY_ACTION_UNSPECIFIED",
		1: "KEY_ACTION_PRESS",
		2: "KEY_ACTION_DOWN",
		3: "KEY_ACTION_UP",
	}
	KeyAction_value = map[string]int32{
		"KEY_ACTION_UNSPECIFIED": 0,
		"KEY_ACTION_PRESS":       1,
		"KEY_ACTION_DOWN":        2,
		"KEY_ACTION_UP":          3,
	}
)

func (x KeyAction) Enum() *KeyAction {
	p := new(KeyAction)
	*p = x
	return p
}

func (x KeyAction) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (KeyAction) Descriptor() protoreflect.EnumDescriptor {
	return file_browser_automation_studio_v1_actions_action_proto_enumTypes[6].Descriptor()
}

func (KeyAction) Type() protoreflect.EnumType {
	return &file_browser_automation_studio_v1_actions_action_proto_enumTypes[6]
}

func (x KeyAction) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use KeyAction.Descriptor instead.
func (KeyAction) EnumDescriptor() ([]byte, []int) {
	return file_browser_automation_studio_v1_actions_action_proto_rawDescGZIP(), []int{6}
}

// KeyboardModifier enumerates keyboard modifier keys.
//
// Modifiers are held during other actions (clicks, key presses).
// Multiple modifiers can be combined.
//
// @usage KeyboardParams.modifiers, ClickParams.modifiers
type KeyboardModifier int32

const (
	// No modifier. Should not appear in modifiers array.
	KeyboardModifier_KEYBOARD_MODIFIER_UNSPECIFIED KeyboardModifier = 0
	// Ctrl key (Control on Mac). Common for shortcuts.
	// Example: Ctrl+C for copy, Ctrl+Click for new tab.
	KeyboardModifier_KEYBOARD_MODIFIER_CTRL KeyboardModifier = 1
	// Shift key. For uppercase, selection extension.
	// Example: Shift+Click for range select, Shift+Tab for back.
	KeyboardModifier_KEYBOARD_MODIFIER_SHIFT KeyboardModifier = 2
	// Alt key (Option on Mac). For alternate actions.
	// Example: Alt+Click for download link.
	KeyboardModifier_KEYBOARD_MODIFIER_ALT KeyboardModifier = 3
	// Meta key (Cmd on Mac, Win on Windows).
	// Example: Cmd+Click for new tab on Mac.
	KeyboardModifier_KEYBOARD_MODIFIER_META KeyboardModifier = 4
)

// Enum value maps for KeyboardModifier.
var (
	KeyboardModifier_name = map[int32]string{
		0: "KEYBOARD_MODIFIER_UNSPECIFIED",
		1: "KEYBOARD_MODIFIER_CTRL",
		2: "KEYBOARD_MODIFIER_SHIFT",
		3: "KEYBOARD_MODIFIER_ALT",
		4: "KEYBOARD_MODIFIER_META",
	}
	KeyboardModifier_value = map[string]int32{
		"KEYBOARD_MODIFIER_UNSPECIFIED": 0,
		"KEYBOARD_MODIFIER_CTRL":        1,
		"KEYBOARD_MODIFIER_SHIFT":       2,
		"KEYBOARD_MODIFIER_ALT":         3,
		"KEYBOARD_MODIFIER_META":        4,
	}
)

func (x KeyboardModifier) Enum() *KeyboardModifier {
	p := new(KeyboardModifier)
	*p = x
	return p
}

func (x KeyboardModifier) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (KeyboardModifier) Descriptor() protoreflect.EnumDescriptor {
	return file_browser_automation_studio_v1_actions_action_proto_enumTypes[7].Descriptor()
}

func (KeyboardModifier) Type() protoreflect.EnumType {
	return &file_browser_automation_studio_v1_actions_action_proto_enumTypes[7]
}

func (x KeyboardModifier) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use KeyboardModifier.Descriptor instead.
func (KeyboardModifier) EnumDescriptor() ([]byte, []int) {
	return file_browser_automation_studio_v1_actions_action_proto_rawDescGZIP(), []int{7}
}

// NavigateParams configures page navigation.
type NavigateParams struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Target URL to navigate to.
	Url string `protobuf:"bytes,1,opt,name=url,proto3" json:"url,omitempty"`
	// CSS selector to wait for after navigation completes.
	WaitForSelector *string `protobuf:"bytes,2,opt,name=wait_for_selector,json=waitForSelector,proto3,oneof" json:"wait_for_selector,omitempty"`
	// Timeout in milliseconds for navigation and wait (default: 30000).
	TimeoutMs *int32 `protobuf:"varint,3,opt,name=timeout_ms,json=timeoutMs,proto3,oneof" json:"timeout_ms,omitempty"`
	// Event to wait for before considering navigation complete.
	WaitUntil *NavigateWaitEvent `protobuf:"varint,4,opt,name=wait_until,json=waitUntil,proto3,enum=browser_automation_studio.v1.NavigateWaitEvent,oneof" json:"wait_until,omitempty"`
	// Optional: interpret navigation target as a scenario+path instead of a raw URL.
	// When destination_type is SCENARIO (or scenario is provided), implementations
	// should resolve a URL using the configured scenario registry / lifecycle system.
	DestinationType *NavigateDestinationType `protobuf:"varint,10,opt,name=destination_type,json=destinationType,proto3,enum=browser_automation_studio.v1.NavigateDestinationType,oneof" json:"destination_type,omitempty"`
	// Scenario name to resolve (e.g., "browser-automation-studio").
	Scenario *string `protobuf:"bytes,11,opt,name=scenario,proto3,oneof" json:"scenario,omitempty"`
	// Path within the scenario to navigate to (e.g., "/").
	ScenarioPath  *string `protobuf:"bytes,12,opt,name=scenario_path,json=scenarioPath,proto3,oneof" json:"scenario_path,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *NavigateParams) Reset() {
	*x = NavigateParams{}
	mi := &file_browser_automation_studio_v1_actions_action_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *NavigateParams) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*NavigateParams) ProtoMessage() {}

func (x *NavigateParams) ProtoReflect() protoreflect.Message {
	mi := &file_browser_automation_studio_v1_actions_action_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use NavigateParams.ProtoReflect.Descriptor instead.
func (*NavigateParams) Descriptor() ([]byte, []int) {
	return file_browser_automation_studio_v1_actions_action_proto_rawDescGZIP(), []int{0}
}

func (x *NavigateParams) GetUrl() string {
	if x != nil {
		return x.Url
	}
	return ""
}

func (x *NavigateParams) GetWaitForSelector() string {
	if x != nil && x.WaitForSelector != nil {
		return *x.WaitForSelector
	}
	return ""
}

func (x *NavigateParams) GetTimeoutMs() int32 {
	if x != nil && x.TimeoutMs != nil {
		return *x.TimeoutMs
	}
	return 0
}

func (x *NavigateParams) GetWaitUntil() NavigateWaitEvent {
	if x != nil && x.WaitUntil != nil {
		return *x.WaitUntil
	}
	return NavigateWaitEvent_NAVIGATE_WAIT_EVENT_UNSPECIFIED
}

func (x *NavigateParams) GetDestinationType() NavigateDestinationType {
	if x != nil && x.DestinationType != nil {
		return *x.DestinationType
	}
	return NavigateDestinationType_NAVIGATE_DESTINATION_TYPE_UNSPECIFIED
}

func (x *NavigateParams) GetScenario() string {
	if x != nil && x.Scenario != nil {
		return *x.Scenario
	}
	return ""
}

func (x *NavigateParams) GetScenarioPath() string {
	if x != nil && x.ScenarioPath != nil {
		return *x.ScenarioPath
	}
	return ""
}

// ClickParams configures pointer click interactions.
type ClickParams struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// CSS selector for target element.
	Selector string `protobuf:"bytes,1,opt,name=selector,proto3" json:"selector,omitempty"`
	// Mouse button (defaults to left if unspecified).
	Button *MouseButton `protobuf:"varint,2,opt,name=button,proto3,enum=browser_automation_studio.v1.MouseButton,oneof" json:"button,omitempty"`
	// Number of clicks (1=single, 2=double, 3=triple).
	ClickCount *int32 `protobuf:"varint,3,opt,name=click_count,json=clickCount,proto3,oneof" json:"click_count,omitempty"`
	// Delay between mousedown and mouseup in milliseconds.
	DelayMs *int32 `protobuf:"varint,4,opt,name=delay_ms,json=delayMs,proto3,oneof" json:"delay_ms,omitempty"`
	// Keyboard modifiers held during click.
	Modifiers []KeyboardModifier `protobuf:"varint,5,rep,packed,name=modifiers,proto3,enum=browser_automation_studio.v1.KeyboardModifier" json:"modifiers,omitempty"`
	// Force click even if element is not visible/actionable.
	Force *bool `protobuf:"varint,6,opt,name=force,proto3,oneof" json:"force,omitempty"`
	// Scroll element into view before clicking.
	ScrollIntoView *bool `protobuf:"varint,7,opt,name=scroll_into_view,json=scrollIntoView,proto3,oneof" json:"scroll_into_view,omitempty"`
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *ClickParams) Reset() {
	*x = ClickParams{}
	mi := &file_browser_automation_studio_v1_actions_action_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ClickParams) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ClickParams) ProtoMessage() {}

func (x *ClickParams) ProtoReflect() protoreflect.Message {
	mi := &file_browser_automation_studio_v1_actions_action_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ClickParams.ProtoReflect.Descriptor instead.
func (*ClickParams) Descriptor() ([]byte, []int) {
	return file_browser_automation_studio_v1_actions_action_proto_rawDescGZIP(), []int{1}
}

func (x *ClickParams) GetSelector() string {
	if x != nil {
		return x.Selector
	}
	return ""
}

func (x *ClickParams) GetButton() MouseButton {
	if x != nil && x.Button != nil {
		return *x.Button
	}
	return MouseButton_MOUSE_BUTTON_UNSPECIFIED
}

func (x *ClickParams) GetClickCount() int32 {
	if x != nil && x.ClickCount != nil {
		return *x.ClickCount
	}
	return 0
}

func (x *ClickParams) GetDelayMs() int32 {
	if x != nil && x.DelayMs != nil {
		return *x.DelayMs
	}
	return 0
}

func (x *ClickParams) GetModifiers() []KeyboardModifier {
	if x != nil {
		return x.Modifiers
	}
	return nil
}

func (x *ClickParams) GetForce() bool {
	if x != nil && x.Force != nil {
		return *x.Force
	}
	return false
}

func (x *ClickParams) GetScrollIntoView() bool {
	if x != nil && x.ScrollIntoView != nil {
		return *x.ScrollIntoView
	}
	return false
}

// InputParams configures text entry into form elements.
type InputParams struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// CSS selector for target input element.
	Selector string `protobuf:"bytes,1,opt,name=selector,proto3" json:"selector,omitempty"`
	// Text value to type.
	Value string `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
	// Mask value in logs/telemetry (for passwords, etc.).
	IsSensitive *bool `protobuf:"varint,3,opt,name=is_sensitive,json=isSensitive,proto3,oneof" json:"is_sensitive,omitempty"`
	// Press Enter after typing (submit form).
	Submit *bool `protobuf:"varint,4,opt,name=submit,proto3,oneof" json:"submit,omitempty"`
	// Clear existing text before typing.
	ClearFirst *bool `protobuf:"varint,5,opt,name=clear_first,json=clearFirst,proto3,oneof" json:"clear_first,omitempty"`
	// Delay between keystrokes in milliseconds.
	DelayMs       *int32 `protobuf:"varint,6,opt,name=delay_ms,json=delayMs,proto3,oneof" json:"delay_ms,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *InputParams) Reset() {
	*x = InputParams{}
	mi := &file_browser_automation_studio_v1_actions_action_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *InputParams) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*InputParams) ProtoMessage() {}

func (x *InputParams) ProtoReflect() protoreflect.Message {
	mi := &file_browser_automation_studio_v1_actions_action_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use InputParams.ProtoReflect.Descriptor instead.
func (*InputParams) Descriptor() ([]byte, []int) {
	return file_browser_automation_studio_v1_actions_action_proto_rawDescGZIP(), []int{2}
}

func (x *InputParams) GetSelector() string {
	if x != nil {
		return x.Selector
	}
	return ""
}

func (x *InputParams) GetValue() string {
	if x != nil {
		return x.Value
	}
	return ""
}

func (x *InputParams) GetIsSensitive() bool {
	if x != nil && x.IsSensitive != nil {
		return *x.IsSensitive
	}
	return false
}

func (x *InputParams) GetSubmit() bool {
	if x != nil && x.Submit != nil {
		return *x.Submit
	}
	return false
}

func (x *InputParams) GetClearFirst() bool {
	if x != nil && x.ClearFirst != nil {
		return *x.ClearFirst
	}
	return false
}

func (x *InputParams) GetDelayMs() int32 {
	if x != nil && x.DelayMs != nil {
		return *x.DelayMs
	}
	return 0
}

// WaitParams configures wait conditions.
type WaitParams struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Wait condition: either duration or selector (one must be set).
	//
	// Types that are valid to be assigned to WaitFor:
	//
	//	*WaitParams_DurationMs
	//	*WaitParams_Selector
	WaitFor isWaitParams_WaitFor `protobuf_oneof:"wait_for"`
	// Element state to wait for when using selector.
	State *WaitState `protobuf:"varint,3,opt,name=state,proto3,enum=browser_automation_studio.v1.WaitState,oneof" json:"state,omitempty"`
	// Timeout in milliseconds for selector waits (default: 30000).
	TimeoutMs     *int32 `protobuf:"varint,4,opt,name=timeout_ms,json=timeoutMs,proto3,oneof" json:"timeout_ms,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *WaitParams) Reset() {
	*x = WaitParams{}
	mi := &file_browser_automation_studio_v1_actions_action_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *WaitParams) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*WaitParams) ProtoMessage() {}

func (x *WaitParams) ProtoReflect() protoreflect.Message {
	mi := &file_browser_automation_studio_v1_actions_action_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use WaitParams.ProtoReflect.Descriptor instead.
func (*WaitParams) Descriptor() ([]byte, []int) {
	return file_browser_automation_studio_v1_actions_action_proto_rawDescGZIP(), []int{3}
}

func (x *WaitParams) GetWaitFor() isWaitParams_WaitFor {
	if x != nil {
		return x.WaitFor
	}
	return nil
}

func (x *WaitParams) GetDurationMs() int32 {
	if x != nil {
		if x, ok := x.WaitFor.(*WaitParams_DurationMs); ok {
			return x.DurationMs
		}
	}
	return 0
}

func (x *WaitParams) GetSelector() string {
	if x != nil {
		if x, ok := x.WaitFor.(*WaitParams_Selector); ok {
			return x.Selector
		}
	}
	return ""
}

func (x *WaitParams) GetState() WaitState {
	if x != nil && x.State != nil {
		return *x.State
	}
	return WaitState_WAIT_STATE_UNSPECIFIED
}

func (x *WaitParams) GetTimeoutMs() int32 {
	if x != nil && x.TimeoutMs != nil {
		return *x.TimeoutMs
	}
	return 0
}

type isWaitParams_WaitFor interface {
	isWaitParams_WaitFor()
}

type WaitParams_DurationMs struct {
	// Fixed duration to wait in milliseconds.
	DurationMs int32 `protobuf:"varint,1,opt,name=duration_ms,json=durationMs,proto3,oneof"`
}

type WaitParams_Selector struct {
	// CSS selector to wait for.
	Selector string `protobuf:"bytes,2,opt,name=selector,proto3,oneof"`
}

func (*WaitParams_DurationMs) isWaitParams_WaitFor() {}

func (*WaitParams_Selector) isWaitParams_WaitFor() {}

// AssertParams configures element assertions.
type AssertParams struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// CSS selector for element to assert on.
	Selector string `protobuf:"bytes,1,opt,name=selector,proto3" json:"selector,omitempty"`
	// Assertion mode to evaluate.
	Mode base.AssertionMode `protobuf:"varint,2,opt,name=mode,proto3,enum=browser_automation_studio.v1.AssertionMode" json:"mode,omitempty"`
	// Expected value for comparison assertions.
	Expected *v1.JsonValue `protobuf:"bytes,3,opt,name=expected,proto3,oneof" json:"expected,omitempty"`
	// Negate the assertion (expect opposite).
	Negated *bool `protobuf:"varint,4,opt,name=negated,proto3,oneof" json:"negated,omitempty"`
	// Case-sensitive text comparison.
	CaseSensitive *bool `protobuf:"varint,5,opt,name=case_sensitive,json=caseSensitive,proto3,oneof" json:"case_sensitive,omitempty"`
	// Attribute name for attribute assertions.
	AttributeName *string `protobuf:"bytes,6,opt,name=attribute_name,json=attributeName,proto3,oneof" json:"attribute_name,omitempty"`
	// Custom failure message.
	FailureMessage *string `protobuf:"bytes,7,opt,name=failure_message,json=failureMessage,proto3,oneof" json:"failure_message,omitempty"`
	// Timeout in milliseconds (default: 5000).
	TimeoutMs     *int32 `protobuf:"varint,8,opt,name=timeout_ms,json=timeoutMs,proto3,oneof" json:"timeout_ms,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *AssertParams) Reset() {
	*x = AssertParams{}
	mi := &file_browser_automation_studio_v1_actions_action_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AssertParams) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AssertParams) ProtoMessage() {}

func (x *AssertParams) ProtoReflect() protoreflect.Message {
	mi := &file_browser_automation_studio_v1_actions_action_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AssertParams.ProtoReflect.Descriptor instead.
func (*AssertParams) Descriptor() ([]byte, []int) {
	return file_browser_automation_studio_v1_actions_action_proto_rawDescGZIP(), []int{4}
}

func (x *AssertParams) GetSelector() string {
	if x != nil {
		return x.Selector
	}
	return ""
}

func (x *AssertParams) GetMode() base.AssertionMode {
	if x != nil {
		return x.Mode
	}
	return base.AssertionMode(0)
}

func (x *AssertParams) GetExpected() *v1.JsonValue {
	if x != nil {
		return x.Expected
	}
	return nil
}

func (x *AssertParams) GetNegated() bool {
	if x != nil && x.Negated != nil {
		return *x.Negated
	}
	return false
}

func (x *AssertParams) GetCaseSensitive() bool {
	if x != nil && x.CaseSensitive != nil {
		return *x.CaseSensitive
	}
	return false
}

func (x *AssertParams) GetAttributeName() string {
	if x != nil && x.AttributeName != nil {
		return *x.AttributeName
	}
	return ""
}

func (x *AssertParams) GetFailureMessage() string {
	if x != nil && x.FailureMessage != nil {
		return *x.FailureMessage
	}
	return ""
}

func (x *AssertParams) GetTimeoutMs() int32 {
	if x != nil && x.TimeoutMs != nil {
		return *x.TimeoutMs
	}
	return 0
}

// ScrollParams configures scroll actions.
type ScrollParams struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// CSS selector to scroll (defaults to viewport if not specified).
	Selector *string `protobuf:"bytes,1,opt,name=selector,proto3,oneof" json:"selector,omitempty"`
	// Absolute horizontal scroll position in pixels.
	X *int32 `protobuf:"varint,2,opt,name=x,proto3,oneof" json:"x,omitempty"`
	// Absolute vertical scroll position in pixels.
	Y *int32 `protobuf:"varint,3,opt,name=y,proto3,oneof" json:"y,omitempty"`
	// Scroll animation behavior.
	Behavior *ScrollBehavior `protobuf:"varint,4,opt,name=behavior,proto3,enum=browser_automation_studio.v1.ScrollBehavior,oneof" json:"behavior,omitempty"`
	// Relative horizontal scroll delta in pixels.
	DeltaX *int32 `protobuf:"varint,5,opt,name=delta_x,json=deltaX,proto3,oneof" json:"delta_x,omitempty"`
	// Relative vertical scroll delta in pixels.
	DeltaY        *int32 `protobuf:"varint,6,opt,name=delta_y,json=deltaY,proto3,oneof" json:"delta_y,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ScrollParams) Reset() {
	*x = ScrollParams{}
	mi := &file_browser_automation_studio_v1_actions_action_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ScrollParams) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ScrollParams) ProtoMessage() {}

func (x *ScrollParams) ProtoReflect() protoreflect.Message {
	mi := &file_browser_automation_studio_v1_actions_action_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ScrollParams.ProtoReflect.Descriptor instead.
func (*ScrollParams) Descriptor() ([]byte, []int) {
	return file_browser_automation_studio_v1_actions_action_proto_rawDescGZIP(), []int{5}
}

func (x *ScrollParams) GetSelector() string {
	if x != nil && x.Selector != nil {
		return *x.Selector
	}
	return ""
}

func (x *ScrollParams) GetX() int32 {
	if x != nil && x.X != nil {
		return *x.X
	}
	return 0
}

func (x *ScrollParams) GetY() int32 {
	if x != nil && x.Y != nil {
		return *x.Y
	}
	return 0
}

func (x *ScrollParams) GetBehavior() ScrollBehavior {
	if x != nil && x.Behavior != nil {
		return *x.Behavior
	}
	return ScrollBehavior_SCROLL_BEHAVIOR_UNSPECIFIED
}

func (x *ScrollParams) GetDeltaX() int32 {
	if x != nil && x.DeltaX != nil {
		return *x.DeltaX
	}
	return 0
}

func (x *ScrollParams) GetDeltaY() int32 {
	if x != nil && x.DeltaY != nil {
		return *x.DeltaY
	}
	return 0
}

// SelectParams configures dropdown/select element interaction.
type SelectParams struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// CSS selector for select element.
	Selector string `protobuf:"bytes,1,opt,name=selector,proto3" json:"selector,omitempty"`
	// Selection method (one must be set).
	//
	// Types that are valid to be assigned to SelectBy:
	//
	//	*SelectParams_Value
	//	*SelectParams_Label
	//	*SelectParams_Index
	SelectBy isSelectParams_SelectBy `protobuf_oneof:"select_by"`
	// Timeout in milliseconds (default: 5000).
	TimeoutMs     *int32 `protobuf:"varint,5,opt,name=timeout_ms,json=timeoutMs,proto3,oneof" json:"timeout_ms,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SelectParams) Reset() {
	*x = SelectParams{}
	mi := &file_browser_automation_studio_v1_actions_action_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SelectParams) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SelectParams) ProtoMessage() {}

func (x *SelectParams) ProtoReflect() protoreflect.Message {
	mi := &file_browser_automation_studio_v1_actions_action_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SelectParams.ProtoReflect.Descriptor instead.
func (*SelectParams) Descriptor() ([]byte, []int) {
	return file_browser_automation_studio_v1_actions_action_proto_rawDescGZIP(), []int{6}
}

func (x *SelectParams) GetSelector() string {
	if x != nil {
		return x.Selector
	}
	return ""
}

func (x *SelectParams) GetSelectBy() isSelectParams_SelectBy {
	if x != nil {
		return x.SelectBy
	}
	return nil
}

func (x *SelectParams) GetValue() string {
	if x != nil {
		if x, ok := x.SelectBy.(*SelectParams_Value); ok {
			return x.Value
		}
	}
	return ""
}

func (x *SelectParams) GetLabel() string {
	if x != nil {
		if x, ok := x.SelectBy.(*SelectParams_Label); ok {
			return x.Label
		}
	}
	return ""
}

func (x *SelectParams) GetIndex() int32 {
	if x != nil {
		if x, ok := x.SelectBy.(*SelectParams_Index); ok {
			return x.Index
		}
	}
	return 0
}

func (x *SelectParams) GetTimeoutMs() int32 {
	if x != nil && x.TimeoutMs != nil {
		return *x.TimeoutMs
	}
	return 0
}

type isSelectParams_SelectBy interface {
	isSelectParams_SelectBy()
}

type SelectParams_Value struct {
	// Select by option value attribute.
	Value string `protobuf:"bytes,2,opt,name=value,proto3,oneof"`
}

type SelectParams_Label struct {
	// Select by visible text label.
	Label string `protobuf:"bytes,3,opt,name=label,proto3,oneof"`
}

type SelectParams_Index struct {
	// Select by zero-based index.
	Index int32 `protobuf:"varint,4,opt,name=index,proto3,oneof"`
}

func (*SelectParams_Value) isSelectParams_SelectBy() {}

func (*SelectParams_Label) isSelectParams_SelectBy() {}

func (*SelectParams_Index) isSelectParams_SelectBy() {}

// EvaluateParams configures JavaScript evaluation.
type EvaluateParams struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// JavaScript expression to evaluate.
	Expression string `protobuf:"bytes,1,opt,name=expression,proto3" json:"expression,omitempty"`
	// Variable name to store the result.
	StoreResult *string `protobuf:"bytes,2,opt,name=store_result,json=storeResult,proto3,oneof" json:"store_result,omitempty"`
	// Arguments to pass to the expression.
	Args          map[string]*v1.JsonValue `protobuf:"bytes,3,rep,name=args,proto3" json:"args,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *EvaluateParams) Reset() {
	*x = EvaluateParams{}
	mi := &file_browser_automation_studio_v1_actions_action_proto_msgTypes[7]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *EvaluateParams) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*EvaluateParams) ProtoMessage() {}

func (x *EvaluateParams) ProtoReflect() protoreflect.Message {
	mi := &file_browser_automation_studio_v1_actions_action_proto_msgTypes[7]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use EvaluateParams.ProtoReflect.Descriptor instead.
func (*EvaluateParams) Descriptor() ([]byte, []int) {
	return file_browser_automation_studio_v1_actions_action_proto_rawDescGZIP(), []int{7}
}

func (x *EvaluateParams) GetExpression() string {
	if x != nil {
		return x.Expression
	}
	return ""
}

func (x *EvaluateParams) GetStoreResult() string {
	if x != nil && x.StoreResult != nil {
		return *x.StoreResult
	}
	return ""
}

func (x *EvaluateParams) GetArgs() map[string]*v1.JsonValue {
	if x != nil {
		return x.Args
	}
	return nil
}

// KeyboardParams configures keyboard interactions.
type KeyboardParams struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Single key to press (e.g., "Enter", "Tab", "a").
	Key *string `protobuf:"bytes,1,opt,name=key,proto3,oneof" json:"key,omitempty"`
	// Sequence of keys to press.
	Keys []string `protobuf:"bytes,2,rep,name=keys,proto3" json:"keys,omitempty"`
	// Keyboard modifiers to hold during the action.
	Modifiers []KeyboardModifier `protobuf:"varint,3,rep,packed,name=modifiers,proto3,enum=browser_automation_studio.v1.KeyboardModifier" json:"modifiers,omitempty"`
	// Type of keyboard action to perform.
	Action        *KeyAction `protobuf:"varint,4,opt,name=action,proto3,enum=browser_automation_studio.v1.KeyAction,oneof" json:"action,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *KeyboardParams) Reset() {
	*x = KeyboardParams{}
	mi := &file_browser_automation_studio_v1_actions_action_proto_msgTypes[8]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *KeyboardParams) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*KeyboardParams) ProtoMessage() {}

func (x *KeyboardParams) ProtoReflect() protoreflect.Message {
	mi := &file_browser_automation_studio_v1_actions_action_proto_msgTypes[8]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use KeyboardParams.ProtoReflect.Descriptor instead.
func (*KeyboardParams) Descriptor() ([]byte, []int) {
	return file_browser_automation_studio_v1_actions_action_proto_rawDescGZIP(), []int{8}
}

func (x *KeyboardParams) GetKey() string {
	if x != nil && x.Key != nil {
		return *x.Key
	}
	return ""
}

func (x *KeyboardParams) GetKeys() []string {
	if x != nil {
		return x.Keys
	}
	return nil
}

func (x *KeyboardParams) GetModifiers() []KeyboardModifier {
	if x != nil {
		return x.Modifiers
	}
	return nil
}

func (x *KeyboardParams) GetAction() KeyAction {
	if x != nil && x.Action != nil {
		return *x.Action
	}
	return KeyAction_KEY_ACTION_UNSPECIFIED
}

// HoverParams configures hover interactions.
type HoverParams struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// CSS selector for element to hover over.
	Selector string `protobuf:"bytes,1,opt,name=selector,proto3" json:"selector,omitempty"`
	// Timeout in milliseconds (default: 5000).
	TimeoutMs     *int32 `protobuf:"varint,2,opt,name=timeout_ms,json=timeoutMs,proto3,oneof" json:"timeout_ms,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *HoverParams) Reset() {
	*x = HoverParams{}
	mi := &file_browser_automation_studio_v1_actions_action_proto_msgTypes[9]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *HoverParams) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*HoverParams) ProtoMessage() {}

func (x *HoverParams) ProtoReflect() protoreflect.Message {
	mi := &file_browser_automation_studio_v1_actions_action_proto_msgTypes[9]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use HoverParams.ProtoReflect.Descriptor instead.
func (*HoverParams) Descriptor() ([]byte, []int) {
	return file_browser_automation_studio_v1_actions_action_proto_rawDescGZIP(), []int{9}
}

func (x *HoverParams) GetSelector() string {
	if x != nil {
		return x.Selector
	}
	return ""
}

func (x *HoverParams) GetTimeoutMs() int32 {
	if x != nil && x.TimeoutMs != nil {
		return *x.TimeoutMs
	}
	return 0
}

// ScreenshotParams configures screenshot capture.
type ScreenshotParams struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Capture full scrollable page vs viewport only.
	FullPage *bool `protobuf:"varint,1,opt,name=full_page,json=fullPage,proto3,oneof" json:"full_page,omitempty"`
	// CSS selector to screenshot specific element.
	Selector *string `protobuf:"bytes,2,opt,name=selector,proto3,oneof" json:"selector,omitempty"`
	// JPEG quality (1-100) for lossy compression.
	Quality       *int32 `protobuf:"varint,3,opt,name=quality,proto3,oneof" json:"quality,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ScreenshotParams) Reset() {
	*x = ScreenshotParams{}
	mi := &file_browser_automation_studio_v1_actions_action_proto_msgTypes[10]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ScreenshotParams) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ScreenshotParams) ProtoMessage() {}

func (x *ScreenshotParams) ProtoReflect() protoreflect.Message {
	mi := &file_browser_automation_studio_v1_actions_action_proto_msgTypes[10]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ScreenshotParams.ProtoReflect.Descriptor instead.
func (*ScreenshotParams) Descriptor() ([]byte, []int) {
	return file_browser_automation_studio_v1_actions_action_proto_rawDescGZIP(), []int{10}
}

func (x *ScreenshotParams) GetFullPage() bool {
	if x != nil && x.FullPage != nil {
		return *x.FullPage
	}
	return false
}

func (x *ScreenshotParams) GetSelector() string {
	if x != nil && x.Selector != nil {
		return *x.Selector
	}
	return ""
}

func (x *ScreenshotParams) GetQuality() int32 {
	if x != nil && x.Quality != nil {
		return *x.Quality
	}
	return 0
}

// FocusParams configures focus interactions.
type FocusParams struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// CSS selector for element to focus.
	Selector string `protobuf:"bytes,1,opt,name=selector,proto3" json:"selector,omitempty"`
	// Whether to scroll element into view.
	Scroll *bool `protobuf:"varint,2,opt,name=scroll,proto3,oneof" json:"scroll,omitempty"`
	// Timeout in milliseconds (default: 5000).
	TimeoutMs     *int32 `protobuf:"varint,3,opt,name=timeout_ms,json=timeoutMs,proto3,oneof" json:"timeout_ms,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *FocusParams) Reset() {
	*x = FocusParams{}
	mi := &file_browser_automation_studio_v1_actions_action_proto_msgTypes[11]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *FocusParams) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*FocusParams) ProtoMessage() {}

func (x *FocusParams) ProtoReflect() protoreflect.Message {
	mi := &file_browser_automation_studio_v1_actions_action_proto_msgTypes[11]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use FocusParams.ProtoReflect.Descriptor instead.
func (*FocusParams) Descriptor() ([]byte, []int) {
	return file_browser_automation_studio_v1_actions_action_proto_rawDescGZIP(), []int{11}
}

func (x *FocusParams) GetSelector() string {
	if x != nil {
		return x.Selector
	}
	return ""
}

func (x *FocusParams) GetScroll() bool {
	if x != nil && x.Scroll != nil {
		return *x.Scroll
	}
	return false
}

func (x *FocusParams) GetTimeoutMs() int32 {
	if x != nil && x.TimeoutMs != nil {
		return *x.TimeoutMs
	}
	return 0
}

// BlurParams configures blur (unfocus) interactions.
type BlurParams struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// CSS selector for element to blur (blurs active element if not specified).
	Selector *string `protobuf:"bytes,1,opt,name=selector,proto3,oneof" json:"selector,omitempty"`
	// Timeout in milliseconds (default: 5000).
	TimeoutMs     *int32 `protobuf:"varint,2,opt,name=timeout_ms,json=timeoutMs,proto3,oneof" json:"timeout_ms,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *BlurParams) Reset() {
	*x = BlurParams{}
	mi := &file_browser_automation_studio_v1_actions_action_proto_msgTypes[12]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *BlurParams) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BlurParams) ProtoMessage() {}

func (x *BlurParams) ProtoReflect() protoreflect.Message {
	mi := &file_browser_automation_studio_v1_actions_action_proto_msgTypes[12]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BlurParams.ProtoReflect.Descriptor instead.
func (*BlurParams) Descriptor() ([]byte, []int) {
	return file_browser_automation_studio_v1_actions_action_proto_rawDescGZIP(), []int{12}
}

func (x *BlurParams) GetSelector() string {
	if x != nil && x.Selector != nil {
		return *x.Selector
	}
	return ""
}

func (x *BlurParams) GetTimeoutMs() int32 {
	if x != nil && x.TimeoutMs != nil {
		return *x.TimeoutMs
	}
	return 0
}

// SubflowParams configures nested workflow execution.
//
// A subflow can target:
//   - A persisted workflow by ID (optionally pinned to a version), OR
//   - A workflow definition file referenced by a path relative to the *project root*.
//
// Paths are interpreted by the API using the project folder associated with the
// parent workflow (i.e., the workflow being executed). Implementations MUST
// reject absolute paths and any traversal segments ('.' or '..').
type SubflowParams struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Types that are valid to be assigned to Target:
	//
	//	*SubflowParams_WorkflowId
	//	*SubflowParams_WorkflowPath
	Target isSubflowParams_Target `protobuf_oneof:"target"`
	// Optional workflow version to invoke when targeting workflow_id.
	WorkflowVersion *int32 `protobuf:"varint,3,opt,name=workflow_version,json=workflowVersion,proto3,oneof" json:"workflow_version,omitempty"`
	// Arguments exposed to the subflow as the "fixture" namespace (e.g. ${fixture.foo}).
	Args          map[string]*v1.JsonValue `protobuf:"bytes,10,rep,name=args,proto3" json:"args,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SubflowParams) Reset() {
	*x = SubflowParams{}
	mi := &file_browser_automation_studio_v1_actions_action_proto_msgTypes[13]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SubflowParams) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SubflowParams) ProtoMessage() {}

func (x *SubflowParams) ProtoReflect() protoreflect.Message {
	mi := &file_browser_automation_studio_v1_actions_action_proto_msgTypes[13]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SubflowParams.ProtoReflect.Descriptor instead.
func (*SubflowParams) Descriptor() ([]byte, []int) {
	return file_browser_automation_studio_v1_actions_action_proto_rawDescGZIP(), []int{13}
}

func (x *SubflowParams) GetTarget() isSubflowParams_Target {
	if x != nil {
		return x.Target
	}
	return nil
}

func (x *SubflowParams) GetWorkflowId() string {
	if x != nil {
		if x, ok := x.Target.(*SubflowParams_WorkflowId); ok {
			return x.WorkflowId
		}
	}
	return ""
}

func (x *SubflowParams) GetWorkflowPath() string {
	if x != nil {
		if x, ok := x.Target.(*SubflowParams_WorkflowPath); ok {
			return x.WorkflowPath
		}
	}
	return ""
}

func (x *SubflowParams) GetWorkflowVersion() int32 {
	if x != nil && x.WorkflowVersion != nil {
		return *x.WorkflowVersion
	}
	return 0
}

func (x *SubflowParams) GetArgs() map[string]*v1.JsonValue {
	if x != nil {
		return x.Args
	}
	return nil
}

type isSubflowParams_Target interface {
	isSubflowParams_Target()
}

type SubflowParams_WorkflowId struct {
	// Workflow ID to invoke as a subflow (UUID format).
	WorkflowId string `protobuf:"bytes,1,opt,name=workflow_id,json=workflowId,proto3,oneof"`
}

type SubflowParams_WorkflowPath struct {
	// Project-relative path to a workflow definition file (e.g. "actions/dismiss-tutorial.json").
	WorkflowPath string `protobuf:"bytes,2,opt,name=workflow_path,json=workflowPath,proto3,oneof"`
}

func (*SubflowParams_WorkflowId) isSubflowParams_Target() {}

func (*SubflowParams_WorkflowPath) isSubflowParams_Target() {}

// ActionMetadata captures optional rich context captured during action execution.
// This data is captured identically during BOTH recording and execution, enabling:
//   - Selector fallbacks: If primary selector fails, try alternatives
//   - Debugging: See exactly what the system saw when it executed the action
//   - Editing: Users can adjust selectors on failed steps using captured alternatives
//
// See "UNIFIED RECORDING/EXECUTION MODEL" in shared.proto for the design rationale.
type ActionMetadata struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Human-readable label for the action.
	Label *string `protobuf:"bytes,1,opt,name=label,proto3,oneof" json:"label,omitempty"`
	// Alternative selectors ranked by confidence.
	// Captured during both recording (user interactions) and execution (code-driven).
	// Enables fallback selector strategies and user editing of failed steps.
	SelectorCandidates []*domain.SelectorCandidate `protobuf:"bytes,2,rep,name=selector_candidates,json=selectorCandidates,proto3" json:"selector_candidates,omitempty"`
	// Element state snapshot when action was captured.
	// Provides context about the target element for debugging and selector refinement.
	ElementSnapshot *domain.ElementMeta `protobuf:"bytes,3,opt,name=element_snapshot,json=elementSnapshot,proto3,oneof" json:"element_snapshot,omitempty"`
	// Confidence score (0.0-1.0) for the primary selector.
	// Higher values indicate more reliable selectors (data-testid > css class > xpath).
	Confidence *float64 `protobuf:"fixed64,4,opt,name=confidence,proto3,oneof" json:"confidence,omitempty"`
	// When this action was captured (during recording or execution).
	CapturedAt *timestamppb.Timestamp `protobuf:"bytes,5,opt,name=captured_at,json=capturedAt,proto3,oneof" json:"captured_at,omitempty"`
	// Element bounding box when captured.
	// Used for visual debugging and screenshot annotations.
	CapturedBoundingBox *base.BoundingBox `protobuf:"bytes,6,opt,name=captured_bounding_box,json=capturedBoundingBox,proto3,oneof" json:"captured_bounding_box,omitempty"`
	unknownFields       protoimpl.UnknownFields
	sizeCache           protoimpl.SizeCache
}

func (x *ActionMetadata) Reset() {
	*x = ActionMetadata{}
	mi := &file_browser_automation_studio_v1_actions_action_proto_msgTypes[14]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ActionMetadata) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ActionMetadata) ProtoMessage() {}

func (x *ActionMetadata) ProtoReflect() protoreflect.Message {
	mi := &file_browser_automation_studio_v1_actions_action_proto_msgTypes[14]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ActionMetadata.ProtoReflect.Descriptor instead.
func (*ActionMetadata) Descriptor() ([]byte, []int) {
	return file_browser_automation_studio_v1_actions_action_proto_rawDescGZIP(), []int{14}
}

func (x *ActionMetadata) GetLabel() string {
	if x != nil && x.Label != nil {
		return *x.Label
	}
	return ""
}

func (x *ActionMetadata) GetSelectorCandidates() []*domain.SelectorCandidate {
	if x != nil {
		return x.SelectorCandidates
	}
	return nil
}

func (x *ActionMetadata) GetElementSnapshot() *domain.ElementMeta {
	if x != nil {
		return x.ElementSnapshot
	}
	return nil
}

func (x *ActionMetadata) GetConfidence() float64 {
	if x != nil && x.Confidence != nil {
		return *x.Confidence
	}
	return 0
}

func (x *ActionMetadata) GetCapturedAt() *timestamppb.Timestamp {
	if x != nil {
		return x.CapturedAt
	}
	return nil
}

func (x *ActionMetadata) GetCapturedBoundingBox() *base.BoundingBox {
	if x != nil {
		return x.CapturedBoundingBox
	}
	return nil
}

// ActionDefinition is THE unified action type used across all BAS operations:
//
//	CONTEXT                   USAGE
//	
//	Recording                 Captured from user interactions with browser
//	Workflow Storage          Persisted in WorkflowNodeV2.action
//	Execution                 Sent to playwright-driver for replay
//	Timeline Streaming        Streamed to UI during live recording/execution
//	Timeline Batch            Returned in historical timeline queries
//
// This is the canonical representation of "what action to perform" throughout
// the entire system. See "UNIFIED RECORDING/EXECUTION MODEL" in shared.proto.
//
// IMPORTANT: Type-Params Consistency Requirement
// The `type` field MUST match the populated `params` oneof case:
//   - ACTION_TYPE_NAVIGATE requires `navigate` params
//   - ACTION_TYPE_CLICK requires `click` params
//   - ACTION_TYPE_INPUT requires `input` params
//   - etc.
//
// The `type` field exists for:
// 1. Efficient filtering/grouping without parsing params
// 2. Forward compatibility when new params are added
// 3. Explicit documentation of intent
//
// Consumers SHOULD validate type-params consistency. Invalid combinations
// (e.g., type=CLICK with navigate params) are malformed and should be rejected.
type ActionDefinition struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Action type classification. MUST match the populated params oneof case.
	// See message-level comment for consistency requirements.
	Type ActionType `protobuf:"varint,1,opt,name=type,proto3,enum=browser_automation_studio.v1.ActionType" json:"type,omitempty"`
	// Type-specific parameters. Exactly one MUST be set, matching the `type` field.
	// The mapping is: ACTION_TYPE_X requires the corresponding `x` params field.
	//
	// Types that are valid to be assigned to Params:
	//
	//	*ActionDefinition_Navigate
	//	*ActionDefinition_Click
	//	*ActionDefinition_Input
	//	*ActionDefinition_Wait
	//	*ActionDefinition_Assert
	//	*ActionDefinition_Scroll
	//	*ActionDefinition_SelectOption
	//	*ActionDefinition_Evaluate
	//	*ActionDefinition_Keyboard
	//	*ActionDefinition_Hover
	//	*ActionDefinition_Screenshot
	//	*ActionDefinition_Focus
	//	*ActionDefinition_Blur
	//	*ActionDefinition_Subflow
	Params isActionDefinition_Params `protobuf_oneof:"params"`
	// Optional rich metadata - preserved from recording, useful for debugging/fallbacks.
	Metadata      *ActionMetadata `protobuf:"bytes,30,opt,name=metadata,proto3" json:"metadata,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ActionDefinition) Reset() {
	*x = ActionDefinition{}
	mi := &file_browser_automation_studio_v1_actions_action_proto_msgTypes[15]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ActionDefinition) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ActionDefinition) ProtoMessage() {}

func (x *ActionDefinition) ProtoReflect() protoreflect.Message {
	mi := &file_browser_automation_studio_v1_actions_action_proto_msgTypes[15]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ActionDefinition.ProtoReflect.Descriptor instead.
func (*ActionDefinition) Descriptor() ([]byte, []int) {
	return file_browser_automation_studio_v1_actions_action_proto_rawDescGZIP(), []int{15}
}

func (x *ActionDefinition) GetType() ActionType {
	if x != nil {
		return x.Type
	}
	return ActionType_ACTION_TYPE_UNSPECIFIED
}

func (x *ActionDefinition) GetParams() isActionDefinition_Params {
	if x != nil {
		return x.Params
	}
	return nil
}

func (x *ActionDefinition) GetNavigate() *NavigateParams {
	if x != nil {
		if x, ok := x.Params.(*ActionDefinition_Navigate); ok {
			return x.Navigate
		}
	}
	return nil
}

func (x *ActionDefinition) GetClick() *ClickParams {
	if x != nil {
		if x, ok := x.Params.(*ActionDefinition_Click); ok {
			return x.Click
		}
	}
	return nil
}

func (x *ActionDefinition) GetInput() *InputParams {
	if x != nil {
		if x, ok := x.Params.(*ActionDefinition_Input); ok {
			return x.Input
		}
	}
	return nil
}

func (x *ActionDefinition) GetWait() *WaitParams {
	if x != nil {
		if x, ok := x.Params.(*ActionDefinition_Wait); ok {
			return x.Wait
		}
	}
	return nil
}

func (x *ActionDefinition) GetAssert() *AssertParams {
	if x != nil {
		if x, ok := x.Params.(*ActionDefinition_Assert); ok {
			return x.Assert
		}
	}
	return nil
}

func (x *ActionDefinition) GetScroll() *ScrollParams {
	if x != nil {
		if x, ok := x.Params.(*ActionDefinition_Scroll); ok {
			return x.Scroll
		}
	}
	return nil
}

func (x *ActionDefinition) GetSelectOption() *SelectParams {
	if x != nil {
		if x, ok := x.Params.(*ActionDefinition_SelectOption); ok {
			return x.SelectOption
		}
	}
	return nil
}

func (x *ActionDefinition) GetEvaluate() *EvaluateParams {
	if x != nil {
		if x, ok := x.Params.(*ActionDefinition_Evaluate); ok {
			return x.Evaluate
		}
	}
	return nil
}

func (x *ActionDefinition) GetKeyboard() *KeyboardParams {
	if x != nil {
		if x, ok := x.Params.(*ActionDefinition_Keyboard); ok {
			return x.Keyboard
		}
	}
	return nil
}

func (x *ActionDefinition) GetHover() *HoverParams {
	if x != nil {
		if x, ok := x.Params.(*ActionDefinition_Hover); ok {
			return x.Hover
		}
	}
	return nil
}

func (x *ActionDefinition) GetScreenshot() *ScreenshotParams {
	if x != nil {
		if x, ok := x.Params.(*ActionDefinition_Screenshot); ok {
			return x.Screenshot
		}
	}
	return nil
}

func (x *ActionDefinition) GetFocus() *FocusParams {
	if x != nil {
		if x, ok := x.Params.(*ActionDefinition_Focus); ok {
			return x.Focus
		}
	}
	return nil
}

func (x *ActionDefinition) GetBlur() *BlurParams {
	if x != nil {
		if x, ok := x.Params.(*ActionDefinition_Blur); ok {
			return x.Blur
		}
	}
	return nil
}

func (x *ActionDefinition) GetSubflow() *SubflowParams {
	if x != nil {
		if x, ok := x.Params.(*ActionDefinition_Subflow); ok {
			return x.Subflow
		}
	}
	return nil
}

func (x *ActionDefinition) GetMetadata() *ActionMetadata {
	if x != nil {
		return x.Metadata
	}
	return nil
}

type isActionDefinition_Params interface {
	isActionDefinition_Params()
}

type ActionDefinition_Navigate struct {
	Navigate *NavigateParams `protobuf:"bytes,10,opt,name=navigate,proto3,oneof"` // Required when type = ACTION_TYPE_NAVIGATE
}

type ActionDefinition_Click struct {
	Click *ClickParams `protobuf:"bytes,11,opt,name=click,proto3,oneof"` // Required when type = ACTION_TYPE_CLICK
}

type ActionDefinition_Input struct {
	Input *InputParams `protobuf:"bytes,12,opt,name=input,proto3,oneof"` // Required when type = ACTION_TYPE_INPUT
}

type ActionDefinition_Wait struct {
	Wait *WaitParams `protobuf:"bytes,13,opt,name=wait,proto3,oneof"` // Required when type = ACTION_TYPE_WAIT
}

type ActionDefinition_Assert struct {
	Assert *AssertParams `protobuf:"bytes,14,opt,name=assert,proto3,oneof"` // Required when type = ACTION_TYPE_ASSERT
}

type ActionDefinition_Scroll struct {
	Scroll *ScrollParams `protobuf:"bytes,15,opt,name=scroll,proto3,oneof"` // Required when type = ACTION_TYPE_SCROLL
}

type ActionDefinition_SelectOption struct {
	SelectOption *SelectParams `protobuf:"bytes,16,opt,name=select_option,json=selectOption,proto3,oneof"` // Required when type = ACTION_TYPE_SELECT
}

type ActionDefinition_Evaluate struct {
	Evaluate *EvaluateParams `protobuf:"bytes,17,opt,name=evaluate,proto3,oneof"` // Required when type = ACTION_TYPE_EVALUATE
}

type ActionDefinition_Keyboard struct {
	Keyboard *KeyboardParams `protobuf:"bytes,18,opt,name=keyboard,proto3,oneof"` // Required when type = ACTION_TYPE_KEYBOARD
}

type ActionDefinition_Hover struct {
	Hover *HoverParams `protobuf:"bytes,19,opt,name=hover,proto3,oneof"` // Required when type = ACTION_TYPE_HOVER
}

type ActionDefinition_Screenshot struct {
	Screenshot *ScreenshotParams `protobuf:"bytes,20,opt,name=screenshot,proto3,oneof"` // Required when type = ACTION_TYPE_SCREENSHOT
}

type ActionDefinition_Focus struct {
	Focus *FocusParams `protobuf:"bytes,21,opt,name=focus,proto3,oneof"` // Required when type = ACTION_TYPE_FOCUS
}

type ActionDefinition_Blur struct {
	Blur *BlurParams `protobuf:"bytes,22,opt,name=blur,proto3,oneof"` // Required when type = ACTION_TYPE_BLUR
}

type ActionDefinition_Subflow struct {
	Subflow *SubflowParams `protobuf:"bytes,23,opt,name=subflow,proto3,oneof"` // Required when type = ACTION_TYPE_SUBFLOW
}

func (*ActionDefinition_Navigate) isActionDefinition_Params() {}

func (*ActionDefinition_Click) isActionDefinition_Params() {}

func (*ActionDefinition_Input) isActionDefinition_Params() {}

func (*ActionDefinition_Wait) isActionDefinition_Params() {}

func (*ActionDefinition_Assert) isActionDefinition_Params() {}

func (*ActionDefinition_Scroll) isActionDefinition_Params() {}

func (*ActionDefinition_SelectOption) isActionDefinition_Params() {}

func (*ActionDefinition_Evaluate) isActionDefinition_Params() {}

func (*ActionDefinition_Keyboard) isActionDefinition_Params() {}

func (*ActionDefinition_Hover) isActionDefinition_Params() {}

func (*ActionDefinition_Screenshot) isActionDefinition_Params() {}

func (*ActionDefinition_Focus) isActionDefinition_Params() {}

func (*ActionDefinition_Blur) isActionDefinition_Params() {}

func (*ActionDefinition_Subflow) isActionDefinition_Params() {}

var File_browser_automation_studio_v1_actions_action_proto protoreflect.FileDescriptor

const file_browser_automation_studio_v1_actions_action_proto_rawDesc = "" +
	"\n" +
	"1browser-automation-studio/v1/actions/action.proto\x12\x1cbrowser_automation_studio.v1\x1a\x1fgoogle/protobuf/timestamp.proto\x1a\x15common/v1/types.proto\x1a.browser-automation-studio/v1/base/shared.proto\x1a0browser-automation-studio/v1/base/geometry.proto\x1a3browser-automation-studio/v1/domain/selectors.proto\"\xe6\x03\n" +
	"\x0eNavigateParams\x12\x10\n" +
	"\x03url\x18\x01 \x01(\tR\x03url\x12/\n" +
	"\x11wait_for_selector\x18\x02 \x01(\tH\x00R\x0fwaitForSelector\x88\x01\x01\x12\"\n" +
	"\n" +
	"timeout_ms\x18\x03 \x01(\x05H\x01R\ttimeoutMs\x88\x01\x01\x12S\n" +
	"\n" +
	"wait_until\x18\x04 \x01(\x0e2/.browser_automation_studio.v1.NavigateWaitEventH\x02R\twaitUntil\x88\x01\x01\x12e\n" +
	"\x10destination_type\x18\n" +
	" \x01(\x0e25.browser_automation_studio.v1.NavigateDestinationTypeH\x03R\x0fdestinationType\x88\x01\x01\x12\x1f\n" +
	"\bscenario\x18\v \x01(\tH\x04R\bscenario\x88\x01\x01\x12(\n" +
	"\rscenario_path\x18\f \x01(\tH\x05R\fscenarioPath\x88\x01\x01B\x14\n" +
	"\x12_wait_for_selectorB\r\n" +
	"\v_timeout_msB\r\n" +
	"\v_wait_untilB\x13\n" +
	"\x11_destination_typeB\v\n" +
	"\t_scenarioB\x10\n" +
	"\x0e_scenario_path\"\x96\x03\n" +
	"\vClickParams\x12\x1a\n" +
	"\bselector\x18\x01 \x01(\tR\bselector\x12F\n" +
	"\x06button\x18\x02 \x01(\x0e2).browser_automation_studio.v1.MouseButtonH\x00R\x06button\x88\x01\x01\x12$\n" +
	"\vclick_count\x18\x03 \x01(\x05H\x01R\n" +
	"clickCount\x88\x01\x01\x12\x1e\n" +
	"\bdelay_ms\x18\x04 \x01(\x05H\x02R\adelayMs\x88\x01\x01\x12L\n" +
	"\tmodifiers\x18\x05 \x03(\x0e2..browser_automation_studio.v1.KeyboardModifierR\tmodifiers\x12\x19\n" +
	"\x05force\x18\x06 \x01(\bH\x03R\x05force\x88\x01\x01\x12-\n" +
	"\x10scroll_into_view\x18\a \x01(\bH\x04R\x0escrollIntoView\x88\x01\x01B\t\n" +
	"\a_buttonB\x0e\n" +
	"\f_click_countB\v\n" +
	"\t_delay_msB\b\n" +
	"\x06_forceB\x13\n" +
	"\x11_scroll_into_view\"\x83\x02\n" +
	"\vInputParams\x12\x1a\n" +
	"\bselector\x18\x01 \x01(\tR\bselector\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value\x12&\n" +
	"\fis_sensitive\x18\x03 \x01(\bH\x00R\visSensitive\x88\x01\x01\x12\x1b\n" +
	"\x06submit\x18\x04 \x01(\bH\x01R\x06submit\x88\x01\x01\x12$\n" +
	"\vclear_first\x18\x05 \x01(\bH\x02R\n" +
	"clearFirst\x88\x01\x01\x12\x1e\n" +
	"\bdelay_ms\x18\x06 \x01(\x05H\x03R\adelayMs\x88\x01\x01B\x0f\n" +
	"\r_is_sensitiveB\t\n" +
	"\a_submitB\x0e\n" +
	"\f_clear_firstB\v\n" +
	"\t_delay_ms\"\xda\x01\n" +
	"\n" +
	"WaitParams\x12!\n" +
	"\vduration_ms\x18\x01 \x01(\x05H\x00R\n" +
	"durationMs\x12\x1c\n" +
	"\bselector\x18\x02 \x01(\tH\x00R\bselector\x12B\n" +
	"\x05state\x18\x03 \x01(\x0e2'.browser_automation_studio.v1.WaitStateH\x01R\x05state\x88\x01\x01\x12\"\n" +
	"\n" +
	"timeout_ms\x18\x04 \x01(\x05H\x02R\ttimeoutMs\x88\x01\x01B\n" +
	"\n" +
	"\bwait_forB\b\n" +
	"\x06_stateB\r\n" +
	"\v_timeout_ms\"\xcd\x03\n" +
	"\fAssertParams\x12\x1a\n" +
	"\bselector\x18\x01 \x01(\tR\bselector\x12?\n" +
	"\x04mode\x18\x02 \x01(\x0e2+.browser_automation_studio.v1.AssertionModeR\x04mode\x125\n" +
	"\bexpected\x18\x03 \x01(\v2\x14.common.v1.JsonValueH\x00R\bexpected\x88\x01\x01\x12\x1d\n" +
	"\anegated\x18\x04 \x01(\bH\x01R\anegated\x88\x01\x01\x12*\n" +
	"\x0ecase_sensitive\x18\x05 \x01(\bH\x02R\rcaseSensitive\x88\x01\x01\x12*\n" +
	"\x0eattribute_name\x18\x06 \x01(\tH\x03R\rattributeName\x88\x01\x01\x12,\n" +
	"\x0ffailure_message\x18\a \x01(\tH\x04R\x0efailureMessage\x88\x01\x01\x12\"\n" +
	"\n" +
	"timeout_ms\x18\b \x01(\x05H\x05R\ttimeoutMs\x88\x01\x01B\v\n" +
	"\t_expectedB\n" +
	"\n" +
	"\b_negatedB\x11\n" +
	"\x0f_case_sensitiveB\x11\n" +
	"\x0f_attribute_nameB\x12\n" +
	"\x10_failure_messageB\r\n" +
	"\v_timeout_ms\"\x9e\x02\n" +
	"\fScrollParams\x12\x1f\n" +
	"\bselector\x18\x01 \x01(\tH\x00R\bselector\x88\x01\x01\x12\x11\n" +
	"\x01x\x18\x02 \x01(\x05H\x01R\x01x\x88\x01\x01\x12\x11\n" +
	"\x01y\x18\x03 \x01(\x05H\x02R\x01y\x88\x01\x01\x12M\n" +
	"\bbehavior\x18\x04 \x01(\x0e2,.browser_automation_studio.v1.ScrollBehaviorH\x03R\bbehavior\x88\x01\x01\x12\x1c\n" +
	"\adelta_x\x18\x05 \x01(\x05H\x04R\x06deltaX\x88\x01\x01\x12\x1c\n" +
	"\adelta_y\x18\x06 \x01(\x05H\x05R\x06deltaY\x88\x01\x01B\v\n" +
	"\t_selectorB\x04\n" +
	"\x02_xB\x04\n" +
	"\x02_yB\v\n" +
	"\t_behaviorB\n" +
	"\n" +
	"\b_delta_xB\n" +
	"\n" +
	"\b_delta_y\"\xb2\x01\n" +
	"\fSelectParams\x12\x1a\n" +
	"\bselector\x18\x01 \x01(\tR\bselector\x12\x16\n" +
	"\x05value\x18\x02 \x01(\tH\x00R\x05value\x12\x16\n" +
	"\x05label\x18\x03 \x01(\tH\x00R\x05label\x12\x16\n" +
	"\x05index\x18\x04 \x01(\x05H\x00R\x05index\x12\"\n" +
	"\n" +
	"timeout_ms\x18\x05 \x01(\x05H\x01R\ttimeoutMs\x88\x01\x01B\v\n" +
	"\tselect_byB\r\n" +
	"\v_timeout_ms\"\x84\x02\n" +
	"\x0eEvaluateParams\x12\x1e\n" +
	"\n" +
	"expression\x18\x01 \x01(\tR\n" +
	"expression\x12&\n" +
	"\fstore_result\x18\x02 \x01(\tH\x00R\vstoreResult\x88\x01\x01\x12J\n" +
	"\x04args\x18\x03 \x03(\v26.browser_automation_studio.v1.EvaluateParams.ArgsEntryR\x04args\x1aM\n" +
	"\tArgsEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12*\n" +
	"\x05value\x18\x02 \x01(\v2\x14.common.v1.JsonValueR\x05value:\x028\x01B\x0f\n" +
	"\r_store_result\"\xe2\x01\n" +
	"\x0eKeyboardParams\x12\x15\n" +
	"\x03key\x18\x01 \x01(\tH\x00R\x03key\x88\x01\x01\x12\x12\n" +
	"\x04keys\x18\x02 \x03(\tR\x04keys\x12L\n" +
	"\tmodifiers\x18\x03 \x03(\x0e2..browser_automation_studio.v1.KeyboardModifierR\tmodifiers\x12D\n" +
	"\x06action\x18\x04 \x01(\x0e2'.browser_automation_studio.v1.KeyActionH\x01R\x06action\x88\x01\x01B\x06\n" +
	"\x04_keyB\t\n" +
	"\a_action\"\\\n" +
	"\vHoverParams\x12\x1a\n" +
	"\bselector\x18\x01 \x01(\tR\bselector\x12\"\n" +
	"\n" +
	"timeout_ms\x18\x02 \x01(\x05H\x00R\ttimeoutMs\x88\x01\x01B\r\n" +
	"\v_timeout_ms\"\x9b\x01\n" +
	"\x10ScreenshotParams\x12 \n" +
	"\tfull_page\x18\x01 \x01(\bH\x00R\bfullPage\x88\x01\x01\x12\x1f\n" +
	"\bselector\x18\x02 \x01(\tH\x01R\bselector\x88\x01\x01\x12\x1d\n" +
	"\aquality\x18\x03 \x01(\x05H\x02R\aquality\x88\x01\x01B\f\n" +
	"\n" +
	"_full_pageB\v\n" +
	"\t_selectorB\n" +
	"\n" +
	"\b_quality\"\x84\x01\n" +
	"\vFocusParams\x12\x1a\n" +
	"\bselector\x18\x01 \x01(\tR\bselector\x12\x1b\n" +
	"\x06scroll\x18\x02 \x01(\bH\x00R\x06scroll\x88\x01\x01\x12\"\n" +
	"\n" +
	"timeout_ms\x18\x03 \x01(\x05H\x01R\ttimeoutMs\x88\x01\x01B\t\n" +
	"\a_scrollB\r\n" +
	"\v_timeout_ms\"m\n" +
	"\n" +
	"BlurParams\x12\x1f\n" +
	"\bselector\x18\x01 \x01(\tH\x00R\bselector\x88\x01\x01\x12\"\n" +
	"\n" +
	"timeout_ms\x18\x02 \x01(\x05H\x01R\ttimeoutMs\x88\x01\x01B\v\n" +
	"\t_selectorB\r\n" +
	"\v_timeout_ms\"\xc2\x02\n" +
	"\rSubflowParams\x12!\n" +
	"\vworkflow_id\x18\x01 \x01(\tH\x00R\n" +
	"workflowId\x12%\n" +
	"\rworkflow_path\x18\x02 \x01(\tH\x00R\fworkflowPath\x12.\n" +
	"\x10workflow_version\x18\x03 \x01(\x05H\x01R\x0fworkflowVersion\x88\x01\x01\x12I\n" +
	"\x04args\x18\n" +
	" \x03(\v25.browser_automation_studio.v1.SubflowParams.ArgsEntryR\x04args\x1aM\n" +
	"\tArgsEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12*\n" +
	"\x05value\x18\x02 \x01(\v2\x14.common.v1.JsonValueR\x05value:\x028\x01B\b\n" +
	"\x06targetB\x13\n" +
	"\x11_workflow_version\"\x8b\x04\n" +
	"\x0eActionMetadata\x12\x19\n" +
	"\x05label\x18\x01 \x01(\tH\x00R\x05label\x88\x01\x01\x12`\n" +
	"\x13selector_candidates\x18\x02 \x03(\v2/.browser_automation_studio.v1.SelectorCandidateR\x12selectorCandidates\x12Y\n" +
	"\x10element_snapshot\x18\x03 \x01(\v2).browser_automation_studio.v1.ElementMetaH\x01R\x0felementSnapshot\x88\x01\x01\x12#\n" +
	"\n" +
	"confidence\x18\x04 \x01(\x01H\x02R\n" +
	"confidence\x88\x01\x01\x12@\n" +
	"\vcaptured_at\x18\x05 \x01(\v2\x1a.google.protobuf.TimestampH\x03R\n" +
	"capturedAt\x88\x01\x01\x12b\n" +
	"\x15captured_bounding_box\x18\x06 \x01(\v2).browser_automation_studio.v1.BoundingBoxH\x04R\x13capturedBoundingBox\x88\x01\x01B\b\n" +
	"\x06_labelB\x13\n" +
	"\x11_element_snapshotB\r\n" +
	"\v_confidenceB\x0e\n" +
	"\f_captured_atB\x18\n" +
	"\x16_captured_bounding_box\"\x8e\t\n" +
	"\x10ActionDefinition\x12<\n" +
	"\x04type\x18\x01 \x01(\x0e2(.browser_automation_studio.v1.ActionTypeR\x04type\x12J\n" +
	"\bnavigate\x18\n" +
	" \x01(\v2,.browser_automation_studio.v1.NavigateParamsH\x00R\bnavigate\x12A\n" +
	"\x05click\x18\v \x01(\v2).browser_automation_studio.v1.ClickParamsH\x00R\x05click\x12A\n" +
	"\x05input\x18\f \x01(\v2).browser_automation_studio.v1.InputParamsH\x00R\x05input\x12>\n" +
	"\x04wait\x18\r \x01(\v2(.browser_automation_studio.v1.WaitParamsH\x00R\x04wait\x12D\n" +
	"\x06assert\x18\x0e \x01(\v2*.browser_automation_studio.v1.AssertParamsH\x00R\x06assert\x12D\n" +
	"\x06scroll\x18\x0f \x01(\v2*.browser_automation_studio.v1.ScrollParamsH\x00R\x06scroll\x12Q\n" +
	"\rselect_option\x18\x10 \x01(\v2*.browser_automation_studio.v1.SelectParamsH\x00R\fselectOption\x12J\n" +
	"\bevaluate\x18\x11 \x01(\v2,.browser_automation_studio.v1.EvaluateParamsH\x00R\bevaluate\x12J\n" +
	"\bkeyboard\x18\x12 \x01(\v2,.browser_automation_studio.v1.KeyboardParamsH\x00R\bkeyboard\x12A\n" +
	"\x05hover\x18\x13 \x01(\v2).browser_automation_studio.v1.HoverParamsH\x00R\x05hover\x12P\n" +
	"\n" +
	"screenshot\x18\x14 \x01(\v2..browser_automation_studio.v1.ScreenshotParamsH\x00R\n" +
	"screenshot\x12A\n" +
	"\x05focus\x18\x15 \x01(\v2).browser_automation_studio.v1.FocusParamsH\x00R\x05focus\x12>\n" +
	"\x04blur\x18\x16 \x01(\v2(.browser_automation_studio.v1.BlurParamsH\x00R\x04blur\x12G\n" +
	"\asubflow\x18\x17 \x01(\v2+.browser_automation_studio.v1.SubflowParamsH\x00R\asubflow\x12H\n" +
	"\bmetadata\x18\x1e \x01(\v2,.browser_automation_studio.v1.ActionMetadataR\bmetadataB\b\n" +
	"\x06params*\xfc\x02\n" +
	"\n" +
	"ActionType\x12\x1b\n" +
	"\x17ACTION_TYPE_UNSPECIFIED\x10\x00\x12\x18\n" +
	"\x14ACTION_TYPE_NAVIGATE\x10\x01\x12\x15\n" +
	"\x11ACTION_TYPE_CLICK\x10\x02\x12\x15\n" +
	"\x11ACTION_TYPE_INPUT\x10\x03\x12\x14\n" +
	"\x10ACTION_TYPE_WAIT\x10\x04\x12\x16\n" +
	"\x12ACTION_TYPE_ASSERT\x10\x05\x12\x16\n" +
	"\x12ACTION_TYPE_SCROLL\x10\x06\x12\x16\n" +
	"\x12ACTION_TYPE_SELECT\x10\a\x12\x18\n" +
	"\x14ACTION_TYPE_EVALUATE\x10\b\x12\x18\n" +
	"\x14ACTION_TYPE_KEYBOARD\x10\t\x12\x15\n" +
	"\x11ACTION_TYPE_HOVER\x10\n" +
	"\x12\x1a\n" +
	"\x16ACTION_TYPE_SCREENSHOT\x10\v\x12\x15\n" +
	"\x11ACTION_TYPE_FOCUS\x10\f\x12\x14\n" +
	"\x10ACTION_TYPE_BLUR\x10\r\x12\x17\n" +
	"\x13ACTION_TYPE_SUBFLOW\x10\x0e*s\n" +
	"\vMouseButton\x12\x1c\n" +
	"\x18MOUSE_BUTTON_UNSPECIFIED\x10\x00\x12\x15\n" +
	"\x11MOUSE_BUTTON_LEFT\x10\x01\x12\x16\n" +
	"\x12MOUSE_BUTTON_RIGHT\x10\x02\x12\x17\n" +
	"\x13MOUSE_BUTTON_MIDDLE\x10\x03*\xa5\x01\n" +
	"\x11NavigateWaitEvent\x12#\n" +
	"\x1fNAVIGATE_WAIT_EVENT_UNSPECIFIED\x10\x00\x12\x1c\n" +
	"\x18NAVIGATE_WAIT_EVENT_LOAD\x10\x01\x12(\n" +
	"$NAVIGATE_WAIT_EVENT_DOMCONTENTLOADED\x10\x02\x12#\n" +
	"\x1fNAVIGATE_WAIT_EVENT_NETWORKIDLE\x10\x03*\x8f\x01\n" +
	"\x17NavigateDestinationType\x12)\n" +
	"%NAVIGATE_DESTINATION_TYPE_UNSPECIFIED\x10\x00\x12!\n" +
	"\x1dNAVIGATE_DESTINATION_TYPE_URL\x10\x01\x12&\n" +
	"\"NAVIGATE_DESTINATION_TYPE_SCENARIO\x10\x02*\x88\x01\n" +
	"\tWaitState\x12\x1a\n" +
	"\x16WAIT_STATE_UNSPECIFIED\x10\x00\x12\x17\n" +
	"\x13WAIT_STATE_ATTACHED\x10\x01\x12\x17\n" +
	"\x13WAIT_STATE_DETACHED\x10\x02\x12\x16\n" +
	"\x12WAIT_STATE_VISIBLE\x10\x03\x12\x15\n" +
	"\x11WAIT_STATE_HIDDEN\x10\x04*g\n" +
	"\x0eScrollBehavior\x12\x1f\n" +
	"\x1bSCROLL_BEHAVIOR_UNSPECIFIED\x10\x00\x12\x18\n" +
	"\x14SCROLL_BEHAVIOR_AUTO\x10\x01\x12\x1a\n" +
	"\x16SCROLL_BEHAVIOR_SMOOTH\x10\x02*e\n" +
	"\tKeyAction\x12\x1a\n" +
	"\x16KEY_ACTION_UNSPECIFIED\x10\x00\x12\x14\n" +
	"\x10KEY_ACTION_PRESS\x10\x01\x12\x13\n" +
	"\x0fKEY_ACTION_DOWN\x10\x02\x12\x11\n" +
	"\rKEY_ACTION_UP\x10\x03*\xa5\x01\n" +
	"\x10KeyboardModifier\x12!\n" +
	"\x1dKEYBOARD_MODIFIER_UNSPECIFIED\x10\x00\x12\x1a\n" +
	"\x16KEYBOARD_MODIFIER_CTRL\x10\x01\x12\x1b\n" +
	"\x17KEYBOARD_MODIFIER_SHIFT\x10\x02\x12\x19\n" +
	"\x15KEYBOARD_MODIFIER_ALT\x10\x03\x12\x1a\n" +
	"\x16KEYBOARD_MODIFIER_META\x10\x04B]Z[github.com/vrooli/vrooli/packages/proto/gen/go/browser-automation-studio/v1/actions;actionsb\x06proto3"

var (
	file_browser_automation_studio_v1_actions_action_proto_rawDescOnce sync.Once
	file_browser_automation_studio_v1_actions_action_proto_rawDescData []byte
)

func file_browser_automation_studio_v1_actions_action_proto_rawDescGZIP() []byte {
	file_browser_automation_studio_v1_actions_action_proto_rawDescOnce.Do(func() {
		file_browser_automation_studio_v1_actions_action_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_browser_automation_studio_v1_actions_action_proto_rawDesc), len(file_browser_automation_studio_v1_actions_action_proto_rawDesc)))
	})
	return file_browser_automation_studio_v1_actions_action_proto_rawDescData
}

var file_browser_automation_studio_v1_actions_action_proto_enumTypes = make([]protoimpl.EnumInfo, 8)
var file_browser_automation_studio_v1_actions_action_proto_msgTypes = make([]protoimpl.MessageInfo, 18)
var file_browser_automation_studio_v1_actions_action_proto_goTypes = []any{
	(ActionType)(0),                  // 0: browser_automation_studio.v1.ActionType
	(MouseButton)(0),                 // 1: browser_automation_studio.v1.MouseButton
	(NavigateWaitEvent)(0),           // 2: browser_automation_studio.v1.NavigateWaitEvent
	(NavigateDestinationType)(0),     // 3: browser_automation_studio.v1.NavigateDestinationType
	(WaitState)(0),                   // 4: browser_automation_studio.v1.WaitState
	(ScrollBehavior)(0),              // 5: browser_automation_studio.v1.ScrollBehavior
	(KeyAction)(0),                   // 6: browser_automation_studio.v1.KeyAction
	(KeyboardModifier)(0),            // 7: browser_automation_studio.v1.KeyboardModifier
	(*NavigateParams)(nil),           // 8: browser_automation_studio.v1.NavigateParams
	(*ClickParams)(nil),              // 9: browser_automation_studio.v1.ClickParams
	(*InputParams)(nil),              // 10: browser_automation_studio.v1.InputParams
	(*WaitParams)(nil),               // 11: browser_automation_studio.v1.WaitParams
	(*AssertParams)(nil),             // 12: browser_automation_studio.v1.AssertParams
	(*ScrollParams)(nil),             // 13: browser_automation_studio.v1.ScrollParams
	(*SelectParams)(nil),             // 14: browser_automation_studio.v1.SelectParams
	(*EvaluateParams)(nil),           // 15: browser_automation_studio.v1.EvaluateParams
	(*KeyboardParams)(nil),           // 16: browser_automation_studio.v1.KeyboardParams
	(*HoverParams)(nil),              // 17: browser_automation_studio.v1.HoverParams
	(*ScreenshotParams)(nil),         // 18: browser_automation_studio.v1.ScreenshotParams
	(*FocusParams)(nil),              // 19: browser_automation_studio.v1.FocusParams
	(*BlurParams)(nil),               // 20: browser_automation_studio.v1.BlurParams
	(*SubflowParams)(nil),            // 21: browser_automation_studio.v1.SubflowParams
	(*ActionMetadata)(nil),           // 22: browser_automation_studio.v1.ActionMetadata
	(*ActionDefinition)(nil),         // 23: browser_automation_studio.v1.ActionDefinition
	nil,                              // 24: browser_automation_studio.v1.EvaluateParams.ArgsEntry
	nil,                              // 25: browser_automation_studio.v1.SubflowParams.ArgsEntry
	(base.AssertionMode)(0),          // 26: browser_automation_studio.v1.AssertionMode
	(*v1.JsonValue)(nil),             // 27: common.v1.JsonValue
	(*domain.SelectorCandidate)(nil), // 28: browser_automation_studio.v1.SelectorCandidate
	(*domain.ElementMeta)(nil),       // 29: browser_automation_studio.v1.ElementMeta
	(*timestamppb.Timestamp)(nil),    // 30: google.protobuf.Timestamp
	(*base.BoundingBox)(nil),         // 31: browser_automation_studio.v1.BoundingBox
}
var file_browser_automation_studio_v1_actions_action_proto_depIdxs = []int32{
	2,  // 0: browser_automation_studio.v1.NavigateParams.wait_until:type_name -> browser_automation_studio.v1.NavigateWaitEvent
	3,  // 1: browser_automation_studio.v1.NavigateParams.destination_type:type_name -> browser_automation_studio.v1.NavigateDestinationType
	1,  // 2: browser_automation_studio.v1.ClickParams.button:type_name -> browser_automation_studio.v1.MouseButton
	7,  // 3: browser_automation_studio.v1.ClickParams.modifiers:type_name -> browser_automation_studio.v1.KeyboardModifier
	4,  // 4: browser_automation_studio.v1.WaitParams.state:type_name -> browser_automation_studio.v1.WaitState
	26, // 5: browser_automation_studio.v1.AssertParams.mode:type_name -> browser_automation_studio.v1.AssertionMode
	27, // 6: browser_automation_studio.v1.AssertParams.expected:type_name -> common.v1.JsonValue
	5,  // 7: browser_automation_studio.v1.ScrollParams.behavior:type_name -> browser_automation_studio.v1.ScrollBehavior
	24, // 8: browser_automation_studio.v1.EvaluateParams.args:type_name -> browser_automation_studio.v1.EvaluateParams.ArgsEntry
	7,  // 9: browser_automation_studio.v1.KeyboardParams.modifiers:type_name -> browser_automation_studio.v1.KeyboardModifier
	6,  // 10: browser_automation_studio.v1.KeyboardParams.action:type_name -> browser_automation_studio.v1.KeyAction
	25, // 11: browser_automation_studio.v1.SubflowParams.args:type_name -> browser_automation_studio.v1.SubflowParams.ArgsEntry
	28, // 12: browser_automation_studio.v1.ActionMetadata.selector_candidates:type_name -> browser_automation_studio.v1.SelectorCandidate
	29, // 13: browser_automation_studio.v1.ActionMetadata.element_snapshot:type_name -> browser_automation_studio.v1.ElementMeta
	30, // 14: browser_automation_studio.v1.ActionMetadata.captured_at:type_name -> google.protobuf.Timestamp
	31, // 15: browser_automation_studio.v1.ActionMetadata.captured_bounding_box:type_name -> browser_automation_studio.v1.BoundingBox
	0,  // 16: browser_automation_studio.v1.ActionDefinition.type:type_name -> browser_automation_studio.v1.ActionType
	8,  // 17: browser_automation_studio.v1.ActionDefinition.navigate:type_name -> browser_automation_studio.v1.NavigateParams
	9,  // 18: browser_automation_studio.v1.ActionDefinition.click:type_name -> browser_automation_studio.v1.ClickParams
	10, // 19: browser_automation_studio.v1.ActionDefinition.input:type_name -> browser_automation_studio.v1.InputParams
	11, // 20: browser_automation_studio.v1.ActionDefinition.wait:type_name -> browser_automation_studio.v1.WaitParams
	12, // 21: browser_automation_studio.v1.ActionDefinition.assert:type_name -> browser_automation_studio.v1.AssertParams
	13, // 22: browser_automation_studio.v1.ActionDefinition.scroll:type_name -> browser_automation_studio.v1.ScrollParams
	14, // 23: browser_automation_studio.v1.ActionDefinition.select_option:type_name -> browser_automation_studio.v1.SelectParams
	15, // 24: browser_automation_studio.v1.ActionDefinition.evaluate:type_name -> browser_automation_studio.v1.EvaluateParams
	16, // 25: browser_automation_studio.v1.ActionDefinition.keyboard:type_name -> browser_automation_studio.v1.KeyboardParams
	17, // 26: browser_automation_studio.v1.ActionDefinition.hover:type_name -> browser_automation_studio.v1.HoverParams
	18, // 27: browser_automation_studio.v1.ActionDefinition.screenshot:type_name -> browser_automation_studio.v1.ScreenshotParams
	19, // 28: browser_automation_studio.v1.ActionDefinition.focus:type_name -> browser_automation_studio.v1.FocusParams
	20, // 29: browser_automation_studio.v1.ActionDefinition.blur:type_name -> browser_automation_studio.v1.BlurParams
	21, // 30: browser_automation_studio.v1.ActionDefinition.subflow:type_name -> browser_automation_studio.v1.SubflowParams
	22, // 31: browser_automation_studio.v1.ActionDefinition.metadata:type_name -> browser_automation_studio.v1.ActionMetadata
	27, // 32: browser_automation_studio.v1.EvaluateParams.ArgsEntry.value:type_name -> common.v1.JsonValue
	27, // 33: browser_automation_studio.v1.SubflowParams.ArgsEntry.value:type_name -> common.v1.JsonValue
	34, // [34:34] is the sub-list for method output_type
	34, // [34:34] is the sub-list for method input_type
	34, // [34:34] is the sub-list for extension type_name
	34, // [34:34] is the sub-list for extension extendee
	0,  // [0:34] is the sub-list for field type_name
}

func init() { file_browser_automation_studio_v1_actions_action_proto_init() }
func file_browser_automation_studio_v1_actions_action_proto_init() {
	if File_browser_automation_studio_v1_actions_action_proto != nil {
		return
	}
	file_browser_automation_studio_v1_actions_action_proto_msgTypes[0].OneofWrappers = []any{}
	file_browser_automation_studio_v1_actions_action_proto_msgTypes[1].OneofWrappers = []any{}
	file_browser_automation_studio_v1_actions_action_proto_msgTypes[2].OneofWrappers = []any{}
	file_browser_automation_studio_v1_actions_action_proto_msgTypes[3].OneofWrappers = []any{
		(*WaitParams_DurationMs)(nil),
		(*WaitParams_Selector)(nil),
	}
	file_browser_automation_studio_v1_actions_action_proto_msgTypes[4].OneofWrappers = []any{}
	file_browser_automation_studio_v1_actions_action_proto_msgTypes[5].OneofWrappers = []any{}
	file_browser_automation_studio_v1_actions_action_proto_msgTypes[6].OneofWrappers = []any{
		(*SelectParams_Value)(nil),
		(*SelectParams_Label)(nil),
		(*SelectParams_Index)(nil),
	}
	file_browser_automation_studio_v1_actions_action_proto_msgTypes[7].OneofWrappers = []any{}
	file_browser_automation_studio_v1_actions_action_proto_msgTypes[8].OneofWrappers = []any{}
	file_browser_automation_studio_v1_actions_action_proto_msgTypes[9].OneofWrappers = []any{}
	file_browser_automation_studio_v1_actions_action_proto_msgTypes[10].OneofWrappers = []any{}
	file_browser_automation_studio_v1_actions_action_proto_msgTypes[11].OneofWrappers = []any{}
	file_browser_automation_studio_v1_actions_action_proto_msgTypes[12].OneofWrappers = []any{}
	file_browser_automation_studio_v1_actions_action_proto_msgTypes[13].OneofWrappers = []any{
		(*SubflowParams_WorkflowId)(nil),
		(*SubflowParams_WorkflowPath)(nil),
	}
	file_browser_automation_studio_v1_actions_action_proto_msgTypes[14].OneofWrappers = []any{}
	file_browser_automation_studio_v1_actions_action_proto_msgTypes[15].OneofWrappers = []any{
		(*ActionDefinition_Navigate)(nil),
		(*ActionDefinition_Click)(nil),
		(*ActionDefinition_Input)(nil),
		(*ActionDefinition_Wait)(nil),
		(*ActionDefinition_Assert)(nil),
		(*ActionDefinition_Scroll)(nil),
		(*ActionDefinition_SelectOption)(nil),
		(*ActionDefinition_Evaluate)(nil),
		(*ActionDefinition_Keyboard)(nil),
		(*ActionDefinition_Hover)(nil),
		(*ActionDefinition_Screenshot)(nil),
		(*ActionDefinition_Focus)(nil),
		(*ActionDefinition_Blur)(nil),
		(*ActionDefinition_Subflow)(nil),
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_browser_automation_studio_v1_actions_action_proto_rawDesc), len(file_browser_automation_studio_v1_actions_action_proto_rawDesc)),
			NumEnums:      8,
			NumMessages:   18,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_browser_automation_studio_v1_actions_action_proto_goTypes,
		DependencyIndexes: file_browser_automation_studio_v1_actions_action_proto_depIdxs,
		EnumInfos:         file_browser_automation_studio_v1_actions_action_proto_enumTypes,
		MessageInfos:      file_browser_automation_studio_v1_actions_action_proto_msgTypes,
	}.Build()
	File_browser_automation_studio_v1_actions_action_proto = out.File
	file_browser_automation_studio_v1_actions_action_proto_goTypes = nil
	file_browser_automation_studio_v1_actions_action_proto_depIdxs = nil
}
