// @generated by protoc-gen-es v2.10.1 with parameter "target=ts,import_extension=none"
// @generated from file browser-automation-studio/v1/recording/session.proto (package browser_automation_studio.v1, syntax proto3)
/* eslint-disable */

import type { GenFile, GenMessage } from "@bufbuild/protobuf/codegenv2";
import { fileDesc, messageDesc } from "@bufbuild/protobuf/codegenv2";
import type { Timestamp } from "@bufbuild/protobuf/wkt";
import { file_google_protobuf_timestamp } from "@bufbuild/protobuf/wkt";
import type { ActionDefinition } from "../actions/action_pb";
import { file_browser_automation_studio_v1_actions_action } from "../actions/action_pb";
import type { TimelineEntry } from "../timeline/entry_pb";
import { file_browser_automation_studio_v1_timeline_entry } from "../timeline/entry_pb";
import type { Message } from "@bufbuild/protobuf";

/**
 * Describes the file browser-automation-studio/v1/recording/session.proto.
 */
export const file_browser_automation_studio_v1_recording_session: GenFile = /*@__PURE__*/
  fileDesc("CjRicm93c2VyLWF1dG9tYXRpb24tc3R1ZGlvL3YxL3JlY29yZGluZy9zZXNzaW9uLnByb3RvEhxicm93c2VyX2F1dG9tYXRpb25fc3R1ZGlvLnYxIpYBCg5SZWNvcmRpbmdTdGF0ZRIUCgxpc19yZWNvcmRpbmcYASABKAgSFAoMcmVjb3JkaW5nX2lkGAIgASgJEhIKCnNlc3Npb25faWQYAyABKAkSFAoMYWN0aW9uX2NvdW50GAQgASgFEi4KCnN0YXJ0ZWRfYXQYBSABKAsyGi5nb29nbGUucHJvdG9idWYuVGltZXN0YW1wImUKHUNyZWF0ZVJlY29yZGluZ1Nlc3Npb25SZXF1ZXN0EhYKDnZpZXdwb3J0X3dpZHRoGAEgASgFEhcKD3ZpZXdwb3J0X2hlaWdodBgCIAEoBRITCgtpbml0aWFsX3VybBgDIAEoCSJkCh5DcmVhdGVSZWNvcmRpbmdTZXNzaW9uUmVzcG9uc2USEgoKc2Vzc2lvbl9pZBgBIAEoCRIuCgpjcmVhdGVkX2F0GAIgASgLMhouZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcCJBChVTdGFydFJlY29yZGluZ1JlcXVlc3QSEgoKc2Vzc2lvbl9pZBgBIAEoCRIUCgxjYWxsYmFja191cmwYAiABKAkicgoWU3RhcnRSZWNvcmRpbmdSZXNwb25zZRIUCgxyZWNvcmRpbmdfaWQYASABKAkSEgoKc2Vzc2lvbl9pZBgCIAEoCRIuCgpzdGFydGVkX2F0GAMgASgLMhouZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcCKJAQoVU3RvcFJlY29yZGluZ1Jlc3BvbnNlEhQKDHJlY29yZGluZ19pZBgBIAEoCRISCgpzZXNzaW9uX2lkGAIgASgJEhQKDGFjdGlvbl9jb3VudBgDIAEoBRIwCgxjb21wbGV0ZWRfYXQYBCABKAsyGi5nb29nbGUucHJvdG9idWYuVGltZXN0YW1wIrMBChdSZWNvcmRpbmdTdGF0dXNSZXNwb25zZRISCgpzZXNzaW9uX2lkGAEgASgJEhQKDGlzX3JlY29yZGluZxgCIAEoCBIUCgxyZWNvcmRpbmdfaWQYAyABKAkSFAoMYWN0aW9uX2NvdW50GAQgASgFEjMKCnN0YXJ0ZWRfYXQYBSABKAsyGi5nb29nbGUucHJvdG9idWYuVGltZXN0YW1wSACIAQFCDQoLX3N0YXJ0ZWRfYXQidQoSR2V0QWN0aW9uc1Jlc3BvbnNlEhIKCnNlc3Npb25faWQYASABKAkSPAoHZW50cmllcxgCIAMoCzIrLmJyb3dzZXJfYXV0b21hdGlvbl9zdHVkaW8udjEuVGltZWxpbmVFbnRyeRINCgVjb3VudBgDIAEoBSKkAgoXR2VuZXJhdGVXb3JrZmxvd1JlcXVlc3QSEgoKc2Vzc2lvbl9pZBgBIAEoCRIMCgRuYW1lGAIgASgJEhIKCnByb2plY3RfaWQYAyABKAkSFAoMcHJvamVjdF9uYW1lGAQgASgJElUKC2VudHJ5X3JhbmdlGAUgASgLMkAuYnJvd3Nlcl9hdXRvbWF0aW9uX3N0dWRpby52MS5HZW5lcmF0ZVdvcmtmbG93UmVxdWVzdC5FbnRyeVJhbmdlEjwKB2VudHJpZXMYBiADKAsyKy5icm93c2VyX2F1dG9tYXRpb25fc3R1ZGlvLnYxLlRpbWVsaW5lRW50cnkaKAoKRW50cnlSYW5nZRINCgVzdGFydBgBIAEoBRILCgNlbmQYAiABKAUiegoYR2VuZXJhdGVXb3JrZmxvd1Jlc3BvbnNlEhMKC3dvcmtmbG93X2lkGAEgASgJEhIKCnByb2plY3RfaWQYAiABKAkSDAoEbmFtZRgDIAEoCRISCgpub2RlX2NvdW50GAQgASgFEhMKC2VudHJ5X2NvdW50GAUgASgFIqsBChRSZXBsYXlQcmV2aWV3UmVxdWVzdBISCgpzZXNzaW9uX2lkGAEgASgJEjwKB2VudHJpZXMYAiADKAsyKy5icm93c2VyX2F1dG9tYXRpb25fc3R1ZGlvLnYxLlRpbWVsaW5lRW50cnkSDQoFbGltaXQYAyABKAUSFwoPc3RvcF9vbl9mYWlsdXJlGAQgASgIEhkKEWFjdGlvbl90aW1lb3V0X21zGAUgASgFIlgKEFJlcGxheUV2ZW50RXJyb3ISDwoHbWVzc2FnZRgBIAEoCRIMCgRjb2RlGAIgASgJEhMKC21hdGNoX2NvdW50GAMgASgFEhAKCHNlbGVjdG9yGAQgASgJIv0BChFSZXBsYXlFbnRyeVJlc3VsdBIQCghlbnRyeV9pZBgBIAEoCRIUCgxzZXF1ZW5jZV9udW0YAiABKAUSDwoHc3VjY2VzcxgDIAEoCBITCgtkdXJhdGlvbl9tcxgEIAEoBRI9CgVlcnJvchgFIAEoCzIuLmJyb3dzZXJfYXV0b21hdGlvbl9zdHVkaW8udjEuUmVwbGF5RXZlbnRFcnJvchIbChNzY3JlZW5zaG90X29uX2Vycm9yGAYgASgJEj4KBmFjdGlvbhgHIAEoCzIuLmJyb3dzZXJfYXV0b21hdGlvbl9zdHVkaW8udjEuQWN0aW9uRGVmaW5pdGlvbiLjAQoVUmVwbGF5UHJldmlld1Jlc3BvbnNlEg8KB3N1Y2Nlc3MYASABKAgSFQoNdG90YWxfZW50cmllcxgCIAEoBRIWCg5wYXNzZWRfZW50cmllcxgDIAEoBRIWCg5mYWlsZWRfZW50cmllcxgEIAEoBRJACgdyZXN1bHRzGAUgAygLMi8uYnJvd3Nlcl9hdXRvbWF0aW9uX3N0dWRpby52MS5SZXBsYXlFbnRyeVJlc3VsdBIZChF0b3RhbF9kdXJhdGlvbl9tcxgGIAEoBRIVCg1zdG9wcGVkX2Vhcmx5GAcgASgIIlkKElNlbGVjdG9yVmFsaWRhdGlvbhINCgV2YWxpZBgBIAEoCBITCgttYXRjaF9jb3VudBgCIAEoBRIQCghzZWxlY3RvchgDIAEoCRINCgVlcnJvchgEIAEoCUJhWl9naXRodWIuY29tL3Zyb29saS92cm9vbGkvcGFja2FnZXMvcHJvdG8vZ2VuL2dvL2Jyb3dzZXItYXV0b21hdGlvbi1zdHVkaW8vdjEvcmVjb3JkaW5nO3JlY29yZGluZ2IGcHJvdG8z", [file_google_protobuf_timestamp, file_browser_automation_studio_v1_actions_action, file_browser_automation_studio_v1_timeline_entry]);

/**
 * RecordingState captures current recording session state.
 *
 * @generated from message browser_automation_studio.v1.RecordingState
 */
export type RecordingState = Message<"browser_automation_studio.v1.RecordingState"> & {
  /**
   * Whether recording is currently active.
   *
   * @generated from field: bool is_recording = 1;
   */
  isRecording: boolean;

  /**
   * Current recording ID (UUID format).
   *
   * @generated from field: string recording_id = 2;
   */
  recordingId: string;

  /**
   * Session ID for the browser session (UUID format).
   *
   * @generated from field: string session_id = 3;
   */
  sessionId: string;

  /**
   * Number of actions captured so far.
   *
   * @generated from field: int32 action_count = 4;
   */
  actionCount: number;

  /**
   * When recording started.
   *
   * @generated from field: google.protobuf.Timestamp started_at = 5;
   */
  startedAt?: Timestamp;
};

/**
 * Describes the message browser_automation_studio.v1.RecordingState.
 * Use `create(RecordingStateSchema)` to create a new message.
 */
export const RecordingStateSchema: GenMessage<RecordingState> = /*@__PURE__*/
  messageDesc(file_browser_automation_studio_v1_recording_session, 0);

/**
 * CreateRecordingSessionRequest creates a browser session for recording.
 *
 * @generated from message browser_automation_studio.v1.CreateRecordingSessionRequest
 */
export type CreateRecordingSessionRequest = Message<"browser_automation_studio.v1.CreateRecordingSessionRequest"> & {
  /**
   * Viewport width in pixels.
   *
   * @generated from field: int32 viewport_width = 1;
   */
  viewportWidth: number;

  /**
   * Viewport height in pixels.
   *
   * @generated from field: int32 viewport_height = 2;
   */
  viewportHeight: number;

  /**
   * Initial URL to navigate to.
   *
   * @generated from field: string initial_url = 3;
   */
  initialUrl: string;
};

/**
 * Describes the message browser_automation_studio.v1.CreateRecordingSessionRequest.
 * Use `create(CreateRecordingSessionRequestSchema)` to create a new message.
 */
export const CreateRecordingSessionRequestSchema: GenMessage<CreateRecordingSessionRequest> = /*@__PURE__*/
  messageDesc(file_browser_automation_studio_v1_recording_session, 1);

/**
 * CreateRecordingSessionResponse is returned after creating a recording session.
 *
 * @generated from message browser_automation_studio.v1.CreateRecordingSessionResponse
 */
export type CreateRecordingSessionResponse = Message<"browser_automation_studio.v1.CreateRecordingSessionResponse"> & {
  /**
   * Unique session identifier (UUID format).
   *
   * @generated from field: string session_id = 1;
   */
  sessionId: string;

  /**
   * When the session was created.
   *
   * @generated from field: google.protobuf.Timestamp created_at = 2;
   */
  createdAt?: Timestamp;
};

/**
 * Describes the message browser_automation_studio.v1.CreateRecordingSessionResponse.
 * Use `create(CreateRecordingSessionResponseSchema)` to create a new message.
 */
export const CreateRecordingSessionResponseSchema: GenMessage<CreateRecordingSessionResponse> = /*@__PURE__*/
  messageDesc(file_browser_automation_studio_v1_recording_session, 2);

/**
 * StartRecordingRequest starts recording on an existing session.
 *
 * @generated from message browser_automation_studio.v1.StartRecordingRequest
 */
export type StartRecordingRequest = Message<"browser_automation_studio.v1.StartRecordingRequest"> & {
  /**
   * Session ID to start recording on (UUID format).
   *
   * @generated from field: string session_id = 1;
   */
  sessionId: string;

  /**
   * Callback URL for streaming events (optional).
   *
   * @generated from field: string callback_url = 2;
   */
  callbackUrl: string;
};

/**
 * Describes the message browser_automation_studio.v1.StartRecordingRequest.
 * Use `create(StartRecordingRequestSchema)` to create a new message.
 */
export const StartRecordingRequestSchema: GenMessage<StartRecordingRequest> = /*@__PURE__*/
  messageDesc(file_browser_automation_studio_v1_recording_session, 3);

/**
 * StartRecordingResponse is returned after starting recording.
 *
 * @generated from message browser_automation_studio.v1.StartRecordingResponse
 */
export type StartRecordingResponse = Message<"browser_automation_studio.v1.StartRecordingResponse"> & {
  /**
   * Unique recording identifier (UUID format).
   *
   * @generated from field: string recording_id = 1;
   */
  recordingId: string;

  /**
   * Session ID the recording is attached to (UUID format).
   *
   * @generated from field: string session_id = 2;
   */
  sessionId: string;

  /**
   * When recording started.
   *
   * @generated from field: google.protobuf.Timestamp started_at = 3;
   */
  startedAt?: Timestamp;
};

/**
 * Describes the message browser_automation_studio.v1.StartRecordingResponse.
 * Use `create(StartRecordingResponseSchema)` to create a new message.
 */
export const StartRecordingResponseSchema: GenMessage<StartRecordingResponse> = /*@__PURE__*/
  messageDesc(file_browser_automation_studio_v1_recording_session, 4);

/**
 * StopRecordingResponse is returned after stopping recording.
 *
 * @generated from message browser_automation_studio.v1.StopRecordingResponse
 */
export type StopRecordingResponse = Message<"browser_automation_studio.v1.StopRecordingResponse"> & {
  /**
   * Recording ID that was stopped (UUID format).
   *
   * @generated from field: string recording_id = 1;
   */
  recordingId: string;

  /**
   * Session ID the recording was attached to (UUID format).
   *
   * @generated from field: string session_id = 2;
   */
  sessionId: string;

  /**
   * Total number of actions captured.
   *
   * @generated from field: int32 action_count = 3;
   */
  actionCount: number;

  /**
   * When recording completed.
   *
   * @generated from field: google.protobuf.Timestamp completed_at = 4;
   */
  completedAt?: Timestamp;
};

/**
 * Describes the message browser_automation_studio.v1.StopRecordingResponse.
 * Use `create(StopRecordingResponseSchema)` to create a new message.
 */
export const StopRecordingResponseSchema: GenMessage<StopRecordingResponse> = /*@__PURE__*/
  messageDesc(file_browser_automation_studio_v1_recording_session, 5);

/**
 * RecordingStatusResponse returns current recording status.
 *
 * @generated from message browser_automation_studio.v1.RecordingStatusResponse
 */
export type RecordingStatusResponse = Message<"browser_automation_studio.v1.RecordingStatusResponse"> & {
  /**
   * Session ID being queried (UUID format).
   *
   * @generated from field: string session_id = 1;
   */
  sessionId: string;

  /**
   * Whether recording is active.
   *
   * @generated from field: bool is_recording = 2;
   */
  isRecording: boolean;

  /**
   * Current recording ID (UUID format, empty if not recording).
   *
   * @generated from field: string recording_id = 3;
   */
  recordingId: string;

  /**
   * Number of actions captured.
   *
   * @generated from field: int32 action_count = 4;
   */
  actionCount: number;

  /**
   * When recording started (null if not recording).
   *
   * @generated from field: optional google.protobuf.Timestamp started_at = 5;
   */
  startedAt?: Timestamp;
};

/**
 * Describes the message browser_automation_studio.v1.RecordingStatusResponse.
 * Use `create(RecordingStatusResponseSchema)` to create a new message.
 */
export const RecordingStatusResponseSchema: GenMessage<RecordingStatusResponse> = /*@__PURE__*/
  messageDesc(file_browser_automation_studio_v1_recording_session, 6);

/**
 * GetActionsResponse returns captured timeline entries from a recording session.
 *
 * @generated from message browser_automation_studio.v1.GetActionsResponse
 */
export type GetActionsResponse = Message<"browser_automation_studio.v1.GetActionsResponse"> & {
  /**
   * Session ID the entries belong to (UUID format).
   *
   * @generated from field: string session_id = 1;
   */
  sessionId: string;

  /**
   * Captured timeline entries (unified format).
   *
   * @generated from field: repeated browser_automation_studio.v1.TimelineEntry entries = 2;
   */
  entries: TimelineEntry[];

  /**
   * Total number of entries.
   *
   * @generated from field: int32 count = 3;
   */
  count: number;
};

/**
 * Describes the message browser_automation_studio.v1.GetActionsResponse.
 * Use `create(GetActionsResponseSchema)` to create a new message.
 */
export const GetActionsResponseSchema: GenMessage<GetActionsResponse> = /*@__PURE__*/
  messageDesc(file_browser_automation_studio_v1_recording_session, 7);

/**
 * GenerateWorkflowRequest generates a workflow from recorded entries.
 *
 * @generated from message browser_automation_studio.v1.GenerateWorkflowRequest
 */
export type GenerateWorkflowRequest = Message<"browser_automation_studio.v1.GenerateWorkflowRequest"> & {
  /**
   * Session ID to generate workflow from (UUID format).
   *
   * @generated from field: string session_id = 1;
   */
  sessionId: string;

  /**
   * Name for the generated workflow.
   *
   * @generated from field: string name = 2;
   */
  name: string;

  /**
   * Project ID to save the workflow to (UUID format).
   *
   * @generated from field: string project_id = 3;
   */
  projectId: string;

  /**
   * Project name (for display).
   *
   * @generated from field: string project_name = 4;
   */
  projectName: string;

  /**
   * Entry range to include (optional, defaults to all).
   *
   * @generated from field: browser_automation_studio.v1.GenerateWorkflowRequest.EntryRange entry_range = 5;
   */
  entryRange?: GenerateWorkflowRequest_EntryRange;

  /**
   * Timeline entries to convert (optional, uses session entries if empty).
   *
   * @generated from field: repeated browser_automation_studio.v1.TimelineEntry entries = 6;
   */
  entries: TimelineEntry[];
};

/**
 * Describes the message browser_automation_studio.v1.GenerateWorkflowRequest.
 * Use `create(GenerateWorkflowRequestSchema)` to create a new message.
 */
export const GenerateWorkflowRequestSchema: GenMessage<GenerateWorkflowRequest> = /*@__PURE__*/
  messageDesc(file_browser_automation_studio_v1_recording_session, 8);

/**
 * Optional range of entries to include.
 *
 * @generated from message browser_automation_studio.v1.GenerateWorkflowRequest.EntryRange
 */
export type GenerateWorkflowRequest_EntryRange = Message<"browser_automation_studio.v1.GenerateWorkflowRequest.EntryRange"> & {
  /**
   * Start index (inclusive).
   *
   * @generated from field: int32 start = 1;
   */
  start: number;

  /**
   * End index (exclusive).
   *
   * @generated from field: int32 end = 2;
   */
  end: number;
};

/**
 * Describes the message browser_automation_studio.v1.GenerateWorkflowRequest.EntryRange.
 * Use `create(GenerateWorkflowRequest_EntryRangeSchema)` to create a new message.
 */
export const GenerateWorkflowRequest_EntryRangeSchema: GenMessage<GenerateWorkflowRequest_EntryRange> = /*@__PURE__*/
  messageDesc(file_browser_automation_studio_v1_recording_session, 8, 0);

/**
 * GenerateWorkflowResponse is returned after generating a workflow.
 *
 * @generated from message browser_automation_studio.v1.GenerateWorkflowResponse
 */
export type GenerateWorkflowResponse = Message<"browser_automation_studio.v1.GenerateWorkflowResponse"> & {
  /**
   * Generated workflow ID (UUID format).
   *
   * @generated from field: string workflow_id = 1;
   */
  workflowId: string;

  /**
   * Project ID the workflow was saved to (UUID format).
   *
   * @generated from field: string project_id = 2;
   */
  projectId: string;

  /**
   * Workflow name.
   *
   * @generated from field: string name = 3;
   */
  name: string;

  /**
   * Number of nodes in the generated workflow.
   *
   * @generated from field: int32 node_count = 4;
   */
  nodeCount: number;

  /**
   * Number of entries that were converted.
   *
   * @generated from field: int32 entry_count = 5;
   */
  entryCount: number;
};

/**
 * Describes the message browser_automation_studio.v1.GenerateWorkflowResponse.
 * Use `create(GenerateWorkflowResponseSchema)` to create a new message.
 */
export const GenerateWorkflowResponseSchema: GenMessage<GenerateWorkflowResponse> = /*@__PURE__*/
  messageDesc(file_browser_automation_studio_v1_recording_session, 9);

/**
 * ReplayPreviewRequest tests recorded entries by replaying them.
 *
 * @generated from message browser_automation_studio.v1.ReplayPreviewRequest
 */
export type ReplayPreviewRequest = Message<"browser_automation_studio.v1.ReplayPreviewRequest"> & {
  /**
   * Session ID to replay on (UUID format).
   *
   * @generated from field: string session_id = 1;
   */
  sessionId: string;

  /**
   * Timeline entries to replay.
   *
   * @generated from field: repeated browser_automation_studio.v1.TimelineEntry entries = 2;
   */
  entries: TimelineEntry[];

  /**
   * Maximum number of entries to replay.
   *
   * @generated from field: int32 limit = 3;
   */
  limit: number;

  /**
   * Stop on first failure.
   *
   * @generated from field: bool stop_on_failure = 4;
   */
  stopOnFailure: boolean;

  /**
   * Timeout per action in milliseconds.
   *
   * @generated from field: int32 action_timeout_ms = 5;
   */
  actionTimeoutMs: number;
};

/**
 * Describes the message browser_automation_studio.v1.ReplayPreviewRequest.
 * Use `create(ReplayPreviewRequestSchema)` to create a new message.
 */
export const ReplayPreviewRequestSchema: GenMessage<ReplayPreviewRequest> = /*@__PURE__*/
  messageDesc(file_browser_automation_studio_v1_recording_session, 10);

/**
 * ReplayEventError contains error details for a failed replay event.
 *
 * @generated from message browser_automation_studio.v1.ReplayEventError
 */
export type ReplayEventError = Message<"browser_automation_studio.v1.ReplayEventError"> & {
  /**
   * Error message.
   *
   * @generated from field: string message = 1;
   */
  message: string;

  /**
   * Error code.
   *
   * @generated from field: string code = 2;
   */
  code: string;

  /**
   * Number of elements matching the selector.
   *
   * @generated from field: int32 match_count = 3;
   */
  matchCount: number;

  /**
   * Selector that failed.
   *
   * @generated from field: string selector = 4;
   */
  selector: string;
};

/**
 * Describes the message browser_automation_studio.v1.ReplayEventError.
 * Use `create(ReplayEventErrorSchema)` to create a new message.
 */
export const ReplayEventErrorSchema: GenMessage<ReplayEventError> = /*@__PURE__*/
  messageDesc(file_browser_automation_studio_v1_recording_session, 11);

/**
 * ReplayEntryResult is the result of replaying a single timeline entry.
 *
 * @generated from message browser_automation_studio.v1.ReplayEntryResult
 */
export type ReplayEntryResult = Message<"browser_automation_studio.v1.ReplayEntryResult"> & {
  /**
   * Entry ID that was replayed (UUID format).
   *
   * @generated from field: string entry_id = 1;
   */
  entryId: string;

  /**
   * Sequence number of the entry.
   *
   * @generated from field: int32 sequence_num = 2;
   */
  sequenceNum: number;

  /**
   * Whether the replay succeeded.
   *
   * @generated from field: bool success = 3;
   */
  success: boolean;

  /**
   * Duration of the replay in milliseconds.
   *
   * @generated from field: int32 duration_ms = 4;
   */
  durationMs: number;

  /**
   * Error details if replay failed.
   *
   * @generated from field: browser_automation_studio.v1.ReplayEventError error = 5;
   */
  error?: ReplayEventError;

  /**
   * Screenshot captured on error.
   *
   * @generated from field: string screenshot_on_error = 6;
   */
  screenshotOnError: string;

  /**
   * The action that was replayed.
   *
   * @generated from field: browser_automation_studio.v1.ActionDefinition action = 7;
   */
  action?: ActionDefinition;
};

/**
 * Describes the message browser_automation_studio.v1.ReplayEntryResult.
 * Use `create(ReplayEntryResultSchema)` to create a new message.
 */
export const ReplayEntryResultSchema: GenMessage<ReplayEntryResult> = /*@__PURE__*/
  messageDesc(file_browser_automation_studio_v1_recording_session, 12);

/**
 * ReplayPreviewResponse is returned from replay preview.
 *
 * @generated from message browser_automation_studio.v1.ReplayPreviewResponse
 */
export type ReplayPreviewResponse = Message<"browser_automation_studio.v1.ReplayPreviewResponse"> & {
  /**
   * Overall success (all entries passed).
   *
   * @generated from field: bool success = 1;
   */
  success: boolean;

  /**
   * Total number of entries attempted.
   *
   * @generated from field: int32 total_entries = 2;
   */
  totalEntries: number;

  /**
   * Number of entries that passed.
   *
   * @generated from field: int32 passed_entries = 3;
   */
  passedEntries: number;

  /**
   * Number of entries that failed.
   *
   * @generated from field: int32 failed_entries = 4;
   */
  failedEntries: number;

  /**
   * Individual replay results.
   *
   * @generated from field: repeated browser_automation_studio.v1.ReplayEntryResult results = 5;
   */
  results: ReplayEntryResult[];

  /**
   * Total duration of the replay in milliseconds.
   *
   * @generated from field: int32 total_duration_ms = 6;
   */
  totalDurationMs: number;

  /**
   * Whether replay stopped early due to failure.
   *
   * @generated from field: bool stopped_early = 7;
   */
  stoppedEarly: boolean;
};

/**
 * Describes the message browser_automation_studio.v1.ReplayPreviewResponse.
 * Use `create(ReplayPreviewResponseSchema)` to create a new message.
 */
export const ReplayPreviewResponseSchema: GenMessage<ReplayPreviewResponse> = /*@__PURE__*/
  messageDesc(file_browser_automation_studio_v1_recording_session, 13);

/**
 * SelectorValidation contains selector validation results from the driver.
 *
 * @generated from message browser_automation_studio.v1.SelectorValidation
 */
export type SelectorValidation = Message<"browser_automation_studio.v1.SelectorValidation"> & {
  /**
   * Whether the selector is valid.
   *
   * @generated from field: bool valid = 1;
   */
  valid: boolean;

  /**
   * Number of elements matching the selector.
   *
   * @generated from field: int32 match_count = 2;
   */
  matchCount: number;

  /**
   * The selector that was validated.
   *
   * @generated from field: string selector = 3;
   */
  selector: string;

  /**
   * Error message if validation failed.
   *
   * @generated from field: string error = 4;
   */
  error: string;
};

/**
 * Describes the message browser_automation_studio.v1.SelectorValidation.
 * Use `create(SelectorValidationSchema)` to create a new message.
 */
export const SelectorValidationSchema: GenMessage<SelectorValidation> = /*@__PURE__*/
  messageDesc(file_browser_automation_studio_v1_recording_session, 14);

