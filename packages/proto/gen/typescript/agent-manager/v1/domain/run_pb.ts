// @generated by protoc-gen-es v2.10.2 with parameter "target=ts,import_extension=none"
// @generated from file agent-manager/v1/domain/run.proto (package agent_manager.v1, syntax proto3)
/* eslint-disable */

import type { GenFile, GenMessage } from "@bufbuild/protobuf/codegenv2";
import { fileDesc, messageDesc } from "@bufbuild/protobuf/codegenv2";
import type { Duration, Timestamp } from "@bufbuild/protobuf/wkt";
import { file_google_protobuf_duration, file_google_protobuf_timestamp } from "@bufbuild/protobuf/wkt";
import { file_buf_validate_validate } from "../../../buf/validate/validate_pb";
import type { ApprovalState, IdempotencyStatus, RunMode, RunnerType, RunPhase, RunStatus } from "./types_pb";
import { file_agent_manager_v1_domain_types } from "./types_pb";
import type { RunConfig } from "./profile_pb";
import { file_agent_manager_v1_domain_profile } from "./profile_pb";
import type { Message } from "@bufbuild/protobuf";

/**
 * Describes the file agent-manager/v1/domain/run.proto.
 */
export const file_agent_manager_v1_domain_run: GenFile = /*@__PURE__*/
  fileDesc("CiFhZ2VudC1tYW5hZ2VyL3YxL2RvbWFpbi9ydW4ucHJvdG8SEGFnZW50X21hbmFnZXIudjEitQkKA1J1bhIKCgJpZBgBIAEoCRIZCgd0YXNrX2lkGAIgASgJQgi6SAVyA7ABARIdChBhZ2VudF9wcm9maWxlX2lkGAMgASgJSACIAQESCwoDdGFnGAQgASgJEhcKCnNhbmRib3hfaWQYBSABKAlIAYgBARIrCghydW5fbW9kZRgGIAEoDjIZLmFnZW50X21hbmFnZXIudjEuUnVuTW9kZRIrCgZzdGF0dXMYByABKA4yGy5hZ2VudF9tYW5hZ2VyLnYxLlJ1blN0YXR1cxIzCgpzdGFydGVkX2F0GAggASgLMhouZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcEgCiAEBEjEKCGVuZGVkX2F0GAkgASgLMhouZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcEgDiAEBEikKBXBoYXNlGAogASgOMhouYWdlbnRfbWFuYWdlci52MS5SdW5QaGFzZRIfChJsYXN0X2NoZWNrcG9pbnRfaWQYCyABKAlIBIgBARI3Cg5sYXN0X2hlYXJ0YmVhdBgMIAEoCzIaLmdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXBIBYgBARIjChBwcm9ncmVzc19wZXJjZW50GA0gASgFQgm6SAYaBBhkKAASFwoPaWRlbXBvdGVuY3lfa2V5GA4gASgJEjIKB3N1bW1hcnkYDyABKAsyHC5hZ2VudF9tYW5hZ2VyLnYxLlJ1blN1bW1hcnlIBogBARIRCgllcnJvcl9tc2cYECABKAkSFgoJZXhpdF9jb2RlGBEgASgFSAeIAQESNwoOYXBwcm92YWxfc3RhdGUYEiABKA4yHy5hZ2VudF9tYW5hZ2VyLnYxLkFwcHJvdmFsU3RhdGUSEwoLYXBwcm92ZWRfYnkYEyABKAkSNAoLYXBwcm92ZWRfYXQYFCABKAsyGi5nb29nbGUucHJvdG9idWYuVGltZXN0YW1wSAiIAQESOQoPcmVzb2x2ZWRfY29uZmlnGBUgASgLMhsuYWdlbnRfbWFuYWdlci52MS5SdW5Db25maWdICYgBARIRCglkaWZmX3BhdGgYFiABKAkSEAoIbG9nX3BhdGgYFyABKAkSFQoNY2hhbmdlZF9maWxlcxgYIAEoBRIYChB0b3RhbF9zaXplX2J5dGVzGBkgASgDEhIKCnNlc3Npb25faWQYHCABKAkSLgoKY3JlYXRlZF9hdBgaIAEoCzIaLmdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXASLgoKdXBkYXRlZF9hdBgbIAEoCzIaLmdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXASLQoHYWN0aW9ucxgdIAEoCzIcLmFnZW50X21hbmFnZXIudjEuUnVuQWN0aW9uc0ITChFfYWdlbnRfcHJvZmlsZV9pZEINCgtfc2FuZGJveF9pZEINCgtfc3RhcnRlZF9hdEILCglfZW5kZWRfYXRCFQoTX2xhc3RfY2hlY2twb2ludF9pZEIRCg9fbGFzdF9oZWFydGJlYXRCCgoIX3N1bW1hcnlCDAoKX2V4aXRfY29kZUIOCgxfYXBwcm92ZWRfYXRCEgoQX3Jlc29sdmVkX2NvbmZpZyKfAgoKUnVuQWN0aW9ucxIXCg9jYW5faW52ZXN0aWdhdGUYASABKAgSHwoXY2FuX2FwcGx5X2ludmVzdGlnYXRpb24YAiABKAgSEgoKY2FuX2RlbGV0ZRgDIAEoCBIQCghjYW5fc3RvcBgEIAEoCBIRCgljYW5fcmV0cnkYBSABKAgSFAoMY2FuX2NvbnRpbnVlGAYgASgIEhMKC2Nhbl9hcHByb3ZlGAcgASgIEhIKCmNhbl9yZWplY3QYCCABKAgSEgoKY2FuX3JldmlldxgJIAEoCBIjChtjYW5fZXh0cmFjdF9yZWNvbW1lbmRhdGlvbnMYCiABKAgSJgoeY2FuX3JlZ2VuZXJhdGVfcmVjb21tZW5kYXRpb25zGAsgASgIIqcBCgpSdW5TdW1tYXJ5EhMKC2Rlc2NyaXB0aW9uGAEgASgJEhYKDmZpbGVzX21vZGlmaWVkGAIgAygJEhUKDWZpbGVzX2NyZWF0ZWQYAyADKAkSFQoNZmlsZXNfZGVsZXRlZBgEIAMoCRITCgt0b2tlbnNfdXNlZBgFIAEoBRISCgp0dXJuc191c2VkGAYgASgFEhUKDWNvc3RfZXN0aW1hdGUYByABKAEixwMKDVJ1bkNoZWNrcG9pbnQSDgoGcnVuX2lkGAEgASgJEikKBXBoYXNlGAIgASgOMhouYWdlbnRfbWFuYWdlci52MS5SdW5QaGFzZRIZChFzdGVwX3dpdGhpbl9waGFzZRgDIAEoBRIXCgpzYW5kYm94X2lkGAQgASgJSACIAQESEAoId29ya19kaXIYBSABKAkSFAoHbG9ja19pZBgGIAEoCUgBiAEBEhsKE2xhc3RfZXZlbnRfc2VxdWVuY2UYByABKAMSMgoObGFzdF9oZWFydGJlYXQYCCABKAsyGi5nb29nbGUucHJvdG9idWYuVGltZXN0YW1wEhMKC3JldHJ5X2NvdW50GAkgASgFEiwKCHNhdmVkX2F0GAogASgLMhouZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcBI/CghtZXRhZGF0YRgLIAMoCzItLmFnZW50X21hbmFnZXIudjEuUnVuQ2hlY2twb2ludC5NZXRhZGF0YUVudHJ5Gi8KDU1ldGFkYXRhRW50cnkSCwoDa2V5GAEgASgJEg0KBXZhbHVlGAIgASgJOgI4AUINCgtfc2FuZGJveF9pZEIKCghfbG9ja19pZCK8AgoLUnVuUHJvZ3Jlc3MSKQoFcGhhc2UYASABKA4yGi5hZ2VudF9tYW5hZ2VyLnYxLlJ1blBoYXNlEhkKEXBoYXNlX2Rlc2NyaXB0aW9uGAIgASgJEhgKEHBlcmNlbnRfY29tcGxldGUYAyABKAUSFgoOY3VycmVudF9hY3Rpb24YBCABKAkSLwoMZWxhcHNlZF90aW1lGAUgASgLMhkuZ29vZ2xlLnByb3RvYnVmLkR1cmF0aW9uEjsKE2VzdGltYXRlZF9yZW1haW5pbmcYBiABKAsyGS5nb29nbGUucHJvdG9idWYuRHVyYXRpb25IAIgBARIvCgtsYXN0X3VwZGF0ZRgHIAEoCzIaLmdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXBCFgoUX2VzdGltYXRlZF9yZW1haW5pbmciggIKEUlkZW1wb3RlbmN5UmVjb3JkEgsKA2tleRgBIAEoCRIzCgZzdGF0dXMYAiABKA4yIy5hZ2VudF9tYW5hZ2VyLnYxLklkZW1wb3RlbmN5U3RhdHVzEhYKCWVudGl0eV9pZBgDIAEoCUgAiAEBEhMKC2VudGl0eV90eXBlGAQgASgJEi4KCmNyZWF0ZWRfYXQYBSABKAsyGi5nb29nbGUucHJvdG9idWYuVGltZXN0YW1wEi4KCmV4cGlyZXNfYXQYBiABKAsyGi5nb29nbGUucHJvdG9idWYuVGltZXN0YW1wEhAKCHJlc3BvbnNlGAcgASgMQgwKCl9lbnRpdHlfaWQi0QEKDFJ1bm5lclN0YXR1cxIxCgtydW5uZXJfdHlwZRgBIAEoDjIcLmFnZW50X21hbmFnZXIudjEuUnVubmVyVHlwZRIRCglhdmFpbGFibGUYAiABKAgSDwoHbWVzc2FnZRgDIAEoCRIUCgxpbnN0YWxsX2hpbnQYBCABKAkSGAoQc3VwcG9ydGVkX21vZGVscxgFIAMoCRI6CgxjYXBhYmlsaXRpZXMYBiABKAsyJC5hZ2VudF9tYW5hZ2VyLnYxLlJ1bm5lckNhcGFiaWxpdGllcyLaAQoSUnVubmVyQ2FwYWJpbGl0aWVzEhoKEnN1cHBvcnRzX3N0cmVhbWluZxgBIAEoCBIZChFzdXBwb3J0c19tZXNzYWdlcxgCIAEoCBIcChRzdXBwb3J0c190b29sX2V2ZW50cxgDIAEoCBIeChZzdXBwb3J0c19jb3N0X3RyYWNraW5nGAQgASgIEh0KFXN1cHBvcnRzX2NhbmNlbGxhdGlvbhgFIAEoCBIRCgltYXhfdHVybnMYBiABKAUSHQoVc3VwcG9ydHNfY29udGludWF0aW9uGAcgASgIIq4BCgtQcm9iZVJlc3VsdBIPCgdzdWNjZXNzGAEgASgIEhIKCmxhdGVuY3lfbXMYAiABKAMSDQoFZXJyb3IYAyABKAkSOwoHZGV0YWlscxgEIAMoCzIqLmFnZW50X21hbmFnZXIudjEuUHJvYmVSZXN1bHQuRGV0YWlsc0VudHJ5Gi4KDERldGFpbHNFbnRyeRILCgNrZXkYASABKAkSDQoFdmFsdWUYAiABKAk6AjgBIlcKDVN0b3BBbGxSZXN1bHQSFQoNc3RvcHBlZF9jb3VudBgBIAEoBRIvCghmYWlsdXJlcxgCIAMoCzIdLmFnZW50X21hbmFnZXIudjEuU3RvcEZhaWx1cmUiLAoLU3RvcEZhaWx1cmUSDgoGcnVuX2lkGAEgASgJEg0KBWVycm9yGAIgASgJIl0KDUFwcHJvdmVSZXN1bHQSDwoHc3VjY2VzcxgBIAEoCBIVCg1maWxlc19hcHBsaWVkGAIgASgFEhMKC2NvbW1pdF9oYXNoGAMgASgJEg8KB21lc3NhZ2UYBCABKAkihwEKB1J1bkRpZmYSDgoGcnVuX2lkGAEgASgJEg8KB2NvbnRlbnQYAiABKAkSKQoFZmlsZXMYAyADKAsyGi5hZ2VudF9tYW5hZ2VyLnYxLkZpbGVEaWZmEjAKDGdlbmVyYXRlZF9hdBgEIAEoCzIaLmdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXAidQoIRmlsZURpZmYSDAoEcGF0aBgBIAEoCRITCgtjaGFuZ2VfdHlwZRgCIAEoCRIRCglhZGRpdGlvbnMYAyABKAUSEQoJZGVsZXRpb25zGAQgASgFEhEKCWlzX2JpbmFyeRgFIAEoCBINCgVwYXRjaBgGIAEoCSJIChJDb250aW51ZVJ1blJlcXVlc3QSGAoGcnVuX2lkGAEgASgJQgi6SAVyA7ABARIYCgdtZXNzYWdlGAIgASgJQge6SARyAhABIm0KE0NvbnRpbnVlUnVuUmVzcG9uc2USDwoHc3VjY2VzcxgBIAEoCBIiCgNydW4YAiABKAsyFS5hZ2VudF9tYW5hZ2VyLnYxLlJ1bhINCgVlcnJvchgDIAEoCRISCgplcnJvcl9jb2RlGAQgASgJIk8KF0RlbGV0ZVJ1bk1lc3NhZ2VSZXF1ZXN0EhgKBnJ1bl9pZBgBIAEoCUIIukgFcgOwAQESGgoIZXZlbnRfaWQYAiABKAlCCLpIBXIDsAEBIisKGERlbGV0ZVJ1bk1lc3NhZ2VSZXNwb25zZRIPCgdzdWNjZXNzGAEgASgIQk9aTWdpdGh1Yi5jb20vdnJvb2xpL3Zyb29saS9wYWNrYWdlcy9wcm90by9nZW4vZ28vYWdlbnQtbWFuYWdlci92MS9kb21haW47ZG9tYWluYgZwcm90bzM", [file_google_protobuf_timestamp, file_google_protobuf_duration, file_buf_validate_validate, file_agent_manager_v1_domain_types, file_agent_manager_v1_domain_profile]);

/**
 * Run represents a single execution attempt of a task.
 *
 * A run is created by associating a task with a profile (or inline config).
 * It tracks execution state, progress, and results.
 *
 * @usage POST /api/v1/runs, GET /api/v1/runs/{id}
 *
 * @generated from message agent_manager.v1.Run
 */
export type Run = Message<"agent_manager.v1.Run"> & {
  /**
   * Unique identifier for this run.
   * @format uuid
   *
   * @generated from field: string id = 1;
   */
  id: string;

  /**
   * Task being executed.
   * @format uuid
   *
   * @generated from field: string task_id = 2;
   */
  taskId: string;

  /**
   * Agent profile used for this run.
   * Optional if inline config is provided.
   * @format uuid
   *
   * @generated from field: optional string agent_profile_id = 3;
   */
  agentProfileId?: string;

  /**
   * Custom tag for identification.
   * Defaults to ID if not set.
   * Used for agent tracking, log filtering, external process identification.
   * Examples: "ecosystem-task-123", "test-genie-abc"
   *
   * @generated from field: string tag = 4;
   */
  tag: string;

  /**
   * Sandbox ID if running in sandboxed mode.
   * @format uuid
   *
   * @generated from field: optional string sandbox_id = 5;
   */
  sandboxId?: string;

  /**
   * Execution mode (sandboxed or in-place).
   *
   * @generated from field: agent_manager.v1.RunMode run_mode = 6;
   */
  runMode: RunMode;

  /**
   * Current status.
   *
   * @generated from field: agent_manager.v1.RunStatus status = 7;
   */
  status: RunStatus;

  /**
   * When the run started executing.
   *
   * @generated from field: optional google.protobuf.Timestamp started_at = 8;
   */
  startedAt?: Timestamp;

  /**
   * When the run finished (success, failure, or cancellation).
   *
   * @generated from field: optional google.protobuf.Timestamp ended_at = 9;
   */
  endedAt?: Timestamp;

  /**
   * Detailed execution phase.
   *
   * @generated from field: agent_manager.v1.RunPhase phase = 10;
   */
  phase: RunPhase;

  /**
   * ID of the last saved checkpoint for resumption.
   * @format uuid
   *
   * @generated from field: optional string last_checkpoint_id = 11;
   */
  lastCheckpointId?: string;

  /**
   * Last heartbeat from the runner.
   * Used for stale run detection.
   *
   * @generated from field: optional google.protobuf.Timestamp last_heartbeat = 12;
   */
  lastHeartbeat?: Timestamp;

  /**
   * Progress percentage (0-100).
   *
   * @generated from field: int32 progress_percent = 13;
   */
  progressPercent: number;

  /**
   * Idempotency key for replay safety.
   *
   * @generated from field: string idempotency_key = 14;
   */
  idempotencyKey: string;

  /**
   * Execution summary after completion.
   *
   * @generated from field: optional agent_manager.v1.RunSummary summary = 15;
   */
  summary?: RunSummary;

  /**
   * Error message if failed.
   *
   * @generated from field: string error_msg = 16;
   */
  errorMsg: string;

  /**
   * Exit code from the runner process.
   *
   * @generated from field: optional int32 exit_code = 17;
   */
  exitCode?: number;

  /**
   * Approval workflow state.
   *
   * @generated from field: agent_manager.v1.ApprovalState approval_state = 18;
   */
  approvalState: ApprovalState;

  /**
   * User who approved/rejected.
   *
   * @generated from field: string approved_by = 19;
   */
  approvedBy: string;

  /**
   * When the approval decision was made.
   *
   * @generated from field: optional google.protobuf.Timestamp approved_at = 20;
   */
  approvedAt?: Timestamp;

  /**
   * Resolved configuration for this run.
   * Merged from profile + inline overrides.
   *
   * @generated from field: optional agent_manager.v1.RunConfig resolved_config = 21;
   */
  resolvedConfig?: RunConfig;

  /**
   * Path to the generated diff file.
   *
   * @generated from field: string diff_path = 22;
   */
  diffPath: string;

  /**
   * Path to the execution log file.
   *
   * @generated from field: string log_path = 23;
   */
  logPath: string;

  /**
   * Number of files changed by this run.
   *
   * @generated from field: int32 changed_files = 24;
   */
  changedFiles: number;

  /**
   * Total size of changes in bytes.
   *
   * @generated from field: int64 total_size_bytes = 25;
   */
  totalSizeBytes: bigint;

  /**
   * Runner-specific session identifier for conversation resumption.
   * Populated from runner stream events:
   *   - Claude Code: session_id
   *   - Codex: thread_id
   *   - OpenCode: sessionID
   * Used with the Continue endpoint to resume conversations.
   *
   * @generated from field: string session_id = 28;
   */
  sessionId: string;

  /**
   * When the run was created.
   *
   * @generated from field: google.protobuf.Timestamp created_at = 26;
   */
  createdAt?: Timestamp;

  /**
   * When the run was last updated.
   *
   * @generated from field: google.protobuf.Timestamp updated_at = 27;
   */
  updatedAt?: Timestamp;

  /**
   * Action availability for this run (computed).
   *
   * @generated from field: agent_manager.v1.RunActions actions = 29;
   */
  actions?: RunActions;
};

/**
 * Describes the message agent_manager.v1.Run.
 * Use `create(RunSchema)` to create a new message.
 */
export const RunSchema: GenMessage<Run> = /*@__PURE__*/
  messageDesc(file_agent_manager_v1_domain_run, 0);

/**
 * RunActions captures which operations are currently allowed for a run.
 *
 * @usage Run.actions
 *
 * @generated from message agent_manager.v1.RunActions
 */
export type RunActions = Message<"agent_manager.v1.RunActions"> & {
  /**
   * @generated from field: bool can_investigate = 1;
   */
  canInvestigate: boolean;

  /**
   * @generated from field: bool can_apply_investigation = 2;
   */
  canApplyInvestigation: boolean;

  /**
   * @generated from field: bool can_delete = 3;
   */
  canDelete: boolean;

  /**
   * @generated from field: bool can_stop = 4;
   */
  canStop: boolean;

  /**
   * @generated from field: bool can_retry = 5;
   */
  canRetry: boolean;

  /**
   * @generated from field: bool can_continue = 6;
   */
  canContinue: boolean;

  /**
   * @generated from field: bool can_approve = 7;
   */
  canApprove: boolean;

  /**
   * @generated from field: bool can_reject = 8;
   */
  canReject: boolean;

  /**
   * @generated from field: bool can_review = 9;
   */
  canReview: boolean;

  /**
   * @generated from field: bool can_extract_recommendations = 10;
   */
  canExtractRecommendations: boolean;

  /**
   * @generated from field: bool can_regenerate_recommendations = 11;
   */
  canRegenerateRecommendations: boolean;
};

/**
 * Describes the message agent_manager.v1.RunActions.
 * Use `create(RunActionsSchema)` to create a new message.
 */
export const RunActionsSchema: GenMessage<RunActions> = /*@__PURE__*/
  messageDesc(file_agent_manager_v1_domain_run, 1);

/**
 * RunSummary contains the structured summary from an agent run.
 *
 * Populated after successful execution with details about
 * what was accomplished and resource usage.
 *
 * @usage Run.summary
 *
 * @generated from message agent_manager.v1.RunSummary
 */
export type RunSummary = Message<"agent_manager.v1.RunSummary"> & {
  /**
   * Human-readable description of what was done.
   *
   * @generated from field: string description = 1;
   */
  description: string;

  /**
   * Files that were modified.
   *
   * @generated from field: repeated string files_modified = 2;
   */
  filesModified: string[];

  /**
   * Files that were created.
   *
   * @generated from field: repeated string files_created = 3;
   */
  filesCreated: string[];

  /**
   * Files that were deleted.
   *
   * @generated from field: repeated string files_deleted = 4;
   */
  filesDeleted: string[];

  /**
   * Total tokens consumed (input + output).
   *
   * @generated from field: int32 tokens_used = 5;
   */
  tokensUsed: number;

  /**
   * Number of conversation turns.
   *
   * @generated from field: int32 turns_used = 6;
   */
  turnsUsed: number;

  /**
   * Estimated cost in USD.
   *
   * @generated from field: double cost_estimate = 7;
   */
  costEstimate: number;
};

/**
 * Describes the message agent_manager.v1.RunSummary.
 * Use `create(RunSummarySchema)` to create a new message.
 */
export const RunSummarySchema: GenMessage<RunSummary> = /*@__PURE__*/
  messageDesc(file_agent_manager_v1_domain_run, 2);

/**
 * RunCheckpoint captures the state needed to resume a run.
 *
 * Checkpoints are saved at phase transitions and enable
 * resumption after interruption.
 *
 * @usage internal resumption
 *
 * @generated from message agent_manager.v1.RunCheckpoint
 */
export type RunCheckpoint = Message<"agent_manager.v1.RunCheckpoint"> & {
  /**
   * Run ID this checkpoint belongs to.
   * @format uuid
   *
   * @generated from field: string run_id = 1;
   */
  runId: string;

  /**
   * Current execution phase.
   *
   * @generated from field: agent_manager.v1.RunPhase phase = 2;
   */
  phase: RunPhase;

  /**
   * Progress within the phase (0-indexed).
   *
   * @generated from field: int32 step_within_phase = 3;
   */
  stepWithinPhase: number;

  /**
   * Sandbox ID if created.
   * @format uuid
   *
   * @generated from field: optional string sandbox_id = 4;
   */
  sandboxId?: string;

  /**
   * Working directory path.
   *
   * @generated from field: string work_dir = 5;
   */
  workDir: string;

  /**
   * Scope lock ID if acquired.
   * @format uuid
   *
   * @generated from field: optional string lock_id = 6;
   */
  lockId?: string;

  /**
   * Last event sequence number persisted.
   *
   * @generated from field: int64 last_event_sequence = 7;
   */
  lastEventSequence: bigint;

  /**
   * When we last confirmed progress.
   *
   * @generated from field: google.protobuf.Timestamp last_heartbeat = 8;
   */
  lastHeartbeat?: Timestamp;

  /**
   * How many times this phase has been retried.
   *
   * @generated from field: int32 retry_count = 9;
   */
  retryCount: number;

  /**
   * When this checkpoint was created.
   *
   * @generated from field: google.protobuf.Timestamp saved_at = 10;
   */
  savedAt?: Timestamp;

  /**
   * Phase-specific state for resumption.
   *
   * @generated from field: map<string, string> metadata = 11;
   */
  metadata: { [key: string]: string };
};

/**
 * Describes the message agent_manager.v1.RunCheckpoint.
 * Use `create(RunCheckpointSchema)` to create a new message.
 */
export const RunCheckpointSchema: GenMessage<RunCheckpoint> = /*@__PURE__*/
  messageDesc(file_agent_manager_v1_domain_run, 3);

/**
 * RunProgress represents the current progress of a run for display.
 *
 * Provides human-readable progress information for UI display.
 *
 * @usage GET /api/v1/runs/{id}/progress, WebSocket progress events
 *
 * @generated from message agent_manager.v1.RunProgress
 */
export type RunProgress = Message<"agent_manager.v1.RunProgress"> & {
  /**
   * Current execution phase.
   *
   * @generated from field: agent_manager.v1.RunPhase phase = 1;
   */
  phase: RunPhase;

  /**
   * Human-readable phase description.
   *
   * @generated from field: string phase_description = 2;
   */
  phaseDescription: string;

  /**
   * Overall progress percentage (0-100).
   *
   * @generated from field: int32 percent_complete = 3;
   */
  percentComplete: number;

  /**
   * What's happening now.
   *
   * @generated from field: string current_action = 4;
   */
  currentAction: string;

  /**
   * How long the run has been active.
   *
   * @generated from field: google.protobuf.Duration elapsed_time = 5;
   */
  elapsedTime?: Duration;

  /**
   * Estimated time remaining (if known).
   *
   * @generated from field: optional google.protobuf.Duration estimated_remaining = 6;
   */
  estimatedRemaining?: Duration;

  /**
   * When progress was last reported.
   *
   * @generated from field: google.protobuf.Timestamp last_update = 7;
   */
  lastUpdate?: Timestamp;
};

/**
 * Describes the message agent_manager.v1.RunProgress.
 * Use `create(RunProgressSchema)` to create a new message.
 */
export const RunProgressSchema: GenMessage<RunProgress> = /*@__PURE__*/
  messageDesc(file_agent_manager_v1_domain_run, 4);

/**
 * IdempotencyRecord tracks whether an operation has been performed.
 *
 * Prevents duplicate work when operations are retried.
 * Records expire after a configurable TTL.
 *
 * @usage internal replay safety
 *
 * @generated from message agent_manager.v1.IdempotencyRecord
 */
export type IdempotencyRecord = Message<"agent_manager.v1.IdempotencyRecord"> & {
  /**
   * Unique operation key.
   * Format: "run-create:task-{taskID}:profile-{profileID}:ts-{timestamp}"
   *
   * @generated from field: string key = 1;
   */
  key: string;

  /**
   * Operation outcome.
   *
   * @generated from field: agent_manager.v1.IdempotencyStatus status = 2;
   */
  status: IdempotencyStatus;

  /**
   * ID of the created/affected entity.
   * @format uuid
   *
   * @generated from field: optional string entity_id = 3;
   */
  entityId?: string;

  /**
   * Type of entity (e.g., "Run", "Task").
   *
   * @generated from field: string entity_type = 4;
   */
  entityType: string;

  /**
   * When this record was created.
   *
   * @generated from field: google.protobuf.Timestamp created_at = 5;
   */
  createdAt?: Timestamp;

  /**
   * When this record can be garbage collected.
   *
   * @generated from field: google.protobuf.Timestamp expires_at = 6;
   */
  expiresAt?: Timestamp;

  /**
   * Cached response (JSON) for successful operations.
   *
   * @generated from field: bytes response = 7;
   */
  response: Uint8Array;
};

/**
 * Describes the message agent_manager.v1.IdempotencyRecord.
 * Use `create(IdempotencyRecordSchema)` to create a new message.
 */
export const IdempotencyRecordSchema: GenMessage<IdempotencyRecord> = /*@__PURE__*/
  messageDesc(file_agent_manager_v1_domain_run, 5);

/**
 * RunnerStatus provides status information for a runner type.
 *
 * Returned by the runner status endpoint to indicate availability.
 *
 * @usage GET /api/v1/runners
 *
 * @generated from message agent_manager.v1.RunnerStatus
 */
export type RunnerStatus = Message<"agent_manager.v1.RunnerStatus"> & {
  /**
   * Which runner type.
   *
   * @generated from field: agent_manager.v1.RunnerType runner_type = 1;
   */
  runnerType: RunnerType;

  /**
   * Whether the runner is available for use.
   *
   * @generated from field: bool available = 2;
   */
  available: boolean;

  /**
   * Human-readable status message.
   *
   * @generated from field: string message = 3;
   */
  message: string;

  /**
   * Installation hint if not available.
   *
   * @generated from field: string install_hint = 4;
   */
  installHint: string;

  /**
   * Supported models for this runner.
   *
   * @generated from field: repeated string supported_models = 5;
   */
  supportedModels: string[];

  /**
   * Runner capabilities.
   *
   * @generated from field: agent_manager.v1.RunnerCapabilities capabilities = 6;
   */
  capabilities?: RunnerCapabilities;
};

/**
 * Describes the message agent_manager.v1.RunnerStatus.
 * Use `create(RunnerStatusSchema)` to create a new message.
 */
export const RunnerStatusSchema: GenMessage<RunnerStatus> = /*@__PURE__*/
  messageDesc(file_agent_manager_v1_domain_run, 6);

/**
 * RunnerCapabilities describes what a runner supports.
 *
 * @usage RunnerStatus.capabilities
 *
 * @generated from message agent_manager.v1.RunnerCapabilities
 */
export type RunnerCapabilities = Message<"agent_manager.v1.RunnerCapabilities"> & {
  /**
   * Supports streaming output.
   *
   * @generated from field: bool supports_streaming = 1;
   */
  supportsStreaming: boolean;

  /**
   * Supports conversation messages.
   *
   * @generated from field: bool supports_messages = 2;
   */
  supportsMessages: boolean;

  /**
   * Supports tool call/result events.
   *
   * @generated from field: bool supports_tool_events = 3;
   */
  supportsToolEvents: boolean;

  /**
   * Supports cost tracking.
   *
   * @generated from field: bool supports_cost_tracking = 4;
   */
  supportsCostTracking: boolean;

  /**
   * Supports run cancellation.
   *
   * @generated from field: bool supports_cancellation = 5;
   */
  supportsCancellation: boolean;

  /**
   * Maximum turns (0 = unlimited).
   *
   * @generated from field: int32 max_turns = 6;
   */
  maxTurns: number;

  /**
   * Supports session continuation (resume/continue conversation).
   *
   * @generated from field: bool supports_continuation = 7;
   */
  supportsContinuation: boolean;
};

/**
 * Describes the message agent_manager.v1.RunnerCapabilities.
 * Use `create(RunnerCapabilitiesSchema)` to create a new message.
 */
export const RunnerCapabilitiesSchema: GenMessage<RunnerCapabilities> = /*@__PURE__*/
  messageDesc(file_agent_manager_v1_domain_run, 7);

/**
 * ProbeResult contains the result of a runner connectivity probe.
 *
 * @usage POST /api/v1/runners/{type}/probe
 *
 * @generated from message agent_manager.v1.ProbeResult
 */
export type ProbeResult = Message<"agent_manager.v1.ProbeResult"> & {
  /**
   * Whether the probe succeeded.
   *
   * @generated from field: bool success = 1;
   */
  success: boolean;

  /**
   * Response time in milliseconds.
   *
   * @generated from field: int64 latency_ms = 2;
   */
  latencyMs: bigint;

  /**
   * Error message if probe failed.
   *
   * @generated from field: string error = 3;
   */
  error: string;

  /**
   * Additional probe details.
   *
   * @generated from field: map<string, string> details = 4;
   */
  details: { [key: string]: string };
};

/**
 * Describes the message agent_manager.v1.ProbeResult.
 * Use `create(ProbeResultSchema)` to create a new message.
 */
export const ProbeResultSchema: GenMessage<ProbeResult> = /*@__PURE__*/
  messageDesc(file_agent_manager_v1_domain_run, 8);

/**
 * StopAllResult contains the result of stopping multiple runs.
 *
 * @usage POST /api/v1/runs/stop-all
 *
 * @generated from message agent_manager.v1.StopAllResult
 */
export type StopAllResult = Message<"agent_manager.v1.StopAllResult"> & {
  /**
   * Number of runs stopped.
   *
   * @generated from field: int32 stopped_count = 1;
   */
  stoppedCount: number;

  /**
   * Runs that failed to stop.
   *
   * @generated from field: repeated agent_manager.v1.StopFailure failures = 2;
   */
  failures: StopFailure[];
};

/**
 * Describes the message agent_manager.v1.StopAllResult.
 * Use `create(StopAllResultSchema)` to create a new message.
 */
export const StopAllResultSchema: GenMessage<StopAllResult> = /*@__PURE__*/
  messageDesc(file_agent_manager_v1_domain_run, 9);

/**
 * StopFailure describes a run that failed to stop.
 *
 * @generated from message agent_manager.v1.StopFailure
 */
export type StopFailure = Message<"agent_manager.v1.StopFailure"> & {
  /**
   * Run ID that failed.
   * @format uuid
   *
   * @generated from field: string run_id = 1;
   */
  runId: string;

  /**
   * Error message.
   *
   * @generated from field: string error = 2;
   */
  error: string;
};

/**
 * Describes the message agent_manager.v1.StopFailure.
 * Use `create(StopFailureSchema)` to create a new message.
 */
export const StopFailureSchema: GenMessage<StopFailure> = /*@__PURE__*/
  messageDesc(file_agent_manager_v1_domain_run, 10);

/**
 * ApproveResult contains the result of approving a run.
 *
 * @usage POST /api/v1/runs/{id}/approve
 *
 * @generated from message agent_manager.v1.ApproveResult
 */
export type ApproveResult = Message<"agent_manager.v1.ApproveResult"> & {
  /**
   * Whether approval was successful.
   *
   * @generated from field: bool success = 1;
   */
  success: boolean;

  /**
   * Number of files applied.
   *
   * @generated from field: int32 files_applied = 2;
   */
  filesApplied: number;

  /**
   * Git commit hash if changes were committed.
   *
   * @generated from field: string commit_hash = 3;
   */
  commitHash: string;

  /**
   * Message describing what was applied.
   *
   * @generated from field: string message = 4;
   */
  message: string;
};

/**
 * Describes the message agent_manager.v1.ApproveResult.
 * Use `create(ApproveResultSchema)` to create a new message.
 */
export const ApproveResultSchema: GenMessage<ApproveResult> = /*@__PURE__*/
  messageDesc(file_agent_manager_v1_domain_run, 11);

/**
 * RunDiff contains the diff output for a run.
 *
 * @usage GET /api/v1/runs/{id}/diff
 *
 * @generated from message agent_manager.v1.RunDiff
 */
export type RunDiff = Message<"agent_manager.v1.RunDiff"> & {
  /**
   * Run ID.
   * @format uuid
   *
   * @generated from field: string run_id = 1;
   */
  runId: string;

  /**
   * Unified diff content.
   *
   * @generated from field: string content = 2;
   */
  content: string;

  /**
   * Individual file changes.
   *
   * @generated from field: repeated agent_manager.v1.FileDiff files = 3;
   */
  files: FileDiff[];

  /**
   * When the diff was generated.
   *
   * @generated from field: google.protobuf.Timestamp generated_at = 4;
   */
  generatedAt?: Timestamp;
};

/**
 * Describes the message agent_manager.v1.RunDiff.
 * Use `create(RunDiffSchema)` to create a new message.
 */
export const RunDiffSchema: GenMessage<RunDiff> = /*@__PURE__*/
  messageDesc(file_agent_manager_v1_domain_run, 12);

/**
 * FileDiff represents changes to a single file.
 *
 * @generated from message agent_manager.v1.FileDiff
 */
export type FileDiff = Message<"agent_manager.v1.FileDiff"> & {
  /**
   * File path.
   *
   * @generated from field: string path = 1;
   */
  path: string;

  /**
   * Change type: added, modified, deleted.
   *
   * @generated from field: string change_type = 2;
   */
  changeType: string;

  /**
   * Lines added.
   *
   * @generated from field: int32 additions = 3;
   */
  additions: number;

  /**
   * Lines deleted.
   *
   * @generated from field: int32 deletions = 4;
   */
  deletions: number;

  /**
   * Whether the file is binary.
   *
   * @generated from field: bool is_binary = 5;
   */
  isBinary: boolean;

  /**
   * Unified diff for this file.
   *
   * @generated from field: string patch = 6;
   */
  patch: string;
};

/**
 * Describes the message agent_manager.v1.FileDiff.
 * Use `create(FileDiffSchema)` to create a new message.
 */
export const FileDiffSchema: GenMessage<FileDiff> = /*@__PURE__*/
  messageDesc(file_agent_manager_v1_domain_run, 13);

/**
 * ContinueRunRequest contains parameters for continuing a run's conversation.
 *
 * Sends a follow-up message to an existing run's session, resuming the
 * conversation even after the runner process has ended (using stored session_id).
 *
 * @usage POST /api/v1/runs/{id}/continue
 *
 * @generated from message agent_manager.v1.ContinueRunRequest
 */
export type ContinueRunRequest = Message<"agent_manager.v1.ContinueRunRequest"> & {
  /**
   * Run ID to continue.
   * @format uuid
   *
   * @generated from field: string run_id = 1;
   */
  runId: string;

  /**
   * Follow-up message to send to the agent.
   *
   * @generated from field: string message = 2;
   */
  message: string;
};

/**
 * Describes the message agent_manager.v1.ContinueRunRequest.
 * Use `create(ContinueRunRequestSchema)` to create a new message.
 */
export const ContinueRunRequestSchema: GenMessage<ContinueRunRequest> = /*@__PURE__*/
  messageDesc(file_agent_manager_v1_domain_run, 14);

/**
 * ContinueRunResponse contains the result of continuing a run.
 *
 * @usage POST /api/v1/runs/{id}/continue response
 *
 * @generated from message agent_manager.v1.ContinueRunResponse
 */
export type ContinueRunResponse = Message<"agent_manager.v1.ContinueRunResponse"> & {
  /**
   * Whether the continuation started successfully.
   *
   * @generated from field: bool success = 1;
   */
  success: boolean;

  /**
   * Updated run with new session state.
   *
   * @generated from field: agent_manager.v1.Run run = 2;
   */
  run?: Run;

  /**
   * Error message if continuation failed.
   *
   * @generated from field: string error = 3;
   */
  error: string;

  /**
   * Error code for programmatic handling.
   * Codes: "session_expired", "continuation_not_supported", "run_not_found"
   *
   * @generated from field: string error_code = 4;
   */
  errorCode: string;
};

/**
 * Describes the message agent_manager.v1.ContinueRunResponse.
 * Use `create(ContinueRunResponseSchema)` to create a new message.
 */
export const ContinueRunResponseSchema: GenMessage<ContinueRunResponse> = /*@__PURE__*/
  messageDesc(file_agent_manager_v1_domain_run, 15);

/**
 * DeleteRunMessageRequest marks a message event as deleted.
 *
 * This appends a message_deleted event instead of removing history.
 *
 * @usage POST /api/v1/runs/{id}/messages/{event_id}/delete
 *
 * @generated from message agent_manager.v1.DeleteRunMessageRequest
 */
export type DeleteRunMessageRequest = Message<"agent_manager.v1.DeleteRunMessageRequest"> & {
  /**
   * Run ID containing the message event.
   * @format uuid
   *
   * @generated from field: string run_id = 1;
   */
  runId: string;

  /**
   * Message event ID to delete.
   * @format uuid
   *
   * @generated from field: string event_id = 2;
   */
  eventId: string;
};

/**
 * Describes the message agent_manager.v1.DeleteRunMessageRequest.
 * Use `create(DeleteRunMessageRequestSchema)` to create a new message.
 */
export const DeleteRunMessageRequestSchema: GenMessage<DeleteRunMessageRequest> = /*@__PURE__*/
  messageDesc(file_agent_manager_v1_domain_run, 16);

/**
 * DeleteRunMessageResponse confirms deletion.
 *
 * @usage POST /api/v1/runs/{id}/messages/{event_id}/delete response
 *
 * @generated from message agent_manager.v1.DeleteRunMessageResponse
 */
export type DeleteRunMessageResponse = Message<"agent_manager.v1.DeleteRunMessageResponse"> & {
  /**
   * Whether the delete event was created.
   *
   * @generated from field: bool success = 1;
   */
  success: boolean;
};

/**
 * Describes the message agent_manager.v1.DeleteRunMessageResponse.
 * Use `create(DeleteRunMessageResponseSchema)` to create a new message.
 */
export const DeleteRunMessageResponseSchema: GenMessage<DeleteRunMessageResponse> = /*@__PURE__*/
  messageDesc(file_agent_manager_v1_domain_run, 17);

