syntax = "proto3";

package browser_automation_studio.v1;

import "google/protobuf/timestamp.proto";
import "browser-automation-studio/v1/actions/action.proto";
import "browser-automation-studio/v1/timeline/entry.proto";

option go_package = "github.com/vrooli/vrooli/packages/proto/gen/go/browser-automation-studio/v1/recording;recording";

// =============================================================================
// RECORDING SESSION MANAGEMENT
// =============================================================================
//
// @layer 3
// @domain recording
// @imports actions, timeline
//
// This file handles the LIFECYCLE of browser recording sessions:
//   - Create/start/stop recording sessions
//   - Query session status and captured entries
//   - Generate workflows from recorded entries
//   - Replay preview for testing
//
// IMPORTANT: This file does NOT define action types or entry formats.
// Those are defined in:
//   - action.proto: ActionDefinition (unified action type)
//   - timeline/entry.proto: TimelineEntry (unified streaming/batch format)
//
// The recording session uses TimelineEntry for captured actions, ensuring
// the same format is used for both recording and execution.
//
// @see shared.proto for "UNIFIED RECORDING/EXECUTION MODEL" design rationale
// =============================================================================

// RecordingState captures current recording session state.
message RecordingState {
  // Whether recording is currently active.
  bool is_recording = 1;
  // Current recording ID (UUID format).
  string recording_id = 2;
  // Session ID for the browser session (UUID format).
  string session_id = 3;
  // Number of actions captured so far.
  int32 action_count = 4;
  // When recording started.
  google.protobuf.Timestamp started_at = 5;
}

// CreateRecordingSessionRequest creates a browser session for recording.
message CreateRecordingSessionRequest {
  // Viewport width in pixels.
  int32 viewport_width = 1;
  // Viewport height in pixels.
  int32 viewport_height = 2;
  // Initial URL to navigate to.
  string initial_url = 3;
}

// CreateRecordingSessionResponse is returned after creating a recording session.
message CreateRecordingSessionResponse {
  // Unique session identifier (UUID format).
  string session_id = 1;
  // When the session was created.
  google.protobuf.Timestamp created_at = 2;
}

// StartRecordingRequest starts recording on an existing session.
message StartRecordingRequest {
  // Session ID to start recording on (UUID format).
  string session_id = 1;
  // Callback URL for streaming events (optional).
  string callback_url = 2;
}

// StartRecordingResponse is returned after starting recording.
message StartRecordingResponse {
  // Unique recording identifier (UUID format).
  string recording_id = 1;
  // Session ID the recording is attached to (UUID format).
  string session_id = 2;
  // When recording started.
  google.protobuf.Timestamp started_at = 3;
}

// StopRecordingResponse is returned after stopping recording.
message StopRecordingResponse {
  // Recording ID that was stopped (UUID format).
  string recording_id = 1;
  // Session ID the recording was attached to (UUID format).
  string session_id = 2;
  // Total number of actions captured.
  int32 action_count = 3;
  // When recording completed.
  google.protobuf.Timestamp completed_at = 4;
}

// RecordingStatusResponse returns current recording status.
message RecordingStatusResponse {
  // Session ID being queried (UUID format).
  string session_id = 1;
  // Whether recording is active.
  bool is_recording = 2;
  // Current recording ID (UUID format, empty if not recording).
  string recording_id = 3;
  // Number of actions captured.
  int32 action_count = 4;
  // When recording started (null if not recording).
  optional google.protobuf.Timestamp started_at = 5;
}

// =============================================================================
// RECORDED ENTRIES (using unified TimelineEntry)
// =============================================================================

// GetActionsResponse returns captured timeline entries from a recording session.
message GetActionsResponse {
  // Session ID the entries belong to (UUID format).
  string session_id = 1;
  // Captured timeline entries (unified format).
  repeated TimelineEntry entries = 2;
  // Total number of entries.
  int32 count = 3;
}

// =============================================================================
// WORKFLOW GENERATION
// =============================================================================

// GenerateWorkflowRequest generates a workflow from recorded entries.
message GenerateWorkflowRequest {
  // Session ID to generate workflow from (UUID format).
  string session_id = 1;
  // Name for the generated workflow.
  string name = 2;
  // Project ID to save the workflow to (UUID format).
  string project_id = 3;
  // Project name (for display).
  string project_name = 4;
  // Optional range of entries to include.
  message EntryRange {
    // Start index (inclusive).
    int32 start = 1;
    // End index (exclusive).
    int32 end = 2;
  }
  // Entry range to include (optional, defaults to all).
  EntryRange entry_range = 5;
  // Timeline entries to convert (optional, uses session entries if empty).
  repeated TimelineEntry entries = 6;
}

// GenerateWorkflowResponse is returned after generating a workflow.
message GenerateWorkflowResponse {
  // Generated workflow ID (UUID format).
  string workflow_id = 1;
  // Project ID the workflow was saved to (UUID format).
  string project_id = 2;
  // Workflow name.
  string name = 3;
  // Number of nodes in the generated workflow.
  int32 node_count = 4;
  // Number of entries that were converted.
  int32 entry_count = 5;
}

// =============================================================================
// REPLAY PREVIEW (testing recorded entries)
// =============================================================================

// ReplayPreviewRequest tests recorded entries by replaying them.
message ReplayPreviewRequest {
  // Session ID to replay on (UUID format).
  string session_id = 1;
  // Timeline entries to replay.
  repeated TimelineEntry entries = 2;
  // Maximum number of entries to replay.
  int32 limit = 3;
  // Stop on first failure.
  bool stop_on_failure = 4;
  // Timeout per action in milliseconds.
  int32 action_timeout_ms = 5;
}

// ReplayEventError contains error details for a failed replay event.
message ReplayEventError {
  // Error message.
  string message = 1;
  // Error code.
  string code = 2;
  // Number of elements matching the selector.
  int32 match_count = 3;
  // Selector that failed.
  string selector = 4;
}

// ReplayEntryResult is the result of replaying a single timeline entry.
message ReplayEntryResult {
  // Entry ID that was replayed (UUID format).
  string entry_id = 1;
  // Sequence number of the entry.
  int32 sequence_num = 2;
  // Whether the replay succeeded.
  bool success = 3;
  // Duration of the replay in milliseconds.
  int32 duration_ms = 4;
  // Error details if replay failed.
  ReplayEventError error = 5;
  // Screenshot captured on error.
  string screenshot_on_error = 6;
  // The action that was replayed.
  ActionDefinition action = 7;
}

// ReplayPreviewResponse is returned from replay preview.
message ReplayPreviewResponse {
  // Overall success (all entries passed).
  bool success = 1;
  // Total number of entries attempted.
  int32 total_entries = 2;
  // Number of entries that passed.
  int32 passed_entries = 3;
  // Number of entries that failed.
  int32 failed_entries = 4;
  // Individual replay results.
  repeated ReplayEntryResult results = 5;
  // Total duration of the replay in milliseconds.
  int32 total_duration_ms = 6;
  // Whether replay stopped early due to failure.
  bool stopped_early = 7;
}

// =============================================================================
// SELECTOR VALIDATION
// =============================================================================

// SelectorValidation contains selector validation results from the driver.
message SelectorValidation {
  // Whether the selector is valid.
  bool valid = 1;
  // Number of elements matching the selector.
  int32 match_count = 2;
  // The selector that was validated.
  string selector = 3;
  // Error message if validation failed.
  string error = 4;
}
