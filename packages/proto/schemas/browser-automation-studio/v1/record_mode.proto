syntax = "proto3";

package browser_automation_studio.v1;

import "google/protobuf/timestamp.proto";
import "browser-automation-studio/v1/action.proto";
import "browser-automation-studio/v1/timeline_event.proto";

option go_package = "github.com/vrooli/vrooli/packages/proto/gen/go/browser-automation-studio/v1;browser_automation_studio_v1";

// =============================================================================
// NOTE: SelectorCandidate, SelectorSet, and ElementMeta are defined in
// selectors.proto (imported via timeline_event.proto -> selectors.proto).
// =============================================================================

// =============================================================================
// RECORDING SESSION MANAGEMENT
// =============================================================================

// RecordingState captures current recording session state.
message RecordingState {
  // Whether recording is currently active.
  bool is_recording = 1;
  // Current recording ID.
  string recording_id = 2;
  // Session ID for the browser session.
  string session_id = 3;
  // Number of actions captured so far.
  int32 action_count = 4;
  // When recording started.
  google.protobuf.Timestamp started_at = 5;
}

// CreateRecordingSessionRequest creates a browser session for recording.
message CreateRecordingSessionRequest {
  // Viewport width in pixels.
  int32 viewport_width = 1;
  // Viewport height in pixels.
  int32 viewport_height = 2;
  // Initial URL to navigate to.
  string initial_url = 3;
}

// CreateRecordingSessionResponse is returned after creating a recording session.
message CreateRecordingSessionResponse {
  // Unique session identifier.
  string session_id = 1;
  // When the session was created.
  google.protobuf.Timestamp created_at = 2;
}

// StartRecordingRequest starts recording on an existing session.
message StartRecordingRequest {
  // Session ID to start recording on.
  string session_id = 1;
  // Callback URL for streaming events (optional).
  string callback_url = 2;
}

// StartRecordingResponse is returned after starting recording.
message StartRecordingResponse {
  // Unique recording identifier.
  string recording_id = 1;
  // Session ID the recording is attached to.
  string session_id = 2;
  // When recording started.
  google.protobuf.Timestamp started_at = 3;
}

// StopRecordingResponse is returned after stopping recording.
message StopRecordingResponse {
  // Recording ID that was stopped.
  string recording_id = 1;
  // Session ID the recording was attached to.
  string session_id = 2;
  // Total number of actions captured.
  int32 action_count = 3;
  // When recording stopped.
  google.protobuf.Timestamp stopped_at = 4;
}

// RecordingStatusResponse returns current recording status.
message RecordingStatusResponse {
  // Session ID being queried.
  string session_id = 1;
  // Whether recording is active.
  bool is_recording = 2;
  // Current recording ID (empty if not recording).
  string recording_id = 3;
  // Number of actions captured.
  int32 action_count = 4;
  // When recording started (null if not recording).
  optional google.protobuf.Timestamp started_at = 5;
}

// =============================================================================
// RECORDED ACTIONS (using unified TimelineEvent)
// =============================================================================

// GetActionsResponse returns captured timeline events from a recording session.
message GetActionsResponse {
  // Session ID the events belong to.
  string session_id = 1;
  // Captured timeline events (unified format).
  repeated TimelineEvent events = 2;
  // Total number of events.
  int32 count = 3;
}

// =============================================================================
// WORKFLOW GENERATION
// =============================================================================

// GenerateWorkflowRequest generates a workflow from recorded events.
message GenerateWorkflowRequest {
  // Session ID to generate workflow from.
  string session_id = 1;
  // Name for the generated workflow.
  string name = 2;
  // Project ID to save the workflow to.
  string project_id = 3;
  // Project name (for display).
  string project_name = 4;
  // Optional range of events to include.
  message EventRange {
    // Start index (inclusive).
    int32 start = 1;
    // End index (exclusive).
    int32 end = 2;
  }
  // Event range to include (optional, defaults to all).
  EventRange event_range = 5;
  // Timeline events to convert (optional, uses session events if empty).
  repeated TimelineEvent events = 6;
}

// GenerateWorkflowResponse is returned after generating a workflow.
message GenerateWorkflowResponse {
  // Generated workflow ID.
  string workflow_id = 1;
  // Project ID the workflow was saved to.
  string project_id = 2;
  // Workflow name.
  string name = 3;
  // Number of nodes in the generated workflow.
  int32 node_count = 4;
  // Number of events that were converted.
  int32 event_count = 5;
}

// =============================================================================
// REPLAY PREVIEW (testing recorded events)
// =============================================================================

// ReplayPreviewRequest tests recorded events by replaying them.
message ReplayPreviewRequest {
  // Session ID to replay on.
  string session_id = 1;
  // Timeline events to replay.
  repeated TimelineEvent events = 2;
  // Maximum number of events to replay.
  int32 limit = 3;
  // Stop on first failure.
  bool stop_on_failure = 4;
  // Timeout per action in milliseconds.
  int32 action_timeout_ms = 5;
}

// ReplayEventError contains error details for a failed replay event.
message ReplayEventError {
  // Error message.
  string message = 1;
  // Error code.
  string code = 2;
  // Number of elements matching the selector.
  int32 match_count = 3;
  // Selector that failed.
  string selector = 4;
}

// ReplayEventResult is the result of replaying a single timeline event.
message ReplayEventResult {
  // Event ID that was replayed.
  string event_id = 1;
  // Sequence number of the event.
  int32 sequence_num = 2;
  // Whether the replay succeeded.
  bool success = 3;
  // Duration of the replay in milliseconds.
  int32 duration_ms = 4;
  // Error details if replay failed.
  ReplayEventError error = 5;
  // Screenshot captured on error.
  string screenshot_on_error = 6;
  // The action that was replayed.
  ActionDefinition action = 7;
}

// ReplayPreviewResponse is returned from replay preview.
message ReplayPreviewResponse {
  // Overall success (all events passed).
  bool success = 1;
  // Total number of events attempted.
  int32 total_events = 2;
  // Number of events that passed.
  int32 passed_events = 3;
  // Number of events that failed.
  int32 failed_events = 4;
  // Individual replay results.
  repeated ReplayEventResult results = 5;
  // Total duration of the replay in milliseconds.
  int32 total_duration_ms = 6;
  // Whether replay stopped early due to failure.
  bool stopped_early = 7;
}

// =============================================================================
// SELECTOR VALIDATION
// =============================================================================

// SelectorValidation contains selector validation results from the driver.
message SelectorValidation {
  // Whether the selector is valid.
  bool valid = 1;
  // Number of elements matching the selector.
  int32 match_count = 2;
  // The selector that was validated.
  string selector = 3;
  // Error message if validation failed.
  string error = 4;
}
